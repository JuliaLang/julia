#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <git2.h>

static void get_julia_origin_master_merge_base(git_oid* merge_base, git_repository *repo);
static int get_julia_build_number(git_repository *repo);
static int get_julia_fork_master_distance(git_repository *repo, git_oid *merge_base);
static void check_lg2(int error, const char *message, const char *extra);

int main (int argc, char **argv)
{
    printf("# This file was autogenerated in base/version_git.c\n"
            "immutable GitVersionInfo\n"
            "    commit::String\n"
            "    commit_short::String\n"
            "    branch::String\n"
            "    build_number::Int\n"
            "    date_string::String\n"
            "    tagged_commit::Bool\n"
            "    fork_master_distance::Int\n"
            "    fork_master_timestamp::Float64\n"
            "end\n");

    if (argc > 1 && !strcmp("NO_GIT", argv[1])){
        printf("# Default output if git is not available.\n");
        printf("const GIT_VERSION_INFO = GitVersionInfo(\"\" ,\"\" ,\"\" ,0 ,\"\" ,true ,0 ,0.)\n");
        return 0;
    }
    git_threads_init();
    
    git_repository *repo;
    check_lg2(git_repository_open_ext(&repo, ".", 0, NULL), "opening repository", NULL);
    git_oid head;
    check_lg2(git_reference_name_to_id(&head, repo, "HEAD"), "fetching head", NULL);
    git_commit *head_commit;
    check_lg2(git_commit_lookup(&head_commit, repo, &head), "getting commit", NULL);
    char head_hash[41] = {0};
    git_oid_fmt(head_hash, &head);

    //get current branch name
    const char* branch = NULL;
    git_reference *branch_ref;
    check_lg2(git_repository_head(&branch_ref, repo), "repository_head", NULL);
    check_lg2(git_branch_name(&branch, branch_ref), "branch_name", NULL);

    //Find common commit in master and branch
    git_oid merge_base;
    get_julia_origin_master_merge_base(&merge_base, repo);

    // get last commit in master
    git_commit *merge_base_commit;
    check_lg2(git_commit_lookup(&merge_base_commit, repo, &merge_base), "getting commit", NULL);
    
    printf("const GIT_VERSION_INFO = GitVersionInfo(\n");
    printf("    \"%.40s\",\n", head_hash); //commit
    printf("    \"%.8s\",\n", head_hash);  //commit_short
    printf("    \"%s\",\n", branch);//branch
    printf("    %d,\n", get_julia_build_number(repo));//build_number
    printf("    \"Timestamp: %lld\",\n", git_commit_time(head_commit));//date_string
    if(1){//tagged_commit
        printf("    True,\n");
    }else{
        printf("    False,\n");
    }
    printf("    %d,\n", get_julia_fork_master_distance(repo, &merge_base)); //fork_master_distance
    printf("    %lld.\n",  git_commit_time(merge_base_commit));//fork_master_timestamp
    printf(")\n");

    git_threads_shutdown();
    return 0;
}

static void get_julia_origin_master_merge_base(git_oid* merge_base, git_repository *repo){
    git_oid current;
    git_oid master;
    check_lg2(git_reference_name_to_id(&current, repo, "HEAD"), "fetching head", NULL);
    
    //Get the remote that has a substring "JuliaLang/julia" in the url
    git_strarray strarr;
    check_lg2(git_remote_list(&strarr, repo),"remote_list", NULL);
    git_remote *remote;
    for(int i = 0; i< strarr.count; i++){
        git_remote_load(&remote, repo, strarr.strings[i]);
        if(strstr(git_remote_url(remote), "JuliaLang/julia")){
            break;
        }
        git_remote_free(remote);
        remote = NULL;
    }
    git_strarray_free(&strarr);
    if(remote){
        char remote_name[255] = "refs/remotes/";
        strncat(remote_name, git_remote_name(remote), 255-1-strlen(remote_name));
        strncat(remote_name, "/", 255 - 1 - strlen(remote_name));
        strncat(remote_name, "master", 255 - 1 - strlen(remote_name));
        check_lg2(git_reference_name_to_id(&master, repo, remote_name), "reference_name_to_id",NULL);
    }else{
        fprintf(stderr, "Failed getting remote");
        exit(1);
    }
    check_lg2(git_merge_base(merge_base, repo, &master, &current), "merge base", NULL);
    return;
}
// replacement for the native libgit2 git_revwalk_hide_glob
// because of https://github.com/libgit2/libgit2/issues/2090
// solution from http://stackoverflow.com/questions/21460474/
static void julia_git_revwalk_hide_glob(git_revwalk *walk, char* glob){
    git_reference_iterator *iter;
    git_reference *ref;
    git_repository* repo = git_revwalk_repository(walk);

    check_lg2(git_reference_iterator_glob_new(&iter, repo, glob), "git_reference_iterator_glob_new", NULL);
    while (git_reference_next(&ref, iter) == 0) {
        git_object *obj;

        /* go down to a commit object */
        check_lg2(git_reference_peel(&obj, ref, GIT_OBJ_COMMIT), "git_reference_peel", NULL);
        /* and hide that */
        check_lg2(git_revwalk_hide(walk, git_object_id(obj)), "revwalk_hide", NULL);

        git_object_free(obj);
        git_reference_free(ref);
    }
}

static int get_julia_build_number(git_repository *repo){
    git_revwalk *walk;
    check_lg2(git_revwalk_new(&walk, repo), "revwalk_new", NULL);
//    git_revwalk_sorting(walk,
//        GIT_SORT_TOPOLOGICAL |
//        GIT_SORT_TIME);
    git_revwalk_push_head(walk);
    // this should work, but failes with annotated tags that Julia use
    //check_lg2(git_revwalk_hide_glob(walk, "refs/tags/*"),"revwalk_hide_glob",NULL);
    julia_git_revwalk_hide_glob(walk, "refs/tags/*");
//    git_revwalk_simplify_first_parent(walk);

    int i = 0;
    git_oid oid;
    while (git_revwalk_next(&oid, walk) == 0) {
        git_commit *c;

        git_commit_lookup(&c, repo, &oid);
        // Exclude merge commits but include root commits and normal commits
        // TODO: uncomment after 0.3
        // if(git_commit_parentcount(c) < 2)
            i++;
        git_commit_free(c);
    }
    return i;
}


static int get_julia_fork_master_distance(git_repository *repo, git_oid *merge_base){
    git_revwalk *walk;
    check_lg2(git_revwalk_new(&walk, repo), "revwalk_new", NULL);
    git_revwalk_sorting(walk,
        GIT_SORT_TOPOLOGICAL |
        GIT_SORT_TIME);
    git_revwalk_push_head(walk);
    git_revwalk_hide(walk, merge_base);
//    git_revwalk_simplify_first_parent(walk);

    int i = 0;
    git_oid oid;
    while (git_revwalk_next(&oid, walk) == 0) {
        git_commit *c;
        //char oidstr[10] = {0};

        git_commit_lookup(&c, repo, &oid);
        //git_oid_tostr(oidstr, 9, &oid);
        if(git_commit_parentcount(c) == 1)
            i++;
        git_commit_free(c);
    }
    return i;
}
/*
 * Sample code copied from
 * https://github.com/libgit2/libgit2/blob/6cb831bd5667d934d8947279523cb235b4f8bba4/examples/common.c#L17-38
 * Licence: Public Domain
 */
static void check_lg2(int error, const char *message, const char *extra)
{
    const git_error *lg2err;
    const char *lg2msg = "", *lg2spacer = "";

    if (!error)
        return;

    if ((lg2err = giterr_last()) != NULL && lg2err->message != NULL) {
        lg2msg = lg2err->message;
        lg2spacer = " - ";
    }

    if (extra)
        fprintf(stderr, "%s '%s' [%d]%s%s\n",
            message, extra, error, lg2spacer, lg2msg);
    else
        fprintf(stderr, "%s [%d]%s%s\n",
            message, error, lg2spacer, lg2msg);

    exit(1);
}
