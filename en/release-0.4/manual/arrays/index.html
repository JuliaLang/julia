

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Multi-dimensional Arrays &mdash; Julia Language 0.4.8-pre documentation</title>
  

  
  

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/julia.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../../_static/julia.css" type="text/css" />
  
    <link rel="top" title="Julia Language 0.4.8-pre documentation" href="../../"/>
        <link rel="next" title="Linear algebra" href="../linear-algebra/"/>
        <link rel="prev" title="Metaprogramming" href="../metaprogramming/"/> 

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div style="text-align:center; background-color:pink; padding:5px 0; font-size:14px; height:30px;">
    This is document is for an old version of Julia.
    Please checkout the
    <a href="https://docs.julialang.org/en/stable/"
       style="color: #2980B9;">
      current stable release
    </a>.
  </div>

  <div class="wy-grid-for-nav" style="top: 30px;">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        <a href="http://julialang.org/"><img src="../../_static/julia-logo.svg" class="logo"></a>
        <!--
        <a href="../../" class="fa fa-home"> Julia Language</a>
        -->
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search/" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
        
            <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../introduction/">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../getting-started/">Getting Started</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../getting-started/#resources">Resources</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../variables/">Variables</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../variables/#allowed-variable-names">Allowed Variable Names</a></li>
<li class="toctree-l2"><a class="reference internal" href="../variables/#stylistic-conventions">Stylistic Conventions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../integers-and-floating-point-numbers/">Integers and Floating-Point Numbers</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../integers-and-floating-point-numbers/#integers">Integers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../integers-and-floating-point-numbers/#floating-point-numbers">Floating-Point Numbers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../integers-and-floating-point-numbers/#arbitrary-precision-arithmetic">Arbitrary Precision Arithmetic</a></li>
<li class="toctree-l2"><a class="reference internal" href="../integers-and-floating-point-numbers/#numeric-literal-coefficients">Numeric Literal Coefficients</a></li>
<li class="toctree-l2"><a class="reference internal" href="../integers-and-floating-point-numbers/#literal-zero-and-one">Literal zero and one</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../mathematical-operations/">Mathematical Operations and Elementary Functions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../mathematical-operations/#arithmetic-operators">Arithmetic Operators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical-operations/#bitwise-operators">Bitwise Operators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical-operations/#updating-operators">Updating operators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical-operations/#numeric-comparisons">Numeric Comparisons</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical-operations/#numerical-conversions">Numerical Conversions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../complex-and-rational-numbers/">Complex and Rational Numbers</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../complex-and-rational-numbers/#complex-numbers">Complex Numbers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../complex-and-rational-numbers/#rational-numbers">Rational Numbers</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../strings/">Strings</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../strings/#characters">Characters</a></li>
<li class="toctree-l2"><a class="reference internal" href="../strings/#string-basics">String Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../strings/#unicode-and-utf-8">Unicode and UTF-8</a></li>
<li class="toctree-l2"><a class="reference internal" href="../strings/#interpolation">Interpolation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../strings/#triple-quoted-string-literals">Triple-Quoted String Literals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../strings/#common-operations">Common Operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../strings/#non-standard-string-literals">Non-Standard String Literals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../strings/#regular-expressions">Regular Expressions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../strings/#id3">Byte Array Literals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../strings/#version-number-literals">Version Number Literals</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../functions/">Functions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../functions/#argument-passing-behavior">Argument Passing Behavior</a></li>
<li class="toctree-l2"><a class="reference internal" href="../functions/#the-return-keyword">The <code class="docutils literal"><span class="pre">return</span></code> Keyword</a></li>
<li class="toctree-l2"><a class="reference internal" href="../functions/#operators-are-functions">Operators Are Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../functions/#operators-with-special-names">Operators With Special Names</a></li>
<li class="toctree-l2"><a class="reference internal" href="../functions/#anonymous-functions">Anonymous Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../functions/#multiple-return-values">Multiple Return Values</a></li>
<li class="toctree-l2"><a class="reference internal" href="../functions/#varargs-functions">Varargs Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../functions/#optional-arguments">Optional Arguments</a></li>
<li class="toctree-l2"><a class="reference internal" href="../functions/#keyword-arguments">Keyword Arguments</a></li>
<li class="toctree-l2"><a class="reference internal" href="../functions/#evaluation-scope-of-default-values">Evaluation Scope of Default Values</a></li>
<li class="toctree-l2"><a class="reference internal" href="../functions/#do-block-syntax-for-function-arguments">Do-Block Syntax for Function Arguments</a></li>
<li class="toctree-l2"><a class="reference internal" href="../functions/#further-reading">Further Reading</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../control-flow/">Control Flow</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../control-flow/#compound-expressions">Compound Expressions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../control-flow/#conditional-evaluation">Conditional Evaluation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../control-flow/#short-circuit-evaluation">Short-Circuit Evaluation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../control-flow/#repeated-evaluation-loops">Repeated Evaluation: Loops</a></li>
<li class="toctree-l2"><a class="reference internal" href="../control-flow/#exception-handling">Exception Handling</a></li>
<li class="toctree-l2"><a class="reference internal" href="../control-flow/#tasks-aka-coroutines">Tasks (aka Coroutines)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../variables-and-scoping/">Scope of Variables</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../variables-and-scoping/#global-scope">Global Scope</a></li>
<li class="toctree-l2"><a class="reference internal" href="../variables-and-scoping/#local-scope">Local Scope</a></li>
<li class="toctree-l2"><a class="reference internal" href="../variables-and-scoping/#constants">Constants</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../types/">Types</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../types/#type-declarations">Type Declarations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../types/#abstract-types">Abstract Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../types/#bits-types">Bits Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../types/#composite-types">Composite Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../types/#immutable-composite-types">Immutable Composite Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../types/#declared-types">Declared Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../types/#type-unions">Type Unions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../types/#man-parametric-types">Parametric Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../types/#type-aliases">Type Aliases</a></li>
<li class="toctree-l2"><a class="reference internal" href="../types/#operations-on-types">Operations on Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../types/#value-types">&#8220;Value types&#8221;</a></li>
<li class="toctree-l2"><a class="reference internal" href="../types/#nullable-types-representing-missing-values">Nullable Types: Representing Missing Values</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../methods/">Methods</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../methods/#defining-methods">Defining Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="../methods/#method-ambiguities">Method Ambiguities</a></li>
<li class="toctree-l2"><a class="reference internal" href="../methods/#parametric-methods">Parametric Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="../methods/#note-on-optional-and-keyword-arguments">Note on Optional and keyword Arguments</a></li>
<li class="toctree-l2"><a class="reference internal" href="../methods/#call-overloading-and-function-like-objects">Call overloading and function-like objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="../methods/#empty-generic-functions">Empty generic functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../constructors/">Constructors</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../constructors/#outer-constructor-methods">Outer Constructor Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="../constructors/#inner-constructor-methods">Inner Constructor Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="../constructors/#incomplete-initialization">Incomplete Initialization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../constructors/#parametric-constructors">Parametric Constructors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../constructors/#case-study-rational">Case Study: Rational</a></li>
<li class="toctree-l2"><a class="reference internal" href="../constructors/#constructors-call-and-conversion">Constructors, Call, and Conversion</a></li>
<li class="toctree-l2"><a class="reference internal" href="../constructors/#outer-only-constructors">Outer-only constructors</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../conversion-and-promotion/">Conversion and Promotion</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../conversion-and-promotion/#conversion">Conversion</a></li>
<li class="toctree-l2"><a class="reference internal" href="../conversion-and-promotion/#promotion">Promotion</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../interfaces/">Interfaces</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../interfaces/#iteration">Iteration</a></li>
<li class="toctree-l2"><a class="reference internal" href="../interfaces/#indexing">Indexing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../interfaces/#abstract-arrays">Abstract Arrays</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../modules/">Modules</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../modules/#summary-of-module-usage">Summary of module usage</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../documentation/">Documentation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../documentation/#accessing-documentation">Accessing Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../documentation/#functions-methods">Functions &amp; Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="../documentation/#advanced-usage">Advanced Usage</a></li>
<li class="toctree-l2"><a class="reference internal" href="../documentation/#syntax-guide">Syntax Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../documentation/#markdown-syntax-notes">Markdown Syntax Notes</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../metaprogramming/">Metaprogramming</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../metaprogramming/#program-representation">Program representation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../metaprogramming/#expressions-and-evaluation">Expressions and evaluation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../metaprogramming/#macros">Macros</a></li>
<li class="toctree-l2"><a class="reference internal" href="../metaprogramming/#code-generation">Code Generation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../metaprogramming/#non-standard-string-literals">Non-Standard String Literals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../metaprogramming/#generated-functions">Generated functions</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Multi-dimensional Arrays</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#arrays">Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="#sparse-matrices">Sparse Matrices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../linear-algebra/">Linear algebra</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../linear-algebra/#matrix-factorizations">Matrix factorizations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../linear-algebra/#special-matrices">Special matrices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../networking-and-streams/">Networking and Streams</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../networking-and-streams/#basic-stream-i-o">Basic Stream I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../networking-and-streams/#text-i-o">Text I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../networking-and-streams/#working-with-files">Working with Files</a></li>
<li class="toctree-l2"><a class="reference internal" href="../networking-and-streams/#a-simple-tcp-example">A simple TCP example</a></li>
<li class="toctree-l2"><a class="reference internal" href="../networking-and-streams/#resolving-ip-addresses">Resolving IP Addresses</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../parallel-computing/">Parallel Computing</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../parallel-computing/#code-availability-and-loading-packages">Code Availability and Loading Packages</a></li>
<li class="toctree-l2"><a class="reference internal" href="../parallel-computing/#data-movement">Data Movement</a></li>
<li class="toctree-l2"><a class="reference internal" href="../parallel-computing/#parallel-map-and-loops">Parallel Map and Loops</a></li>
<li class="toctree-l2"><a class="reference internal" href="../parallel-computing/#synchronization-with-remote-references">Synchronization With Remote References</a></li>
<li class="toctree-l2"><a class="reference internal" href="../parallel-computing/#scheduling">Scheduling</a></li>
<li class="toctree-l2"><a class="reference internal" href="../parallel-computing/#channels">Channels</a></li>
<li class="toctree-l2"><a class="reference internal" href="../parallel-computing/#remoterefs-and-abstractchannels">RemoteRefs and AbstractChannels</a></li>
<li class="toctree-l2"><a class="reference internal" href="../parallel-computing/#shared-arrays">Shared Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="../parallel-computing/#distributed-garbage-collection">Distributed Garbage Collection</a></li>
<li class="toctree-l2"><a class="reference internal" href="../parallel-computing/#clustermanagers">ClusterManagers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../parallel-computing/#cluster-managers-with-custom-transports">Cluster Managers with custom transports</a></li>
<li class="toctree-l2"><a class="reference internal" href="../parallel-computing/#specifying-network-topology-experimental">Specifying network topology (Experimental)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../dates/">Date and DateTime</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../dates/#constructors">Constructors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dates/#durations-comparisons">Durations/Comparisons</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dates/#accessor-functions">Accessor Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dates/#query-functions">Query Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dates/#timetype-period-arithmetic">TimeType-Period Arithmetic</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dates/#adjuster-functions">Adjuster Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dates/#period-types">Period Types</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../running-external-programs/">Running External Programs</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../running-external-programs/#interpolation">Interpolation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../running-external-programs/#quoting">Quoting</a></li>
<li class="toctree-l2"><a class="reference internal" href="../running-external-programs/#pipelines">Pipelines</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../calling-c-and-fortran-code/">Calling C and Fortran Code</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../calling-c-and-fortran-code/#creating-c-compatible-julia-function-pointers">Creating C-Compatible Julia Function Pointers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../calling-c-and-fortran-code/#mapping-c-types-to-julia">Mapping C Types to Julia</a></li>
<li class="toctree-l2"><a class="reference internal" href="../calling-c-and-fortran-code/#mapping-c-functions-to-julia">Mapping C Functions to Julia</a></li>
<li class="toctree-l2"><a class="reference internal" href="../calling-c-and-fortran-code/#garbage-collection-safety">Garbage Collection Safety</a></li>
<li class="toctree-l2"><a class="reference internal" href="../calling-c-and-fortran-code/#non-constant-function-specifications">Non-constant Function Specifications</a></li>
<li class="toctree-l2"><a class="reference internal" href="../calling-c-and-fortran-code/#indirect-calls">Indirect Calls</a></li>
<li class="toctree-l2"><a class="reference internal" href="../calling-c-and-fortran-code/#calling-convention">Calling Convention</a></li>
<li class="toctree-l2"><a class="reference internal" href="../calling-c-and-fortran-code/#accessing-global-variables">Accessing Global Variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="../calling-c-and-fortran-code/#accessing-data-through-a-pointer">Accessing Data through a Pointer</a></li>
<li class="toctree-l2"><a class="reference internal" href="../calling-c-and-fortran-code/#thread-safety">Thread-safety</a></li>
<li class="toctree-l2"><a class="reference internal" href="../calling-c-and-fortran-code/#more-about-callbacks">More About Callbacks</a></li>
<li class="toctree-l2"><a class="reference internal" href="../calling-c-and-fortran-code/#c">C++</a></li>
<li class="toctree-l2"><a class="reference internal" href="../calling-c-and-fortran-code/#handling-operating-system-variation">Handling Operating System Variation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../interacting-with-julia/">Interacting With Julia</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../interacting-with-julia/#the-different-prompt-modes">The different prompt modes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../interacting-with-julia/#key-bindings">Key bindings</a></li>
<li class="toctree-l2"><a class="reference internal" href="../interacting-with-julia/#tab-completion">Tab completion</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../embedding/">Embedding Julia</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../embedding/#high-level-embedding">High-Level Embedding</a></li>
<li class="toctree-l2"><a class="reference internal" href="../embedding/#converting-types">Converting Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../embedding/#calling-julia-functions">Calling Julia Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../embedding/#memory-management">Memory Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="../embedding/#working-with-arrays">Working with Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="../embedding/#exceptions">Exceptions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../packages/">Packages</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../packages/#package-status">Package Status</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/#adding-and-removing-packages">Adding and Removing Packages</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/#offline-installation-of-packages">Offline Installation of Packages</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/#installing-unregistered-packages">Installing Unregistered Packages</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/#updating-packages">Updating Packages</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/#checkout-pin-and-free">Checkout, Pin and Free</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/#custom-metadata-repository">Custom METADATA Repository</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../packages/#package-development">Package Development</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../packages/#initial-setup">Initial Setup</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/#making-changes-to-an-existing-package">Making changes to an existing package</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/#creating-a-new-package">Creating a new Package</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/#fixing-package-requirements">Fixing Package Requirements</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/#man-package-requirements">Requirements Specification</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../profile/">Profiling</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../profile/#basic-usage">Basic usage</a></li>
<li class="toctree-l2"><a class="reference internal" href="../profile/#accumulation-and-clearing">Accumulation and clearing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../profile/#options-for-controlling-the-display-of-profile-results">Options for controlling the display of profile results</a></li>
<li class="toctree-l2"><a class="reference internal" href="../profile/#configuration">Configuration</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../profile/#memory-allocation-analysis">Memory allocation analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../performance-tips/">Performance Tips</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../performance-tips/#avoid-global-variables">Avoid global variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="../performance-tips/#measure-performance-with-time-and-pay-attention-to-memory-allocation">Measure performance with <code class="docutils literal"><span class="pre">&#64;time</span></code> and pay attention to memory allocation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../performance-tips/#tools">Tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="../performance-tips/#avoid-containers-with-abstract-type-parameters">Avoid containers with abstract type parameters</a></li>
<li class="toctree-l2"><a class="reference internal" href="../performance-tips/#type-declarations">Type declarations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../performance-tips/#break-functions-into-multiple-definitions">Break functions into multiple definitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../performance-tips/#write-type-stable-functions">Write &#8220;type-stable&#8221; functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../performance-tips/#avoid-changing-the-type-of-a-variable">Avoid changing the type of a variable</a></li>
<li class="toctree-l2"><a class="reference internal" href="../performance-tips/#separate-kernel-functions">Separate kernel functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../performance-tips/#access-arrays-in-memory-order-along-columns">Access arrays in memory order, along columns</a></li>
<li class="toctree-l2"><a class="reference internal" href="../performance-tips/#pre-allocating-outputs">Pre-allocating outputs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../performance-tips/#avoid-string-interpolation-for-i-o">Avoid string interpolation for I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../performance-tips/#optimize-network-i-o-during-parallel-execution">Optimize network I/O during parallel execution</a></li>
<li class="toctree-l2"><a class="reference internal" href="../performance-tips/#fix-deprecation-warnings">Fix deprecation warnings</a></li>
<li class="toctree-l2"><a class="reference internal" href="../performance-tips/#tweaks">Tweaks</a></li>
<li class="toctree-l2"><a class="reference internal" href="../performance-tips/#performance-annotations">Performance Annotations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../performance-tips/#treat-subnormal-numbers-as-zeros">Treat Subnormal Numbers as Zeros</a></li>
<li class="toctree-l2"><a class="reference internal" href="../performance-tips/#code-warntype"><code class="docutils literal"><span class="pre">&#64;code_warntype</span></code></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../workflow-tips/">Workflow Tips</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../workflow-tips/#repl-based-workflow">REPL-based workflow</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflow-tips/#browser-based-workflow">Browser-based workflow</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../style-guide/">Style Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#write-functions-not-just-scripts">Write functions, not just scripts</a></li>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#avoid-writing-overly-specific-types">Avoid writing overly-specific types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#handle-excess-argument-diversity-in-the-caller">Handle excess argument diversity in the caller</a></li>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#append-to-names-of-functions-that-modify-their-arguments">Append <code class="docutils literal"><span class="pre">!</span></code> to names of functions that modify their arguments</a></li>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#avoid-strange-type-unions">Avoid strange type Unions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#avoid-type-unions-in-fields">Avoid type Unions in fields</a></li>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#avoid-elaborate-container-types">Avoid elaborate container types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#use-naming-conventions-consistent-with-julia-s-base">Use naming conventions consistent with Julia&#8217;s <code class="docutils literal"><span class="pre">base/</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#don-t-overuse-try-catch">Don&#8217;t overuse try-catch</a></li>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#don-t-parenthesize-conditions">Don&#8217;t parenthesize conditions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#don-t-overuse">Don&#8217;t overuse ...</a></li>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#don-t-use-unnecessary-static-parameters">Don&#8217;t use unnecessary static parameters</a></li>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#avoid-confusion-about-whether-something-is-an-instance-or-a-type">Avoid confusion about whether something is an instance or a type</a></li>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#don-t-overuse-macros">Don&#8217;t overuse macros</a></li>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#don-t-expose-unsafe-operations-at-the-interface-level">Don&#8217;t expose unsafe operations at the interface level</a></li>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#don-t-overload-methods-of-base-container-types">Don&#8217;t overload methods of base container types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#be-careful-with-type-equality">Be careful with type equality</a></li>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#do-not-write-x-f-x">Do not write <code class="docutils literal"><span class="pre">x-&gt;f(x)</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#avoid-using-floats-for-numeric-literals-in-generic-code-when-possible">Avoid using floats for numeric literals in generic code when possible</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../faq/">Frequently Asked Questions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../faq/#sessions-and-the-repl">Sessions and the REPL</a></li>
<li class="toctree-l2"><a class="reference internal" href="../faq/#functions">Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../faq/#types-type-declarations-and-constructors">Types, type declarations, and constructors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../faq/#packages-and-modules">Packages and Modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="../faq/#nothingness-and-missing-values">Nothingness and missing values</a></li>
<li class="toctree-l2"><a class="reference internal" href="../faq/#memory">Memory</a></li>
<li class="toctree-l2"><a class="reference internal" href="../faq/#asynchronous-io-and-concurrent-synchronous-writes">Asynchronous IO and concurrent synchronous writes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../faq/#julia-releases">Julia Releases</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../noteworthy-differences/">Noteworthy Differences from other Languages</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../noteworthy-differences/#noteworthy-differences-from-matlab">Noteworthy differences from MATLAB</a></li>
<li class="toctree-l2"><a class="reference internal" href="../noteworthy-differences/#noteworthy-differences-from-r">Noteworthy differences from R</a></li>
<li class="toctree-l2"><a class="reference internal" href="../noteworthy-differences/#noteworthy-differences-from-python">Noteworthy differences from Python</a></li>
<li class="toctree-l2"><a class="reference internal" href="../noteworthy-differences/#noteworthy-differences-from-c-c">Noteworthy differences from C/C++</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../unicode-input/">Unicode Input</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/base/">Essentials</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/base/#introduction">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/base/#getting-around">Getting Around</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/base/#all-objects">All Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/base/#types">Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/base/#generic-functions">Generic Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/base/#syntax">Syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/base/#nullables">Nullables</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/base/#system">System</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/base/#errors">Errors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/base/#events">Events</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/base/#reflection">Reflection</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/base/#internals">Internals</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/collections/">Collections and Data Structures</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/collections/#iteration">Iteration</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/collections/#general-collections">General Collections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/collections/#iterable-collections">Iterable Collections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/collections/#indexable-collections">Indexable Collections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/collections/#associative-collections">Associative Collections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/collections/#set-like-collections">Set-Like Collections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/collections/#dequeues">Dequeues</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/collections/#priorityqueue">PriorityQueue</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/collections/#heap-functions">Heap Functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/math/">Mathematics</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/math/#mathematical-operators">Mathematical Operators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/math/#mathematical-functions">Mathematical Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/math/#statistics">Statistics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/math/#signal-processing">Signal Processing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/math/#numerical-integration">Numerical Integration</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/numbers/">Numbers</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/numbers/#standard-numeric-types">Standard Numeric Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/numbers/#data-formats">Data Formats</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/numbers/#general-number-functions-and-constants">General Number Functions and Constants</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/numbers/#bigfloats">BigFloats</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/numbers/#random-numbers">Random Numbers</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/strings/">Strings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/arrays/">Arrays</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/arrays/#basic-functions">Basic functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/arrays/#constructors">Constructors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/arrays/#mathematical-operators-and-functions">Mathematical operators and functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/arrays/#indexing-assignment-and-concatenation">Indexing, Assignment, and Concatenation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/arrays/#array-functions">Array functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/arrays/#combinatorics">Combinatorics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/arrays/#bitarrays">BitArrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/arrays/#sparse-matrices">Sparse Matrices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/parallel/">Tasks and Parallel Computing</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/parallel/#tasks">Tasks</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/parallel/#general-parallel-computing-support">General Parallel Computing Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/parallel/#shared-arrays">Shared Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/parallel/#cluster-manager-interface">Cluster Manager Interface</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/linalg/">Linear Algebra</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/linalg/#module-Base.LinAlg">Standard Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/linalg/#module-Base.LinAlg.BLAS">BLAS Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/linalg/#module-Base.LinAlg.LAPACK">LAPACK Functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/constants/">Constants</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/file/">Filesystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/io-network/">I/O and Network</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/io-network/#general-i-o">General I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/io-network/#text-i-o">Text I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/io-network/#multimedia-i-o">Multimedia I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/io-network/#memory-mapped-i-o">Memory-mapped I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/io-network/#network-i-o">Network I/O</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/punctuation/">Punctuation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/sort/">Sorting and Related Functions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/sort/#sorting-functions">Sorting Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/sort/#order-related-functions">Order-Related Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/sort/#sorting-algorithms">Sorting Algorithms</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/pkg/">Package Manager Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/dates/">Dates and Time</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/dates/#dates-and-time-types">Dates and Time Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/dates/#dates-functions">Dates Functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/test/">Unit and Functional Testing</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/test/#testing-base-julia">Testing Base Julia</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/test/#test-framework">Test Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/test/#handlers">Handlers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/test/#macros">Macros</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/test/#functions">Functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/c/">C Interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/c/#llvm-interface">LLVM Interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/libc/">C Standard Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/libdl/">Dynamic Linker</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/profile/">Profiling</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../devdocs/reflection/">Reflection and introspection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../devdocs/julia/">Documentation of Julia&#8217;s Internals</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/init/">Initialization of the Julia runtime</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/eval/">Eval of Julia code</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/ast/">Julia ASTs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/types/">More about types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/object/">Memory layout of Julia Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/cartesian/">Base.Cartesian</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/meta/">Talking to the compiler (the <code class="docutils literal"><span class="pre">:meta</span></code> mechanism)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/subarrays/">SubArrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/sysimg/">System Image Building</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/llvm/">Working with LLVM</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/stdio/">printf() and stdio in the Julia runtime</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/promote-op/">Operator-sensitive promotion</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../devdocs/C/">Developing/debugging Julia&#8217;s C code</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/backtraces/">Reporting and analyzing crashes (segfaults)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/debuggingtips/">gdb debugging tips</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/valgrind/">Using Valgrind with Julia</a></li>
</ul>
</li>
</ul>

        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../">Julia Language</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../">Docs</a> &raquo;</li>
      
    <li>Multi-dimensional Arrays</li>
      <li class="wy-breadcrumbs-aside">
        
          <a href="../../_sources/manual/arrays.txt" rel="nofollow"> View page source</a>
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document">
            
  <div class="section" id="multi-dimensional-arrays">
<span id="man-arrays"></span><h1>Multi-dimensional Arrays<a class="headerlink" href="#multi-dimensional-arrays" title="Permalink to this headline">¶</a></h1>
<p>Julia, like most technical computing languages, provides a first-class
array implementation. Most technical computing languages pay a lot of
attention to their array implementation at the expense of other
containers. Julia does not treat arrays in any special way. The array
library is implemented almost completely in Julia itself, and derives
its performance from the compiler, just like any other code written in
Julia. As such, it&#8217;s also possible to define custom array types by
inheriting from <code class="docutils literal"><span class="pre">AbstractArray.</span></code> See the <a class="reference internal" href="../interfaces/#man-interfaces-abstractarray"><span class="std std-ref">manual section on the
AbstractArray interface</span></a> for more details
on implementing a custom array type.</p>
<p>An array is a collection of objects stored in a multi-dimensional
grid.  In the most general case, an array may contain objects of type
<code class="docutils literal"><span class="pre">Any</span></code>.  For most computational purposes, arrays should contain
objects of a more specific type, such as <code class="docutils literal"><span class="pre">Float64</span></code> or <code class="docutils literal"><span class="pre">Int32</span></code>.</p>
<p>In general, unlike many other technical computing languages, Julia does
not expect programs to be written in a vectorized style for performance.
Julia&#8217;s compiler uses type inference and generates optimized code for
scalar array indexing, allowing programs to be written in a style that
is convenient and readable, without sacrificing performance, and using
less memory at times.</p>
<p>In Julia, all arguments to functions are passed by reference. Some
technical computing languages pass arrays by value, and this is
convenient in many cases. In Julia, modifications made to input arrays
within a function will be visible in the parent function. The entire
Julia array library ensures that inputs are not modified by library
functions. User code, if it needs to exhibit similar behavior, should
take care to create a copy of inputs that it may modify.</p>
<div class="section" id="arrays">
<h2>Arrays<a class="headerlink" href="#arrays" title="Permalink to this headline">¶</a></h2>
<div class="section" id="basic-functions">
<h3>Basic Functions<a class="headerlink" href="#basic-functions" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<colgroup>
<col width="28%" />
<col width="72%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Function</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><a class="reference internal" href="../../stdlib/collections/#Base.eltype" title="Base.eltype"><code class="xref jl jl-func docutils literal"><span class="pre">eltype(A)</span></code></a></td>
<td>the type of the elements contained in <code class="docutils literal"><span class="pre">A</span></code></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="../../stdlib/strings/#Base.length" title="Base.length"><code class="xref jl jl-func docutils literal"><span class="pre">length(A)</span></code></a></td>
<td>the number of elements in <code class="docutils literal"><span class="pre">A</span></code></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="../../stdlib/arrays/#Base.ndims" title="Base.ndims"><code class="xref jl jl-func docutils literal"><span class="pre">ndims(A)</span></code></a></td>
<td>the number of dimensions of <code class="docutils literal"><span class="pre">A</span></code></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="../../stdlib/arrays/#Base.size" title="Base.size"><code class="xref jl jl-func docutils literal"><span class="pre">size(A)</span></code></a></td>
<td>a tuple containing the dimensions of <code class="docutils literal"><span class="pre">A</span></code></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="../../stdlib/arrays/#Base.size" title="Base.size"><code class="xref jl jl-func docutils literal"><span class="pre">size(A,n)</span></code></a></td>
<td>the size of <code class="docutils literal"><span class="pre">A</span></code> in a particular dimension</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="../../stdlib/arrays/#Base.eachindex" title="Base.eachindex"><code class="xref jl jl-func docutils literal"><span class="pre">eachindex(A)</span></code></a></td>
<td>an efficient iterator for visiting each position in <code class="docutils literal"><span class="pre">A</span></code></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="../../stdlib/arrays/#Base.stride" title="Base.stride"><code class="xref jl jl-func docutils literal"><span class="pre">stride(A,k)</span></code></a></td>
<td>the stride (linear index distance between adjacent elements) along dimension <code class="docutils literal"><span class="pre">k</span></code></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="../../stdlib/arrays/#Base.strides" title="Base.strides"><code class="xref jl jl-func docutils literal"><span class="pre">strides(A)</span></code></a></td>
<td>a tuple of the strides in each dimension</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="construction-and-initialization">
<h3>Construction and Initialization<a class="headerlink" href="#construction-and-initialization" title="Permalink to this headline">¶</a></h3>
<p>Many functions for constructing and initializing arrays are provided. In
the following list of such functions, calls with a <code class="docutils literal"><span class="pre">dims...</span></code> argument
can either take a single tuple of dimension sizes or a series of
dimension sizes passed as a variable number of arguments.</p>
<table border="1" class="docutils">
<colgroup>
<col width="43%" />
<col width="58%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Function</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><a class="reference internal" href="../../stdlib/arrays/#Base.Array" title="Base.Array"><code class="xref jl jl-func docutils literal"><span class="pre">Array(type,</span> <span class="pre">dims...)</span></code></a></td>
<td>an uninitialized dense array</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="../../stdlib/arrays/#Base.cell" title="Base.cell"><code class="xref jl jl-func docutils literal"><span class="pre">cell(dims...)</span></code></a></td>
<td>an uninitialized cell array (heterogeneous array)</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="../../stdlib/arrays/#Base.zeros" title="Base.zeros"><code class="xref jl jl-func docutils literal"><span class="pre">zeros(type,</span> <span class="pre">dims...)</span></code></a></td>
<td>an array of all zeros of specified type, defaults to <code class="docutils literal"><span class="pre">Float64</span></code> if
<code class="docutils literal"><span class="pre">type</span></code> not specified</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="../../stdlib/arrays/#Base.zeros" title="Base.zeros"><code class="xref jl jl-func docutils literal"><span class="pre">zeros(A)</span></code></a></td>
<td>an array of all zeros of same element type and shape of <code class="docutils literal"><span class="pre">A</span></code></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="../../stdlib/arrays/#Base.ones" title="Base.ones"><code class="xref jl jl-func docutils literal"><span class="pre">ones(type,</span> <span class="pre">dims...)</span></code></a></td>
<td>an array of all ones of specified type, defaults to <code class="docutils literal"><span class="pre">Float64</span></code> if
<code class="docutils literal"><span class="pre">type</span></code> not specified</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="../../stdlib/arrays/#Base.ones" title="Base.ones"><code class="xref jl jl-func docutils literal"><span class="pre">ones(A)</span></code></a></td>
<td>an array of all ones of same element type and shape of <code class="docutils literal"><span class="pre">A</span></code></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="../../stdlib/arrays/#Base.trues" title="Base.trues"><code class="xref jl jl-func docutils literal"><span class="pre">trues(dims...)</span></code></a></td>
<td>a <code class="docutils literal"><span class="pre">Bool</span></code> array with all values <code class="docutils literal"><span class="pre">true</span></code></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="../../stdlib/arrays/#Base.trues" title="Base.trues"><code class="xref jl jl-func docutils literal"><span class="pre">trues(A)</span></code></a></td>
<td>a <code class="docutils literal"><span class="pre">Bool</span></code> array with all values <code class="docutils literal"><span class="pre">true</span></code> and the shape of <code class="docutils literal"><span class="pre">A</span></code></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="../../stdlib/arrays/#Base.falses" title="Base.falses"><code class="xref jl jl-func docutils literal"><span class="pre">falses(dims...)</span></code></a></td>
<td>a <code class="docutils literal"><span class="pre">Bool</span></code> array with all values <code class="docutils literal"><span class="pre">false</span></code></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="../../stdlib/arrays/#Base.falses" title="Base.falses"><code class="xref jl jl-func docutils literal"><span class="pre">falses(A)</span></code></a></td>
<td>a <code class="docutils literal"><span class="pre">Bool</span></code> array with all values <code class="docutils literal"><span class="pre">false</span></code> and the shape of <code class="docutils literal"><span class="pre">A</span></code></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="../../stdlib/arrays/#Base.reshape" title="Base.reshape"><code class="xref jl jl-func docutils literal"><span class="pre">reshape(A,</span> <span class="pre">dims...)</span></code></a></td>
<td>an array with the same data as the given array, but with
different dimensions.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="../../stdlib/base/#Base.copy" title="Base.copy"><code class="xref jl jl-func docutils literal"><span class="pre">copy(A)</span></code></a></td>
<td>copy <code class="docutils literal"><span class="pre">A</span></code></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="../../stdlib/base/#Base.deepcopy" title="Base.deepcopy"><code class="xref jl jl-func docutils literal"><span class="pre">deepcopy(A)</span></code></a></td>
<td>copy <code class="docutils literal"><span class="pre">A</span></code>, recursively copying its elements</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="../../stdlib/arrays/#Base.similar" title="Base.similar"><code class="xref jl jl-func docutils literal"><span class="pre">similar(A,</span> <span class="pre">element_type,</span> <span class="pre">dims...)</span></code></a></td>
<td>an uninitialized array of the same type as the given array
(dense, sparse, etc.), but with the specified element type and
dimensions. The second and third arguments are both optional,
defaulting to the element type and dimensions of <code class="docutils literal"><span class="pre">A</span></code> if omitted.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="../../stdlib/arrays/#Base.reinterpret" title="Base.reinterpret"><code class="xref jl jl-func docutils literal"><span class="pre">reinterpret(type,</span> <span class="pre">A)</span></code></a></td>
<td>an array with the same binary data as the given array, but with the
specified element type</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="../../stdlib/numbers/#Base.rand" title="Base.rand"><code class="xref jl jl-func docutils literal"><span class="pre">rand(dims)</span></code></a></td>
<td><a class="reference internal" href="../../stdlib/arrays/#Base.Array" title="Base.Array"><code class="xref jl jl-obj docutils literal"><span class="pre">Array</span></code></a> of <code class="docutils literal"><span class="pre">Float64</span></code>s with random, iid[#]_ and uniformly
distributed values in the half-open interval <span class="math">\([0, 1)\)</span></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="../../stdlib/numbers/#Base.randn" title="Base.randn"><code class="xref jl jl-func docutils literal"><span class="pre">randn(dims)</span></code></a></td>
<td><a class="reference internal" href="../../stdlib/arrays/#Base.Array" title="Base.Array"><code class="xref jl jl-obj docutils literal"><span class="pre">Array</span></code></a> of <code class="docutils literal"><span class="pre">Float64</span></code>s with random, iid and standard normally
distributed random values</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="../../stdlib/arrays/#Base.eye" title="Base.eye"><code class="xref jl jl-func docutils literal"><span class="pre">eye(n)</span></code></a></td>
<td><code class="docutils literal"><span class="pre">n</span></code>-by-<code class="docutils literal"><span class="pre">n</span></code> identity matrix</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="../../stdlib/arrays/#Base.eye" title="Base.eye"><code class="xref jl jl-func docutils literal"><span class="pre">eye(m,</span> <span class="pre">n)</span></code></a></td>
<td><code class="docutils literal"><span class="pre">m</span></code>-by-<code class="docutils literal"><span class="pre">n</span></code> identity matrix</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="../../stdlib/arrays/#Base.linspace" title="Base.linspace"><code class="xref jl jl-func docutils literal"><span class="pre">linspace(start,</span> <span class="pre">stop,</span> <span class="pre">n)</span></code></a></td>
<td>range of <code class="docutils literal"><span class="pre">n</span></code> linearly spaced elements from <code class="docutils literal"><span class="pre">start</span></code> to <code class="docutils literal"><span class="pre">stop</span></code></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="../../stdlib/arrays/#Base.fill!" title="Base.fill!"><code class="xref jl jl-func docutils literal"><span class="pre">fill!(A,</span> <span class="pre">x)</span></code></a></td>
<td>fill the array <code class="docutils literal"><span class="pre">A</span></code> with the value <code class="docutils literal"><span class="pre">x</span></code></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="../../stdlib/arrays/#Base.fill" title="Base.fill"><code class="xref jl jl-func docutils literal"><span class="pre">fill(x,</span> <span class="pre">dims)</span></code></a></td>
<td>create an array filled with the value <code class="docutils literal"><span class="pre">x</span></code></td>
</tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>iid</em>, independently and identically distributed.</td></tr>
</tbody>
</table>
<p>The syntax <code class="docutils literal"><span class="pre">[A,</span> <span class="pre">B,</span> <span class="pre">C,</span> <span class="pre">...]</span></code> constructs a 1-d array (vector) of its arguments.</p>
</div>
<div class="section" id="concatenation">
<h3>Concatenation<a class="headerlink" href="#concatenation" title="Permalink to this headline">¶</a></h3>
<p>Arrays can be constructed and also concatenated using the following
functions:</p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="67%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Function</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><a class="reference internal" href="../../stdlib/arrays/#Base.cat" title="Base.cat"><code class="xref jl jl-func docutils literal"><span class="pre">cat(k,</span> <span class="pre">A...)</span></code></a></td>
<td>concatenate input n-d arrays along the dimension <code class="docutils literal"><span class="pre">k</span></code></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="../../stdlib/arrays/#Base.vcat" title="Base.vcat"><code class="xref jl jl-func docutils literal"><span class="pre">vcat(A...)</span></code></a></td>
<td>shorthand for <code class="docutils literal"><span class="pre">cat(1,</span> <span class="pre">A...)</span></code></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="../../stdlib/arrays/#Base.hcat" title="Base.hcat"><code class="xref jl jl-func docutils literal"><span class="pre">hcat(A...)</span></code></a></td>
<td>shorthand for <code class="docutils literal"><span class="pre">cat(2,</span> <span class="pre">A...)</span></code></td>
</tr>
</tbody>
</table>
<p>Scalar values passed to these functions are treated as 1-element arrays.</p>
<p>The concatenation functions are used so often that they have special syntax:</p>
<table border="1" class="docutils">
<colgroup>
<col width="59%" />
<col width="41%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Expression</th>
<th class="head">Calls</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">[A;</span> <span class="pre">B;</span> <span class="pre">C;</span> <span class="pre">...]</span></code></td>
<td><a class="reference internal" href="../../stdlib/arrays/#Base.vcat" title="Base.vcat"><code class="xref jl jl-func docutils literal"><span class="pre">vcat()</span></code></a></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">[A</span> <span class="pre">B</span> <span class="pre">C</span> <span class="pre">...]</span></code></td>
<td><a class="reference internal" href="../../stdlib/arrays/#Base.hcat" title="Base.hcat"><code class="xref jl jl-func docutils literal"><span class="pre">hcat()</span></code></a></td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">[A</span> <span class="pre">B;</span> <span class="pre">C</span> <span class="pre">D;</span> <span class="pre">...]</span></code></td>
<td><a class="reference internal" href="../../stdlib/arrays/#Base.hvcat" title="Base.hvcat"><code class="xref jl jl-func docutils literal"><span class="pre">hvcat()</span></code></a></td>
</tr>
</tbody>
</table>
<p><a class="reference internal" href="../../stdlib/arrays/#Base.hvcat" title="Base.hvcat"><code class="xref jl jl-func docutils literal"><span class="pre">hvcat()</span></code></a> concatenates in both dimension 1 (with semicolons) and dimension 2
(with spaces).</p>
</div>
<div class="section" id="typed-array-initializers">
<h3>Typed array initializers<a class="headerlink" href="#typed-array-initializers" title="Permalink to this headline">¶</a></h3>
<p>An array with a specific element type can be constructed using the syntax
<code class="docutils literal"><span class="pre">T[A,</span> <span class="pre">B,</span> <span class="pre">C,</span> <span class="pre">...]</span></code>. This will construct a 1-d array with element type
<code class="docutils literal"><span class="pre">T</span></code>, initialized to contain elements <code class="docutils literal"><span class="pre">A</span></code>, <code class="docutils literal"><span class="pre">B</span></code>, <code class="docutils literal"><span class="pre">C</span></code>, etc.
For example <code class="docutils literal"><span class="pre">Any[x,</span> <span class="pre">y,</span> <span class="pre">z]</span></code> constructs a heterogeneous array that can
contain any values.</p>
<p>Concatenation syntax can similarly be prefixed with a type to specify
the element type of the result.</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="p">[[</span><span class="mi">1</span> <span class="mi">2</span><span class="p">]</span> <span class="p">[</span><span class="mi">3</span> <span class="mi">4</span><span class="p">]]</span>
<span class="mi">1</span><span class="n">x4</span> <span class="kt">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">2</span><span class="p">}</span><span class="o">:</span>
 <span class="mi">1</span>  <span class="mi">2</span>  <span class="mi">3</span>  <span class="mi">4</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="kt">Int8</span><span class="p">[[</span><span class="mi">1</span> <span class="mi">2</span><span class="p">]</span> <span class="p">[</span><span class="mi">3</span> <span class="mi">4</span><span class="p">]]</span>
<span class="mi">1</span><span class="n">x4</span> <span class="kt">Array</span><span class="p">{</span><span class="kt">Int8</span><span class="p">,</span><span class="mi">2</span><span class="p">}</span><span class="o">:</span>
 <span class="mi">1</span>  <span class="mi">2</span>  <span class="mi">3</span>  <span class="mi">4</span>
</pre></div>
</div>
</div>
<div class="section" id="comprehensions">
<span id="id2"></span><h3>Comprehensions<a class="headerlink" href="#comprehensions" title="Permalink to this headline">¶</a></h3>
<p>Comprehensions provide a general and powerful way to construct arrays.
Comprehension syntax is similar to set construction notation in
mathematics:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">=</span> <span class="p">[</span> <span class="n">F</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="o">...</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span><span class="o">=</span><span class="n">rx</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">ry</span><span class="p">,</span> <span class="o">...</span> <span class="p">]</span>
</pre></div>
</div>
<p>The meaning of this form is that <code class="docutils literal"><span class="pre">F(x,y,...)</span></code> is evaluated with the
variables <code class="docutils literal"><span class="pre">x</span></code>, <code class="docutils literal"><span class="pre">y</span></code>, etc. taking on each value in their given list of
values. Values can be specified as any iterable object, but will
commonly be ranges like <code class="docutils literal"><span class="pre">1:n</span></code> or <code class="docutils literal"><span class="pre">2:(n-1)</span></code>, or explicit arrays of
values like <code class="docutils literal"><span class="pre">[1.2,</span> <span class="pre">3.4,</span> <span class="pre">5.7]</span></code>. The result is an N-d dense array with
dimensions that are the concatenation of the dimensions of the variable
ranges <code class="docutils literal"><span class="pre">rx</span></code>, <code class="docutils literal"><span class="pre">ry</span></code>, etc. and each <code class="docutils literal"><span class="pre">F(x,y,...)</span></code> evaluation returns a
scalar.</p>
<p>The following example computes a weighted average of the current element
and its left and right neighbor along a 1-d grid. :</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="kd">const</span> <span class="n">x</span> <span class="o">=</span> <span class="n">rand</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
<span class="mi">8</span><span class="o">-</span><span class="n">element</span> <span class="kt">Array</span><span class="p">{</span><span class="kt">Float64</span><span class="p">,</span><span class="mi">1</span><span class="p">}</span><span class="o">:</span>
 <span class="mf">0.843025</span>
 <span class="mf">0.869052</span>
 <span class="mf">0.365105</span>
 <span class="mf">0.699456</span>
 <span class="mf">0.977653</span>
 <span class="mf">0.994953</span>
 <span class="mf">0.41084</span>
 <span class="mf">0.809411</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="p">[</span> <span class="mf">0.25</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.25</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="o">=</span><span class="mi">2</span><span class="o">:</span><span class="n">length</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span> <span class="p">]</span>
<span class="mi">6</span><span class="o">-</span><span class="n">element</span> <span class="kt">Array</span><span class="p">{</span><span class="kt">Float64</span><span class="p">,</span><span class="mi">1</span><span class="p">}</span><span class="o">:</span>
 <span class="mf">0.736559</span>
 <span class="mf">0.57468</span>
 <span class="mf">0.685417</span>
 <span class="mf">0.912429</span>
 <span class="mf">0.8446</span>
 <span class="mf">0.656511</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In the above example, <code class="docutils literal"><span class="pre">x</span></code> is declared as constant because type
inference in Julia does not work as well on non-constant global
variables.</p>
</div>
<p>The resulting array type is inferred from the expression; in order to control
the type explicitly, the type can be prepended to the comprehension. For example,
in the above example we could have avoided declaring <code class="docutils literal"><span class="pre">x</span></code> as constant, and ensured
that the result is of type <code class="docutils literal"><span class="pre">Float64</span></code> by writing:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="kt">Float64</span><span class="p">[</span> <span class="mf">0.25</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.25</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="o">=</span><span class="mi">2</span><span class="o">:</span><span class="n">length</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span> <span class="p">]</span>
</pre></div>
</div>
</div>
<div class="section" id="indexing">
<span id="man-array-indexing"></span><h3>Indexing<a class="headerlink" href="#indexing" title="Permalink to this headline">¶</a></h3>
<p>The general syntax for indexing into an n-dimensional array A is:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">X</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">I_1</span><span class="p">,</span> <span class="n">I_2</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">I_n</span><span class="p">]</span>
</pre></div>
</div>
<p>where each <code class="docutils literal"><span class="pre">I_k</span></code> may be:</p>
<ol class="arabic simple">
<li>A scalar integer</li>
<li>A <code class="docutils literal"><span class="pre">Range</span></code> of the form <code class="docutils literal"><span class="pre">a:b</span></code>, or <code class="docutils literal"><span class="pre">a:b:c</span></code></li>
<li>A <code class="docutils literal"><span class="pre">:</span></code> or <code class="docutils literal"><span class="pre">Colon()</span></code> to select entire dimensions</li>
<li>An arbitrary integer vector, including the empty vector <code class="docutils literal"><span class="pre">[]</span></code></li>
<li>A boolean vector</li>
</ol>
<p>The result <code class="docutils literal"><span class="pre">X</span></code> generally has dimensions
<code class="docutils literal"><span class="pre">(length(I_1),</span> <span class="pre">length(I_2),</span> <span class="pre">...,</span> <span class="pre">length(I_n))</span></code>, with location
<code class="docutils literal"><span class="pre">(i_1,</span> <span class="pre">i_2,</span> <span class="pre">...,</span> <span class="pre">i_n)</span></code> of <code class="docutils literal"><span class="pre">X</span></code> containing the value
<code class="docutils literal"><span class="pre">A[I_1[i_1],</span> <span class="pre">I_2[i_2],</span> <span class="pre">...,</span> <span class="pre">I_n[i_n]]</span></code>. Trailing dimensions
indexed with scalars are dropped. For example, the dimensions of <code class="docutils literal"><span class="pre">A[I,</span> <span class="pre">1]</span></code> will be
<code class="docutils literal"><span class="pre">(length(I),)</span></code>. Boolean vectors are first transformed with <code class="docutils literal"><span class="pre">find</span></code>; the size of
a dimension indexed by a boolean vector will be the number of true values in the vector.
As a special part of this syntax, the <code class="docutils literal"><span class="pre">end</span></code> keyword may be used to represent the last
index of each dimension within the indexing brackets, as determined by the size of the
innermost array being indexed.</p>
<p>Alternatively, single elements of a multidimensional array can be indexed as</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="nb">I</span><span class="p">]</span>
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">I</span></code> is a <code class="docutils literal"><span class="pre">CartesianIndex</span></code>, effectively an <code class="docutils literal"><span class="pre">n</span></code>-tuple of integers.
See <a class="reference internal" href="#man-array-iteration"><span class="std std-ref">Iteration</span></a> below.</p>
<p>Indexing syntax is equivalent to a call to <code class="docutils literal"><span class="pre">getindex</span></code>:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">X</span> <span class="o">=</span> <span class="n">getindex</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">I_1</span><span class="p">,</span> <span class="n">I_2</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">I_n</span><span class="p">)</span>
</pre></div>
</div>
<p>Example:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="o">:</span><span class="mi">16</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="mi">4</span><span class="n">x4</span> <span class="kt">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">2</span><span class="p">}</span><span class="o">:</span>
 <span class="mi">1</span>  <span class="mi">5</span>   <span class="mi">9</span>  <span class="mi">13</span>
 <span class="mi">2</span>  <span class="mi">6</span>  <span class="mi">10</span>  <span class="mi">14</span>
 <span class="mi">3</span>  <span class="mi">7</span>  <span class="mi">11</span>  <span class="mi">15</span>
 <span class="mi">4</span>  <span class="mi">8</span>  <span class="mi">12</span>  <span class="mi">16</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="o">:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="o">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="mi">2</span><span class="n">x2</span> <span class="kt">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">2</span><span class="p">}</span><span class="o">:</span>
 <span class="mi">6</span>  <span class="mi">10</span>
 <span class="mi">7</span>  <span class="mi">11</span>
</pre></div>
</div>
<p>Empty ranges of the form <code class="docutils literal"><span class="pre">n:n-1</span></code> are sometimes used to indicate the inter-index
location between <code class="docutils literal"><span class="pre">n-1</span></code> and <code class="docutils literal"><span class="pre">n</span></code>.  For example, the <a class="reference internal" href="../../stdlib/sort/#Base.searchsorted" title="Base.searchsorted"><code class="xref jl jl-func docutils literal"><span class="pre">searchsorted()</span></code></a> function uses
this convention to indicate the insertion point of a value not found in a sorted
array:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">];</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">searchsorted</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="mi">3</span><span class="o">:</span><span class="mi">2</span>
</pre></div>
</div>
</div>
<div class="section" id="assignment">
<h3>Assignment<a class="headerlink" href="#assignment" title="Permalink to this headline">¶</a></h3>
<p>The general syntax for assigning values in an n-dimensional array A is:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">A</span><span class="p">[</span><span class="n">I_1</span><span class="p">,</span> <span class="n">I_2</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">I_n</span><span class="p">]</span> <span class="o">=</span> <span class="n">X</span>
</pre></div>
</div>
<p>where each <code class="docutils literal"><span class="pre">I_k</span></code> may be:</p>
<ol class="arabic simple">
<li>A scalar integer</li>
<li>A <code class="docutils literal"><span class="pre">Range</span></code> of the form <code class="docutils literal"><span class="pre">a:b</span></code>, or <code class="docutils literal"><span class="pre">a:b:c</span></code></li>
<li>A <code class="docutils literal"><span class="pre">:</span></code> or <code class="docutils literal"><span class="pre">Colon()</span></code> to select entire dimensions</li>
<li>An arbitrary integer vector, including the empty vector <code class="docutils literal"><span class="pre">[]</span></code></li>
<li>A boolean vector</li>
</ol>
<p>If <code class="docutils literal"><span class="pre">X</span></code> is an array, its size must be <code class="docutils literal"><span class="pre">(length(I_1),</span> <span class="pre">length(I_2),</span> <span class="pre">...,</span> <span class="pre">length(I_n))</span></code>,
and the value in location <code class="docutils literal"><span class="pre">i_1,</span> <span class="pre">i_2,</span> <span class="pre">...,</span> <span class="pre">i_n</span></code> of <code class="docutils literal"><span class="pre">A</span></code> is overwritten with
the value <code class="docutils literal"><span class="pre">X[I_1[i_1],</span> <span class="pre">I_2[i_2],</span> <span class="pre">...,</span> <span class="pre">I_n[i_n]]</span></code>. If <code class="docutils literal"><span class="pre">X</span></code> is not an array, its
value is written to all referenced locations of <code class="docutils literal"><span class="pre">A</span></code>.</p>
<p>A boolean vector used as an index behaves as in <a class="reference internal" href="../../stdlib/collections/#Base.getindex" title="Base.getindex"><code class="xref jl jl-func docutils literal"><span class="pre">getindex()</span></code></a> (it is first transformed
with <a class="reference internal" href="../../stdlib/arrays/#Base.find" title="Base.find"><code class="xref jl jl-func docutils literal"><span class="pre">find()</span></code></a>).</p>
<p>Index assignment syntax is equivalent to a call to <a class="reference internal" href="../../stdlib/collections/#Base.setindex!" title="Base.setindex!"><code class="xref jl jl-func docutils literal"><span class="pre">setindex!()</span></code></a>:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">setindex!</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">I_1</span><span class="p">,</span> <span class="n">I_2</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">I_n</span><span class="p">)</span>
</pre></div>
</div>
<p>Example:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="o">:</span><span class="mi">9</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="mi">3</span><span class="n">x3</span> <span class="kt">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">2</span><span class="p">}</span><span class="o">:</span>
 <span class="mi">1</span>  <span class="mi">4</span>  <span class="mi">7</span>
 <span class="mi">2</span>  <span class="mi">5</span>  <span class="mi">8</span>
 <span class="mi">3</span>  <span class="mi">6</span>  <span class="mi">9</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="o">:</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="o">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="o">-</span><span class="mi">1</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">x</span>
<span class="mi">3</span><span class="n">x3</span> <span class="kt">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">2</span><span class="p">}</span><span class="o">:</span>
 <span class="mi">1</span>  <span class="o">-</span><span class="mi">1</span>  <span class="o">-</span><span class="mi">1</span>
 <span class="mi">2</span>  <span class="o">-</span><span class="mi">1</span>  <span class="o">-</span><span class="mi">1</span>
 <span class="mi">3</span>   <span class="mi">6</span>   <span class="mi">9</span>
</pre></div>
</div>
</div>
<div class="section" id="iteration">
<span id="man-array-iteration"></span><h3>Iteration<a class="headerlink" href="#iteration" title="Permalink to this headline">¶</a></h3>
<p>The recommended ways to iterate over a whole array are</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">a</span> <span class="kp">in</span> <span class="n">A</span>
    <span class="c"># Do something with the element a</span>
<span class="k">end</span>

<span class="k">for</span> <span class="n">i</span> <span class="kp">in</span> <span class="n">eachindex</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="c"># Do something with i and/or A[i]</span>
<span class="k">end</span>
</pre></div>
</div>
<p>The first construct is used when you need the value, but not index, of each element.  In the second construct, <code class="docutils literal"><span class="pre">i</span></code> will be an <code class="docutils literal"><span class="pre">Int</span></code> if <code class="docutils literal"><span class="pre">A</span></code> is an array
type with fast linear indexing; otherwise, it will be a <code class="docutils literal"><span class="pre">CartesianIndex</span></code>:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">=</span> <span class="n">rand</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="n">B</span> <span class="o">=</span> <span class="n">sub</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="mi">1</span><span class="o">:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="o">:</span><span class="mi">3</span><span class="p">)</span>
<span class="n">julia</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">i</span> <span class="kp">in</span> <span class="n">eachindex</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
           <span class="nd">@show</span> <span class="n">i</span>
       <span class="k">end</span>
       <span class="n">i</span> <span class="o">=</span> <span class="n">Base</span><span class="o">.</span><span class="n">IteratorsMD</span><span class="o">.</span><span class="n">CartesianIndex_2</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
       <span class="n">i</span> <span class="o">=</span> <span class="n">Base</span><span class="o">.</span><span class="n">IteratorsMD</span><span class="o">.</span><span class="n">CartesianIndex_2</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
       <span class="n">i</span> <span class="o">=</span> <span class="n">Base</span><span class="o">.</span><span class="n">IteratorsMD</span><span class="o">.</span><span class="n">CartesianIndex_2</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
       <span class="n">i</span> <span class="o">=</span> <span class="n">Base</span><span class="o">.</span><span class="n">IteratorsMD</span><span class="o">.</span><span class="n">CartesianIndex_2</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
       <span class="n">i</span> <span class="o">=</span> <span class="n">Base</span><span class="o">.</span><span class="n">IteratorsMD</span><span class="o">.</span><span class="n">CartesianIndex_2</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
       <span class="n">i</span> <span class="o">=</span> <span class="n">Base</span><span class="o">.</span><span class="n">IteratorsMD</span><span class="o">.</span><span class="n">CartesianIndex_2</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>In contrast with <code class="docutils literal"><span class="pre">for</span> <span class="pre">i</span> <span class="pre">=</span> <span class="pre">1:length(A)</span></code>, iterating with <code class="docutils literal"><span class="pre">eachindex</span></code> provides an efficient way to iterate over any array type.</p>
</div>
<div class="section" id="array-traits">
<h3>Array traits<a class="headerlink" href="#array-traits" title="Permalink to this headline">¶</a></h3>
<p>If you write a custom <code class="xref jl jl-obj docutils literal"><span class="pre">AbstractArray</span></code> type, you can specify that it has fast linear indexing using</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">Base</span><span class="o">.</span><span class="n">linearindexing</span><span class="p">{</span><span class="n">T</span><span class="o">&lt;:</span><span class="n">MyArray</span><span class="p">}(</span><span class="o">::</span><span class="kt">Type</span><span class="p">{</span><span class="n">T</span><span class="p">})</span> <span class="o">=</span> <span class="n">LinearFast</span><span class="p">()</span>
</pre></div>
</div>
<p>This setting will cause <code class="docutils literal"><span class="pre">eachindex</span></code> iteration over a <code class="docutils literal"><span class="pre">MyArray</span></code> to use integers.  If you don&#8217;t specify this trait, the default value <code class="docutils literal"><span class="pre">LinearSlow()</span></code> is used.</p>
</div>
<div class="section" id="vectorized-operators-and-functions">
<h3>Vectorized Operators and Functions<a class="headerlink" href="#vectorized-operators-and-functions" title="Permalink to this headline">¶</a></h3>
<p>The following operators are supported for arrays. The dot version of a binary
operator should be used for elementwise operations.</p>
<ol class="arabic simple">
<li>Unary arithmetic — <code class="docutils literal"><span class="pre">-</span></code>, <code class="docutils literal"><span class="pre">+</span></code>, <code class="docutils literal"><span class="pre">!</span></code></li>
<li>Binary arithmetic — <code class="docutils literal"><span class="pre">+</span></code>, <code class="docutils literal"><span class="pre">-</span></code>, <code class="docutils literal"><span class="pre">*</span></code>, <code class="docutils literal"><span class="pre">.*</span></code>, <code class="docutils literal"><span class="pre">/</span></code>, <code class="docutils literal"><span class="pre">./</span></code>,
<code class="docutils literal"><span class="pre">\</span></code>, <code class="docutils literal"><span class="pre">.\</span></code>, <code class="docutils literal"><span class="pre">^</span></code>, <code class="docutils literal"><span class="pre">.^</span></code>, <code class="docutils literal"><span class="pre">div</span></code>, <code class="docutils literal"><span class="pre">mod</span></code></li>
<li>Comparison — <code class="docutils literal"><span class="pre">.==</span></code>, <code class="docutils literal"><span class="pre">.!=</span></code>, <code class="docutils literal"><span class="pre">.&lt;</span></code>, <code class="docutils literal"><span class="pre">.&lt;=</span></code>, <code class="docutils literal"><span class="pre">.&gt;</span></code>, <code class="docutils literal"><span class="pre">.&gt;=</span></code></li>
<li>Unary Boolean or bitwise — <code class="docutils literal"><span class="pre">~</span></code></li>
<li>Binary Boolean or bitwise — <code class="docutils literal"><span class="pre">&amp;</span></code>, <code class="docutils literal"><span class="pre">|</span></code>, <code class="docutils literal"><span class="pre">$</span></code></li>
</ol>
<p>Some operators without dots operate elementwise anyway when one argument is a
scalar. These operators are <code class="docutils literal"><span class="pre">*</span></code>, <code class="docutils literal"><span class="pre">+</span></code>, <code class="docutils literal"><span class="pre">-</span></code>, and the bitwise operators. The
operators <code class="docutils literal"><span class="pre">/</span></code> and <code class="docutils literal"><span class="pre">\</span></code> operate elementwise when the denominator is a scalar.</p>
<p>Note that comparisons such as <code class="docutils literal"><span class="pre">==</span></code> operate on whole arrays, giving a single
boolean answer. Use dot operators for elementwise comparisons.</p>
<p>The following built-in functions are also vectorized, whereby the functions act
elementwise:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">abs</span> <span class="n">abs2</span> <span class="n">angle</span> <span class="n">cbrt</span>
<span class="n">airy</span> <span class="n">airyai</span> <span class="n">airyaiprime</span> <span class="n">airybi</span> <span class="n">airybiprime</span> <span class="n">airyprime</span>
<span class="n">acos</span> <span class="n">acosh</span> <span class="n">asin</span> <span class="n">asinh</span> <span class="n">atan</span> <span class="n">atan2</span> <span class="n">atanh</span>
<span class="n">acsc</span> <span class="n">acsch</span> <span class="n">asec</span> <span class="n">asech</span> <span class="n">acot</span> <span class="n">acoth</span>
<span class="n">cos</span>  <span class="n">cospi</span> <span class="n">cosh</span>  <span class="n">sin</span>  <span class="n">sinpi</span> <span class="n">sinh</span>  <span class="n">tan</span>  <span class="n">tanh</span>  <span class="n">sinc</span>  <span class="n">cosc</span>
<span class="n">csc</span>  <span class="n">csch</span>  <span class="n">sec</span>  <span class="n">sech</span>  <span class="n">cot</span>  <span class="n">coth</span>
<span class="n">acosd</span> <span class="n">asind</span> <span class="n">atand</span> <span class="n">asecd</span> <span class="n">acscd</span> <span class="n">acotd</span>
<span class="n">cosd</span>  <span class="n">sind</span>  <span class="n">tand</span>  <span class="n">secd</span>  <span class="n">cscd</span>  <span class="n">cotd</span>
<span class="n">besselh</span> <span class="n">besseli</span> <span class="n">besselj</span> <span class="n">besselj0</span> <span class="n">besselj1</span> <span class="n">besselk</span> <span class="n">bessely</span> <span class="n">bessely0</span> <span class="n">bessely1</span>
<span class="n">exp</span>  <span class="n">erf</span>  <span class="n">erfc</span>  <span class="n">erfinv</span> <span class="n">erfcinv</span> <span class="n">exp2</span>  <span class="n">expm1</span>
<span class="n">beta</span> <span class="n">dawson</span> <span class="n">digamma</span> <span class="n">erfcx</span> <span class="n">erfi</span>
<span class="n">exponent</span> <span class="n">eta</span> <span class="n">zeta</span> <span class="n">gamma</span>
<span class="n">hankelh1</span> <span class="n">hankelh2</span>
 <span class="n">ceil</span>  <span class="n">floor</span>  <span class="n">round</span>  <span class="n">trunc</span>
<span class="n">isfinite</span> <span class="n">isinf</span> <span class="n">isnan</span>
<span class="n">lbeta</span> <span class="n">lfact</span> <span class="n">lgamma</span>
<span class="n">log</span> <span class="n">log10</span> <span class="n">log1p</span> <span class="n">log2</span>
<span class="n">copysign</span> <span class="n">max</span> <span class="n">min</span> <span class="n">significand</span>
<span class="n">sqrt</span> <span class="n">hypot</span>
</pre></div>
</div>
<p>Note that there is a difference between <a class="reference internal" href="../../stdlib/math/#Base.min" title="Base.min"><code class="xref jl jl-func docutils literal"><span class="pre">min()</span></code></a> and <a class="reference internal" href="../../stdlib/math/#Base.max" title="Base.max"><code class="xref jl jl-func docutils literal"><span class="pre">max()</span></code></a>, which operate
elementwise over multiple array arguments, and <a class="reference internal" href="../../stdlib/collections/#Base.minimum" title="Base.minimum"><code class="xref jl jl-func docutils literal"><span class="pre">minimum()</span></code></a> and <a class="reference internal" href="../../stdlib/collections/#Base.maximum" title="Base.maximum"><code class="xref jl jl-func docutils literal"><span class="pre">maximum()</span></code></a>, which
find the smallest and largest values within an array.</p>
<p>Julia provides the <code class="xref jl jl-func docutils literal"><span class="pre">&#64;vectorize_1arg()</span></code> and <code class="xref jl jl-func docutils literal"><span class="pre">&#64;vectorize_2arg()</span></code>
macros to automatically vectorize any function of one or two arguments
respectively.  Each of these takes two arguments, namely the <code class="docutils literal"><span class="pre">Type</span></code> of
argument (which is usually chosen to be the most general possible) and
the name of the function to vectorize. Here is a simple example:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">square</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="n">x</span><span class="o">^</span><span class="mi">2</span>
<span class="n">square</span> <span class="p">(</span><span class="n">generic</span> <span class="k">function</span> <span class="n">with</span> <span class="mi">1</span> <span class="n">method</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nd">@vectorize_1arg</span> <span class="kt">Number</span> <span class="n">square</span>
<span class="n">square</span> <span class="p">(</span><span class="n">generic</span> <span class="k">function</span> <span class="n">with</span> <span class="mi">4</span> <span class="n">methods</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">methods</span><span class="p">(</span><span class="n">square</span><span class="p">)</span>
<span class="c"># 4 methods for generic function &quot;square&quot;:</span>
<span class="n">square</span><span class="p">{</span><span class="n">T</span><span class="o">&lt;:</span><span class="kt">Number</span><span class="p">}(</span><span class="o">::</span><span class="kt">AbstractArray</span><span class="p">{</span><span class="n">T</span><span class="o">&lt;:</span><span class="kt">Number</span><span class="p">,</span><span class="mi">1</span><span class="p">})</span> <span class="n">at</span> <span class="n">operators</span><span class="o">.</span><span class="n">jl</span><span class="o">:</span><span class="mi">380</span>
<span class="n">square</span><span class="p">{</span><span class="n">T</span><span class="o">&lt;:</span><span class="kt">Number</span><span class="p">}(</span><span class="o">::</span><span class="kt">AbstractArray</span><span class="p">{</span><span class="n">T</span><span class="o">&lt;:</span><span class="kt">Number</span><span class="p">,</span><span class="mi">2</span><span class="p">})</span> <span class="n">at</span> <span class="n">operators</span><span class="o">.</span><span class="n">jl</span><span class="o">:</span><span class="mi">381</span>
<span class="n">square</span><span class="p">{</span><span class="n">T</span><span class="o">&lt;:</span><span class="kt">Number</span><span class="p">}(</span><span class="o">::</span><span class="kt">AbstractArray</span><span class="p">{</span><span class="n">T</span><span class="o">&lt;:</span><span class="kt">Number</span><span class="p">,</span><span class="n">N</span><span class="p">})</span> <span class="n">at</span> <span class="n">operators</span><span class="o">.</span><span class="n">jl</span><span class="o">:</span><span class="mi">383</span>
<span class="n">square</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="n">at</span> <span class="n">none</span><span class="o">:</span><span class="mi">1</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">square</span><span class="p">([</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">4</span><span class="p">;</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span><span class="p">])</span>
<span class="mi">2</span><span class="n">x3</span> <span class="kt">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">2</span><span class="p">}</span><span class="o">:</span>
  <span class="mi">1</span>   <span class="mi">4</span>  <span class="mi">16</span>
 <span class="mi">25</span>  <span class="mi">36</span>  <span class="mi">49</span>
</pre></div>
</div>
</div>
<div class="section" id="broadcasting">
<h3>Broadcasting<a class="headerlink" href="#broadcasting" title="Permalink to this headline">¶</a></h3>
<p>It is sometimes useful to perform element-by-element binary operations
on arrays of different sizes, such as adding a vector to each column
of a matrix.  An inefficient way to do this would be to replicate the
vector to the size of the matrix:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">rand</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span> <span class="n">A</span> <span class="o">=</span> <span class="n">rand</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">repmat</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span><span class="o">+</span><span class="n">A</span>
<span class="mi">2</span><span class="n">x3</span> <span class="kt">Array</span><span class="p">{</span><span class="kt">Float64</span><span class="p">,</span><span class="mi">2</span><span class="p">}</span><span class="o">:</span>
 <span class="mf">1.20813</span>  <span class="mf">1.82068</span>  <span class="mf">1.25387</span>
 <span class="mf">1.56851</span>  <span class="mf">1.86401</span>  <span class="mf">1.67846</span>
</pre></div>
</div>
<p>This is wasteful when dimensions get large, so Julia offers
<a class="reference internal" href="../../stdlib/arrays/#Base.broadcast" title="Base.broadcast"><code class="xref jl jl-func docutils literal"><span class="pre">broadcast()</span></code></a>, which expands singleton dimensions in
array arguments to match the corresponding dimension in the other
array without using extra memory, and applies the given
function elementwise:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">broadcast</span><span class="p">(</span><span class="o">+</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">A</span><span class="p">)</span>
<span class="mi">2</span><span class="n">x3</span> <span class="kt">Array</span><span class="p">{</span><span class="kt">Float64</span><span class="p">,</span><span class="mi">2</span><span class="p">}</span><span class="o">:</span>
 <span class="mf">1.20813</span>  <span class="mf">1.82068</span>  <span class="mf">1.25387</span>
 <span class="mf">1.56851</span>  <span class="mf">1.86401</span>  <span class="mf">1.67846</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">rand</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="mi">1</span><span class="n">x2</span> <span class="kt">Array</span><span class="p">{</span><span class="kt">Float64</span><span class="p">,</span><span class="mi">2</span><span class="p">}</span><span class="o">:</span>
 <span class="mf">0.867535</span>  <span class="mf">0.00457906</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">broadcast</span><span class="p">(</span><span class="o">+</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="mi">2</span><span class="n">x2</span> <span class="kt">Array</span><span class="p">{</span><span class="kt">Float64</span><span class="p">,</span><span class="mi">2</span><span class="p">}</span><span class="o">:</span>
 <span class="mf">1.71056</span>  <span class="mf">0.847604</span>
 <span class="mf">1.73659</span>  <span class="mf">0.873631</span>
</pre></div>
</div>
<p>Elementwise operators such as <code class="docutils literal"><span class="pre">.+</span></code> and <code class="docutils literal"><span class="pre">.*</span></code> perform broadcasting if necessary. There is also a <a class="reference internal" href="../../stdlib/arrays/#Base.broadcast!" title="Base.broadcast!"><code class="xref jl jl-func docutils literal"><span class="pre">broadcast!()</span></code></a> function to specify an explicit destination, and <a class="reference internal" href="../../stdlib/arrays/#Base.broadcast_getindex" title="Base.broadcast_getindex"><code class="xref jl jl-func docutils literal"><span class="pre">broadcast_getindex()</span></code></a> and <a class="reference internal" href="../../stdlib/arrays/#Base.broadcast_setindex!" title="Base.broadcast_setindex!"><code class="xref jl jl-func docutils literal"><span class="pre">broadcast_setindex!()</span></code></a> that broadcast the indices before indexing.</p>
</div>
<div class="section" id="implementation">
<h3>Implementation<a class="headerlink" href="#implementation" title="Permalink to this headline">¶</a></h3>
<p>The base array type in Julia is the abstract type
<code class="docutils literal"><span class="pre">AbstractArray{T,N}</span></code>. It is parametrized by the number of dimensions
<code class="docutils literal"><span class="pre">N</span></code> and the element type <code class="docutils literal"><span class="pre">T</span></code>. <code class="xref jl jl-obj docutils literal"><span class="pre">AbstractVector</span></code> and
<code class="xref jl jl-obj docutils literal"><span class="pre">AbstractMatrix</span></code> are aliases for the 1-d and 2-d cases. Operations on
<code class="xref jl jl-obj docutils literal"><span class="pre">AbstractArray</span></code> objects are defined using higher level operators and
functions, in a way that is independent of the underlying storage.
These operations generally work correctly as a fallback for any
specific array implementation.</p>
<p>The <code class="xref jl jl-obj docutils literal"><span class="pre">AbstractArray</span></code> type includes anything vaguely array-like, and
implementations of it might be quite different from conventional
arrays. For example, elements might be computed on request rather than
stored.  However, any concrete <code class="docutils literal"><span class="pre">AbstractArray{T,N}</span></code> type should
generally implement at least <a class="reference internal" href="../../stdlib/arrays/#Base.size" title="Base.size"><code class="xref jl jl-func docutils literal"><span class="pre">size(A)</span></code></a> (returning an <code class="docutils literal"><span class="pre">Int</span></code> tuple),
<a class="reference internal" href="../../stdlib/collections/#Base.getindex" title="Base.getindex"><code class="xref jl jl-func docutils literal"><span class="pre">getindex(A,i)</span></code></a> and <a class="reference internal" href="../../stdlib/collections/#Base.getindex" title="Base.getindex"><code class="xref jl jl-func docutils literal"><span class="pre">getindex(A,i1,...,iN)</span></code></a>;
mutable arrays should also implement <a class="reference internal" href="../../stdlib/collections/#Base.setindex!" title="Base.setindex!"><code class="xref jl jl-func docutils literal"><span class="pre">setindex!()</span></code></a>.  It
is recommended that these operations have nearly constant time complexity,
or technically Õ(1) complexity, as otherwise some array functions may
be unexpectedly slow.   Concrete types should also typically provide
a <a class="reference internal" href="../../stdlib/arrays/#Base.similar" title="Base.similar"><code class="xref jl jl-func docutils literal"><span class="pre">similar(A,T=eltype(A),dims=size(A))</span></code></a> method, which is used to allocate
a similar array for <a class="reference internal" href="../../stdlib/base/#Base.copy" title="Base.copy"><code class="xref jl jl-func docutils literal"><span class="pre">copy()</span></code></a> and other out-of-place operations.
No matter how an <code class="docutils literal"><span class="pre">AbstractArray{T,N}</span></code> is represented internally,
<code class="docutils literal"><span class="pre">T</span></code> is the type of object returned by <em>integer</em> indexing (<code class="docutils literal"><span class="pre">A[1,</span>
<span class="pre">...,</span> <span class="pre">1]</span></code>, when <code class="docutils literal"><span class="pre">A</span></code> is not empty) and <code class="docutils literal"><span class="pre">N</span></code> should be the length of
the tuple returned by <a class="reference internal" href="../../stdlib/arrays/#Base.size" title="Base.size"><code class="xref jl jl-func docutils literal"><span class="pre">size()</span></code></a>.</p>
<p><code class="xref jl jl-obj docutils literal"><span class="pre">DenseArray</span></code> is an abstract subtype of <code class="xref jl jl-obj docutils literal"><span class="pre">AbstractArray</span></code> intended
to include all arrays that are laid out at regular offsets in memory,
and which can therefore be passed to external C and Fortran functions
expecting this memory layout.  Subtypes should provide a method
<a class="reference internal" href="../../stdlib/arrays/#Base.stride" title="Base.stride"><code class="xref jl jl-func docutils literal"><span class="pre">stride(A,k)</span></code></a> that returns the &#8220;stride&#8221; of dimension <code class="docutils literal"><span class="pre">k</span></code>:
increasing the index of dimension <code class="docutils literal"><span class="pre">k</span></code> by <code class="docutils literal"><span class="pre">1</span></code> should increase the
index <code class="docutils literal"><span class="pre">i</span></code> of <a class="reference internal" href="../../stdlib/collections/#Base.getindex" title="Base.getindex"><code class="xref jl jl-func docutils literal"><span class="pre">getindex(A,i)</span></code></a> by <a class="reference internal" href="../../stdlib/arrays/#Base.stride" title="Base.stride"><code class="xref jl jl-func docutils literal"><span class="pre">stride(A,k)</span></code></a>.  If a
pointer conversion method <a class="reference internal" href="../../stdlib/c/#Base.unsafe_convert" title="Base.unsafe_convert"><code class="xref jl jl-func docutils literal"><span class="pre">Base.unsafe_convert(Ptr{T},</span> <span class="pre">A)</span></code></a> is provided, the
memory layout should correspond in the same way to these strides.</p>
<p>The <a class="reference internal" href="../../stdlib/arrays/#Base.Array" title="Base.Array"><code class="xref jl jl-obj docutils literal"><span class="pre">Array</span></code></a> type is a specific instance of <code class="xref jl jl-obj docutils literal"><span class="pre">DenseArray</span></code>
where elements are stored in column-major order (see additional notes in
<a class="reference internal" href="../performance-tips/#man-performance-tips"><span class="std std-ref">Performance Tips</span></a>). <code class="xref jl jl-obj docutils literal"><span class="pre">Vector</span></code> and <code class="xref jl jl-obj docutils literal"><span class="pre">Matrix</span></code> are aliases for
the 1-d and 2-d cases. Specific operations such as scalar indexing,
assignment, and a few other basic storage-specific operations are all
that have to be implemented for <a class="reference internal" href="../../stdlib/arrays/#Base.Array" title="Base.Array"><code class="xref jl jl-obj docutils literal"><span class="pre">Array</span></code></a>, so that the rest of the array
library can be implemented in a generic manner.</p>
<p><code class="xref jl jl-obj docutils literal"><span class="pre">SubArray</span></code> is a specialization of <code class="xref jl jl-obj docutils literal"><span class="pre">AbstractArray</span></code> that performs
indexing by reference rather than by copying. A <code class="xref jl jl-obj docutils literal"><span class="pre">SubArray</span></code> is created
with the <a class="reference internal" href="../../stdlib/arrays/#Base.sub" title="Base.sub"><code class="xref jl jl-func docutils literal"><span class="pre">sub()</span></code></a> function, which is called the same way as <a class="reference internal" href="../../stdlib/collections/#Base.getindex" title="Base.getindex"><code class="xref jl jl-func docutils literal"><span class="pre">getindex()</span></code></a> (with
an array and a series of index arguments). The result of <a class="reference internal" href="../../stdlib/arrays/#Base.sub" title="Base.sub"><code class="xref jl jl-func docutils literal"><span class="pre">sub()</span></code></a> looks
the same as the result of <a class="reference internal" href="../../stdlib/collections/#Base.getindex" title="Base.getindex"><code class="xref jl jl-func docutils literal"><span class="pre">getindex()</span></code></a>, except the data is left in place.
<a class="reference internal" href="../../stdlib/arrays/#Base.sub" title="Base.sub"><code class="xref jl jl-func docutils literal"><span class="pre">sub()</span></code></a> stores the input index vectors in a <code class="xref jl jl-obj docutils literal"><span class="pre">SubArray</span></code> object, which
can later be used to index the original array indirectly.</p>
<p><code class="xref jl jl-obj docutils literal"><span class="pre">StridedVector</span></code> and <code class="xref jl jl-obj docutils literal"><span class="pre">StridedMatrix</span></code> are convenient aliases defined
to make it possible for Julia to call a wider range of BLAS and LAPACK
functions by passing them either <a class="reference internal" href="../../stdlib/arrays/#Base.Array" title="Base.Array"><code class="xref jl jl-obj docutils literal"><span class="pre">Array</span></code></a> or <code class="xref jl jl-obj docutils literal"><span class="pre">SubArray</span></code> objects, and
thus saving inefficiencies from memory allocation and copying.</p>
<p>The following example computes the QR decomposition of a small section
of a larger array, without creating any temporaries, and by calling the
appropriate LAPACK function with the right leading dimension size and
stride parameters.</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">rand</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span>
<span class="mi">10</span><span class="n">x10</span> <span class="kt">Array</span><span class="p">{</span><span class="kt">Float64</span><span class="p">,</span><span class="mi">2</span><span class="p">}</span><span class="o">:</span>
 <span class="mf">0.561255</span>   <span class="mf">0.226678</span>   <span class="mf">0.203391</span>  <span class="mf">0.308912</span>   <span class="n">…</span>  <span class="mf">0.750307</span>  <span class="mf">0.235023</span>   <span class="mf">0.217964</span>
 <span class="mf">0.718915</span>   <span class="mf">0.537192</span>   <span class="mf">0.556946</span>  <span class="mf">0.996234</span>      <span class="mf">0.666232</span>  <span class="mf">0.509423</span>   <span class="mf">0.660788</span>
 <span class="mf">0.493501</span>   <span class="mf">0.0565622</span>  <span class="mf">0.118392</span>  <span class="mf">0.493498</span>      <span class="mf">0.262048</span>  <span class="mf">0.940693</span>   <span class="mf">0.252965</span>
 <span class="mf">0.0470779</span>  <span class="mf">0.736979</span>   <span class="mf">0.264822</span>  <span class="mf">0.228787</span>      <span class="mf">0.161441</span>  <span class="mf">0.897023</span>   <span class="mf">0.567641</span>
 <span class="mf">0.343935</span>   <span class="mf">0.32327</span>    <span class="mf">0.795673</span>  <span class="mf">0.452242</span>      <span class="mf">0.468819</span>  <span class="mf">0.628507</span>   <span class="mf">0.511528</span>
 <span class="mf">0.935597</span>   <span class="mf">0.991511</span>   <span class="mf">0.571297</span>  <span class="mf">0.74485</span>    <span class="n">…</span>  <span class="mf">0.84589</span>   <span class="mf">0.178834</span>   <span class="mf">0.284413</span>
 <span class="mf">0.160706</span>   <span class="mf">0.672252</span>   <span class="mf">0.133158</span>  <span class="mf">0.65554</span>       <span class="mf">0.371826</span>  <span class="mf">0.770628</span>   <span class="mf">0.0531208</span>
 <span class="mf">0.306617</span>   <span class="mf">0.836126</span>   <span class="mf">0.301198</span>  <span class="mf">0.0224702</span>     <span class="mf">0.39344</span>   <span class="mf">0.0370205</span>  <span class="mf">0.536062</span>
 <span class="mf">0.890947</span>   <span class="mf">0.168877</span>   <span class="mf">0.32002</span>   <span class="mf">0.486136</span>      <span class="mf">0.096078</span>  <span class="mf">0.172048</span>   <span class="mf">0.77672</span>
 <span class="mf">0.507762</span>   <span class="mf">0.573567</span>   <span class="mf">0.220124</span>  <span class="mf">0.165816</span>      <span class="mf">0.211049</span>  <span class="mf">0.433277</span>   <span class="mf">0.539476</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">sub</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">2</span><span class="o">:</span><span class="mi">2</span><span class="o">:</span><span class="mi">8</span><span class="p">,</span><span class="mi">2</span><span class="o">:</span><span class="mi">2</span><span class="o">:</span><span class="mi">4</span><span class="p">)</span>
<span class="mi">4</span><span class="n">x2</span> <span class="kt">SubArray</span><span class="p">{</span><span class="kt">Float64</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="kt">Array</span><span class="p">{</span><span class="kt">Float64</span><span class="p">,</span><span class="mi">2</span><span class="p">},</span><span class="kt">Tuple</span><span class="p">{</span><span class="kt">StepRange</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="kt">Int64</span><span class="p">},</span><span class="kt">StepRange</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="kt">Int64</span><span class="p">}},</span><span class="mi">1</span><span class="p">}</span><span class="o">:</span>
 <span class="mf">0.537192</span>  <span class="mf">0.996234</span>
 <span class="mf">0.736979</span>  <span class="mf">0.228787</span>
 <span class="mf">0.991511</span>  <span class="mf">0.74485</span>
 <span class="mf">0.836126</span>  <span class="mf">0.0224702</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">r</span><span class="p">)</span> <span class="o">=</span> <span class="n">qr</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">q</span>
<span class="mi">4</span><span class="n">x2</span> <span class="kt">Array</span><span class="p">{</span><span class="kt">Float64</span><span class="p">,</span><span class="mi">2</span><span class="p">}</span><span class="o">:</span>
 <span class="o">-</span><span class="mf">0.338809</span>   <span class="mf">0.78934</span>
 <span class="o">-</span><span class="mf">0.464815</span>  <span class="o">-</span><span class="mf">0.230274</span>
 <span class="o">-</span><span class="mf">0.625349</span>   <span class="mf">0.194538</span>
 <span class="o">-</span><span class="mf">0.527347</span>  <span class="o">-</span><span class="mf">0.534856</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">r</span>
<span class="mi">2</span><span class="n">x2</span> <span class="kt">Array</span><span class="p">{</span><span class="kt">Float64</span><span class="p">,</span><span class="mi">2</span><span class="p">}</span><span class="o">:</span>
 <span class="o">-</span><span class="mf">1.58553</span>  <span class="o">-</span><span class="mf">0.921517</span>
  <span class="mf">0.0</span>       <span class="mf">0.866567</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="sparse-matrices">
<h2>Sparse Matrices<a class="headerlink" href="#sparse-matrices" title="Permalink to this headline">¶</a></h2>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Sparse_matrix">Sparse matrices</a> are
matrices that contain enough zeros that storing them in a special data
structure leads to savings in space and execution time. Sparse
matrices may be used when operations on the sparse representation of a
matrix lead to considerable gains in either time or space when
compared to performing the same operations on a dense matrix.</p>
<div class="section" id="compressed-sparse-column-csc-storage">
<h3>Compressed Sparse Column (CSC) Storage<a class="headerlink" href="#compressed-sparse-column-csc-storage" title="Permalink to this headline">¶</a></h3>
<p>In Julia, sparse matrices are stored in the <a class="reference external" href="https://en.wikipedia.org/wiki/Sparse_matrix#Compressed_sparse_column_.28CSC_or_CCS.29">Compressed Sparse Column
(CSC) format</a>.
Julia sparse matrices have the type <code class="docutils literal"><span class="pre">SparseMatrixCSC{Tv,Ti}</span></code>, where <code class="docutils literal"><span class="pre">Tv</span></code>
is the type of the nonzero values, and <code class="docutils literal"><span class="pre">Ti</span></code> is the integer type for
storing column pointers and row indices.:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="k">type</span> <span class="kt">SparseMatrixCSC</span><span class="p">{</span><span class="n">Tv</span><span class="p">,</span><span class="n">Ti</span><span class="o">&lt;:</span><span class="kt">Integer</span><span class="p">}</span> <span class="o">&lt;:</span> <span class="kt">AbstractSparseMatrix</span><span class="p">{</span><span class="n">Tv</span><span class="p">,</span><span class="n">Ti</span><span class="p">}</span>
    <span class="n">m</span><span class="o">::</span><span class="kt">Int</span>                  <span class="c"># Number of rows</span>
    <span class="n">n</span><span class="o">::</span><span class="kt">Int</span>                  <span class="c"># Number of columns</span>
    <span class="n">colptr</span><span class="o">::</span><span class="kt">Vector</span><span class="p">{</span><span class="n">Ti</span><span class="p">}</span>      <span class="c"># Column i is in colptr[i]:(colptr[i+1]-1)</span>
    <span class="n">rowval</span><span class="o">::</span><span class="kt">Vector</span><span class="p">{</span><span class="n">Ti</span><span class="p">}</span>      <span class="c"># Row values of nonzeros</span>
    <span class="n">nzval</span><span class="o">::</span><span class="kt">Vector</span><span class="p">{</span><span class="n">Tv</span><span class="p">}</span>       <span class="c"># Nonzero values</span>
<span class="k">end</span>
</pre></div>
</div>
<p>The compressed sparse column storage makes it easy and quick to access
the elements in the column of a sparse matrix, whereas accessing the
sparse matrix by rows is considerably slower. Operations such as
insertion of nonzero values one at a time in the CSC structure tend to
be slow. This is because all elements of the sparse matrix that are
beyond the point of insertion have to be moved one place over.</p>
<p>All operations on sparse matrices are carefully implemented to exploit
the CSC data structure for performance, and to avoid expensive operations.</p>
<p>If you have data in CSC format from a different application or library,
and wish to import it in Julia, make sure that you use 1-based indexing.
The row indices in every column need to be sorted. If your <code class="xref jl jl-obj docutils literal"><span class="pre">SparseMatrixCSC</span></code>
object contains unsorted row indices, one quick way to sort them is by
doing a double transpose.</p>
<p>In some applications, it is convenient to store explicit zero values
in a <code class="xref jl jl-obj docutils literal"><span class="pre">SparseMatrixCSC</span></code>. These <em>are</em> accepted by functions in <code class="xref jl jl-mod docutils literal"><span class="pre">Base</span></code>
(but there is no guarantee that they will be preserved in mutating
operations).  Such explicitly stored zeros are treated as structural
nonzeros by many routines.  The <a class="reference internal" href="../../stdlib/arrays/#Base.nnz" title="Base.nnz"><code class="xref jl jl-func docutils literal"><span class="pre">nnz()</span></code></a> function returns the number of
elements explicitly stored in the sparse data structure,
including structural nonzeros. In order to count the exact number of actual
values that are nonzero, use <a class="reference internal" href="../../stdlib/arrays/#Base.countnz" title="Base.countnz"><code class="xref jl jl-func docutils literal"><span class="pre">countnz()</span></code></a>, which inspects every stored
element of a sparse matrix.</p>
</div>
<div class="section" id="sparse-matrix-constructors">
<h3>Sparse matrix constructors<a class="headerlink" href="#sparse-matrix-constructors" title="Permalink to this headline">¶</a></h3>
<p>The simplest way to create sparse matrices is to use functions
equivalent to the <a class="reference internal" href="../../stdlib/arrays/#Base.zeros" title="Base.zeros"><code class="xref jl jl-func docutils literal"><span class="pre">zeros()</span></code></a> and <a class="reference internal" href="../../stdlib/arrays/#Base.eye" title="Base.eye"><code class="xref jl jl-func docutils literal"><span class="pre">eye()</span></code></a> functions that Julia provides
for working with dense matrices. To produce sparse matrices instead,
you can use the same names with an <code class="docutils literal"><span class="pre">sp</span></code> prefix:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">spzeros</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
<span class="mi">3</span><span class="n">x5</span> <span class="n">sparse</span> <span class="n">matrix</span> <span class="n">with</span> <span class="mi">0</span> <span class="kt">Float64</span> <span class="n">entries</span><span class="o">:</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">speye</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
<span class="mi">3</span><span class="n">x5</span> <span class="n">sparse</span> <span class="n">matrix</span> <span class="n">with</span> <span class="mi">3</span> <span class="kt">Float64</span> <span class="n">entries</span><span class="o">:</span>
        <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>  <span class="o">=</span>  <span class="mf">1.0</span>
        <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>  <span class="o">=</span>  <span class="mf">1.0</span>
        <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>  <span class="o">=</span>  <span class="mf">1.0</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="../../stdlib/arrays/#Base.sparse" title="Base.sparse"><code class="xref jl jl-func docutils literal"><span class="pre">sparse()</span></code></a> function is often a handy way to construct sparse
matrices. It takes as its input a vector <code class="docutils literal"><span class="pre">I</span></code> of row indices, a
vector <code class="docutils literal"><span class="pre">J</span></code> of column indices, and a vector <code class="docutils literal"><span class="pre">V</span></code> of nonzero
values. <code class="docutils literal"><span class="pre">sparse(I,J,V)</span></code> constructs a sparse matrix such that
<code class="docutils literal"><span class="pre">S[I[k],</span> <span class="pre">J[k]]</span> <span class="pre">=</span> <span class="pre">V[k]</span></code>.</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="nb">I</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">];</span> <span class="n">J</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">9</span><span class="p">];</span> <span class="n">V</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">S</span> <span class="o">=</span> <span class="n">sparse</span><span class="p">(</span><span class="nb">I</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">V</span><span class="p">)</span>
<span class="mi">5</span><span class="n">x18</span> <span class="n">sparse</span> <span class="n">matrix</span> <span class="n">with</span> <span class="mi">4</span> <span class="kt">Int64</span> <span class="n">entries</span><span class="o">:</span>
        <span class="p">[</span><span class="mi">1</span> <span class="p">,</span>  <span class="mi">4</span><span class="p">]</span>  <span class="o">=</span>  <span class="mi">1</span>
        <span class="p">[</span><span class="mi">4</span> <span class="p">,</span>  <span class="mi">7</span><span class="p">]</span>  <span class="o">=</span>  <span class="mi">2</span>
        <span class="p">[</span><span class="mi">5</span> <span class="p">,</span>  <span class="mi">9</span><span class="p">]</span>  <span class="o">=</span>  <span class="mi">3</span>
        <span class="p">[</span><span class="mi">3</span> <span class="p">,</span> <span class="mi">18</span><span class="p">]</span>  <span class="o">=</span>  <span class="o">-</span><span class="mi">5</span>
</pre></div>
</div>
<p>The inverse of the <a class="reference internal" href="../../stdlib/arrays/#Base.sparse" title="Base.sparse"><code class="xref jl jl-func docutils literal"><span class="pre">sparse()</span></code></a> function is <a class="reference internal" href="../../stdlib/arrays/#Base.findn" title="Base.findn"><code class="xref jl jl-func docutils literal"><span class="pre">findn()</span></code></a>, which
retrieves the inputs used to create the sparse matrix.</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">findn</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
<span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">18</span><span class="p">])</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">findnz</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
<span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">18</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">5</span><span class="p">])</span>
</pre></div>
</div>
<p>Another way to create sparse matrices is to convert a dense matrix
into a sparse matrix using the <a class="reference internal" href="../../stdlib/arrays/#Base.sparse" title="Base.sparse"><code class="xref jl jl-func docutils literal"><span class="pre">sparse()</span></code></a> function:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">sparse</span><span class="p">(</span><span class="n">eye</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="mi">5</span><span class="n">x5</span> <span class="n">sparse</span> <span class="n">matrix</span> <span class="n">with</span> <span class="mi">5</span> <span class="kt">Float64</span> <span class="n">entries</span><span class="o">:</span>
        <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>  <span class="o">=</span>  <span class="mf">1.0</span>
        <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>  <span class="o">=</span>  <span class="mf">1.0</span>
        <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>  <span class="o">=</span>  <span class="mf">1.0</span>
        <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>  <span class="o">=</span>  <span class="mf">1.0</span>
        <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>  <span class="o">=</span>  <span class="mf">1.0</span>
</pre></div>
</div>
<p>You can go in the other direction using the <a class="reference internal" href="../../stdlib/linalg/#Base.full" title="Base.full"><code class="xref jl jl-func docutils literal"><span class="pre">full()</span></code></a> function. The
<a class="reference internal" href="../../stdlib/arrays/#Base.issparse" title="Base.issparse"><code class="xref jl jl-func docutils literal"><span class="pre">issparse()</span></code></a> function can be used to query if a matrix is sparse.</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">issparse</span><span class="p">(</span><span class="n">speye</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="kc">true</span>
</pre></div>
</div>
</div>
<div class="section" id="sparse-matrix-operations">
<h3>Sparse matrix operations<a class="headerlink" href="#sparse-matrix-operations" title="Permalink to this headline">¶</a></h3>
<p>Arithmetic operations on sparse matrices also work as they do on dense
matrices. Indexing of, assignment into, and concatenation of sparse
matrices work in the same way as dense matrices. Indexing operations,
especially assignment, are expensive, when carried out one element at
a time. In many cases it may be better to convert the sparse matrix
into <code class="docutils literal"><span class="pre">(I,J,V)</span></code> format using <a class="reference internal" href="../../stdlib/arrays/#Base.findnz" title="Base.findnz"><code class="xref jl jl-func docutils literal"><span class="pre">findnz()</span></code></a>, manipulate the non-zeroes or
the structure in the dense vectors <code class="docutils literal"><span class="pre">(I,J,V)</span></code>, and then reconstruct
the sparse matrix.</p>
</div>
<div class="section" id="correspondence-of-dense-and-sparse-methods">
<h3>Correspondence of dense and sparse methods<a class="headerlink" href="#correspondence-of-dense-and-sparse-methods" title="Permalink to this headline">¶</a></h3>
<p>The following table gives a correspondence between built-in methods on sparse
matrices and their corresponding methods on dense matrix types. In general,
methods that generate sparse matrices differ from their dense counterparts in
that the resulting matrix follows the same sparsity pattern as a given sparse
matrix <code class="docutils literal"><span class="pre">S</span></code>, or that the resulting sparse matrix has density <code class="docutils literal"><span class="pre">d</span></code>, i.e. each
matrix element has a probability <code class="docutils literal"><span class="pre">d</span></code> of being non-zero.</p>
<p>Details can be found in the <a class="reference internal" href="../../stdlib/arrays/#stdlib-sparse"><span class="std std-ref">Sparse Matrices</span></a> section of the standard library
reference.</p>
<table border="1" class="docutils">
<colgroup>
<col width="34%" />
<col width="29%" />
<col width="37%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Sparse</th>
<th class="head">Dense</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><a class="reference internal" href="../../stdlib/arrays/#Base.spzeros" title="Base.spzeros"><code class="xref jl jl-func docutils literal"><span class="pre">spzeros(m,n)</span></code></a></td>
<td><a class="reference internal" href="../../stdlib/arrays/#Base.zeros" title="Base.zeros"><code class="xref jl jl-func docutils literal"><span class="pre">zeros(m,n)</span></code></a></td>
<td>Creates a <em>m</em>-by-<em>n</em> matrix of zeros.
(<a class="reference internal" href="../../stdlib/arrays/#Base.spzeros" title="Base.spzeros"><code class="xref jl jl-func docutils literal"><span class="pre">spzeros(m,n)</span></code></a> is empty.)</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="../../stdlib/arrays/#Base.spones" title="Base.spones"><code class="xref jl jl-func docutils literal"><span class="pre">spones(S)</span></code></a></td>
<td><a class="reference internal" href="../../stdlib/arrays/#Base.ones" title="Base.ones"><code class="xref jl jl-func docutils literal"><span class="pre">ones(m,n)</span></code></a></td>
<td>Creates a matrix filled with ones.
Unlike the dense version, <a class="reference internal" href="../../stdlib/arrays/#Base.spones" title="Base.spones"><code class="xref jl jl-func docutils literal"><span class="pre">spones()</span></code></a>
has the same sparsity pattern as <em>S</em>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="../../stdlib/arrays/#Base.speye" title="Base.speye"><code class="xref jl jl-func docutils literal"><span class="pre">speye(n)</span></code></a></td>
<td><a class="reference internal" href="../../stdlib/arrays/#Base.eye" title="Base.eye"><code class="xref jl jl-func docutils literal"><span class="pre">eye(n)</span></code></a></td>
<td>Creates a <em>n</em>-by-<em>n</em> identity matrix.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="../../stdlib/linalg/#Base.full" title="Base.full"><code class="xref jl jl-func docutils literal"><span class="pre">full(S)</span></code></a></td>
<td><a class="reference internal" href="../../stdlib/arrays/#Base.sparse" title="Base.sparse"><code class="xref jl jl-func docutils literal"><span class="pre">sparse(A)</span></code></a></td>
<td>Interconverts between dense
and sparse formats.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="../../stdlib/arrays/#Base.sprand" title="Base.sprand"><code class="xref jl jl-func docutils literal"><span class="pre">sprand(m,n,d)</span></code></a></td>
<td><a class="reference internal" href="../../stdlib/numbers/#Base.rand" title="Base.rand"><code class="xref jl jl-func docutils literal"><span class="pre">rand(m,n)</span></code></a></td>
<td>Creates a <em>m</em>-by-<em>n</em> random matrix (of
density <em>d</em>) with iid non-zero elements
distributed uniformly on the
half-open interval <span class="math">\([0, 1)\)</span>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="../../stdlib/arrays/#Base.sprandn" title="Base.sprandn"><code class="xref jl jl-func docutils literal"><span class="pre">sprandn(m,n,d)</span></code></a></td>
<td><a class="reference internal" href="../../stdlib/numbers/#Base.randn" title="Base.randn"><code class="xref jl jl-func docutils literal"><span class="pre">randn(m,n)</span></code></a></td>
<td>Creates a <em>m</em>-by-<em>n</em> random matrix (of
density <em>d</em>) with iid non-zero elements
distributed according to the standard
normal (Gaussian) distribution.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="../../stdlib/arrays/#Base.sprandn" title="Base.sprandn"><code class="xref jl jl-func docutils literal"><span class="pre">sprandn(m,n,d,X)</span></code></a></td>
<td><a class="reference internal" href="../../stdlib/numbers/#Base.randn" title="Base.randn"><code class="xref jl jl-func docutils literal"><span class="pre">randn(m,n,X)</span></code></a></td>
<td>Creates a <em>m</em>-by-<em>n</em> random matrix (of
density <em>d</em>) with iid non-zero elements
distributed according to the <em>X</em>
distribution. (Requires the
<code class="docutils literal"><span class="pre">Distributions</span></code> package.)</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="../../stdlib/arrays/#Base.sprandbool" title="Base.sprandbool"><code class="xref jl jl-func docutils literal"><span class="pre">sprandbool(m,n,d)</span></code></a></td>
<td><a class="reference internal" href="../../stdlib/numbers/#Base.rand" title="Base.rand"><code class="xref jl jl-func docutils literal"><span class="pre">rand(Bool,m,n)</span></code></a></td>
<td>Creates a <em>m</em>-by-<em>n</em> random matrix (of
density <em>d</em>) with non-zero  <code class="docutils literal"><span class="pre">Bool</span></code>
elements with probability <em>d</em> (<em>d</em> =0.5
for <a class="reference internal" href="../../stdlib/numbers/#Base.rand" title="Base.rand"><code class="xref jl jl-func docutils literal"><span class="pre">rand(Bool)</span></code></a>.)</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>


          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../linear-algebra/" class="btn btn-neutral float-right" title="Linear algebra">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../metaprogramming/" class="btn btn-neutral" title="Metaprogramming"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
    </p>
  </div>

  <a href="https://github.com/snide/sphinx_rtd_theme">Sphinx theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>
</footer>
        </div>
      </div>

    </section>

  </div>
  

  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'0.4.8-pre',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>