

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Constructors &mdash; Julia Language 0.4.8-pre documentation</title>
  

  
  

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/julia.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../../_static/julia.css" type="text/css" />
  
    <link rel="top" title="Julia Language 0.4.8-pre documentation" href="../../"/>
        <link rel="next" title="Conversion and Promotion" href="../conversion-and-promotion/"/>
        <link rel="prev" title="Methods" href="../methods/"/> 

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        <a href="http://julialang.org/"><img src="../../_static/julia-logo.svg" class="logo"></a>
        <!--
        <a href="../../" class="fa fa-home"> Julia Language</a>
        -->
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search/" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
        
            <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../introduction/">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../getting-started/">Getting Started</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../getting-started/#resources">Resources</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../variables/">Variables</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../variables/#allowed-variable-names">Allowed Variable Names</a></li>
<li class="toctree-l2"><a class="reference internal" href="../variables/#stylistic-conventions">Stylistic Conventions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../integers-and-floating-point-numbers/">Integers and Floating-Point Numbers</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../integers-and-floating-point-numbers/#integers">Integers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../integers-and-floating-point-numbers/#floating-point-numbers">Floating-Point Numbers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../integers-and-floating-point-numbers/#arbitrary-precision-arithmetic">Arbitrary Precision Arithmetic</a></li>
<li class="toctree-l2"><a class="reference internal" href="../integers-and-floating-point-numbers/#numeric-literal-coefficients">Numeric Literal Coefficients</a></li>
<li class="toctree-l2"><a class="reference internal" href="../integers-and-floating-point-numbers/#literal-zero-and-one">Literal zero and one</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../mathematical-operations/">Mathematical Operations and Elementary Functions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../mathematical-operations/#arithmetic-operators">Arithmetic Operators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical-operations/#bitwise-operators">Bitwise Operators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical-operations/#updating-operators">Updating operators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical-operations/#numeric-comparisons">Numeric Comparisons</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical-operations/#numerical-conversions">Numerical Conversions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../complex-and-rational-numbers/">Complex and Rational Numbers</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../complex-and-rational-numbers/#complex-numbers">Complex Numbers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../complex-and-rational-numbers/#rational-numbers">Rational Numbers</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../strings/">Strings</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../strings/#characters">Characters</a></li>
<li class="toctree-l2"><a class="reference internal" href="../strings/#string-basics">String Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../strings/#unicode-and-utf-8">Unicode and UTF-8</a></li>
<li class="toctree-l2"><a class="reference internal" href="../strings/#interpolation">Interpolation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../strings/#triple-quoted-string-literals">Triple-Quoted String Literals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../strings/#common-operations">Common Operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../strings/#non-standard-string-literals">Non-Standard String Literals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../strings/#regular-expressions">Regular Expressions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../strings/#id3">Byte Array Literals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../strings/#version-number-literals">Version Number Literals</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../functions/">Functions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../functions/#argument-passing-behavior">Argument Passing Behavior</a></li>
<li class="toctree-l2"><a class="reference internal" href="../functions/#the-return-keyword">The <code class="docutils literal"><span class="pre">return</span></code> Keyword</a></li>
<li class="toctree-l2"><a class="reference internal" href="../functions/#operators-are-functions">Operators Are Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../functions/#operators-with-special-names">Operators With Special Names</a></li>
<li class="toctree-l2"><a class="reference internal" href="../functions/#anonymous-functions">Anonymous Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../functions/#multiple-return-values">Multiple Return Values</a></li>
<li class="toctree-l2"><a class="reference internal" href="../functions/#varargs-functions">Varargs Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../functions/#optional-arguments">Optional Arguments</a></li>
<li class="toctree-l2"><a class="reference internal" href="../functions/#keyword-arguments">Keyword Arguments</a></li>
<li class="toctree-l2"><a class="reference internal" href="../functions/#evaluation-scope-of-default-values">Evaluation Scope of Default Values</a></li>
<li class="toctree-l2"><a class="reference internal" href="../functions/#do-block-syntax-for-function-arguments">Do-Block Syntax for Function Arguments</a></li>
<li class="toctree-l2"><a class="reference internal" href="../functions/#further-reading">Further Reading</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../control-flow/">Control Flow</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../control-flow/#compound-expressions">Compound Expressions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../control-flow/#conditional-evaluation">Conditional Evaluation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../control-flow/#short-circuit-evaluation">Short-Circuit Evaluation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../control-flow/#repeated-evaluation-loops">Repeated Evaluation: Loops</a></li>
<li class="toctree-l2"><a class="reference internal" href="../control-flow/#exception-handling">Exception Handling</a></li>
<li class="toctree-l2"><a class="reference internal" href="../control-flow/#tasks-aka-coroutines">Tasks (aka Coroutines)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../variables-and-scoping/">Scope of Variables</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../variables-and-scoping/#global-scope">Global Scope</a></li>
<li class="toctree-l2"><a class="reference internal" href="../variables-and-scoping/#local-scope">Local Scope</a></li>
<li class="toctree-l2"><a class="reference internal" href="../variables-and-scoping/#constants">Constants</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../types/">Types</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../types/#type-declarations">Type Declarations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../types/#abstract-types">Abstract Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../types/#bits-types">Bits Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../types/#composite-types">Composite Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../types/#immutable-composite-types">Immutable Composite Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../types/#declared-types">Declared Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../types/#type-unions">Type Unions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../types/#man-parametric-types">Parametric Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../types/#type-aliases">Type Aliases</a></li>
<li class="toctree-l2"><a class="reference internal" href="../types/#operations-on-types">Operations on Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../types/#value-types">&#8220;Value types&#8221;</a></li>
<li class="toctree-l2"><a class="reference internal" href="../types/#nullable-types-representing-missing-values">Nullable Types: Representing Missing Values</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../methods/">Methods</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../methods/#defining-methods">Defining Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="../methods/#method-ambiguities">Method Ambiguities</a></li>
<li class="toctree-l2"><a class="reference internal" href="../methods/#parametric-methods">Parametric Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="../methods/#note-on-optional-and-keyword-arguments">Note on Optional and keyword Arguments</a></li>
<li class="toctree-l2"><a class="reference internal" href="../methods/#call-overloading-and-function-like-objects">Call overloading and function-like objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="../methods/#empty-generic-functions">Empty generic functions</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Constructors</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#outer-constructor-methods">Outer Constructor Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="#inner-constructor-methods">Inner Constructor Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="#incomplete-initialization">Incomplete Initialization</a></li>
<li class="toctree-l2"><a class="reference internal" href="#parametric-constructors">Parametric Constructors</a></li>
<li class="toctree-l2"><a class="reference internal" href="#case-study-rational">Case Study: Rational</a></li>
<li class="toctree-l2"><a class="reference internal" href="#constructors-call-and-conversion">Constructors, Call, and Conversion</a></li>
<li class="toctree-l2"><a class="reference internal" href="#outer-only-constructors">Outer-only constructors</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../conversion-and-promotion/">Conversion and Promotion</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../conversion-and-promotion/#conversion">Conversion</a></li>
<li class="toctree-l2"><a class="reference internal" href="../conversion-and-promotion/#promotion">Promotion</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../interfaces/">Interfaces</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../interfaces/#iteration">Iteration</a></li>
<li class="toctree-l2"><a class="reference internal" href="../interfaces/#indexing">Indexing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../interfaces/#abstract-arrays">Abstract Arrays</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../modules/">Modules</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../modules/#summary-of-module-usage">Summary of module usage</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../documentation/">Documentation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../documentation/#accessing-documentation">Accessing Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../documentation/#functions-methods">Functions &amp; Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="../documentation/#advanced-usage">Advanced Usage</a></li>
<li class="toctree-l2"><a class="reference internal" href="../documentation/#syntax-guide">Syntax Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../documentation/#markdown-syntax-notes">Markdown Syntax Notes</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../metaprogramming/">Metaprogramming</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../metaprogramming/#program-representation">Program representation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../metaprogramming/#expressions-and-evaluation">Expressions and evaluation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../metaprogramming/#macros">Macros</a></li>
<li class="toctree-l2"><a class="reference internal" href="../metaprogramming/#code-generation">Code Generation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../metaprogramming/#non-standard-string-literals">Non-Standard String Literals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../metaprogramming/#generated-functions">Generated functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../arrays/">Multi-dimensional Arrays</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../arrays/#arrays">Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="../arrays/#sparse-matrices">Sparse Matrices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../linear-algebra/">Linear algebra</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../linear-algebra/#matrix-factorizations">Matrix factorizations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../linear-algebra/#special-matrices">Special matrices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../networking-and-streams/">Networking and Streams</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../networking-and-streams/#basic-stream-i-o">Basic Stream I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../networking-and-streams/#text-i-o">Text I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../networking-and-streams/#working-with-files">Working with Files</a></li>
<li class="toctree-l2"><a class="reference internal" href="../networking-and-streams/#a-simple-tcp-example">A simple TCP example</a></li>
<li class="toctree-l2"><a class="reference internal" href="../networking-and-streams/#resolving-ip-addresses">Resolving IP Addresses</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../parallel-computing/">Parallel Computing</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../parallel-computing/#code-availability-and-loading-packages">Code Availability and Loading Packages</a></li>
<li class="toctree-l2"><a class="reference internal" href="../parallel-computing/#data-movement">Data Movement</a></li>
<li class="toctree-l2"><a class="reference internal" href="../parallel-computing/#parallel-map-and-loops">Parallel Map and Loops</a></li>
<li class="toctree-l2"><a class="reference internal" href="../parallel-computing/#synchronization-with-remote-references">Synchronization With Remote References</a></li>
<li class="toctree-l2"><a class="reference internal" href="../parallel-computing/#scheduling">Scheduling</a></li>
<li class="toctree-l2"><a class="reference internal" href="../parallel-computing/#channels">Channels</a></li>
<li class="toctree-l2"><a class="reference internal" href="../parallel-computing/#remoterefs-and-abstractchannels">RemoteRefs and AbstractChannels</a></li>
<li class="toctree-l2"><a class="reference internal" href="../parallel-computing/#shared-arrays">Shared Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="../parallel-computing/#distributed-garbage-collection">Distributed Garbage Collection</a></li>
<li class="toctree-l2"><a class="reference internal" href="../parallel-computing/#clustermanagers">ClusterManagers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../parallel-computing/#cluster-managers-with-custom-transports">Cluster Managers with custom transports</a></li>
<li class="toctree-l2"><a class="reference internal" href="../parallel-computing/#specifying-network-topology-experimental">Specifying network topology (Experimental)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../dates/">Date and DateTime</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../dates/#constructors">Constructors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dates/#durations-comparisons">Durations/Comparisons</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dates/#accessor-functions">Accessor Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dates/#query-functions">Query Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dates/#timetype-period-arithmetic">TimeType-Period Arithmetic</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dates/#adjuster-functions">Adjuster Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dates/#period-types">Period Types</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../running-external-programs/">Running External Programs</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../running-external-programs/#interpolation">Interpolation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../running-external-programs/#quoting">Quoting</a></li>
<li class="toctree-l2"><a class="reference internal" href="../running-external-programs/#pipelines">Pipelines</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../calling-c-and-fortran-code/">Calling C and Fortran Code</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../calling-c-and-fortran-code/#creating-c-compatible-julia-function-pointers">Creating C-Compatible Julia Function Pointers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../calling-c-and-fortran-code/#mapping-c-types-to-julia">Mapping C Types to Julia</a></li>
<li class="toctree-l2"><a class="reference internal" href="../calling-c-and-fortran-code/#mapping-c-functions-to-julia">Mapping C Functions to Julia</a></li>
<li class="toctree-l2"><a class="reference internal" href="../calling-c-and-fortran-code/#garbage-collection-safety">Garbage Collection Safety</a></li>
<li class="toctree-l2"><a class="reference internal" href="../calling-c-and-fortran-code/#non-constant-function-specifications">Non-constant Function Specifications</a></li>
<li class="toctree-l2"><a class="reference internal" href="../calling-c-and-fortran-code/#indirect-calls">Indirect Calls</a></li>
<li class="toctree-l2"><a class="reference internal" href="../calling-c-and-fortran-code/#calling-convention">Calling Convention</a></li>
<li class="toctree-l2"><a class="reference internal" href="../calling-c-and-fortran-code/#accessing-global-variables">Accessing Global Variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="../calling-c-and-fortran-code/#accessing-data-through-a-pointer">Accessing Data through a Pointer</a></li>
<li class="toctree-l2"><a class="reference internal" href="../calling-c-and-fortran-code/#thread-safety">Thread-safety</a></li>
<li class="toctree-l2"><a class="reference internal" href="../calling-c-and-fortran-code/#more-about-callbacks">More About Callbacks</a></li>
<li class="toctree-l2"><a class="reference internal" href="../calling-c-and-fortran-code/#c">C++</a></li>
<li class="toctree-l2"><a class="reference internal" href="../calling-c-and-fortran-code/#handling-operating-system-variation">Handling Operating System Variation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../interacting-with-julia/">Interacting With Julia</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../interacting-with-julia/#the-different-prompt-modes">The different prompt modes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../interacting-with-julia/#key-bindings">Key bindings</a></li>
<li class="toctree-l2"><a class="reference internal" href="../interacting-with-julia/#tab-completion">Tab completion</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../embedding/">Embedding Julia</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../embedding/#high-level-embedding">High-Level Embedding</a></li>
<li class="toctree-l2"><a class="reference internal" href="../embedding/#converting-types">Converting Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../embedding/#calling-julia-functions">Calling Julia Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../embedding/#memory-management">Memory Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="../embedding/#working-with-arrays">Working with Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="../embedding/#exceptions">Exceptions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../packages/">Packages</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../packages/#package-status">Package Status</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/#adding-and-removing-packages">Adding and Removing Packages</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/#offline-installation-of-packages">Offline Installation of Packages</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/#installing-unregistered-packages">Installing Unregistered Packages</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/#updating-packages">Updating Packages</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/#checkout-pin-and-free">Checkout, Pin and Free</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/#custom-metadata-repository">Custom METADATA Repository</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../packages/#package-development">Package Development</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../packages/#initial-setup">Initial Setup</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/#making-changes-to-an-existing-package">Making changes to an existing package</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/#creating-a-new-package">Creating a new Package</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/#fixing-package-requirements">Fixing Package Requirements</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/#man-package-requirements">Requirements Specification</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../profile/">Profiling</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../profile/#basic-usage">Basic usage</a></li>
<li class="toctree-l2"><a class="reference internal" href="../profile/#accumulation-and-clearing">Accumulation and clearing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../profile/#options-for-controlling-the-display-of-profile-results">Options for controlling the display of profile results</a></li>
<li class="toctree-l2"><a class="reference internal" href="../profile/#configuration">Configuration</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../profile/#memory-allocation-analysis">Memory allocation analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../performance-tips/">Performance Tips</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../performance-tips/#avoid-global-variables">Avoid global variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="../performance-tips/#measure-performance-with-time-and-pay-attention-to-memory-allocation">Measure performance with <code class="docutils literal"><span class="pre">&#64;time</span></code> and pay attention to memory allocation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../performance-tips/#tools">Tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="../performance-tips/#avoid-containers-with-abstract-type-parameters">Avoid containers with abstract type parameters</a></li>
<li class="toctree-l2"><a class="reference internal" href="../performance-tips/#type-declarations">Type declarations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../performance-tips/#break-functions-into-multiple-definitions">Break functions into multiple definitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../performance-tips/#write-type-stable-functions">Write &#8220;type-stable&#8221; functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../performance-tips/#avoid-changing-the-type-of-a-variable">Avoid changing the type of a variable</a></li>
<li class="toctree-l2"><a class="reference internal" href="../performance-tips/#separate-kernel-functions">Separate kernel functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../performance-tips/#access-arrays-in-memory-order-along-columns">Access arrays in memory order, along columns</a></li>
<li class="toctree-l2"><a class="reference internal" href="../performance-tips/#pre-allocating-outputs">Pre-allocating outputs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../performance-tips/#avoid-string-interpolation-for-i-o">Avoid string interpolation for I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../performance-tips/#optimize-network-i-o-during-parallel-execution">Optimize network I/O during parallel execution</a></li>
<li class="toctree-l2"><a class="reference internal" href="../performance-tips/#fix-deprecation-warnings">Fix deprecation warnings</a></li>
<li class="toctree-l2"><a class="reference internal" href="../performance-tips/#tweaks">Tweaks</a></li>
<li class="toctree-l2"><a class="reference internal" href="../performance-tips/#performance-annotations">Performance Annotations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../performance-tips/#treat-subnormal-numbers-as-zeros">Treat Subnormal Numbers as Zeros</a></li>
<li class="toctree-l2"><a class="reference internal" href="../performance-tips/#code-warntype"><code class="docutils literal"><span class="pre">&#64;code_warntype</span></code></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../workflow-tips/">Workflow Tips</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../workflow-tips/#repl-based-workflow">REPL-based workflow</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflow-tips/#browser-based-workflow">Browser-based workflow</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../style-guide/">Style Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#write-functions-not-just-scripts">Write functions, not just scripts</a></li>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#avoid-writing-overly-specific-types">Avoid writing overly-specific types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#handle-excess-argument-diversity-in-the-caller">Handle excess argument diversity in the caller</a></li>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#append-to-names-of-functions-that-modify-their-arguments">Append <code class="docutils literal"><span class="pre">!</span></code> to names of functions that modify their arguments</a></li>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#avoid-strange-type-unions">Avoid strange type Unions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#avoid-type-unions-in-fields">Avoid type Unions in fields</a></li>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#avoid-elaborate-container-types">Avoid elaborate container types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#use-naming-conventions-consistent-with-julia-s-base">Use naming conventions consistent with Julia&#8217;s <code class="docutils literal"><span class="pre">base/</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#don-t-overuse-try-catch">Don&#8217;t overuse try-catch</a></li>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#don-t-parenthesize-conditions">Don&#8217;t parenthesize conditions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#don-t-overuse">Don&#8217;t overuse ...</a></li>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#don-t-use-unnecessary-static-parameters">Don&#8217;t use unnecessary static parameters</a></li>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#avoid-confusion-about-whether-something-is-an-instance-or-a-type">Avoid confusion about whether something is an instance or a type</a></li>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#don-t-overuse-macros">Don&#8217;t overuse macros</a></li>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#don-t-expose-unsafe-operations-at-the-interface-level">Don&#8217;t expose unsafe operations at the interface level</a></li>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#don-t-overload-methods-of-base-container-types">Don&#8217;t overload methods of base container types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#be-careful-with-type-equality">Be careful with type equality</a></li>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#do-not-write-x-f-x">Do not write <code class="docutils literal"><span class="pre">x-&gt;f(x)</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#avoid-using-floats-for-numeric-literals-in-generic-code-when-possible">Avoid using floats for numeric literals in generic code when possible</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../faq/">Frequently Asked Questions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../faq/#sessions-and-the-repl">Sessions and the REPL</a></li>
<li class="toctree-l2"><a class="reference internal" href="../faq/#functions">Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../faq/#types-type-declarations-and-constructors">Types, type declarations, and constructors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../faq/#packages-and-modules">Packages and Modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="../faq/#nothingness-and-missing-values">Nothingness and missing values</a></li>
<li class="toctree-l2"><a class="reference internal" href="../faq/#memory">Memory</a></li>
<li class="toctree-l2"><a class="reference internal" href="../faq/#asynchronous-io-and-concurrent-synchronous-writes">Asynchronous IO and concurrent synchronous writes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../faq/#julia-releases">Julia Releases</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../noteworthy-differences/">Noteworthy Differences from other Languages</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../noteworthy-differences/#noteworthy-differences-from-matlab">Noteworthy differences from MATLAB</a></li>
<li class="toctree-l2"><a class="reference internal" href="../noteworthy-differences/#noteworthy-differences-from-r">Noteworthy differences from R</a></li>
<li class="toctree-l2"><a class="reference internal" href="../noteworthy-differences/#noteworthy-differences-from-python">Noteworthy differences from Python</a></li>
<li class="toctree-l2"><a class="reference internal" href="../noteworthy-differences/#noteworthy-differences-from-c-c">Noteworthy differences from C/C++</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../unicode-input/">Unicode Input</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/base/">Essentials</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/base/#introduction">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/base/#getting-around">Getting Around</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/base/#all-objects">All Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/base/#types">Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/base/#generic-functions">Generic Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/base/#syntax">Syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/base/#nullables">Nullables</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/base/#system">System</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/base/#errors">Errors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/base/#events">Events</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/base/#reflection">Reflection</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/base/#internals">Internals</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/collections/">Collections and Data Structures</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/collections/#iteration">Iteration</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/collections/#general-collections">General Collections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/collections/#iterable-collections">Iterable Collections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/collections/#indexable-collections">Indexable Collections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/collections/#associative-collections">Associative Collections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/collections/#set-like-collections">Set-Like Collections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/collections/#dequeues">Dequeues</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/collections/#priorityqueue">PriorityQueue</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/collections/#heap-functions">Heap Functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/math/">Mathematics</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/math/#mathematical-operators">Mathematical Operators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/math/#mathematical-functions">Mathematical Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/math/#statistics">Statistics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/math/#signal-processing">Signal Processing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/math/#numerical-integration">Numerical Integration</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/numbers/">Numbers</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/numbers/#standard-numeric-types">Standard Numeric Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/numbers/#data-formats">Data Formats</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/numbers/#general-number-functions-and-constants">General Number Functions and Constants</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/numbers/#bigfloats">BigFloats</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/numbers/#random-numbers">Random Numbers</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/strings/">Strings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/arrays/">Arrays</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/arrays/#basic-functions">Basic functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/arrays/#constructors">Constructors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/arrays/#mathematical-operators-and-functions">Mathematical operators and functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/arrays/#indexing-assignment-and-concatenation">Indexing, Assignment, and Concatenation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/arrays/#array-functions">Array functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/arrays/#combinatorics">Combinatorics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/arrays/#bitarrays">BitArrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/arrays/#sparse-matrices">Sparse Matrices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/parallel/">Tasks and Parallel Computing</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/parallel/#tasks">Tasks</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/parallel/#general-parallel-computing-support">General Parallel Computing Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/parallel/#shared-arrays">Shared Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/parallel/#cluster-manager-interface">Cluster Manager Interface</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/linalg/">Linear Algebra</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/linalg/#module-Base.LinAlg">Standard Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/linalg/#module-Base.LinAlg.BLAS">BLAS Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/linalg/#module-Base.LinAlg.LAPACK">LAPACK Functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/constants/">Constants</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/file/">Filesystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/io-network/">I/O and Network</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/io-network/#general-i-o">General I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/io-network/#text-i-o">Text I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/io-network/#multimedia-i-o">Multimedia I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/io-network/#memory-mapped-i-o">Memory-mapped I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/io-network/#network-i-o">Network I/O</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/punctuation/">Punctuation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/sort/">Sorting and Related Functions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/sort/#sorting-functions">Sorting Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/sort/#order-related-functions">Order-Related Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/sort/#sorting-algorithms">Sorting Algorithms</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/pkg/">Package Manager Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/dates/">Dates and Time</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/dates/#dates-and-time-types">Dates and Time Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/dates/#dates-functions">Dates Functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/test/">Unit and Functional Testing</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/test/#testing-base-julia">Testing Base Julia</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/test/#test-framework">Test Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/test/#handlers">Handlers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/test/#macros">Macros</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/test/#functions">Functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/c/">C Interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/c/#llvm-interface">LLVM Interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/libc/">C Standard Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/libdl/">Dynamic Linker</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/profile/">Profiling</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../devdocs/reflection/">Reflection and introspection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../devdocs/julia/">Documentation of Julia&#8217;s Internals</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/init/">Initialization of the Julia runtime</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/eval/">Eval of Julia code</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/ast/">Julia ASTs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/types/">More about types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/object/">Memory layout of Julia Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/cartesian/">Base.Cartesian</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/meta/">Talking to the compiler (the <code class="docutils literal"><span class="pre">:meta</span></code> mechanism)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/subarrays/">SubArrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/sysimg/">System Image Building</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/llvm/">Working with LLVM</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/stdio/">printf() and stdio in the Julia runtime</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/promote-op/">Operator-sensitive promotion</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../devdocs/C/">Developing/debugging Julia&#8217;s C code</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/backtraces/">Reporting and analyzing crashes (segfaults)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/debuggingtips/">gdb debugging tips</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/valgrind/">Using Valgrind with Julia</a></li>
</ul>
</li>
</ul>

        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../">Julia Language</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../">Docs</a> &raquo;</li>
      
    <li>Constructors</li>
      <li class="wy-breadcrumbs-aside">
        
          <a href="../../_sources/manual/constructors.txt" rel="nofollow"> View page source</a>
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document">
            
  <div class="section" id="constructors">
<span id="man-constructors"></span><h1>Constructors<a class="headerlink" href="#constructors" title="Permalink to this headline">¶</a></h1>
<p>Constructors <a class="footnote-reference" href="#id2" id="id1">[1]</a> are functions that create new objects — specifically,
instances of <a class="reference internal" href="../types/#man-composite-types"><span class="std std-ref">Composite Types</span></a>. In Julia,
type objects also serve as constructor functions: they create new
instances of themselves when applied to an argument tuple as a function.
This much was already mentioned briefly when composite types were
introduced. For example:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="k">type</span><span class="nc"> Foo</span>
  <span class="n">bar</span>
  <span class="n">baz</span>
<span class="k">end</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">foo</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">Foo</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">foo</span><span class="o">.</span><span class="n">bar</span>
<span class="mi">1</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">foo</span><span class="o">.</span><span class="n">baz</span>
<span class="mi">2</span>
</pre></div>
</div>
<p>For many types, forming new objects by binding their field values
together is all that is ever needed to create instances. There are,
however, cases where more functionality is required when creating
composite objects. Sometimes invariants must be enforced, either by
checking arguments or by transforming them. <a class="reference external" href="https://en.wikipedia.org/wiki/Recursion_%28computer_science%29#Recursive_data_structures_.28structural_recursion.29">Recursive data
structures</a>,
especially those that may be self-referential, often cannot be
constructed cleanly without first being created in an incomplete state
and then altered programmatically to be made whole, as a separate step
from object creation. Sometimes, it&#8217;s just convenient to be able to
construct objects with fewer or different types of parameters than they
have fields. Julia&#8217;s system for object construction addresses all of
these cases and more.</p>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Nomenclature: while the term “constructor” generally refers to
the entire function which constructs objects of a type, it is common to
abuse terminology slightly and refer to specific constructor methods as
“constructors”. In such situations, it is generally clear from context
that the term is used to mean “constructor method” rather than
“constructor function”, especially as it is often used in the sense of
singling out a particular method of the constructor from all of the
others.</td></tr>
</tbody>
</table>
<div class="section" id="outer-constructor-methods">
<h2>Outer Constructor Methods<a class="headerlink" href="#outer-constructor-methods" title="Permalink to this headline">¶</a></h2>
<p>A constructor is just like any other function in Julia in that its
overall behavior is defined by the combined behavior of its methods.
Accordingly, you can add functionality to a constructor by simply
defining new methods. For example, let&#8217;s say you want to add a
constructor method for <code class="docutils literal"><span class="pre">Foo</span></code> objects that takes only one argument and
uses the given value for both the <code class="docutils literal"><span class="pre">bar</span></code> and <code class="docutils literal"><span class="pre">baz</span></code> fields. This is
simple:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">Foo</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">Foo</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">Foo</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>You could also add a zero-argument <code class="docutils literal"><span class="pre">Foo</span></code> constructor method that
supplies default values for both of the <code class="docutils literal"><span class="pre">bar</span></code> and <code class="docutils literal"><span class="pre">baz</span></code> fields:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">Foo</span><span class="p">()</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">Foo</span><span class="p">()</span>
<span class="n">Foo</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>Here the zero-argument constructor method calls the single-argument
constructor method, which in turn calls the automatically provided
two-argument constructor method. For reasons that will become clear very
shortly, additional constructor methods declared as normal methods like
this are called <em>outer</em> constructor methods. Outer constructor methods
can only ever create a new instance by calling another constructor
method, such as the automatically provided default ones.</p>
</div>
<div class="section" id="inner-constructor-methods">
<h2>Inner Constructor Methods<a class="headerlink" href="#inner-constructor-methods" title="Permalink to this headline">¶</a></h2>
<p>While outer constructor methods succeed in addressing the problem of
providing additional convenience methods for constructing objects, they
fail to address the other two use cases mentioned in the introduction of
this chapter: enforcing invariants, and allowing construction of
self-referential objects. For these problems, one needs <em>inner</em>
constructor methods. An inner constructor method is much like an outer
constructor method, with two differences:</p>
<ol class="arabic simple">
<li>It is declared inside the block of a type declaration, rather than
outside of it like normal methods.</li>
<li>It has access to a special locally existent function called <code class="docutils literal"><span class="pre">new</span></code>
that creates objects of the block&#8217;s type.</li>
</ol>
<p>For example, suppose one wants to declare a type that holds a pair of
real numbers, subject to the constraint that the first number is
not greater than the second one. One could declare it like this:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="k">type</span><span class="nc"> OrderedPair</span>
  <span class="n">x</span><span class="p">::</span><span class="n">Real</span>
  <span class="n">y</span><span class="p">::</span><span class="n">Real</span>

  <span class="n">OrderedPair</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span> <span class="o">?</span> <span class="nb">error</span><span class="p">(</span><span class="s">&quot;out of order&quot;</span><span class="p">)</span> <span class="p">:</span> <span class="nb">new</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
<span class="k">end</span>
</pre></div>
</div>
<p>Now <code class="docutils literal"><span class="pre">OrderedPair</span></code> objects can only be constructed such that
<code class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;=</span> <span class="pre">y</span></code>:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">OrderedPair</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">OrderedPair</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">OrderedPair</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">ERROR</span><span class="p">:</span> <span class="n">out</span> <span class="n">of</span> <span class="n">order</span>
 <span class="k">in</span> <span class="n">call</span> <span class="n">at</span> <span class="n">none</span><span class="p">:</span><span class="mi">5</span>
</pre></div>
</div>
<p>You can still reach in and directly change the field values to violate
this invariant, but messing around with an object&#8217;s internals uninvited is
considered poor form. You (or someone else) can also provide additional
outer constructor methods at any later point, but once a type is
declared, there is no way to add more inner constructor methods. Since
outer constructor methods can only create objects by calling other
constructor methods, ultimately, some inner constructor must be called
to create an object. This guarantees that all objects of the declared
type must come into existence by a call to one of the inner constructor
methods provided with the type, thereby giving some degree of
enforcement of a type&#8217;s invariants.</p>
<p>Of course, if the type is declared as <code class="docutils literal"><span class="pre">immutable</span></code>, then its
constructor-provided invariants are fully enforced. This is an important
consideration when deciding whether a type should be immutable.</p>
<p>If any inner constructor method is defined, no default constructor
method is provided: it is presumed that you have supplied yourself with
all the inner constructors you need. The default constructor is
equivalent to writing your own inner constructor method that takes all
of the object&#8217;s fields as parameters (constrained to be of the correct
type, if the corresponding field has a type), and passes them to
<code class="docutils literal"><span class="pre">new</span></code>, returning the resulting object:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="k">type</span><span class="nc"> Foo</span>
  <span class="n">bar</span>
  <span class="n">baz</span>

  <span class="n">Foo</span><span class="p">(</span><span class="n">bar</span><span class="p">,</span><span class="n">baz</span><span class="p">)</span> <span class="o">=</span> <span class="nb">new</span><span class="p">(</span><span class="n">bar</span><span class="p">,</span><span class="n">baz</span><span class="p">)</span>
<span class="k">end</span>
</pre></div>
</div>
<p>This declaration has the same effect as the earlier definition of the
<code class="docutils literal"><span class="pre">Foo</span></code> type without an explicit inner constructor method. The following
two types are equivalent — one with a default constructor, the other
with an explicit constructor:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="k">type</span><span class="nc"> T1</span>
  <span class="n">x</span><span class="p">::</span><span class="kt">Int64</span>
<span class="k">end</span>

<span class="k">type</span><span class="nc"> T2</span>
  <span class="n">x</span><span class="p">::</span><span class="kt">Int64</span>
  <span class="n">T2</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="nb">new</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="k">end</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">T1</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">T1</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">T2</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">T2</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">T1</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>
<span class="n">T1</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">T2</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>
<span class="n">T2</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>It is considered good form to provide as few inner constructor methods
as possible: only those taking all arguments explicitly and enforcing
essential error checking and transformation. Additional convenience
constructor methods, supplying default values or auxiliary
transformations, should be provided as outer constructors that call the
inner constructors to do the heavy lifting. This separation is typically
quite natural.</p>
</div>
<div class="section" id="incomplete-initialization">
<h2>Incomplete Initialization<a class="headerlink" href="#incomplete-initialization" title="Permalink to this headline">¶</a></h2>
<p>The final problem which has still not been addressed is construction of
self-referential objects, or more generally, recursive data structures.
Since the fundamental difficulty may not be immediately obvious, let us
briefly explain it. Consider the following recursive type declaration:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="k">type</span><span class="nc"> SelfReferential</span>
  <span class="n">obj</span><span class="p">::</span><span class="n">SelfReferential</span>
<span class="k">end</span>
</pre></div>
</div>
<p>This type may appear innocuous enough, until one considers how to
construct an instance of it. If <code class="docutils literal"><span class="pre">a</span></code> is an instance of
<code class="docutils literal"><span class="pre">SelfReferential</span></code>, then a second instance can be created by the call:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">b</span> <span class="o">=</span> <span class="n">SelfReferential</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
<p>But how does one construct the first instance when no instance exists to
provide as a valid value for its <code class="docutils literal"><span class="pre">obj</span></code> field? The only solution is to
allow creating an incompletely initialized instance of
<code class="docutils literal"><span class="pre">SelfReferential</span></code> with an unassigned <code class="docutils literal"><span class="pre">obj</span></code> field, and using that
incomplete instance as a valid value for the <code class="docutils literal"><span class="pre">obj</span></code> field of another
instance, such as, for example, itself.</p>
<p>To allow for the creation of incompletely initialized objects, Julia
allows the <code class="docutils literal"><span class="pre">new</span></code> function to be called with fewer than the number of
fields that the type has, returning an object with the unspecified
fields uninitialized. The inner constructor method can then use the
incomplete object, finishing its initialization before returning it.
Here, for example, we take another crack at defining the
<code class="docutils literal"><span class="pre">SelfReferential</span></code> type, with a zero-argument inner constructor
returning instances having <code class="docutils literal"><span class="pre">obj</span></code> fields pointing to themselves:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="k">type</span><span class="nc"> SelfReferential</span>
  <span class="n">obj</span><span class="p">::</span><span class="n">SelfReferential</span>

  <span class="n">SelfReferential</span><span class="p">()</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">=</span> <span class="nb">new</span><span class="p">();</span> <span class="n">x</span><span class="o">.</span><span class="n">obj</span> <span class="o">=</span> <span class="n">x</span><span class="p">)</span>
<span class="k">end</span>
</pre></div>
</div>
<p>We can verify that this constructor works and constructs objects that
are, in fact, self-referential:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">SelfReferential</span><span class="p">();</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nb">is</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="n">true</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nb">is</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span>
<span class="n">true</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nb">is</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">obj</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span>
<span class="n">true</span>
</pre></div>
</div>
<p>Although it is generally a good idea to return a fully initialized
object from an inner constructor, incompletely initialized objects can
be returned:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="k">type</span><span class="nc"> Incomplete</span>
         <span class="n">xx</span>
         <span class="n">Incomplete</span><span class="p">()</span> <span class="o">=</span> <span class="nb">new</span><span class="p">()</span>
       <span class="k">end</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">z</span> <span class="o">=</span> <span class="n">Incomplete</span><span class="p">();</span>
</pre></div>
</div>
<p>While you are allowed to create objects with uninitialized fields, any
access to an uninitialized reference is an immediate error:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">z</span><span class="o">.</span><span class="n">xx</span>
<span class="n">ERROR</span><span class="p">:</span> <span class="n">UndefRefError</span><span class="p">:</span> <span class="n">access</span> <span class="n">to</span> <span class="n">undefined</span> <span class="n">reference</span>
</pre></div>
</div>
<p>This avoids the need to continually check for <code class="docutils literal"><span class="pre">null</span></code> values.
However, not all object fields are references. Julia considers some
types to be &#8220;plain data&#8221;, meaning all of their data is self-contained
and does not reference other objects. The plain data types consist of bits
types (e.g. <code class="docutils literal"><span class="pre">Int</span></code>) and immutable structs of other plain data types.
The initial contents of a plain data type is undefined:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="k">type</span><span class="nc"> HasPlain</span>
         <span class="n">n</span><span class="p">::</span><span class="kt">Int</span>
         <span class="n">HasPlain</span><span class="p">()</span> <span class="o">=</span> <span class="nb">new</span><span class="p">()</span>
       <span class="k">end</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">HasPlain</span><span class="p">()</span>
<span class="n">HasPlain</span><span class="p">(</span><span class="mi">438103441441</span><span class="p">)</span>
</pre></div>
</div>
<p>Arrays of plain data types exhibit the same behavior.</p>
<p>You can pass incomplete objects to other functions from inner constructors to
delegate their completion:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="k">type</span><span class="nc"> Lazy</span>
  <span class="n">xx</span>

  <span class="n">Lazy</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">=</span> <span class="n">complete_me</span><span class="p">(</span><span class="nb">new</span><span class="p">(),</span> <span class="n">v</span><span class="p">)</span>
<span class="k">end</span>
</pre></div>
</div>
<p>As with incomplete objects returned from constructors, if
<code class="docutils literal"><span class="pre">complete_me</span></code> or any of its callees try to access the <code class="docutils literal"><span class="pre">xx</span></code> field of
the <code class="docutils literal"><span class="pre">Lazy</span></code> object before it has been initialized, an error will be
thrown immediately.</p>
</div>
<div class="section" id="parametric-constructors">
<h2>Parametric Constructors<a class="headerlink" href="#parametric-constructors" title="Permalink to this headline">¶</a></h2>
<p>Parametric types add a few wrinkles to the constructor story. Recall
from <a class="reference internal" href="../types/#man-parametric-types"><span class="std std-ref">Parametric Types</span></a> that, by default,
instances of parametric composite types can be constructed either with
explicitly given type parameters or with type parameters implied by the
types of the arguments given to the constructor. Here are some examples:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="k">type</span><span class="nc"> Point</span><span class="p">{</span><span class="n">T</span><span class="o">&lt;:</span><span class="n">Real</span><span class="p">}</span>
         <span class="n">x</span><span class="p">::</span><span class="n">T</span>
         <span class="n">y</span><span class="p">::</span><span class="n">T</span>
       <span class="k">end</span>

<span class="c">## implicit T ##</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">Point</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">Point</span><span class="p">{</span><span class="kt">Int64</span><span class="p">}(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">Point</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">2.5</span><span class="p">)</span>
<span class="n">Point</span><span class="p">{</span><span class="kt">Float64</span><span class="p">}(</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">2.5</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">Point</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mf">2.5</span><span class="p">)</span>
<span class="n">ERROR</span><span class="p">:</span> <span class="n">MethodError</span><span class="p">:</span> <span class="sb">`convert`</span> <span class="n">has</span> <span class="n">no</span> <span class="n">method</span> <span class="n">matching</span> <span class="nb">convert</span><span class="p">(::</span><span class="n">Type</span><span class="p">{</span><span class="n">Point</span><span class="p">{</span><span class="n">T</span><span class="o">&lt;:</span><span class="n">Real</span><span class="p">}},</span> <span class="p">::</span><span class="kt">Int64</span><span class="p">,</span> <span class="p">::</span><span class="kt">Float64</span><span class="p">)</span>
<span class="n">This</span> <span class="n">may</span> <span class="n">have</span> <span class="n">arisen</span> <span class="n">from</span> <span class="n">a</span> <span class="n">call</span> <span class="n">to</span> <span class="n">the</span> <span class="n">constructor</span> <span class="n">Point</span><span class="p">{</span><span class="n">T</span><span class="o">&lt;:</span><span class="n">Real</span><span class="p">}(</span><span class="o">...</span><span class="p">),</span>
<span class="n">since</span> <span class="k">type</span><span class="nc"> constructors</span> <span class="n">fall</span> <span class="n">back</span> <span class="n">to</span> <span class="nb">convert</span> <span class="n">methods</span><span class="o">.</span>
<span class="n">Closest</span> <span class="n">candidates</span> <span class="n">are</span><span class="p">:</span>
  <span class="n">Point</span><span class="p">{</span><span class="n">T</span><span class="o">&lt;:</span><span class="n">Real</span><span class="p">}(::</span><span class="n">T</span><span class="o">&lt;:</span><span class="n">Real</span><span class="p">,</span> <span class="o">!</span><span class="n">Matched</span><span class="p">::</span><span class="n">T</span><span class="o">&lt;:</span><span class="n">Real</span><span class="p">)</span>
  <span class="n">call</span><span class="p">{</span><span class="n">T</span><span class="p">}(::</span><span class="n">Type</span><span class="p">{</span><span class="n">T</span><span class="p">},</span> <span class="p">::</span><span class="kt">Any</span><span class="p">)</span>
  <span class="nb">convert</span><span class="p">{</span><span class="n">T</span><span class="p">}(::</span><span class="n">Type</span><span class="p">{</span><span class="n">T</span><span class="p">},</span> <span class="o">!</span><span class="n">Matched</span><span class="p">::</span><span class="n">T</span><span class="p">)</span>
 <span class="k">in</span> <span class="n">call</span> <span class="n">at</span> <span class="n">essentials</span><span class="o">.</span><span class="n">jl</span><span class="p">:</span><span class="mi">57</span>

<span class="c">## explicit T ##</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">Point</span><span class="p">{</span><span class="kt">Int64</span><span class="p">}(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">Point</span><span class="p">{</span><span class="kt">Int64</span><span class="p">}(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">Point</span><span class="p">{</span><span class="kt">Int64</span><span class="p">}(</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">2.5</span><span class="p">)</span>
<span class="n">ERROR</span><span class="p">:</span> <span class="n">InexactError</span><span class="p">()</span>
 <span class="k">in</span> <span class="n">call</span> <span class="n">at</span> <span class="n">none</span><span class="p">:</span><span class="mi">2</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">Point</span><span class="p">{</span><span class="kt">Float64</span><span class="p">}(</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">2.5</span><span class="p">)</span>
<span class="n">Point</span><span class="p">{</span><span class="kt">Float64</span><span class="p">}(</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">2.5</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">Point</span><span class="p">{</span><span class="kt">Float64</span><span class="p">}(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">Point</span><span class="p">{</span><span class="kt">Float64</span><span class="p">}(</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">2.0</span><span class="p">)</span>
</pre></div>
</div>
<p>As you can see, for constructor calls with explicit type parameters, the
arguments are converted to the implied field types: <code class="docutils literal"><span class="pre">Point{Int64}(1,2)</span></code>
works, but <code class="docutils literal"><span class="pre">Point{Int64}(1.0,2.5)</span></code> raises an
<code class="docutils literal"><span class="pre">InexactError</span></code> when converting <code class="docutils literal"><span class="pre">2.5</span></code> to <code class="docutils literal"><span class="pre">Int64</span></code>.
When the type is implied by the
arguments to the constructor call, as in <code class="docutils literal"><span class="pre">Point(1,2)</span></code>, then the types
of the arguments must agree — otherwise the <code class="docutils literal"><span class="pre">T</span></code> cannot be determined —
but any pair of real arguments with matching type may be given to the
generic <code class="docutils literal"><span class="pre">Point</span></code> constructor.</p>
<p>What&#8217;s really going on here is that <code class="docutils literal"><span class="pre">Point</span></code>, <code class="docutils literal"><span class="pre">Point{Float64}</span></code> and
<code class="docutils literal"><span class="pre">Point{Int64}</span></code> are all different constructor functions. In fact,
<code class="docutils literal"><span class="pre">Point{T}</span></code> is a distinct constructor function for each type <code class="docutils literal"><span class="pre">T</span></code>.
Without any explicitly provided inner constructors, the declaration of
the composite type <code class="docutils literal"><span class="pre">Point{T&lt;:Real}</span></code> automatically provides an inner
constructor, <code class="docutils literal"><span class="pre">Point{T}</span></code>, for each possible type <code class="docutils literal"><span class="pre">T&lt;:Real</span></code>, that
behaves just like non-parametric default inner constructors do. It also
provides a single general outer <code class="docutils literal"><span class="pre">Point</span></code> constructor that takes pairs
of real arguments, which must be of the same type. This automatic
provision of constructors is equivalent to the following explicit
declaration:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="k">type</span><span class="nc"> Point</span><span class="p">{</span><span class="n">T</span><span class="o">&lt;:</span><span class="n">Real</span><span class="p">}</span>
  <span class="n">x</span><span class="p">::</span><span class="n">T</span>
  <span class="n">y</span><span class="p">::</span><span class="n">T</span>

  <span class="n">Point</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="nb">new</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
<span class="k">end</span>

<span class="n">Point</span><span class="p">{</span><span class="n">T</span><span class="o">&lt;:</span><span class="n">Real</span><span class="p">}(</span><span class="n">x</span><span class="p">::</span><span class="n">T</span><span class="p">,</span> <span class="n">y</span><span class="p">::</span><span class="n">T</span><span class="p">)</span> <span class="o">=</span> <span class="n">Point</span><span class="p">{</span><span class="n">T</span><span class="p">}(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<p>Some features of parametric constructor definitions at work here deserve
comment. First, inner constructor declarations always define methods of
<code class="docutils literal"><span class="pre">Point{T}</span></code> rather than methods of the general <code class="docutils literal"><span class="pre">Point</span></code> constructor
function. Since <code class="docutils literal"><span class="pre">Point</span></code> is not a concrete type, it makes no sense for
it to even have inner constructor methods at all. Thus, the inner method
declaration <code class="docutils literal"><span class="pre">Point(x,y)</span> <span class="pre">=</span> <span class="pre">new(x,y)</span></code> provides an inner
constructor method for each value of <code class="docutils literal"><span class="pre">T</span></code>. It is this method
declaration that defines the behavior of constructor calls with explicit
type parameters like <code class="docutils literal"><span class="pre">Point{Int64}(1,2)</span></code> and
<code class="docutils literal"><span class="pre">Point{Float64}(1.0,2.0)</span></code>. The outer constructor declaration, on the
other hand, defines a method for the general <code class="docutils literal"><span class="pre">Point</span></code> constructor which
only applies to pairs of values of the same real type. This declaration
makes constructor calls without explicit type parameters, like
<code class="docutils literal"><span class="pre">Point(1,2)</span></code> and <code class="docutils literal"><span class="pre">Point(1.0,2.5)</span></code>, work. Since the method
declaration restricts the arguments to being of the same type, calls
like <code class="docutils literal"><span class="pre">Point(1,2.5)</span></code>, with arguments of different types, result in &#8220;no
method&#8221; errors.</p>
<p>Suppose we wanted to make the constructor call <code class="docutils literal"><span class="pre">Point(1,2.5)</span></code> work by
&#8220;promoting&#8221; the integer value <code class="docutils literal"><span class="pre">1</span></code> to the floating-point value <code class="docutils literal"><span class="pre">1.0</span></code>.
The simplest way to achieve this is to define the following additional
outer constructor method:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">Point</span><span class="p">(</span><span class="n">x</span><span class="p">::</span><span class="kt">Int64</span><span class="p">,</span> <span class="n">y</span><span class="p">::</span><span class="kt">Float64</span><span class="p">)</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="nb">convert</span><span class="p">(</span><span class="kt">Float64</span><span class="p">,</span><span class="n">x</span><span class="p">),</span><span class="n">y</span><span class="p">);</span>
</pre></div>
</div>
<p>This method uses the <a class="reference internal" href="../../stdlib/base/#Base.convert" title="Base.convert"><code class="xref jl jl-func docutils literal"><span class="pre">convert()</span></code></a> function to explicitly convert <code class="docutils literal"><span class="pre">x</span></code> to
<a class="reference internal" href="../../stdlib/numbers/#Base.Float64" title="Base.Float64"><code class="xref jl jl-class docutils literal"><span class="pre">Float64</span></code></a> and then delegates construction to the general constructor
for the case where both arguments are <a class="reference internal" href="../../stdlib/numbers/#Base.Float64" title="Base.Float64"><code class="xref jl jl-class docutils literal"><span class="pre">Float64</span></code></a>. With this method
definition what was previously a <a class="reference internal" href="../../stdlib/base/#Base.MethodError" title="Base.MethodError"><code class="xref jl jl-exc docutils literal"><span class="pre">MethodError</span></code></a> now successfully
creates a point of type <code class="docutils literal"><span class="pre">Point{Float64}</span></code>:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">Point</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mf">2.5</span><span class="p">)</span>
<span class="n">Point</span><span class="p">{</span><span class="kt">Float64</span><span class="p">}(</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">2.5</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nb">typeof</span><span class="p">(</span><span class="n">ans</span><span class="p">)</span>
<span class="n">Point</span><span class="p">{</span><span class="kt">Float64</span><span class="p">}</span>
</pre></div>
</div>
<p>However, other similar calls still don&#8217;t work:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">Point</span><span class="p">(</span><span class="mf">1.5</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">ERROR</span><span class="p">:</span> <span class="n">MethodError</span><span class="p">:</span> <span class="sb">`convert`</span> <span class="n">has</span> <span class="n">no</span> <span class="n">method</span> <span class="n">matching</span> <span class="nb">convert</span><span class="p">(::</span><span class="n">Type</span><span class="p">{</span><span class="n">Point</span><span class="p">{</span><span class="n">T</span><span class="o">&lt;:</span><span class="n">Real</span><span class="p">}},</span> <span class="p">::</span><span class="kt">Float64</span><span class="p">,</span> <span class="p">::</span><span class="kt">Int64</span><span class="p">)</span>
<span class="n">This</span> <span class="n">may</span> <span class="n">have</span> <span class="n">arisen</span> <span class="n">from</span> <span class="n">a</span> <span class="n">call</span> <span class="n">to</span> <span class="n">the</span> <span class="n">constructor</span> <span class="n">Point</span><span class="p">{</span><span class="n">T</span><span class="o">&lt;:</span><span class="n">Real</span><span class="p">}(</span><span class="o">...</span><span class="p">),</span>
<span class="n">since</span> <span class="k">type</span><span class="nc"> constructors</span> <span class="n">fall</span> <span class="n">back</span> <span class="n">to</span> <span class="nb">convert</span> <span class="n">methods</span><span class="o">.</span>
<span class="n">Closest</span> <span class="n">candidates</span> <span class="n">are</span><span class="p">:</span>
  <span class="n">Point</span><span class="p">{</span><span class="n">T</span><span class="o">&lt;:</span><span class="n">Real</span><span class="p">}(::</span><span class="n">T</span><span class="o">&lt;:</span><span class="n">Real</span><span class="p">,</span> <span class="o">!</span><span class="n">Matched</span><span class="p">::</span><span class="n">T</span><span class="o">&lt;:</span><span class="n">Real</span><span class="p">)</span>
  <span class="n">call</span><span class="p">{</span><span class="n">T</span><span class="p">}(::</span><span class="n">Type</span><span class="p">{</span><span class="n">T</span><span class="p">},</span> <span class="p">::</span><span class="kt">Any</span><span class="p">)</span>
  <span class="nb">convert</span><span class="p">{</span><span class="n">T</span><span class="p">}(::</span><span class="n">Type</span><span class="p">{</span><span class="n">T</span><span class="p">},</span> <span class="o">!</span><span class="n">Matched</span><span class="p">::</span><span class="n">T</span><span class="p">)</span>
  <span class="o">...</span>
 <span class="k">in</span> <span class="n">call</span> <span class="n">at</span> <span class="n">essentials</span><span class="o">.</span><span class="n">jl</span><span class="p">:</span><span class="mi">57</span>
</pre></div>
</div>
<p>For a much more general way of making all such calls work sensibly, see
<a class="reference internal" href="../conversion-and-promotion/#man-conversion-and-promotion"><span class="std std-ref">Conversion and Promotion</span></a>. At the risk
of spoiling the suspense, we can reveal here that all it takes is
the following outer method definition to make all calls to the general
<code class="docutils literal"><span class="pre">Point</span></code> constructor work as one would expect:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">Point</span><span class="p">(</span><span class="n">x</span><span class="p">::</span><span class="n">Real</span><span class="p">,</span> <span class="n">y</span><span class="p">::</span><span class="n">Real</span><span class="p">)</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="nb">promote</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span class="o">...</span><span class="p">);</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">promote</span></code> function converts all its arguments to a common type
— in this case <a class="reference internal" href="../../stdlib/numbers/#Base.Float64" title="Base.Float64"><code class="xref jl jl-class docutils literal"><span class="pre">Float64</span></code></a>. With this method definition, the <code class="docutils literal"><span class="pre">Point</span></code>
constructor promotes its arguments the same way that numeric operators
like <a class="reference internal" href="../../stdlib/math/#Base.+" title="Base.+"><code class="xref jl jl-obj docutils literal"><span class="pre">+</span></code></a> do, and works for all kinds of real numbers:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">Point</span><span class="p">(</span><span class="mf">1.5</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">Point</span><span class="p">{</span><span class="kt">Float64</span><span class="p">}(</span><span class="mf">1.5</span><span class="p">,</span><span class="mf">2.0</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">Point</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="o">//</span><span class="mi">2</span><span class="p">)</span>
<span class="n">Point</span><span class="p">{</span><span class="n">Rational</span><span class="p">{</span><span class="kt">Int64</span><span class="p">}}(</span><span class="mi">1</span><span class="o">//</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="o">//</span><span class="mi">2</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">Point</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span><span class="mi">1</span><span class="o">//</span><span class="mi">2</span><span class="p">)</span>
<span class="n">Point</span><span class="p">{</span><span class="kt">Float64</span><span class="p">}(</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">0.5</span><span class="p">)</span>
</pre></div>
</div>
<p>Thus, while the implicit type parameter constructors provided by default
in Julia are fairly strict, it is possible to make them behave in a more
relaxed but sensible manner quite easily. Moreover, since constructors
can leverage all of the power of the type system, methods, and multiple
dispatch, defining sophisticated behavior is typically quite simple.</p>
</div>
<div class="section" id="case-study-rational">
<h2>Case Study: Rational<a class="headerlink" href="#case-study-rational" title="Permalink to this headline">¶</a></h2>
<p>Perhaps the best way to tie all these pieces together is to present a
real world example of a parametric composite type and its constructor
methods. To that end, here is beginning of
<a class="reference external" href="https://github.com/JuliaLang/julia/blob/master/base/rational.jl">rational.jl</a>,
which implements Julia&#8217;s <a class="reference internal" href="../complex-and-rational-numbers/#man-rational-numbers"><span class="std std-ref">Rational Numbers</span></a>:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="k">immutable</span> <span class="n">Rational</span><span class="p">{</span><span class="n">T</span><span class="o">&lt;:</span><span class="n">Integer</span><span class="p">}</span> <span class="o">&lt;:</span> <span class="n">Real</span>
    <span class="n">num</span><span class="p">::</span><span class="n">T</span>
    <span class="n">den</span><span class="p">::</span><span class="n">T</span>

    <span class="k">function</span><span class="nf"> Rational</span><span class="p">(</span><span class="n">num</span><span class="p">::</span><span class="n">T</span><span class="p">,</span> <span class="n">den</span><span class="p">::</span><span class="n">T</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">num</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">den</span> <span class="o">==</span> <span class="mi">0</span>
            <span class="nb">error</span><span class="p">(</span><span class="s">&quot;invalid rational: 0//0&quot;</span><span class="p">)</span>
        <span class="k">end</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">gcd</span><span class="p">(</span><span class="n">den</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span>
        <span class="n">num</span> <span class="o">=</span> <span class="n">div</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span>
        <span class="n">den</span> <span class="o">=</span> <span class="n">div</span><span class="p">(</span><span class="n">den</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span>
        <span class="nb">new</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">den</span><span class="p">)</span>
    <span class="k">end</span>
<span class="k">end</span>
<span class="n">Rational</span><span class="p">{</span><span class="n">T</span><span class="o">&lt;:</span><span class="n">Integer</span><span class="p">}(</span><span class="n">n</span><span class="p">::</span><span class="n">T</span><span class="p">,</span> <span class="n">d</span><span class="p">::</span><span class="n">T</span><span class="p">)</span> <span class="o">=</span> <span class="n">Rational</span><span class="p">{</span><span class="n">T</span><span class="p">}(</span><span class="n">n</span><span class="p">,</span><span class="n">d</span><span class="p">)</span>
<span class="n">Rational</span><span class="p">(</span><span class="n">n</span><span class="p">::</span><span class="n">Integer</span><span class="p">,</span> <span class="n">d</span><span class="p">::</span><span class="n">Integer</span><span class="p">)</span> <span class="o">=</span> <span class="n">Rational</span><span class="p">(</span><span class="nb">promote</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">d</span><span class="p">)</span><span class="o">...</span><span class="p">)</span>
<span class="n">Rational</span><span class="p">(</span><span class="n">n</span><span class="p">::</span><span class="n">Integer</span><span class="p">)</span> <span class="o">=</span> <span class="n">Rational</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">one</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>

<span class="o">//</span><span class="p">(</span><span class="n">n</span><span class="p">::</span><span class="n">Integer</span><span class="p">,</span> <span class="n">d</span><span class="p">::</span><span class="n">Integer</span><span class="p">)</span> <span class="o">=</span> <span class="n">Rational</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">d</span><span class="p">)</span>
<span class="o">//</span><span class="p">(</span><span class="n">x</span><span class="p">::</span><span class="n">Rational</span><span class="p">,</span> <span class="n">y</span><span class="p">::</span><span class="n">Integer</span><span class="p">)</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">num</span> <span class="o">//</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">den</span><span class="o">*</span><span class="n">y</span><span class="p">)</span>
<span class="o">//</span><span class="p">(</span><span class="n">x</span><span class="p">::</span><span class="n">Integer</span><span class="p">,</span> <span class="n">y</span><span class="p">::</span><span class="n">Rational</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="o">.</span><span class="n">den</span><span class="p">)</span> <span class="o">//</span> <span class="n">y</span><span class="o">.</span><span class="n">num</span>
<span class="o">//</span><span class="p">(</span><span class="n">x</span><span class="p">::</span><span class="n">Complex</span><span class="p">,</span> <span class="n">y</span><span class="p">::</span><span class="n">Real</span><span class="p">)</span> <span class="o">=</span> <span class="n">complex</span><span class="p">(</span><span class="n">real</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">//</span><span class="n">y</span><span class="p">,</span> <span class="n">imag</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">//</span><span class="n">y</span><span class="p">)</span>
<span class="o">//</span><span class="p">(</span><span class="n">x</span><span class="p">::</span><span class="n">Real</span><span class="p">,</span> <span class="n">y</span><span class="p">::</span><span class="n">Complex</span><span class="p">)</span> <span class="o">=</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="o">&#39;//</span><span class="n">real</span><span class="p">(</span><span class="n">y</span><span class="o">*</span><span class="n">y</span><span class="o">&#39;</span><span class="p">)</span>

<span class="k">function</span><span class="nf"> </span><span class="o">//</span><span class="p">(</span><span class="n">x</span><span class="p">::</span><span class="n">Complex</span><span class="p">,</span> <span class="n">y</span><span class="p">::</span><span class="n">Complex</span><span class="p">)</span>
    <span class="n">xy</span> <span class="o">=</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="o">&#39;</span>
    <span class="n">yy</span> <span class="o">=</span> <span class="n">real</span><span class="p">(</span><span class="n">y</span><span class="o">*</span><span class="n">y</span><span class="o">&#39;</span><span class="p">)</span>
    <span class="n">complex</span><span class="p">(</span><span class="n">real</span><span class="p">(</span><span class="n">xy</span><span class="p">)</span><span class="o">//</span><span class="n">yy</span><span class="p">,</span> <span class="n">imag</span><span class="p">(</span><span class="n">xy</span><span class="p">)</span><span class="o">//</span><span class="n">yy</span><span class="p">)</span>
<span class="k">end</span>
</pre></div>
</div>
<p>The first line — <code class="docutils literal"><span class="pre">immutable</span> <span class="pre">Rational{T&lt;:Int}</span> <span class="pre">&lt;:</span> <span class="pre">Real</span></code> — declares that
<code class="xref jl jl-class docutils literal"><span class="pre">Rational</span></code> takes one type parameter of an integer type, and is itself
a real type. The field declarations <code class="docutils literal"><span class="pre">num::T</span></code> and <code class="docutils literal"><span class="pre">den::T</span></code> indicate
that the data held in a <code class="docutils literal"><span class="pre">Rational{T}</span></code> object are a pair of integers of
type <code class="docutils literal"><span class="pre">T</span></code>, one representing the rational value&#8217;s numerator and the
other representing its denominator.</p>
<p>Now things get interesting. <code class="xref jl jl-class docutils literal"><span class="pre">Rational</span></code> has a single inner constructor
method which checks that both of <code class="docutils literal"><span class="pre">num</span></code> and <code class="docutils literal"><span class="pre">den</span></code> aren&#8217;t zero and
ensures that every rational is constructed in &#8220;lowest terms&#8221; with a
non-negative denominator. This is accomplished by dividing the given
numerator and denominator values by their greatest common divisor,
computed using the <code class="docutils literal"><span class="pre">gcd</span></code> function. Since <code class="docutils literal"><span class="pre">gcd</span></code> returns the greatest
common divisor of its arguments with sign matching the first argument
(<code class="docutils literal"><span class="pre">den</span></code> here), after this division the new value of <code class="docutils literal"><span class="pre">den</span></code> is
guaranteed to be non-negative. Because this is the only inner
constructor for <code class="xref jl jl-class docutils literal"><span class="pre">Rational</span></code>, we can be certain that <code class="xref jl jl-class docutils literal"><span class="pre">Rational</span></code>
objects are always constructed in this normalized form.</p>
<p><code class="xref jl jl-class docutils literal"><span class="pre">Rational</span></code> also provides several outer constructor methods for
convenience. The first is the &#8220;standard&#8221; general constructor that infers
the type parameter <code class="docutils literal"><span class="pre">T</span></code> from the type of the numerator and denominator
when they have the same type. The second applies when the given
numerator and denominator values have different types: it promotes them
to a common type and then delegates construction to the outer
constructor for arguments of matching type. The third outer constructor
turns integer values into rationals by supplying a value of <code class="docutils literal"><span class="pre">1</span></code> as the
denominator.</p>
<p>Following the outer constructor definitions, we have a number of methods
for the <a class="reference internal" href="../../stdlib/math/#Base.//" title="Base.//"><code class="xref jl jl-obj docutils literal"><span class="pre">//</span></code></a> operator, which provides a syntax for writing rationals.
Before these definitions, <a class="reference internal" href="../../stdlib/math/#Base.//" title="Base.//"><code class="xref jl jl-obj docutils literal"><span class="pre">//</span></code></a> is a completely undefined operator with
only syntax and no meaning. Afterwards, it behaves just as described in
<a class="reference internal" href="../complex-and-rational-numbers/#man-rational-numbers"><span class="std std-ref">Rational Numbers</span></a>
— its entire behavior is defined in these few lines. The first and most
basic definition just makes <code class="docutils literal"><span class="pre">a//b</span></code> construct a <code class="xref jl jl-class docutils literal"><span class="pre">Rational</span></code> by
applying the <code class="xref jl jl-class docutils literal"><span class="pre">Rational</span></code> constructor to <code class="docutils literal"><span class="pre">a</span></code> and <code class="docutils literal"><span class="pre">b</span></code> when they are
integers. When one of the operands of <a class="reference internal" href="../../stdlib/math/#Base.//" title="Base.//"><code class="xref jl jl-obj docutils literal"><span class="pre">//</span></code></a> is already a rational
number, we construct a new rational for the resulting ratio slightly
differently; this behavior is actually identical to division of a
rational with an integer. Finally, applying <a class="reference internal" href="../../stdlib/math/#Base.//" title="Base.//"><code class="xref jl jl-obj docutils literal"><span class="pre">//</span></code></a> to complex integral
values creates an instance of <code class="docutils literal"><span class="pre">Complex{Rational}</span></code> — a complex number
whose real and imaginary parts are rationals:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="nb">im</span><span class="p">)</span><span class="o">//</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">2</span><span class="nb">im</span><span class="p">)</span>
<span class="o">-</span><span class="mi">3</span><span class="o">//</span><span class="mi">5</span> <span class="o">+</span> <span class="mi">4</span><span class="o">//</span><span class="mi">5</span><span class="o">*</span><span class="nb">im</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nb">typeof</span><span class="p">(</span><span class="n">ans</span><span class="p">)</span>
<span class="n">Complex</span><span class="p">{</span><span class="n">Rational</span><span class="p">{</span><span class="kt">Int64</span><span class="p">}}</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">ans</span> <span class="o">&lt;:</span> <span class="n">Complex</span><span class="p">{</span><span class="n">Rational</span><span class="p">}</span>
<span class="n">false</span>
</pre></div>
</div>
<p>Thus, although the <a class="reference internal" href="../../stdlib/math/#Base.//" title="Base.//"><code class="xref jl jl-obj docutils literal"><span class="pre">//</span></code></a> operator usually returns an instance of
<code class="xref jl jl-class docutils literal"><span class="pre">Rational</span></code>, if either of its arguments are complex integers, it will
return an instance of <code class="docutils literal"><span class="pre">Complex{Rational}</span></code> instead. The interested
reader should consider perusing the rest of
<a class="reference external" href="https://github.com/JuliaLang/julia/blob/master/base/rational.jl">rational.jl</a>:
it is short, self-contained, and implements an entire basic Julia type.</p>
</div>
<div class="section" id="constructors-call-and-conversion">
<span id="id4"></span><h2>Constructors, Call, and Conversion<a class="headerlink" href="#constructors-call-and-conversion" title="Permalink to this headline">¶</a></h2>
<p>Technically, constructors <code class="docutils literal"><span class="pre">T(args...)</span></code> in Julia are implemented by
defining new methods <code class="docutils literal"><span class="pre">Base.call(::Type{T},</span> <span class="pre">args...)</span></code> for the
<a class="reference internal" href="../../stdlib/base/#Base.call" title="Base.call"><code class="xref jl jl-func docutils literal"><span class="pre">call()</span></code></a> function.  That is, Julia types are not functions, but
they can be called as if they were functions (functors) via
call overloading, just like any other Julia object.  This also means
that you can declare more flexible constructors, e.g. constructors for
abstract types, by instead explicitly defining <code class="docutils literal"><span class="pre">Base.call</span></code> methods
using <code class="docutils literal"><span class="pre">function</span></code> syntax.</p>
<p>However, in some cases you could consider adding methods to
<code class="docutils literal"><span class="pre">Base.convert</span></code> <em>instead</em> of defining a constructor, because defining
a <a class="reference internal" href="../../stdlib/base/#Base.convert" title="Base.convert"><code class="xref jl jl-func docutils literal"><span class="pre">convert()</span></code></a> method <em>automatically</em> defines a corresponding
constructor, while the reverse is not true.  That is, defining
<code class="docutils literal"><span class="pre">Base.convert(::Type{T},</span> <span class="pre">args...)</span> <span class="pre">=</span> <span class="pre">...</span></code> automatically defines a
constructor <code class="docutils literal"><span class="pre">T(args...)</span> <span class="pre">=</span> <span class="pre">...</span></code>.</p>
<p><code class="docutils literal"><span class="pre">convert</span></code> is used extensively throughout Julia whenever one type
needs to be converted to another (e.g. in assignment, <code class="docutils literal"><span class="pre">ccall</span></code>,
etcetera), and should generally only be defined (or successful) if the
conversion is lossless.  For example, <code class="docutils literal"><span class="pre">convert(Int,</span> <span class="pre">3.0)</span></code> produces
<code class="docutils literal"><span class="pre">3</span></code>, but <code class="docutils literal"><span class="pre">convert(Int,</span> <span class="pre">3.2)</span></code> throws an <code class="docutils literal"><span class="pre">InexactError</span></code>.  If you
want to define a constructor for a lossless conversion from one type
to another, you should probably define a <code class="docutils literal"><span class="pre">convert</span></code> method instead.</p>
<p>On the other hand, if your constructor does not represent a lossless
conversion, or doesn&#8217;t represent &#8220;conversion&#8221; at all, it is better
to leave it as a constructor rather than a <code class="docutils literal"><span class="pre">convert</span></code> method.  For
example, the <code class="docutils literal"><span class="pre">Array(Int)</span></code> constructor creates a zero-dimensional
<code class="docutils literal"><span class="pre">Array</span></code> of the type <code class="docutils literal"><span class="pre">Int</span></code>, but is not really a &#8220;conversion&#8221; from
<code class="docutils literal"><span class="pre">Int</span></code> to an <code class="docutils literal"><span class="pre">Array</span></code>.</p>
</div>
<div class="section" id="outer-only-constructors">
<h2>Outer-only constructors<a class="headerlink" href="#outer-only-constructors" title="Permalink to this headline">¶</a></h2>
<p>As we have seen, a typical parametric type has inner constructors
that are called when type parameters are known; e.g. they apply
to <code class="docutils literal"><span class="pre">Point{Int}</span></code> but not to <code class="docutils literal"><span class="pre">Point</span></code>.
Optionally, outer constructors that determine type parameters
automatically can be added, for example constructing a
<code class="docutils literal"><span class="pre">Point{Int}</span></code> from the call <code class="docutils literal"><span class="pre">Point(1,2)</span></code>.
Outer constructors call inner constructors to do the core
work of making an instance.
However, in some cases one would rather not provide inner constructors,
so that specific type parameters cannot be requested manually.</p>
<p>For example, say we define a type that stores a vector along with
an accurate representation of its sum:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="k">type</span><span class="nc"> SummedArray</span><span class="p">{</span><span class="n">T</span><span class="o">&lt;:</span><span class="n">Number</span><span class="p">,</span><span class="n">S</span><span class="o">&lt;:</span><span class="n">Number</span><span class="p">}</span>
    <span class="n">data</span><span class="p">::</span><span class="n">Vector</span><span class="p">{</span><span class="n">T</span><span class="p">}</span>
    <span class="n">sum</span><span class="p">::</span><span class="n">S</span>
<span class="k">end</span>
</pre></div>
</div>
<p>The problem is that we want <code class="docutils literal"><span class="pre">S</span></code> to be a larger type than <code class="docutils literal"><span class="pre">T</span></code>, so
that we can sum many elements with less information loss.
For example, when <code class="docutils literal"><span class="pre">T</span></code> is <code class="docutils literal"><span class="pre">Int32</span></code>, we would like <code class="docutils literal"><span class="pre">S</span></code> to be <code class="docutils literal"><span class="pre">Int64</span></code>.
Therefore we want to avoid an interface that allows the user to construct
instances of the type <code class="docutils literal"><span class="pre">SummedArray{Int32,Int32}</span></code>.
One way to do this is to provide only an outer constructor for <code class="docutils literal"><span class="pre">SummedArray</span></code>.
This can be done using explicit <code class="docutils literal"><span class="pre">call</span></code> overloading:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="k">type</span><span class="nc"> SummedArray</span><span class="p">{</span><span class="n">T</span><span class="o">&lt;:</span><span class="n">Number</span><span class="p">,</span><span class="n">S</span><span class="o">&lt;:</span><span class="n">Number</span><span class="p">}</span>
    <span class="n">data</span><span class="p">::</span><span class="n">Vector</span><span class="p">{</span><span class="n">T</span><span class="p">}</span>
    <span class="n">sum</span><span class="p">::</span><span class="n">S</span>

    <span class="k">function</span><span class="nf"> call</span><span class="p">{</span><span class="n">T</span><span class="p">}(::</span><span class="n">Type</span><span class="p">{</span><span class="n">SummedArray</span><span class="p">},</span> <span class="n">a</span><span class="p">::</span><span class="n">Vector</span><span class="p">{</span><span class="n">T</span><span class="p">})</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">widen</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
        <span class="nb">new</span><span class="p">{</span><span class="n">T</span><span class="p">,</span><span class="n">S</span><span class="p">}(</span><span class="n">a</span><span class="p">,</span> <span class="n">sum</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">a</span><span class="p">))</span>
    <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
<p>This constructor will be invoked by the syntax <code class="docutils literal"><span class="pre">SummedArray(a)</span></code>.
The syntax <code class="docutils literal"><span class="pre">new{T,S}</span></code> allows specifying parameters for the type to be
constructed, i.e. this call will return a <code class="docutils literal"><span class="pre">SummedArray{T,S}</span></code>.</p>
</div>
</div>


          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../conversion-and-promotion/" class="btn btn-neutral float-right" title="Conversion and Promotion">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../methods/" class="btn btn-neutral" title="Methods"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
    </p>
  </div>

  <a href="https://github.com/snide/sphinx_rtd_theme">Sphinx theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>
</footer>
        </div>
      </div>

    </section>

  </div>
  

  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'0.4.8-pre',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>