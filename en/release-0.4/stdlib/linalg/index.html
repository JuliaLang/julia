

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Linear Algebra &mdash; Julia Language 0.4.8-pre documentation</title>
  

  
  

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/julia.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../../_static/julia.css" type="text/css" />
  
    <link rel="top" title="Julia Language 0.4.8-pre documentation" href="../../"/>
        <link rel="next" title="Constants" href="../constants/"/>
        <link rel="prev" title="Tasks and Parallel Computing" href="../parallel/"/> 

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div style="text-align:center; background-color:pink; padding:5px 0; font-size:14px; height:30px;">
    This is document is for an old version of Julia.
    Please checkout the
    <a href="https://docs.julialang.org/en/stable/"
       style="color: #2980B9;">
      current stable release
    </a>.
  </div>

  <div class="wy-grid-for-nav" style="top: 30px;">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        <a href="http://julialang.org/"><img src="../../_static/julia-logo.svg" class="logo"></a>
        <!--
        <a href="../../" class="fa fa-home"> Julia Language</a>
        -->
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search/" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
        
            <ul>
<li class="toctree-l1"><a class="reference internal" href="../../manual/introduction/">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/getting-started/">Getting Started</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/getting-started/#resources">Resources</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/variables/">Variables</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/variables/#allowed-variable-names">Allowed Variable Names</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/variables/#stylistic-conventions">Stylistic Conventions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/integers-and-floating-point-numbers/">Integers and Floating-Point Numbers</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/integers-and-floating-point-numbers/#integers">Integers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/integers-and-floating-point-numbers/#floating-point-numbers">Floating-Point Numbers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/integers-and-floating-point-numbers/#arbitrary-precision-arithmetic">Arbitrary Precision Arithmetic</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/integers-and-floating-point-numbers/#numeric-literal-coefficients">Numeric Literal Coefficients</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/integers-and-floating-point-numbers/#literal-zero-and-one">Literal zero and one</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/mathematical-operations/">Mathematical Operations and Elementary Functions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/mathematical-operations/#arithmetic-operators">Arithmetic Operators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/mathematical-operations/#bitwise-operators">Bitwise Operators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/mathematical-operations/#updating-operators">Updating operators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/mathematical-operations/#numeric-comparisons">Numeric Comparisons</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/mathematical-operations/#numerical-conversions">Numerical Conversions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/complex-and-rational-numbers/">Complex and Rational Numbers</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/complex-and-rational-numbers/#complex-numbers">Complex Numbers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/complex-and-rational-numbers/#rational-numbers">Rational Numbers</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/strings/">Strings</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/strings/#characters">Characters</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/strings/#string-basics">String Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/strings/#unicode-and-utf-8">Unicode and UTF-8</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/strings/#interpolation">Interpolation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/strings/#triple-quoted-string-literals">Triple-Quoted String Literals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/strings/#common-operations">Common Operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/strings/#non-standard-string-literals">Non-Standard String Literals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/strings/#regular-expressions">Regular Expressions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/strings/#id3">Byte Array Literals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/strings/#version-number-literals">Version Number Literals</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/functions/">Functions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/functions/#argument-passing-behavior">Argument Passing Behavior</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/functions/#the-return-keyword">The <code class="docutils literal"><span class="pre">return</span></code> Keyword</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/functions/#operators-are-functions">Operators Are Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/functions/#operators-with-special-names">Operators With Special Names</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/functions/#anonymous-functions">Anonymous Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/functions/#multiple-return-values">Multiple Return Values</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/functions/#varargs-functions">Varargs Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/functions/#optional-arguments">Optional Arguments</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/functions/#keyword-arguments">Keyword Arguments</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/functions/#evaluation-scope-of-default-values">Evaluation Scope of Default Values</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/functions/#do-block-syntax-for-function-arguments">Do-Block Syntax for Function Arguments</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/functions/#further-reading">Further Reading</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/control-flow/">Control Flow</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/control-flow/#compound-expressions">Compound Expressions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/control-flow/#conditional-evaluation">Conditional Evaluation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/control-flow/#short-circuit-evaluation">Short-Circuit Evaluation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/control-flow/#repeated-evaluation-loops">Repeated Evaluation: Loops</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/control-flow/#exception-handling">Exception Handling</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/control-flow/#tasks-aka-coroutines">Tasks (aka Coroutines)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/variables-and-scoping/">Scope of Variables</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/variables-and-scoping/#global-scope">Global Scope</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/variables-and-scoping/#local-scope">Local Scope</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/variables-and-scoping/#constants">Constants</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/types/">Types</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/types/#type-declarations">Type Declarations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/types/#abstract-types">Abstract Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/types/#bits-types">Bits Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/types/#composite-types">Composite Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/types/#immutable-composite-types">Immutable Composite Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/types/#declared-types">Declared Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/types/#type-unions">Type Unions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/types/#man-parametric-types">Parametric Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/types/#type-aliases">Type Aliases</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/types/#operations-on-types">Operations on Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/types/#value-types">&#8220;Value types&#8221;</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/types/#nullable-types-representing-missing-values">Nullable Types: Representing Missing Values</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/methods/">Methods</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/methods/#defining-methods">Defining Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/methods/#method-ambiguities">Method Ambiguities</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/methods/#parametric-methods">Parametric Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/methods/#note-on-optional-and-keyword-arguments">Note on Optional and keyword Arguments</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/methods/#call-overloading-and-function-like-objects">Call overloading and function-like objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/methods/#empty-generic-functions">Empty generic functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/constructors/">Constructors</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/constructors/#outer-constructor-methods">Outer Constructor Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/constructors/#inner-constructor-methods">Inner Constructor Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/constructors/#incomplete-initialization">Incomplete Initialization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/constructors/#parametric-constructors">Parametric Constructors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/constructors/#case-study-rational">Case Study: Rational</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/constructors/#constructors-call-and-conversion">Constructors, Call, and Conversion</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/constructors/#outer-only-constructors">Outer-only constructors</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/conversion-and-promotion/">Conversion and Promotion</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/conversion-and-promotion/#conversion">Conversion</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/conversion-and-promotion/#promotion">Promotion</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/interfaces/">Interfaces</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/interfaces/#iteration">Iteration</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/interfaces/#indexing">Indexing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/interfaces/#abstract-arrays">Abstract Arrays</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/modules/">Modules</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/modules/#summary-of-module-usage">Summary of module usage</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/documentation/">Documentation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/documentation/#accessing-documentation">Accessing Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/documentation/#functions-methods">Functions &amp; Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/documentation/#advanced-usage">Advanced Usage</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/documentation/#syntax-guide">Syntax Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/documentation/#markdown-syntax-notes">Markdown Syntax Notes</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/metaprogramming/">Metaprogramming</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/metaprogramming/#program-representation">Program representation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/metaprogramming/#expressions-and-evaluation">Expressions and evaluation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/metaprogramming/#macros">Macros</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/metaprogramming/#code-generation">Code Generation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/metaprogramming/#non-standard-string-literals">Non-Standard String Literals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/metaprogramming/#generated-functions">Generated functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/arrays/">Multi-dimensional Arrays</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/arrays/#arrays">Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/arrays/#sparse-matrices">Sparse Matrices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/linear-algebra/">Linear algebra</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/linear-algebra/#matrix-factorizations">Matrix factorizations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/linear-algebra/#special-matrices">Special matrices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/networking-and-streams/">Networking and Streams</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/networking-and-streams/#basic-stream-i-o">Basic Stream I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/networking-and-streams/#text-i-o">Text I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/networking-and-streams/#working-with-files">Working with Files</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/networking-and-streams/#a-simple-tcp-example">A simple TCP example</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/networking-and-streams/#resolving-ip-addresses">Resolving IP Addresses</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/parallel-computing/">Parallel Computing</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/parallel-computing/#code-availability-and-loading-packages">Code Availability and Loading Packages</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/parallel-computing/#data-movement">Data Movement</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/parallel-computing/#parallel-map-and-loops">Parallel Map and Loops</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/parallel-computing/#synchronization-with-remote-references">Synchronization With Remote References</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/parallel-computing/#scheduling">Scheduling</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/parallel-computing/#channels">Channels</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/parallel-computing/#remoterefs-and-abstractchannels">RemoteRefs and AbstractChannels</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/parallel-computing/#shared-arrays">Shared Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/parallel-computing/#distributed-garbage-collection">Distributed Garbage Collection</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/parallel-computing/#clustermanagers">ClusterManagers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/parallel-computing/#cluster-managers-with-custom-transports">Cluster Managers with custom transports</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/parallel-computing/#specifying-network-topology-experimental">Specifying network topology (Experimental)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/dates/">Date and DateTime</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/dates/#constructors">Constructors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/dates/#durations-comparisons">Durations/Comparisons</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/dates/#accessor-functions">Accessor Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/dates/#query-functions">Query Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/dates/#timetype-period-arithmetic">TimeType-Period Arithmetic</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/dates/#adjuster-functions">Adjuster Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/dates/#period-types">Period Types</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/running-external-programs/">Running External Programs</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/running-external-programs/#interpolation">Interpolation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/running-external-programs/#quoting">Quoting</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/running-external-programs/#pipelines">Pipelines</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/calling-c-and-fortran-code/">Calling C and Fortran Code</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/calling-c-and-fortran-code/#creating-c-compatible-julia-function-pointers">Creating C-Compatible Julia Function Pointers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/calling-c-and-fortran-code/#mapping-c-types-to-julia">Mapping C Types to Julia</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/calling-c-and-fortran-code/#mapping-c-functions-to-julia">Mapping C Functions to Julia</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/calling-c-and-fortran-code/#garbage-collection-safety">Garbage Collection Safety</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/calling-c-and-fortran-code/#non-constant-function-specifications">Non-constant Function Specifications</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/calling-c-and-fortran-code/#indirect-calls">Indirect Calls</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/calling-c-and-fortran-code/#calling-convention">Calling Convention</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/calling-c-and-fortran-code/#accessing-global-variables">Accessing Global Variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/calling-c-and-fortran-code/#accessing-data-through-a-pointer">Accessing Data through a Pointer</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/calling-c-and-fortran-code/#thread-safety">Thread-safety</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/calling-c-and-fortran-code/#more-about-callbacks">More About Callbacks</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/calling-c-and-fortran-code/#c">C++</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/calling-c-and-fortran-code/#handling-operating-system-variation">Handling Operating System Variation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/interacting-with-julia/">Interacting With Julia</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/interacting-with-julia/#the-different-prompt-modes">The different prompt modes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/interacting-with-julia/#key-bindings">Key bindings</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/interacting-with-julia/#tab-completion">Tab completion</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/embedding/">Embedding Julia</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/embedding/#high-level-embedding">High-Level Embedding</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/embedding/#converting-types">Converting Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/embedding/#calling-julia-functions">Calling Julia Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/embedding/#memory-management">Memory Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/embedding/#working-with-arrays">Working with Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/embedding/#exceptions">Exceptions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/packages/">Packages</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/packages/#package-status">Package Status</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/packages/#adding-and-removing-packages">Adding and Removing Packages</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/packages/#offline-installation-of-packages">Offline Installation of Packages</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/packages/#installing-unregistered-packages">Installing Unregistered Packages</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/packages/#updating-packages">Updating Packages</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/packages/#checkout-pin-and-free">Checkout, Pin and Free</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/packages/#custom-metadata-repository">Custom METADATA Repository</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/packages/#package-development">Package Development</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/packages/#initial-setup">Initial Setup</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/packages/#making-changes-to-an-existing-package">Making changes to an existing package</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/packages/#creating-a-new-package">Creating a new Package</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/packages/#fixing-package-requirements">Fixing Package Requirements</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/packages/#man-package-requirements">Requirements Specification</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/profile/">Profiling</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/profile/#basic-usage">Basic usage</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/profile/#accumulation-and-clearing">Accumulation and clearing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/profile/#options-for-controlling-the-display-of-profile-results">Options for controlling the display of profile results</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/profile/#configuration">Configuration</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/profile/#memory-allocation-analysis">Memory allocation analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/performance-tips/">Performance Tips</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#avoid-global-variables">Avoid global variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#measure-performance-with-time-and-pay-attention-to-memory-allocation">Measure performance with <code class="docutils literal"><span class="pre">&#64;time</span></code> and pay attention to memory allocation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#tools">Tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#avoid-containers-with-abstract-type-parameters">Avoid containers with abstract type parameters</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#type-declarations">Type declarations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#break-functions-into-multiple-definitions">Break functions into multiple definitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#write-type-stable-functions">Write &#8220;type-stable&#8221; functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#avoid-changing-the-type-of-a-variable">Avoid changing the type of a variable</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#separate-kernel-functions">Separate kernel functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#access-arrays-in-memory-order-along-columns">Access arrays in memory order, along columns</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#pre-allocating-outputs">Pre-allocating outputs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#avoid-string-interpolation-for-i-o">Avoid string interpolation for I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#optimize-network-i-o-during-parallel-execution">Optimize network I/O during parallel execution</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#fix-deprecation-warnings">Fix deprecation warnings</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#tweaks">Tweaks</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#performance-annotations">Performance Annotations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#treat-subnormal-numbers-as-zeros">Treat Subnormal Numbers as Zeros</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#code-warntype"><code class="docutils literal"><span class="pre">&#64;code_warntype</span></code></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/workflow-tips/">Workflow Tips</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/workflow-tips/#repl-based-workflow">REPL-based workflow</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/workflow-tips/#browser-based-workflow">Browser-based workflow</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/style-guide/">Style Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#write-functions-not-just-scripts">Write functions, not just scripts</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#avoid-writing-overly-specific-types">Avoid writing overly-specific types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#handle-excess-argument-diversity-in-the-caller">Handle excess argument diversity in the caller</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#append-to-names-of-functions-that-modify-their-arguments">Append <code class="docutils literal"><span class="pre">!</span></code> to names of functions that modify their arguments</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#avoid-strange-type-unions">Avoid strange type Unions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#avoid-type-unions-in-fields">Avoid type Unions in fields</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#avoid-elaborate-container-types">Avoid elaborate container types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#use-naming-conventions-consistent-with-julia-s-base">Use naming conventions consistent with Julia&#8217;s <code class="docutils literal"><span class="pre">base/</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#don-t-overuse-try-catch">Don&#8217;t overuse try-catch</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#don-t-parenthesize-conditions">Don&#8217;t parenthesize conditions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#don-t-overuse">Don&#8217;t overuse ...</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#don-t-use-unnecessary-static-parameters">Don&#8217;t use unnecessary static parameters</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#avoid-confusion-about-whether-something-is-an-instance-or-a-type">Avoid confusion about whether something is an instance or a type</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#don-t-overuse-macros">Don&#8217;t overuse macros</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#don-t-expose-unsafe-operations-at-the-interface-level">Don&#8217;t expose unsafe operations at the interface level</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#don-t-overload-methods-of-base-container-types">Don&#8217;t overload methods of base container types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#be-careful-with-type-equality">Be careful with type equality</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#do-not-write-x-f-x">Do not write <code class="docutils literal"><span class="pre">x-&gt;f(x)</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#avoid-using-floats-for-numeric-literals-in-generic-code-when-possible">Avoid using floats for numeric literals in generic code when possible</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/faq/">Frequently Asked Questions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/faq/#sessions-and-the-repl">Sessions and the REPL</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/faq/#functions">Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/faq/#types-type-declarations-and-constructors">Types, type declarations, and constructors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/faq/#packages-and-modules">Packages and Modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/faq/#nothingness-and-missing-values">Nothingness and missing values</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/faq/#memory">Memory</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/faq/#asynchronous-io-and-concurrent-synchronous-writes">Asynchronous IO and concurrent synchronous writes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/faq/#julia-releases">Julia Releases</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/noteworthy-differences/">Noteworthy Differences from other Languages</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/noteworthy-differences/#noteworthy-differences-from-matlab">Noteworthy differences from MATLAB</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/noteworthy-differences/#noteworthy-differences-from-r">Noteworthy differences from R</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/noteworthy-differences/#noteworthy-differences-from-python">Noteworthy differences from Python</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/noteworthy-differences/#noteworthy-differences-from-c-c">Noteworthy differences from C/C++</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/unicode-input/">Unicode Input</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../base/">Essentials</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../base/#introduction">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../base/#getting-around">Getting Around</a></li>
<li class="toctree-l2"><a class="reference internal" href="../base/#all-objects">All Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="../base/#types">Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../base/#generic-functions">Generic Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../base/#syntax">Syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="../base/#nullables">Nullables</a></li>
<li class="toctree-l2"><a class="reference internal" href="../base/#system">System</a></li>
<li class="toctree-l2"><a class="reference internal" href="../base/#errors">Errors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../base/#events">Events</a></li>
<li class="toctree-l2"><a class="reference internal" href="../base/#reflection">Reflection</a></li>
<li class="toctree-l2"><a class="reference internal" href="../base/#internals">Internals</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../collections/">Collections and Data Structures</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../collections/#iteration">Iteration</a></li>
<li class="toctree-l2"><a class="reference internal" href="../collections/#general-collections">General Collections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../collections/#iterable-collections">Iterable Collections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../collections/#indexable-collections">Indexable Collections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../collections/#associative-collections">Associative Collections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../collections/#set-like-collections">Set-Like Collections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../collections/#dequeues">Dequeues</a></li>
<li class="toctree-l2"><a class="reference internal" href="../collections/#priorityqueue">PriorityQueue</a></li>
<li class="toctree-l2"><a class="reference internal" href="../collections/#heap-functions">Heap Functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../math/">Mathematics</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../math/#mathematical-operators">Mathematical Operators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../math/#mathematical-functions">Mathematical Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../math/#statistics">Statistics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../math/#signal-processing">Signal Processing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../math/#numerical-integration">Numerical Integration</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../numbers/">Numbers</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../numbers/#standard-numeric-types">Standard Numeric Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../numbers/#data-formats">Data Formats</a></li>
<li class="toctree-l2"><a class="reference internal" href="../numbers/#general-number-functions-and-constants">General Number Functions and Constants</a></li>
<li class="toctree-l2"><a class="reference internal" href="../numbers/#bigfloats">BigFloats</a></li>
<li class="toctree-l2"><a class="reference internal" href="../numbers/#random-numbers">Random Numbers</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../strings/">Strings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../arrays/">Arrays</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../arrays/#basic-functions">Basic functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../arrays/#constructors">Constructors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../arrays/#mathematical-operators-and-functions">Mathematical operators and functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../arrays/#indexing-assignment-and-concatenation">Indexing, Assignment, and Concatenation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../arrays/#array-functions">Array functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../arrays/#combinatorics">Combinatorics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../arrays/#bitarrays">BitArrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="../arrays/#sparse-matrices">Sparse Matrices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../parallel/">Tasks and Parallel Computing</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../parallel/#tasks">Tasks</a></li>
<li class="toctree-l2"><a class="reference internal" href="../parallel/#general-parallel-computing-support">General Parallel Computing Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../parallel/#shared-arrays">Shared Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="../parallel/#cluster-manager-interface">Cluster Manager Interface</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Linear Algebra</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#module-Base.LinAlg">Standard Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-Base.LinAlg.BLAS">BLAS Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-Base.LinAlg.LAPACK">LAPACK Functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../constants/">Constants</a></li>
<li class="toctree-l1"><a class="reference internal" href="../file/">Filesystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../io-network/">I/O and Network</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../io-network/#general-i-o">General I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../io-network/#text-i-o">Text I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../io-network/#multimedia-i-o">Multimedia I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../io-network/#memory-mapped-i-o">Memory-mapped I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../io-network/#network-i-o">Network I/O</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../punctuation/">Punctuation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sort/">Sorting and Related Functions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../sort/#sorting-functions">Sorting Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sort/#order-related-functions">Order-Related Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sort/#sorting-algorithms">Sorting Algorithms</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../pkg/">Package Manager Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dates/">Dates and Time</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../dates/#dates-and-time-types">Dates and Time Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dates/#dates-functions">Dates Functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../test/">Unit and Functional Testing</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../test/#testing-base-julia">Testing Base Julia</a></li>
<li class="toctree-l2"><a class="reference internal" href="../test/#test-framework">Test Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="../test/#handlers">Handlers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../test/#macros">Macros</a></li>
<li class="toctree-l2"><a class="reference internal" href="../test/#functions">Functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../c/">C Interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../c/#llvm-interface">LLVM Interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../libc/">C Standard Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="../libdl/">Dynamic Linker</a></li>
<li class="toctree-l1"><a class="reference internal" href="../profile/">Profiling</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../devdocs/reflection/">Reflection and introspection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../devdocs/julia/">Documentation of Julia&#8217;s Internals</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/init/">Initialization of the Julia runtime</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/eval/">Eval of Julia code</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/ast/">Julia ASTs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/types/">More about types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/object/">Memory layout of Julia Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/cartesian/">Base.Cartesian</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/meta/">Talking to the compiler (the <code class="docutils literal"><span class="pre">:meta</span></code> mechanism)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/subarrays/">SubArrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/sysimg/">System Image Building</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/llvm/">Working with LLVM</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/stdio/">printf() and stdio in the Julia runtime</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/promote-op/">Operator-sensitive promotion</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../devdocs/C/">Developing/debugging Julia&#8217;s C code</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/backtraces/">Reporting and analyzing crashes (segfaults)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/debuggingtips/">gdb debugging tips</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/valgrind/">Using Valgrind with Julia</a></li>
</ul>
</li>
</ul>

        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../">Julia Language</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../">Docs</a> &raquo;</li>
      
    <li>Linear Algebra</li>
      <li class="wy-breadcrumbs-aside">
        
          <a href="../../_sources/stdlib/linalg.txt" rel="nofollow"> View page source</a>
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document">
            
  <div class="section" id="linear-algebra">
<span id="stdlib-linalg"></span><h1>Linear Algebra<a class="headerlink" href="#linear-algebra" title="Permalink to this headline">¶</a></h1>
<div class="section" id="module-Base.LinAlg">
<span id="standard-functions"></span><h2>Standard Functions<a class="headerlink" href="#module-Base.LinAlg" title="Permalink to this headline">¶</a></h2>
<p>Linear algebra functions in Julia are largely implemented by calling functions from <a class="reference external" href="http://www.netlib.org/lapack/">LAPACK</a>.  Sparse factorizations call functions from <a class="reference external" href="http://faculty.cse.tamu.edu/davis/suitesparse.html">SuiteSparse</a>.</p>
<dl class="function">
<dt id="Base.*">
<code class="descname">*</code><span class="sig-paren">(</span><em>A</em>, <em>B</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.*" title="Permalink to this definition">¶</a></dt>
<dd><p>Matrix multiplication</p>
</dd></dl>

<dl class="function">
<dt id="Base.\">
<code class="descname">\</code><span class="sig-paren">(</span><em>A</em>, <em>B</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.\" title="Permalink to this definition">¶</a></dt>
<dd><p>Matrix division using a polyalgorithm. For input matrices <code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">B</span></code>, the result <code class="docutils literal"><span class="pre">X</span></code> is such that <code class="docutils literal"><span class="pre">A*X</span> <span class="pre">==</span> <span class="pre">B</span></code> when <code class="docutils literal"><span class="pre">A</span></code> is square.  The solver that is used depends upon the structure of <code class="docutils literal"><span class="pre">A</span></code>.  A direct solver is used for upper or lower triangular <code class="docutils literal"><span class="pre">A</span></code>.  For Hermitian <code class="docutils literal"><span class="pre">A</span></code> (equivalent to symmetric <code class="docutils literal"><span class="pre">A</span></code> for non-complex <code class="docutils literal"><span class="pre">A</span></code>) the <code class="docutils literal"><span class="pre">BunchKaufman</span></code> factorization is used.  Otherwise an LU factorization is used. For rectangular <code class="docutils literal"><span class="pre">A</span></code> the result is the minimum-norm least squares solution computed by a pivoted QR factorization of <code class="docutils literal"><span class="pre">A</span></code> and a rank estimate of <code class="docutils literal"><span class="pre">A</span></code> based on the R factor.</p>
<p>When <code class="docutils literal"><span class="pre">A</span></code> is sparse, a similar polyalgorithm is used. For indefinite matrices, the <code class="docutils literal"><span class="pre">LDLt</span></code> factorization does not use pivoting during the numerical factorization and therefore the procedure can fail even for invertible matrices.</p>
</dd></dl>

<dl class="function">
<dt id="Base.dot">
<code class="descname">dot</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.dot" title="Permalink to this definition">¶</a></dt>
<dt id="Base.⋅">
<code class="descname">⋅</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.⋅" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the dot product. For complex vectors, the first vector is conjugated.</p>
</dd></dl>

<dl class="function">
<dt id="Base.vecdot">
<code class="descname">vecdot</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.vecdot" title="Permalink to this definition">¶</a></dt>
<dd><p>For any iterable containers <code class="docutils literal"><span class="pre">x</span></code> and <code class="docutils literal"><span class="pre">y</span></code> (including arrays of any dimension) of numbers (or any element type for which <code class="docutils literal"><span class="pre">dot</span></code> is defined), compute the Euclidean dot product (the sum of <code class="docutils literal"><span class="pre">dot(x[i],y[i])</span></code>) as if they were vectors.</p>
</dd></dl>

<dl class="function">
<dt id="Base.cross">
<code class="descname">cross</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.cross" title="Permalink to this definition">¶</a></dt>
<dt id="Base.×">
<code class="descname">×</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.×" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the cross product of two 3-vectors.</p>
</dd></dl>

<dl class="function">
<dt id="Base.factorize">
<code class="descname">factorize</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.factorize" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute a convenient factorization (including LU, Cholesky, Bunch-Kaufman, LowerTriangular, UpperTriangular) of <code class="docutils literal"><span class="pre">A</span></code>, based upon the type of the input matrix. The return value can then be reused for efficient solving of multiple systems. For example: <code class="docutils literal"><span class="pre">A=factorize(A);</span> <span class="pre">x=A\b;</span> <span class="pre">y=A\C</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.full">
<code class="descname">full</code><span class="sig-paren">(</span><em>F</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.full" title="Permalink to this definition">¶</a></dt>
<dd><p>Reconstruct the matrix <code class="docutils literal"><span class="pre">A</span></code> from the factorization <code class="docutils literal"><span class="pre">F=factorize(A)</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.lu">
<code class="descname">lu</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span> &rarr; L, U, p<a class="headerlink" href="#Base.lu" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the LU factorization of <code class="docutils literal"><span class="pre">A</span></code>, such that <code class="docutils literal"><span class="pre">A[p,:]</span> <span class="pre">=</span> <span class="pre">L*U</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.lufact">
<code class="descname">lufact</code><span class="sig-paren">(</span><em>A</em><span class="optional">[</span>, <em>pivot=Val{true}</em><span class="optional">]</span><span class="sig-paren">)</span> &rarr; F<a class="headerlink" href="#Base.lufact" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the LU factorization of <code class="docutils literal"><span class="pre">A</span></code>. The return type of <code class="docutils literal"><span class="pre">F</span></code> depends on the type of <code class="docutils literal"><span class="pre">A</span></code>. In most cases, if <code class="docutils literal"><span class="pre">A</span></code> is a subtype <code class="docutils literal"><span class="pre">S</span></code> of AbstractMatrix with an element type <code class="docutils literal"><span class="pre">T</span></code> supporting <code class="docutils literal"><span class="pre">+</span></code>, <code class="docutils literal"><span class="pre">-</span></code>, <code class="docutils literal"><span class="pre">*</span></code> and <code class="docutils literal"><span class="pre">/</span></code> the return type is <code class="docutils literal"><span class="pre">LU{T,S{T}}</span></code>. If pivoting is chosen (default) the element type should also support <code class="docutils literal"><span class="pre">abs</span></code> and <code class="docutils literal"><span class="pre">&lt;</span></code>. When <code class="docutils literal"><span class="pre">A</span></code> is sparse and have element of type <code class="docutils literal"><span class="pre">Float32</span></code>, <code class="docutils literal"><span class="pre">Float64</span></code>, <code class="docutils literal"><span class="pre">Complex{Float32}</span></code>, or <code class="docutils literal"><span class="pre">Complex{Float64}</span></code> the return type is <code class="docutils literal"><span class="pre">UmfpackLU</span></code>. Some examples are shown in the table below.</p>
<table border="1" class="docutils">
<colgroup>
<col width="24%" />
<col width="27%" />
<col width="49%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Type of input <code class="docutils literal"><span class="pre">A</span></code></th>
<th class="head">Type of output <code class="docutils literal"><span class="pre">F</span></code></th>
<th class="head">Relationship between <code class="docutils literal"><span class="pre">F</span></code> and <code class="docutils literal"><span class="pre">A</span></code></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="xref jl jl-func docutils literal"><span class="pre">Matrix()</span></code></td>
<td><code class="docutils literal"><span class="pre">LU</span></code></td>
<td><code class="docutils literal"><span class="pre">F[:L]*F[:U]</span> <span class="pre">==</span> <span class="pre">A[F[:p],</span> <span class="pre">:]</span></code></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Base.Tridiagonal" title="Base.Tridiagonal"><code class="xref jl jl-func docutils literal"><span class="pre">Tridiagonal()</span></code></a></td>
<td><code class="docutils literal"><span class="pre">LU{T,Tridiagonal{T}}</span></code></td>
<td><code class="docutils literal"><span class="pre">F[:L]*F[:U]</span> <span class="pre">==</span> <span class="pre">A[F[:p],</span> <span class="pre">:]</span></code></td>
</tr>
<tr class="row-even"><td><code class="xref jl jl-func docutils literal"><span class="pre">SparseMatrixCSC()</span></code></td>
<td><code class="docutils literal"><span class="pre">UmfpackLU</span></code></td>
<td><code class="docutils literal"><span class="pre">F[:L]*F[:U]</span> <span class="pre">==</span> <span class="pre">(F[:Rs]</span> <span class="pre">.*</span> <span class="pre">A)[F[:p],</span> <span class="pre">F[:q]]</span></code></td>
</tr>
</tbody>
</table>
<p>The individual components of the factorization <code class="docutils literal"><span class="pre">F</span></code> can be accessed by indexing:</p>
<table border="1" class="docutils">
<colgroup>
<col width="12%" />
<col width="42%" />
<col width="6%" />
<col width="26%" />
<col width="14%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Component</th>
<th class="head">Description</th>
<th class="head"><code class="docutils literal"><span class="pre">LU</span></code></th>
<th class="head"><code class="docutils literal"><span class="pre">LU{T,Tridiagonal{T}}</span></code></th>
<th class="head"><code class="docutils literal"><span class="pre">UmfpackLU</span></code></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">F[:L]</span></code></td>
<td><code class="docutils literal"><span class="pre">L</span></code> (lower triangular) part of <code class="docutils literal"><span class="pre">LU</span></code></td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">F[:U]</span></code></td>
<td><code class="docutils literal"><span class="pre">U</span></code> (upper triangular) part of <code class="docutils literal"><span class="pre">LU</span></code></td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">F[:p]</span></code></td>
<td>(right) permutation <code class="docutils literal"><span class="pre">Vector</span></code></td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">F[:P]</span></code></td>
<td>(right) permutation <code class="docutils literal"><span class="pre">Matrix</span></code></td>
<td>✓</td>
<td>✓</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">F[:q]</span></code></td>
<td>left permutation <code class="docutils literal"><span class="pre">Vector</span></code></td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>✓</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">F[:Rs]</span></code></td>
<td><code class="docutils literal"><span class="pre">Vector</span></code> of scaling factors</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>✓</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">F[:(:)]</span></code></td>
<td><code class="docutils literal"><span class="pre">(L,U,p,q,Rs)</span></code> components</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>✓</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="10%" />
<col width="39%" />
<col width="21%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Supported function</th>
<th class="head"><code class="docutils literal"><span class="pre">LU</span></code></th>
<th class="head"><code class="docutils literal"><span class="pre">LU{T,Tridiagonal{T}}</span></code></th>
<th class="head"><code class="docutils literal"><span class="pre">UmfpackLU</span></code></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">/</span></code></td>
<td>✓</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">\</span></code></td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">cond</span></code></td>
<td>✓</td>
<td>&nbsp;</td>
<td>✓</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">det</span></code></td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">logdet</span></code></td>
<td>✓</td>
<td>✓</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">logabsdet</span></code></td>
<td>✓</td>
<td>✓</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">size</span></code></td>
<td>✓</td>
<td>✓</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Base.lufact!">
<code class="descname">lufact!</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span> &rarr; LU<a class="headerlink" href="#Base.lufact!" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal"><span class="pre">lufact!</span></code> is the same as <a class="reference internal" href="#Base.lufact" title="Base.lufact"><code class="xref jl jl-func docutils literal"><span class="pre">lufact()</span></code></a>, but saves space by overwriting the input <code class="docutils literal"><span class="pre">A</span></code>, instead of creating a copy.  For sparse <code class="docutils literal"><span class="pre">A</span></code> the <code class="docutils literal"><span class="pre">nzval</span></code> field is not overwritten but the index fields, <code class="docutils literal"><span class="pre">colptr</span></code> and <code class="docutils literal"><span class="pre">rowval</span></code> are decremented in place, converting from 1-based indices to 0-based indices.</p>
</dd></dl>

<dl class="function">
<dt id="Base.chol">
<code class="descname">chol</code><span class="sig-paren">(</span><em>A</em><span class="optional">[</span>, <em>LU</em><span class="optional">]</span><span class="sig-paren">)</span> &rarr; F<a class="headerlink" href="#Base.chol" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Cholesky factorization of a symmetric positive definite matrix <code class="docutils literal"><span class="pre">A</span></code> and return the matrix <code class="docutils literal"><span class="pre">F</span></code>. If <code class="docutils literal"><span class="pre">LU</span></code> is <code class="docutils literal"><span class="pre">Val{:U}</span></code> (Upper), <code class="docutils literal"><span class="pre">F</span></code> is of type <code class="docutils literal"><span class="pre">UpperTriangular</span></code> and <code class="docutils literal"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">F'*F</span></code>. If <code class="docutils literal"><span class="pre">LU</span></code> is <code class="docutils literal"><span class="pre">Val{:L}</span></code> (Lower), <code class="docutils literal"><span class="pre">F</span></code> is of type <code class="docutils literal"><span class="pre">LowerTriangular</span></code> and <code class="docutils literal"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">F*F'</span></code>. <code class="docutils literal"><span class="pre">LU</span></code> defaults to <code class="docutils literal"><span class="pre">Val{:U}</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.cholfact">
<code class="descname">cholfact</code><span class="sig-paren">(</span><em>A, [LU=:U[,pivot=Val{false}]][;tol=-1.0]</em><span class="sig-paren">)</span> &rarr; Cholesky<a class="headerlink" href="#Base.cholfact" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Cholesky factorization of a dense symmetric positive (semi)definite matrix <code class="docutils literal"><span class="pre">A</span></code> and return either a <code class="docutils literal"><span class="pre">Cholesky</span></code> if <code class="docutils literal"><span class="pre">pivot==Val{false}</span></code> or <code class="docutils literal"><span class="pre">CholeskyPivoted</span></code> if <code class="docutils literal"><span class="pre">pivot==Val{true}</span></code>. <code class="docutils literal"><span class="pre">LU</span></code> may be <code class="docutils literal"><span class="pre">:L</span></code> for using the lower part or <code class="docutils literal"><span class="pre">:U</span></code> for the upper part. The default is to use <code class="docutils literal"><span class="pre">:U</span></code>. The triangular matrix can be obtained from the factorization <code class="docutils literal"><span class="pre">F</span></code> with: <code class="docutils literal"><span class="pre">F[:L]</span></code> and <code class="docutils literal"><span class="pre">F[:U]</span></code>. The following functions are available for <code class="docutils literal"><span class="pre">Cholesky</span></code> objects: <code class="docutils literal"><span class="pre">size</span></code>, <code class="docutils literal"><span class="pre">\</span></code>, <code class="docutils literal"><span class="pre">inv</span></code>, <code class="docutils literal"><span class="pre">det</span></code>. For <code class="docutils literal"><span class="pre">CholeskyPivoted</span></code> there is also defined a <code class="docutils literal"><span class="pre">rank</span></code>. If <code class="docutils literal"><span class="pre">pivot==Val{false}</span></code> a <code class="docutils literal"><span class="pre">PosDefException</span></code> exception is thrown in case the matrix is not positive definite. The argument <code class="docutils literal"><span class="pre">tol</span></code> determines the tolerance for determining the rank. For negative values, the tolerance is the machine precision.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">cholfact</code><span class="sig-paren">(</span><em>A; shift=0</em>, <em>perm=Int[]</em><span class="sig-paren">)</span> &rarr; CHOLMOD.Factor</dt>
<dd><p>Compute the Cholesky factorization of a sparse positive definite matrix <code class="docutils literal"><span class="pre">A</span></code>. A fill-reducing permutation is used. <code class="docutils literal"><span class="pre">F</span> <span class="pre">=</span> <span class="pre">cholfact(A)</span></code> is most frequently used to solve systems of equations with <code class="docutils literal"><span class="pre">F\b</span></code>, but also the methods <code class="docutils literal"><span class="pre">diag</span></code>, <code class="docutils literal"><span class="pre">det</span></code>, <code class="docutils literal"><span class="pre">logdet</span></code> are defined for <code class="docutils literal"><span class="pre">F</span></code>. You can also extract individual factors from <code class="docutils literal"><span class="pre">F</span></code>, using <code class="docutils literal"><span class="pre">F[:L]</span></code>. However, since pivoting is on by default, the factorization is internally represented as <code class="docutils literal"><span class="pre">A</span> <span class="pre">==</span> <span class="pre">P'*L*L'*P</span></code> with a permutation matrix <code class="docutils literal"><span class="pre">P</span></code>; using just <code class="docutils literal"><span class="pre">L</span></code> without accounting for <code class="docutils literal"><span class="pre">P</span></code> will give incorrect answers. To include the effects of permutation, it&#8217;s typically preferable to extact &#8220;combined&#8221; factors like <code class="docutils literal"><span class="pre">PtL</span> <span class="pre">=</span> <span class="pre">F[:PtL]</span></code> (the equivalent of <code class="docutils literal"><span class="pre">P'*L</span></code>) and <code class="docutils literal"><span class="pre">LtP</span> <span class="pre">=</span> <span class="pre">F[:UP]</span></code> (the equivalent of <code class="docutils literal"><span class="pre">L'*P</span></code>).</p>
<p>Setting optional <code class="docutils literal"><span class="pre">shift</span></code> keyword argument computes the factorization of <code class="docutils literal"><span class="pre">A+shift*I</span></code> instead of <code class="docutils literal"><span class="pre">A</span></code>. If the <code class="docutils literal"><span class="pre">perm</span></code> argument is nonempty, it should be a permutation of <code class="docutils literal"><span class="pre">1:size(A,1)</span></code> giving the ordering to use (instead of CHOLMOD&#8217;s default AMD ordering).</p>
<p>The function calls the C library CHOLMOD and many other functions from the library are wrapped but not exported.</p>
</dd></dl>

<dl class="function">
<dt id="Base.cholfact!">
<code class="descname">cholfact!</code><span class="sig-paren">(</span><em>A [,LU=:U [,pivot=Val{false}]][;tol=-1.0]</em><span class="sig-paren">)</span> &rarr; Cholesky<a class="headerlink" href="#Base.cholfact!" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal"><span class="pre">cholfact!</span></code> is the same as <a class="reference internal" href="#Base.cholfact" title="Base.cholfact"><code class="xref jl jl-func docutils literal"><span class="pre">cholfact()</span></code></a>, but saves space by overwriting the input <code class="docutils literal"><span class="pre">A</span></code>, instead of creating a copy. <code class="docutils literal"><span class="pre">cholfact!</span></code> can also reuse the symbolic factorization from a different matrix <code class="docutils literal"><span class="pre">F</span></code> with the same structure when used as: <code class="docutils literal"><span class="pre">cholfact!(F::CholmodFactor,</span> <span class="pre">A)</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.ldltfact">
<code class="descname">ldltfact</code><span class="sig-paren">(</span><em>::SymTridiagonal</em><span class="sig-paren">)</span> &rarr; LDLt<a class="headerlink" href="#Base.ldltfact" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute an <code class="docutils literal"><span class="pre">LDLt</span></code> factorization of a real symmetric tridiagonal matrix such that <code class="docutils literal"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">L*Diagonal(d)*L'</span></code> where <code class="docutils literal"><span class="pre">L</span></code> is a unit lower triangular matrix and <code class="docutils literal"><span class="pre">d</span></code> is a vector. The main use of an <code class="docutils literal"><span class="pre">LDLt</span></code> factorization <code class="docutils literal"><span class="pre">F</span> <span class="pre">=</span> <span class="pre">ldltfact(A)</span></code> is to solve the linear system of equations <code class="docutils literal"><span class="pre">Ax</span> <span class="pre">=</span> <span class="pre">b</span></code> with <code class="docutils literal"><span class="pre">F\b</span></code>.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">ldltfact</code><span class="sig-paren">(</span><em>::Union{SparseMatrixCSC</em>, <em>Symmetric{Float64</em>, <em>SparseMatrixCSC{Flaot64</em>, <em>SuiteSparse_long}}</em>, <em>Hermitian{Complex{Float64}</em>, <em>SparseMatrixCSC{Complex{Float64}</em>, <em>SuiteSparse_long}}}; shift=0</em>, <em>perm=Int[]</em><span class="sig-paren">)</span> &rarr; CHOLMOD.Factor</dt>
<dd><p>Compute the <code class="docutils literal"><span class="pre">LDLt</span></code> factorization of a sparse symmetric or Hermitian matrix. A fill-reducing permutation is used. <code class="docutils literal"><span class="pre">F</span> <span class="pre">=</span> <span class="pre">ldltfact(A)</span></code> is most frequently used to solve systems of equations <code class="docutils literal"><span class="pre">A*x</span> <span class="pre">=</span> <span class="pre">b</span></code> with <code class="docutils literal"><span class="pre">F\b</span></code>, but also the methods <code class="docutils literal"><span class="pre">diag</span></code>, <code class="docutils literal"><span class="pre">det</span></code>, <code class="docutils literal"><span class="pre">logdet</span></code> are defined for <code class="docutils literal"><span class="pre">F</span></code>. You can also extract individual factors from <code class="docutils literal"><span class="pre">F</span></code>, using <code class="docutils literal"><span class="pre">F[:L]</span></code>. However, since pivoting is on by default, the factorization is internally represented as <code class="docutils literal"><span class="pre">A</span> <span class="pre">==</span> <span class="pre">P'*L*D*L'*P</span></code> with a permutation matrix <code class="docutils literal"><span class="pre">P</span></code>; using just <code class="docutils literal"><span class="pre">L</span></code> without accounting for <code class="docutils literal"><span class="pre">P</span></code> will give incorrect answers. To include the effects of permutation, it&#8217;s typically preferable to extact &#8220;combined&#8221; factors like <code class="docutils literal"><span class="pre">PtL</span> <span class="pre">=</span> <span class="pre">F[:PtL]</span></code> (the equivalent of <code class="docutils literal"><span class="pre">P'*L</span></code>) and <code class="docutils literal"><span class="pre">LtP</span> <span class="pre">=</span> <span class="pre">F[:UP]</span></code> (the equivalent of <code class="docutils literal"><span class="pre">L'*P</span></code>). The complete list of supported factors is <code class="docutils literal"><span class="pre">:L,</span> <span class="pre">:PtL,</span> <span class="pre">:D,</span> <span class="pre">:UP,</span> <span class="pre">:U,</span> <span class="pre">:LD,</span> <span class="pre">:DU,</span> <span class="pre">:PtLD,</span> <span class="pre">:DUP</span></code>.</p>
<p>Setting optional <code class="docutils literal"><span class="pre">shift</span></code> keyword argument computes the factorization of <code class="docutils literal"><span class="pre">A+shift*I</span></code> instead of <code class="docutils literal"><span class="pre">A</span></code>. If the <code class="docutils literal"><span class="pre">perm</span></code> argument is nonempty, it should be a permutation of <code class="docutils literal"><span class="pre">1:size(A,1)</span></code> giving the ordering to use (instead of CHOLMOD&#8217;s default AMD ordering).</p>
<p>The function calls the C library CHOLMOD and many other functions from the library are wrapped but not exported.</p>
</dd></dl>

<dl class="function">
<dt id="Base.ldltfact!">
<code class="descname">ldltfact!</code><span class="sig-paren">(</span><em>::SymTridiagonal</em><span class="sig-paren">)</span> &rarr; LDLt<a class="headerlink" href="#Base.ldltfact!" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as <code class="docutils literal"><span class="pre">ldltfact</span></code>, but saves space by overwriting the input <code class="docutils literal"><span class="pre">A</span></code>, instead of creating a copy.</p>
</dd></dl>

<dl class="function">
<dt id="Base.qr">
<code class="descname">qr</code><span class="sig-paren">(</span><em>A</em><span class="optional">[</span>, <em>pivot=Val{false}][;thin=true</em><span class="optional">]</span><span class="sig-paren">)</span> &rarr; Q, R, [p]<a class="headerlink" href="#Base.qr" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the (pivoted) QR factorization of <code class="docutils literal"><span class="pre">A</span></code> such that either <code class="docutils literal"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">Q*R</span></code> or <code class="docutils literal"><span class="pre">A[:,p]</span> <span class="pre">=</span> <span class="pre">Q*R</span></code>. Also see <code class="docutils literal"><span class="pre">qrfact</span></code>. The default is to compute a thin factorization. Note that <code class="docutils literal"><span class="pre">R</span></code> is not extended with zeros when the full <code class="docutils literal"><span class="pre">Q</span></code> is requested.</p>
</dd></dl>

<dl class="function">
<dt id="Base.qrfact">
<code class="descname">qrfact</code><span class="sig-paren">(</span><em>A</em><span class="optional">[</span>, <em>pivot=Val{false}</em><span class="optional">]</span><span class="sig-paren">)</span> &rarr; F<a class="headerlink" href="#Base.qrfact" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the QR factorization of <code class="docutils literal"><span class="pre">A</span></code>. The return type of <code class="docutils literal"><span class="pre">F</span></code> depends on the element type of <code class="docutils literal"><span class="pre">A</span></code> and whether pivoting is specified (with <code class="docutils literal"><span class="pre">pivot==Val{true}</span></code>).</p>
<table border="1" class="docutils">
<colgroup>
<col width="19%" />
<col width="20%" />
<col width="17%" />
<col width="44%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Return type</th>
<th class="head"><code class="docutils literal"><span class="pre">eltype(A)</span></code></th>
<th class="head"><code class="docutils literal"><span class="pre">pivot</span></code></th>
<th class="head">Relationship between <code class="docutils literal"><span class="pre">F</span></code> and <code class="docutils literal"><span class="pre">A</span></code></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">QR</span></code></td>
<td>not <code class="docutils literal"><span class="pre">BlasFloat</span></code></td>
<td>either</td>
<td><code class="docutils literal"><span class="pre">A==F[:Q]*F[:R]</span></code></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">QRCompactWY</span></code></td>
<td><code class="docutils literal"><span class="pre">BlasFloat</span></code></td>
<td><code class="docutils literal"><span class="pre">Val{false}</span></code></td>
<td><code class="docutils literal"><span class="pre">A==F[:Q]*F[:R]</span></code></td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">QRPivoted</span></code></td>
<td><code class="docutils literal"><span class="pre">BlasFloat</span></code></td>
<td><code class="docutils literal"><span class="pre">Val{true}</span></code></td>
<td><code class="docutils literal"><span class="pre">A[:,F[:p]]==F[:Q]*F[:R]</span></code></td>
</tr>
</tbody>
</table>
<p><code class="docutils literal"><span class="pre">BlasFloat</span></code> refers to any of: <code class="docutils literal"><span class="pre">Float32</span></code>, <code class="docutils literal"><span class="pre">Float64</span></code>, <code class="docutils literal"><span class="pre">Complex64</span></code> or <code class="docutils literal"><span class="pre">Complex128</span></code>.</p>
<p>The individual components of the factorization <code class="docutils literal"><span class="pre">F</span></code> can be accessed by indexing:</p>
<table border="1" class="docutils">
<colgroup>
<col width="10%" />
<col width="40%" />
<col width="16%" />
<col width="19%" />
<col width="16%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Component</th>
<th class="head">Description</th>
<th class="head"><code class="docutils literal"><span class="pre">QR</span></code></th>
<th class="head"><code class="docutils literal"><span class="pre">QRCompactWY</span></code></th>
<th class="head"><code class="docutils literal"><span class="pre">QRPivoted</span></code></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">F[:Q]</span></code></td>
<td><code class="docutils literal"><span class="pre">Q</span></code> (orthogonal/unitary) part of <code class="docutils literal"><span class="pre">QR</span></code></td>
<td>✓ (<code class="docutils literal"><span class="pre">QRPackedQ</span></code>)</td>
<td>✓ (<code class="docutils literal"><span class="pre">QRCompactWYQ</span></code>)</td>
<td>✓ (<code class="docutils literal"><span class="pre">QRPackedQ</span></code>)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">F[:R]</span></code></td>
<td><code class="docutils literal"><span class="pre">R</span></code> (upper right triangular) part of <code class="docutils literal"><span class="pre">QR</span></code></td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">F[:p]</span></code></td>
<td>pivot <code class="docutils literal"><span class="pre">Vector</span></code></td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>✓</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">F[:P]</span></code></td>
<td>(pivot) permutation <code class="docutils literal"><span class="pre">Matrix</span></code></td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>✓</td>
</tr>
</tbody>
</table>
<p>The following functions are available for the <code class="docutils literal"><span class="pre">QR</span></code> objects: <code class="docutils literal"><span class="pre">size</span></code>, <code class="docutils literal"><span class="pre">\</span></code>. When <code class="docutils literal"><span class="pre">A</span></code> is rectangular, <code class="docutils literal"><span class="pre">\</span></code> will return a least squares solution and if the solution is not unique, the one with smallest norm is returned.</p>
<p>Multiplication with respect to either thin or full <code class="docutils literal"><span class="pre">Q</span></code> is allowed, i.e. both <code class="docutils literal"><span class="pre">F[:Q]*F[:R]</span></code> and <code class="docutils literal"><span class="pre">F[:Q]*A</span></code> are supported. A <code class="docutils literal"><span class="pre">Q</span></code> matrix can be converted into a regular matrix with <a class="reference internal" href="#Base.full" title="Base.full"><code class="xref jl jl-func docutils literal"><span class="pre">full()</span></code></a> which has a named argument <code class="docutils literal"><span class="pre">thin</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p><code class="docutils literal"><span class="pre">qrfact</span></code> returns multiple types because LAPACK uses several representations that minimize the memory storage requirements of products of Householder elementary reflectors, so that the <code class="docutils literal"><span class="pre">Q</span></code> and <code class="docutils literal"><span class="pre">R</span></code> matrices can be stored compactly rather as two separate dense matrices.</p>
<p>The data contained in <code class="docutils literal"><span class="pre">QR</span></code> or <code class="docutils literal"><span class="pre">QRPivoted</span></code> can be used to construct the <code class="docutils literal"><span class="pre">QRPackedQ</span></code> type, which is a compact representation of the rotation matrix:</p>
<div class="math">
\[Q = \prod_{i=1}^{\min(m,n)} (I - \tau_i v_i v_i^T)\]</div>
<p>where <span class="math">\(\tau_i\)</span> is the scale factor and <span class="math">\(v_i\)</span> is the projection vector associated with the <span class="math">\(i^{th}\)</span> Householder elementary reflector.</p>
<p>The data contained in <code class="docutils literal"><span class="pre">QRCompactWY</span></code> can be used to construct the <code class="docutils literal"><span class="pre">QRCompactWYQ</span></code> type, which is a compact representation of the rotation matrix</p>
<div class="math">
\[Q = I + Y T Y^T\]</div>
<p class="last">where <code class="docutils literal"><span class="pre">Y</span></code> is <span class="math">\(m \times r\)</span> lower trapezoidal and <code class="docutils literal"><span class="pre">T</span></code> is <span class="math">\(r \times r\)</span> upper triangular. The <em>compact WY</em> representation <a class="reference internal" href="#schreiber1989" id="id1">[Schreiber1989]</a> is not to be confused with the older, <em>WY</em> representation <a class="reference internal" href="#bischof1987" id="id2">[Bischof1987]</a>. (The LAPACK documentation uses <code class="docutils literal"><span class="pre">V</span></code> in lieu of <code class="docutils literal"><span class="pre">Y</span></code>.)</p>
</div>
<table class="docutils citation" frame="void" id="bischof1987" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Bischof1987]</td><td><em>(<a class="fn-backref" href="#id2">1</a>, <a class="fn-backref" href="#id3">2</a>)</em> C Bischof and C Van Loan, &#8220;The WY representation for products
of Householder matrices&#8221;, SIAM J Sci Stat Comput 8 (1987), s2-s13.
<a class="reference external" href="http://dx.doi.org/10.1137/0908009">doi:10.1137/0908009</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="schreiber1989" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[Schreiber1989]</a></td><td>R Schreiber and C Van Loan, &#8220;A storage-efficient WY
representation for products of Householder transformations&#8221;,
SIAM J Sci Stat Comput 10 (1989), 53-57.
<a class="reference external" href="http://dx.doi.org/10.1137/0910005">doi:10.1137/0910005</a></td></tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">qrfact</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span> &rarr; SPQR.Factorization</dt>
<dd><p>Compute the QR factorization of a sparse matrix <code class="docutils literal"><span class="pre">A</span></code>. A fill-reducing permutation is used. The main application of this type is to solve least squares problems with <code class="docutils literal"><span class="pre">\</span></code>. The function calls the C library SPQR and a few additional functions from the library are wrapped but not exported.</p>
</dd></dl>

<dl class="function">
<dt id="Base.qrfact!">
<code class="descname">qrfact!</code><span class="sig-paren">(</span><em>A</em><span class="optional">[</span>, <em>pivot=Val{false}</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#Base.qrfact!" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal"><span class="pre">qrfact!</span></code> is the same as <a class="reference internal" href="#Base.qrfact" title="Base.qrfact"><code class="xref jl jl-func docutils literal"><span class="pre">qrfact()</span></code></a> when <code class="docutils literal"><span class="pre">A</span></code> is a subtype of <code class="docutils literal"><span class="pre">StridedMatrix</span></code>, but saves space by overwriting the input <code class="docutils literal"><span class="pre">A</span></code>, instead of creating a copy.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">full</code><span class="sig-paren">(</span><em>QRCompactWYQ</em><span class="optional">[</span>, <em>thin=true</em><span class="optional">]</span><span class="sig-paren">)</span> &rarr; Matrix</dt>
<dd><p>Converts an orthogonal or unitary matrix stored as a <code class="docutils literal"><span class="pre">QRCompactWYQ</span></code>
object, i.e. in the compact WY format <a class="reference internal" href="#bischof1987" id="id3">[Bischof1987]</a>, to a dense matrix.</p>
<p>Optionally takes a <code class="docutils literal"><span class="pre">thin</span></code> Boolean argument, which if <code class="docutils literal"><span class="pre">true</span></code> omits the
columns that span the rows of <code class="docutils literal"><span class="pre">R</span></code> in the QR factorization that are zero.
The resulting matrix is the <code class="docutils literal"><span class="pre">Q</span></code> in a thin QR factorization (sometimes
called the reduced QR factorization).  If <code class="docutils literal"><span class="pre">false</span></code>, returns a <code class="docutils literal"><span class="pre">Q</span></code> that
spans all rows of <code class="docutils literal"><span class="pre">R</span></code> in its corresponding QR factorization.</p>
</dd></dl>

<dl class="function">
<dt id="Base.bkfact">
<code class="descname">bkfact</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span> &rarr; BunchKaufman<a class="headerlink" href="#Base.bkfact" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Bunch-Kaufman <a class="reference internal" href="#bunch1977" id="id4">[Bunch1977]</a> factorization of a real symmetric or complex Hermitian matrix <code class="docutils literal"><span class="pre">A</span></code> and return a <code class="docutils literal"><span class="pre">BunchKaufman</span></code> object. The following functions are available for <code class="docutils literal"><span class="pre">BunchKaufman</span></code> objects: <code class="docutils literal"><span class="pre">size</span></code>, <code class="docutils literal"><span class="pre">\</span></code>, <code class="docutils literal"><span class="pre">inv</span></code>, <code class="docutils literal"><span class="pre">issym</span></code>, <code class="docutils literal"><span class="pre">ishermitian</span></code>.</p>
<table class="docutils citation" frame="void" id="bunch1977" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[Bunch1977]</a></td><td>J R Bunch and L Kaufman, Some stable methods for calculating inertia and solving symmetric linear systems, Mathematics of Computation 31:137 (1977), 163-179. <a class="reference external" href="http://www.ams.org/journals/mcom/1977-31-137/S0025-5718-1977-0428694-0">url</a>.</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Base.bkfact!">
<code class="descname">bkfact!</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span> &rarr; BunchKaufman<a class="headerlink" href="#Base.bkfact!" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal"><span class="pre">bkfact!</span></code> is the same as <a class="reference internal" href="#Base.bkfact" title="Base.bkfact"><code class="xref jl jl-func docutils literal"><span class="pre">bkfact()</span></code></a>, but saves space by overwriting the input <code class="docutils literal"><span class="pre">A</span></code>, instead of creating a copy.</p>
</dd></dl>

<dl class="function">
<dt id="Base.eig">
<code class="descname">eig</code><span class="sig-paren">(</span><em>A,[irange,][vl,][vu,][permute=true,][scale=true]</em><span class="sig-paren">)</span> &rarr; D, V<a class="headerlink" href="#Base.eig" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes eigenvalues and eigenvectors of <code class="docutils literal"><span class="pre">A</span></code>. See <a class="reference internal" href="#Base.eigfact" title="Base.eigfact"><code class="xref jl jl-func docutils literal"><span class="pre">eigfact()</span></code></a> for
details on the <code class="docutils literal"><span class="pre">balance</span></code> keyword argument.</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">eig</span><span class="p">([</span><span class="mf">1.0</span> <span class="mf">0.0</span> <span class="mf">0.0</span><span class="p">;</span> <span class="mf">0.0</span> <span class="mf">3.0</span> <span class="mf">0.0</span><span class="p">;</span> <span class="mf">0.0</span> <span class="mf">0.0</span> <span class="mf">18.0</span><span class="p">])</span>
<span class="p">([</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">3.0</span><span class="p">,</span><span class="mf">18.0</span><span class="p">],</span>
<span class="mi">3</span><span class="n">x3</span> <span class="kt">Array</span><span class="p">{</span><span class="kt">Float64</span><span class="p">,</span><span class="mi">2</span><span class="p">}</span><span class="o">:</span>
 <span class="mf">1.0</span>  <span class="mf">0.0</span>  <span class="mf">0.0</span>
 <span class="mf">0.0</span>  <span class="mf">1.0</span>  <span class="mf">0.0</span>
 <span class="mf">0.0</span>  <span class="mf">0.0</span>  <span class="mf">1.0</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">eig</span></code> is a wrapper around <a class="reference internal" href="#Base.eigfact" title="Base.eigfact"><code class="xref jl jl-func docutils literal"><span class="pre">eigfact()</span></code></a>, extracting all parts of the
factorization to a tuple; where possible, using <a class="reference internal" href="#Base.eigfact" title="Base.eigfact"><code class="xref jl jl-func docutils literal"><span class="pre">eigfact()</span></code></a> is
recommended.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">eig</code><span class="sig-paren">(</span><em>A</em>, <em>B</em><span class="sig-paren">)</span> &rarr; D, V</dt>
<dd><p>Computes generalized eigenvalues and vectors of <code class="docutils literal"><span class="pre">A</span></code> with respect to <code class="docutils literal"><span class="pre">B</span></code>.</p>
<p><code class="docutils literal"><span class="pre">eig</span></code> is a wrapper around <a class="reference internal" href="#Base.eigfact" title="Base.eigfact"><code class="xref jl jl-func docutils literal"><span class="pre">eigfact()</span></code></a>, extracting all parts of the
factorization to a tuple; where possible, using <a class="reference internal" href="#Base.eigfact" title="Base.eigfact"><code class="xref jl jl-func docutils literal"><span class="pre">eigfact()</span></code></a> is
recommended.</p>
</dd></dl>

<dl class="function">
<dt id="Base.eigvals">
<code class="descname">eigvals</code><span class="sig-paren">(</span><em>A,[irange,][vl,][vu]</em><span class="sig-paren">)</span> &rarr; values<a class="headerlink" href="#Base.eigvals" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the eigenvalues of <code class="docutils literal"><span class="pre">A</span></code>. If <code class="docutils literal"><span class="pre">A</span></code> is <code class="docutils literal"><span class="pre">Symmetric</span></code>, <code class="docutils literal"><span class="pre">Hermitian</span></code> or <code class="docutils literal"><span class="pre">SymTridiagonal</span></code>, it is possible to calculate only a subset of the eigenvalues by specifying either a <code class="docutils literal"><span class="pre">UnitRange</span></code> <code class="docutils literal"><span class="pre">irange</span></code> covering indices of the sorted eigenvalues, or a pair <code class="docutils literal"><span class="pre">vl</span></code> and <code class="docutils literal"><span class="pre">vu</span></code> for the lower and upper boundaries of the eigenvalues.</p>
<p>For general non-symmetric matrices it is possible to specify how the matrix is balanced before the eigenvector calculation. The option <code class="docutils literal"><span class="pre">permute=true</span></code> permutes the matrix to become closer to upper triangular, and <code class="docutils literal"><span class="pre">scale=true</span></code> scales the matrix by its diagonal elements to make rows and columns moreequal in norm. The default is <code class="docutils literal"><span class="pre">true</span></code> for both options.</p>
</dd></dl>

<dl class="function">
<dt id="Base.eigvals!">
<code class="descname">eigvals!</code><span class="sig-paren">(</span><em>A,[irange,][vl,][vu]</em><span class="sig-paren">)</span> &rarr; values<a class="headerlink" href="#Base.eigvals!" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as <code class="docutils literal"><span class="pre">eigvals</span></code>, but saves space by overwriting the input <code class="docutils literal"><span class="pre">A</span></code> (and <code class="docutils literal"><span class="pre">B</span></code>), instead of creating a copy.</p>
</dd></dl>

<dl class="function">
<dt id="Base.eigmax">
<code class="descname">eigmax</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.eigmax" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the largest eigenvalue of <code class="docutils literal"><span class="pre">A</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.eigmin">
<code class="descname">eigmin</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.eigmin" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the smallest eigenvalue of <code class="docutils literal"><span class="pre">A</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.eigvecs">
<code class="descname">eigvecs</code><span class="sig-paren">(</span><em>A, [eigvals,][permute=true,][scale=true]</em><span class="sig-paren">)</span> &rarr; Matrix<a class="headerlink" href="#Base.eigvecs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a matrix <code class="docutils literal"><span class="pre">M</span></code> whose columns are the eigenvectors of <code class="docutils literal"><span class="pre">A</span></code>.
(The <code class="docutils literal"><span class="pre">k</span></code>th eigenvector can be obtained from the slice <code class="docutils literal"><span class="pre">M[:,</span> <span class="pre">k]</span></code>.)
The <code class="docutils literal"><span class="pre">permute</span></code> and <code class="docutils literal"><span class="pre">scale</span></code> keywords are the same as for <a class="reference internal" href="#Base.eigfact" title="Base.eigfact"><code class="xref jl jl-func docutils literal"><span class="pre">eigfact()</span></code></a>.</p>
<p>For <a class="reference internal" href="#Base.SymTridiagonal" title="Base.SymTridiagonal"><code class="xref jl jl-class docutils literal"><span class="pre">SymTridiagonal</span></code></a> matrices, if the optional vector of eigenvalues
<code class="docutils literal"><span class="pre">eigvals</span></code> is specified, returns the specific corresponding eigenvectors.</p>
</dd></dl>

<dl class="function">
<dt id="Base.eigfact">
<code class="descname">eigfact</code><span class="sig-paren">(</span><em>A,[irange,][vl,][vu,][permute=true,][scale=true]</em><span class="sig-paren">)</span> &rarr; Eigen<a class="headerlink" href="#Base.eigfact" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the eigenvalue decomposition of <code class="docutils literal"><span class="pre">A</span></code>, returning an <code class="docutils literal"><span class="pre">Eigen</span></code>
factorization object <code class="docutils literal"><span class="pre">F</span></code> which contains the eigenvalues in <code class="docutils literal"><span class="pre">F[:values]</span></code>
and the eigenvectors in the columns of the matrix <code class="docutils literal"><span class="pre">F[:vectors]</span></code>.
(The <code class="docutils literal"><span class="pre">k</span></code>th eigenvector can be obtained from the slice <code class="docutils literal"><span class="pre">F[:vectors][:,</span> <span class="pre">k]</span></code>.)</p>
<p>The following functions are available for <code class="docutils literal"><span class="pre">Eigen</span></code> objects: <code class="docutils literal"><span class="pre">inv</span></code>,
<code class="docutils literal"><span class="pre">det</span></code>.</p>
<p>If <code class="docutils literal"><span class="pre">A</span></code> is <code class="xref jl jl-class docutils literal"><span class="pre">Symmetric</span></code>, <code class="xref jl jl-class docutils literal"><span class="pre">Hermitian</span></code> or <a class="reference internal" href="#Base.SymTridiagonal" title="Base.SymTridiagonal"><code class="xref jl jl-class docutils literal"><span class="pre">SymTridiagonal</span></code></a>,
it is possible to calculate only a subset of the eigenvalues by specifying
either a <code class="xref jl jl-class docutils literal"><span class="pre">UnitRange</span></code> <code class="docutils literal"><span class="pre">irange</span></code> covering indices of the sorted
eigenvalues or a pair <code class="docutils literal"><span class="pre">vl</span></code> and <code class="docutils literal"><span class="pre">vu</span></code> for the lower and upper boundaries
of the eigenvalues.</p>
<p>For general nonsymmetric matrices it is possible to specify how the matrix
is balanced before the eigenvector calculation. The option <code class="docutils literal"><span class="pre">permute=true</span></code>
permutes the matrix to become closer to upper triangular, and <code class="docutils literal"><span class="pre">scale=true</span></code>
scales the matrix by its diagonal elements to make rows and columns more
equal in norm. The default is <code class="docutils literal"><span class="pre">true</span></code> for both options.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">eigfact</code><span class="sig-paren">(</span><em>A</em>, <em>B</em><span class="sig-paren">)</span> &rarr; GeneralizedEigen</dt>
<dd><p>Computes the generalized eigenvalue decomposition of <code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">B</span></code>,
returning a <code class="docutils literal"><span class="pre">GeneralizedEigen</span></code> factorization object <code class="docutils literal"><span class="pre">F</span></code> which contains
the generalized eigenvalues in <code class="docutils literal"><span class="pre">F[:values]</span></code> and the generalized
eigenvectors in the columns of the matrix <code class="docutils literal"><span class="pre">F[:vectors]</span></code>. (The <code class="docutils literal"><span class="pre">k</span></code>th
generalized eigenvector can be obtained from the slice <code class="docutils literal"><span class="pre">F[:vectors][:,</span>
<span class="pre">k]</span></code>.)</p>
</dd></dl>

<dl class="function">
<dt id="Base.eigfact!">
<code class="descname">eigfact!</code><span class="sig-paren">(</span><em>A</em><span class="optional">[</span>, <em>B</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#Base.eigfact!" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as <a class="reference internal" href="#Base.eigfact" title="Base.eigfact"><code class="xref jl jl-func docutils literal"><span class="pre">eigfact()</span></code></a>, but saves space by overwriting the input <code class="docutils literal"><span class="pre">A</span></code> (and
<code class="docutils literal"><span class="pre">B</span></code>), instead of creating a copy.</p>
</dd></dl>

<dl class="function">
<dt id="Base.hessfact">
<code class="descname">hessfact</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.hessfact" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Hessenberg decomposition of <code class="docutils literal"><span class="pre">A</span></code> and return a <code class="docutils literal"><span class="pre">Hessenberg</span></code> object. If <code class="docutils literal"><span class="pre">F</span></code> is the factorization object, the unitary matrix can be accessed with <code class="docutils literal"><span class="pre">F[:Q]</span></code> and the Hessenberg matrix with <code class="docutils literal"><span class="pre">F[:H]</span></code>. When <code class="docutils literal"><span class="pre">Q</span></code> is extracted, the resulting type is the <code class="docutils literal"><span class="pre">HessenbergQ</span></code> object, and may be converted to a regular matrix with <a class="reference internal" href="#Base.full" title="Base.full"><code class="xref jl jl-func docutils literal"><span class="pre">full()</span></code></a>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.hessfact!">
<code class="descname">hessfact!</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.hessfact!" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal"><span class="pre">hessfact!</span></code> is the same as <a class="reference internal" href="#Base.hessfact" title="Base.hessfact"><code class="xref jl jl-func docutils literal"><span class="pre">hessfact()</span></code></a>, but saves space by overwriting the input <code class="docutils literal"><span class="pre">A</span></code>, instead of creating a copy.</p>
</dd></dl>

<dl class="function">
<dt id="Base.schurfact">
<code class="descname">schurfact</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span> &rarr; Schur<a class="headerlink" href="#Base.schurfact" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the Schur factorization of the matrix <code class="docutils literal"><span class="pre">A</span></code>. The (quasi) triangular Schur factor can be obtained from the <code class="docutils literal"><span class="pre">Schur</span></code> object <code class="docutils literal"><span class="pre">F</span></code> with either <code class="docutils literal"><span class="pre">F[:Schur]</span></code> or <code class="docutils literal"><span class="pre">F[:T]</span></code> and the unitary/orthogonal Schur vectors can be obtained with <code class="docutils literal"><span class="pre">F[:vectors]</span></code> or <code class="docutils literal"><span class="pre">F[:Z]</span></code> such that <code class="docutils literal"><span class="pre">A=F[:vectors]*F[:Schur]*F[:vectors]'</span></code>. The eigenvalues of <code class="docutils literal"><span class="pre">A</span></code> can be obtained with <code class="docutils literal"><span class="pre">F[:values]</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.schurfact!">
<code class="descname">schurfact!</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.schurfact!" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the Schur factorization of <code class="docutils literal"><span class="pre">A</span></code>, overwriting <code class="docutils literal"><span class="pre">A</span></code> in the process. See <a class="reference internal" href="#Base.schurfact" title="Base.schurfact"><code class="xref jl jl-func docutils literal"><span class="pre">schurfact()</span></code></a></p>
</dd></dl>

<dl class="function">
<dt id="Base.schur">
<code class="descname">schur</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span> &rarr; Schur[:T], Schur[:Z], Schur[:values]<a class="headerlink" href="#Base.schur" title="Permalink to this definition">¶</a></dt>
<dd><p>See <a class="reference internal" href="#Base.schurfact" title="Base.schurfact"><code class="xref jl jl-func docutils literal"><span class="pre">schurfact()</span></code></a></p>
</dd></dl>

<dl class="function">
<dt id="Base.ordschur">
<code class="descname">ordschur</code><span class="sig-paren">(</span><em>Q</em>, <em>T</em>, <em>select</em><span class="sig-paren">)</span> &rarr; Schur<a class="headerlink" href="#Base.ordschur" title="Permalink to this definition">¶</a></dt>
<dd><p>Reorders the Schur factorization of a real matrix <code class="docutils literal"><span class="pre">A=Q*T*Q'</span></code> according to the logical array <code class="docutils literal"><span class="pre">select</span></code> returning a Schur object <code class="docutils literal"><span class="pre">F</span></code>. The selected eigenvalues appear in the leading diagonal of <code class="docutils literal"><span class="pre">F[:Schur]</span></code> and the corresponding leading columns of <code class="docutils literal"><span class="pre">F[:vectors]</span></code> form an orthonormal basis of the corresponding right invariant subspace. A complex conjugate pair of eigenvalues must be either both included or excluded via <code class="docutils literal"><span class="pre">select</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.ordschur!">
<code class="descname">ordschur!</code><span class="sig-paren">(</span><em>Q</em>, <em>T</em>, <em>select</em><span class="sig-paren">)</span> &rarr; Schur<a class="headerlink" href="#Base.ordschur!" title="Permalink to this definition">¶</a></dt>
<dd><p>Reorders the Schur factorization of a real matrix <code class="docutils literal"><span class="pre">A=Q*T*Q'</span></code>, overwriting <code class="docutils literal"><span class="pre">Q</span></code> and <code class="docutils literal"><span class="pre">T</span></code> in the process. See <a class="reference internal" href="#Base.ordschur" title="Base.ordschur"><code class="xref jl jl-func docutils literal"><span class="pre">ordschur()</span></code></a></p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">ordschur</code><span class="sig-paren">(</span><em>S</em>, <em>select</em><span class="sig-paren">)</span> &rarr; Schur</dt>
<dd><p>Reorders the Schur factorization <code class="docutils literal"><span class="pre">S</span></code> of type <code class="docutils literal"><span class="pre">Schur</span></code>.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">ordschur!</code><span class="sig-paren">(</span><em>S</em>, <em>select</em><span class="sig-paren">)</span> &rarr; Schur</dt>
<dd><p>Reorders the Schur factorization <code class="docutils literal"><span class="pre">S</span></code> of type <code class="docutils literal"><span class="pre">Schur</span></code>, overwriting <code class="docutils literal"><span class="pre">S</span></code> in the process. See <a class="reference internal" href="#Base.ordschur" title="Base.ordschur"><code class="xref jl jl-func docutils literal"><span class="pre">ordschur()</span></code></a></p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">schurfact</code><span class="sig-paren">(</span><em>A</em>, <em>B</em><span class="sig-paren">)</span> &rarr; GeneralizedSchur</dt>
<dd><p>Computes the Generalized Schur (or QZ) factorization of the matrices <code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">B</span></code>. The (quasi) triangular Schur factors can be obtained from the <code class="docutils literal"><span class="pre">Schur</span></code> object <code class="docutils literal"><span class="pre">F</span></code> with <code class="docutils literal"><span class="pre">F[:S]</span></code> and <code class="docutils literal"><span class="pre">F[:T]</span></code>, the left unitary/orthogonal Schur vectors can be obtained with <code class="docutils literal"><span class="pre">F[:left]</span></code> or <code class="docutils literal"><span class="pre">F[:Q]</span></code> and the right unitary/orthogonal Schur vectors can be obtained with <code class="docutils literal"><span class="pre">F[:right]</span></code> or <code class="docutils literal"><span class="pre">F[:Z]</span></code> such that <code class="docutils literal"><span class="pre">A=F[:left]*F[:S]*F[:right]'</span></code> and <code class="docutils literal"><span class="pre">B=F[:left]*F[:T]*F[:right]'</span></code>. The generalized eigenvalues of <code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">B</span></code> can be obtained with <code class="docutils literal"><span class="pre">F[:alpha]./F[:beta]</span></code>.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">schur</code><span class="sig-paren">(</span><em>A</em>, <em>B</em><span class="sig-paren">)</span> &rarr; GeneralizedSchur[:S], GeneralizedSchur[:T], GeneralizedSchur[:Q], GeneralizedSchur[:Z]</dt>
<dd><p>See <a class="reference internal" href="#Base.schurfact" title="Base.schurfact"><code class="xref jl jl-func docutils literal"><span class="pre">schurfact()</span></code></a></p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">ordschur</code><span class="sig-paren">(</span><em>S</em>, <em>T</em>, <em>Q</em>, <em>Z</em>, <em>select</em><span class="sig-paren">)</span> &rarr; GeneralizedSchur</dt>
<dd><p>Reorders the Generalized Schur factorization of a matrix <code class="docutils literal"><span class="pre">(A,</span> <span class="pre">B)</span> <span class="pre">=</span> <span class="pre">(Q*S*Z^{H},</span> <span class="pre">Q*T*Z^{H})</span></code> according to the logical array <code class="docutils literal"><span class="pre">select</span></code> and returns a GeneralizedSchur object <code class="docutils literal"><span class="pre">GS</span></code>.  The selected eigenvalues appear in the leading diagonal of both <code class="docutils literal"><span class="pre">(GS[:S],</span> <span class="pre">GS[:T])</span></code> and the left and right unitary/orthogonal Schur vectors are also reordered such that <code class="docutils literal"><span class="pre">(A,</span> <span class="pre">B)</span> <span class="pre">=</span> <span class="pre">GS[:Q]*(GS[:S],</span> <span class="pre">GS[:T])*GS[:Z]^{H}</span></code> still holds and the generalized eigenvalues of <code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">B</span></code> can still be obtained with <code class="docutils literal"><span class="pre">GS[:alpha]./GS[:beta]</span></code>.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">ordschur!</code><span class="sig-paren">(</span><em>S</em>, <em>T</em>, <em>Q</em>, <em>Z</em>, <em>select</em><span class="sig-paren">)</span> &rarr; GeneralizedSchur</dt>
<dd><p>Reorders the Generalized Schur factorization of a matrix by overwriting the matrices <code class="docutils literal"><span class="pre">(S,</span> <span class="pre">T,</span> <span class="pre">Q,</span> <span class="pre">Z)</span></code> in the process.  See <a class="reference internal" href="#Base.ordschur" title="Base.ordschur"><code class="xref jl jl-func docutils literal"><span class="pre">ordschur()</span></code></a>.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">ordschur</code><span class="sig-paren">(</span><em>GS</em>, <em>select</em><span class="sig-paren">)</span> &rarr; GeneralizedSchur</dt>
<dd><p>Reorders the Generalized Schur factorization of a Generalized Schur object.  See <a class="reference internal" href="#Base.ordschur" title="Base.ordschur"><code class="xref jl jl-func docutils literal"><span class="pre">ordschur()</span></code></a>.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">ordschur!</code><span class="sig-paren">(</span><em>GS</em>, <em>select</em><span class="sig-paren">)</span> &rarr; GeneralizedSchur</dt>
<dd><p>Reorders the Generalized Schur factorization of a Generalized Schur object by overwriting the object with the new factorization.  See <a class="reference internal" href="#Base.ordschur" title="Base.ordschur"><code class="xref jl jl-func docutils literal"><span class="pre">ordschur()</span></code></a>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.svdfact">
<code class="descname">svdfact</code><span class="sig-paren">(</span><em>A</em><span class="optional">[</span>, <em>thin=true</em><span class="optional">]</span><span class="sig-paren">)</span> &rarr; SVD<a class="headerlink" href="#Base.svdfact" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Singular Value Decomposition (SVD) of <code class="docutils literal"><span class="pre">A</span></code> and return an <code class="docutils literal"><span class="pre">SVD</span></code> object. <code class="docutils literal"><span class="pre">U</span></code>, <code class="docutils literal"><span class="pre">S</span></code>, <code class="docutils literal"><span class="pre">V</span></code> and <code class="docutils literal"><span class="pre">Vt</span></code> can be obtained from the factorization <code class="docutils literal"><span class="pre">F</span></code> with <code class="docutils literal"><span class="pre">F[:U]</span></code>, <code class="docutils literal"><span class="pre">F[:S]</span></code>, <code class="docutils literal"><span class="pre">F[:V]</span></code> and <code class="docutils literal"><span class="pre">F[:Vt]</span></code>, such that <code class="docutils literal"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">U*diagm(S)*Vt</span></code>. If <code class="docutils literal"><span class="pre">thin</span></code> is <code class="docutils literal"><span class="pre">true</span></code>, an economy mode decomposition is returned. The algorithm produces <code class="docutils literal"><span class="pre">Vt</span></code> and hence <code class="docutils literal"><span class="pre">Vt</span></code> is more efficient to extract than <code class="docutils literal"><span class="pre">V</span></code>. The default is to produce a thin decomposition.</p>
</dd></dl>

<dl class="function">
<dt id="Base.svdfact!">
<code class="descname">svdfact!</code><span class="sig-paren">(</span><em>A</em><span class="optional">[</span>, <em>thin=true</em><span class="optional">]</span><span class="sig-paren">)</span> &rarr; SVD<a class="headerlink" href="#Base.svdfact!" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal"><span class="pre">svdfact!</span></code> is the same as <a class="reference internal" href="#Base.svdfact" title="Base.svdfact"><code class="xref jl jl-func docutils literal"><span class="pre">svdfact()</span></code></a>, but saves space by overwriting the input <code class="docutils literal"><span class="pre">A</span></code>, instead of creating a copy. If <code class="docutils literal"><span class="pre">thin</span></code> is <code class="docutils literal"><span class="pre">true</span></code>, an economy mode decomposition is returned. The default is to produce a thin decomposition.</p>
</dd></dl>

<dl class="function">
<dt id="Base.svd">
<code class="descname">svd</code><span class="sig-paren">(</span><em>A</em><span class="optional">[</span>, <em>thin=true</em><span class="optional">]</span><span class="sig-paren">)</span> &rarr; U, S, V<a class="headerlink" href="#Base.svd" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper around <code class="docutils literal"><span class="pre">svdfact</span></code> extracting all parts the factorization to a tuple. Direct use of <code class="docutils literal"><span class="pre">svdfact</span></code> is therefore generally more efficient. Computes the SVD of <code class="docutils literal"><span class="pre">A</span></code>, returning <code class="docutils literal"><span class="pre">U</span></code>, vector <code class="docutils literal"><span class="pre">S</span></code>, and <code class="docutils literal"><span class="pre">V</span></code> such that <code class="docutils literal"><span class="pre">A</span> <span class="pre">==</span> <span class="pre">U*diagm(S)*V'</span></code>. If <code class="docutils literal"><span class="pre">thin</span></code> is <code class="docutils literal"><span class="pre">true</span></code>, an economy mode decomposition is returned. The default is to produce a thin decomposition.</p>
</dd></dl>

<dl class="function">
<dt id="Base.svdvals">
<code class="descname">svdvals</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.svdvals" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the singular values of <code class="docutils literal"><span class="pre">A</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.svdvals!">
<code class="descname">svdvals!</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.svdvals!" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the singular values of <code class="docutils literal"><span class="pre">A</span></code>, while saving space by overwriting the input.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">svdfact</code><span class="sig-paren">(</span><em>A</em>, <em>B</em><span class="sig-paren">)</span> &rarr; GeneralizedSVD</dt>
<dd><p>Compute the generalized SVD of <code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">B</span></code>, returning a <code class="docutils literal"><span class="pre">GeneralizedSVD</span></code> Factorization object <code class="docutils literal"><span class="pre">F</span></code>, such that <code class="docutils literal"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">F[:U]*F[:D1]*F[:R0]*F[:Q]'</span></code> and <code class="docutils literal"><span class="pre">B</span> <span class="pre">=</span> <span class="pre">F[:V]*F[:D2]*F[:R0]*F[:Q]'</span></code>.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">svd</code><span class="sig-paren">(</span><em>A</em>, <em>B</em><span class="sig-paren">)</span> &rarr; U, V, Q, D1, D2, R0</dt>
<dd><p>Wrapper around <code class="docutils literal"><span class="pre">svdfact</span></code> extracting all parts the factorization to a tuple. Direct use of <code class="docutils literal"><span class="pre">svdfact</span></code> is therefore generally more efficient. The function returns the generalized SVD of <code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">B</span></code>, returning <code class="docutils literal"><span class="pre">U</span></code>, <code class="docutils literal"><span class="pre">V</span></code>, <code class="docutils literal"><span class="pre">Q</span></code>, <code class="docutils literal"><span class="pre">D1</span></code>, <code class="docutils literal"><span class="pre">D2</span></code>, and <code class="docutils literal"><span class="pre">R0</span></code> such that <code class="docutils literal"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">U*D1*R0*Q'</span></code> and <code class="docutils literal"><span class="pre">B</span> <span class="pre">=</span> <span class="pre">V*D2*R0*Q'</span></code>.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">svdvals</code><span class="sig-paren">(</span><em>A</em>, <em>B</em><span class="sig-paren">)</span></dt>
<dd><p>Return only the singular values from the generalized singular value decomposition of <code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">B</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.givens{T}">
<code class="descname">givens{T}</code><span class="sig-paren">(</span><em>::T</em>, <em>::T</em>, <em>::Integer</em>, <em>::Integer</em><span class="sig-paren">)</span> &rarr; {Givens, T}<a class="headerlink" href="#Base.givens{T}" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the tuple <code class="docutils literal"><span class="pre">(G,</span> <span class="pre">r)</span> <span class="pre">=</span> <span class="pre">givens(f,</span> <span class="pre">g,</span> <span class="pre">i1,</span> <span class="pre">i2)</span></code> where <code class="docutils literal"><span class="pre">G</span></code> is a Givens rotation and <code class="docutils literal"><span class="pre">r</span></code> is a scalar such that <code class="docutils literal"><span class="pre">G*x=y</span></code> with <code class="docutils literal"><span class="pre">x[i1]=f</span></code>, <code class="docutils literal"><span class="pre">x[i2]=g</span></code>, <code class="docutils literal"><span class="pre">y[i1]=r</span></code>, and <code class="docutils literal"><span class="pre">y[i2]=0</span></code>. The cosine and sine of the rotation angle can be extracted from the <code class="docutils literal"><span class="pre">Givens</span></code> type with <code class="docutils literal"><span class="pre">G.c</span></code> and <code class="docutils literal"><span class="pre">G.s</span></code> respectively. The arguments <code class="docutils literal"><span class="pre">f</span></code> and <code class="docutils literal"><span class="pre">g</span></code> can be either <code class="docutils literal"><span class="pre">Float32</span></code>, <code class="docutils literal"><span class="pre">Float64</span></code>, <code class="docutils literal"><span class="pre">Complex{Float32}</span></code>, or <code class="docutils literal"><span class="pre">Complex{Float64}</span></code>. The <code class="docutils literal"><span class="pre">Givens</span></code> type supports left multiplication <code class="docutils literal"><span class="pre">G*A</span></code> and conjugated transpose right multiplication <code class="docutils literal"><span class="pre">A*G'</span></code>. The type doesn&#8217;t have a <code class="docutils literal"><span class="pre">size</span></code> and can therefore be multiplied with matrices of arbitrary size as long as <code class="docutils literal"><span class="pre">i2&lt;=size(A,2)</span></code> for <code class="docutils literal"><span class="pre">G*A</span></code> or <code class="docutils literal"><span class="pre">i2&lt;=size(A,1)</span></code> for <code class="docutils literal"><span class="pre">A*G'</span></code>.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">givens{T}</code><span class="sig-paren">(</span><em>::AbstractArray{T}</em>, <em>::Integer</em>, <em>::Integer</em>, <em>::Integer</em><span class="sig-paren">)</span> &rarr; {Givens, T}</dt>
<dd><p>Computes the tuple <code class="docutils literal"><span class="pre">(G,</span> <span class="pre">r)</span> <span class="pre">=</span> <span class="pre">givens(A,</span> <span class="pre">i1,</span> <span class="pre">i2,</span> <span class="pre">col)</span></code> where <code class="docutils literal"><span class="pre">G</span></code> is Givens rotation and <code class="docutils literal"><span class="pre">r</span></code> is a scalar such that <code class="docutils literal"><span class="pre">G*A[:,col]=y</span></code> with <code class="docutils literal"><span class="pre">y[i1]=r</span></code>, and <code class="docutils literal"><span class="pre">y[i2]=0</span></code>. The cosine and sine of the rotation angle can be extracted from the <code class="docutils literal"><span class="pre">Givens</span></code> type with <code class="docutils literal"><span class="pre">G.c</span></code> and <code class="docutils literal"><span class="pre">G.s</span></code> respectively. The element type of <code class="docutils literal"><span class="pre">A</span></code> can be either <code class="docutils literal"><span class="pre">Float32</span></code>, <code class="docutils literal"><span class="pre">Float64</span></code>, <code class="docutils literal"><span class="pre">Complex{Float32}</span></code>, or <code class="docutils literal"><span class="pre">Complex{Float64}</span></code>. The <code class="docutils literal"><span class="pre">Givens</span></code> type supports left multiplication <code class="docutils literal"><span class="pre">G*A</span></code> and conjugated transpose right multiplication <code class="docutils literal"><span class="pre">A*G'</span></code>. The type doesn&#8217;t have a <code class="docutils literal"><span class="pre">size</span></code> and can therefore be multiplied with matrices of arbitrary size as long as <code class="docutils literal"><span class="pre">i2&lt;=size(A,2)</span></code> for <code class="docutils literal"><span class="pre">G*A</span></code> or <code class="docutils literal"><span class="pre">i2&lt;=size(A,1)</span></code> for <code class="docutils literal"><span class="pre">A*G'</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.triu">
<code class="descname">triu</code><span class="sig-paren">(</span><em>M</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.triu" title="Permalink to this definition">¶</a></dt>
<dd><p>Upper triangle of a matrix.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">triu</code><span class="sig-paren">(</span><em>M</em>, <em>k</em><span class="sig-paren">)</span></dt>
<dd><p>Returns the upper triangle of <code class="docutils literal"><span class="pre">M</span></code> starting from the <code class="docutils literal"><span class="pre">k</span></code>th superdiagonal.</p>
</dd></dl>

<dl class="function">
<dt id="Base.triu!">
<code class="descname">triu!</code><span class="sig-paren">(</span><em>M</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.triu!" title="Permalink to this definition">¶</a></dt>
<dd><p>Upper triangle of a matrix, overwriting <code class="docutils literal"><span class="pre">M</span></code> in the process.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">triu!</code><span class="sig-paren">(</span><em>M</em>, <em>k</em><span class="sig-paren">)</span></dt>
<dd><p>Returns the upper triangle of <code class="docutils literal"><span class="pre">M</span></code> starting from the <code class="docutils literal"><span class="pre">k</span></code>th superdiagonal, overwriting <code class="docutils literal"><span class="pre">M</span></code> in the process.</p>
</dd></dl>

<dl class="function">
<dt id="Base.tril">
<code class="descname">tril</code><span class="sig-paren">(</span><em>M</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.tril" title="Permalink to this definition">¶</a></dt>
<dd><p>Lower triangle of a matrix.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">tril</code><span class="sig-paren">(</span><em>M</em>, <em>k</em><span class="sig-paren">)</span></dt>
<dd><p>Returns the lower triangle of <code class="docutils literal"><span class="pre">M</span></code> starting from the <code class="docutils literal"><span class="pre">k</span></code>th superdiagonal.</p>
</dd></dl>

<dl class="function">
<dt id="Base.tril!">
<code class="descname">tril!</code><span class="sig-paren">(</span><em>M</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.tril!" title="Permalink to this definition">¶</a></dt>
<dd><p>Lower triangle of a matrix, overwriting <code class="docutils literal"><span class="pre">M</span></code> in the process.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">tril!</code><span class="sig-paren">(</span><em>M</em>, <em>k</em><span class="sig-paren">)</span></dt>
<dd><p>Returns the lower triangle of <code class="docutils literal"><span class="pre">M</span></code> starting from the <code class="docutils literal"><span class="pre">k</span></code>th superdiagonal, overwriting <code class="docutils literal"><span class="pre">M</span></code> in the process.</p>
</dd></dl>

<dl class="function">
<dt id="Base.diagind">
<code class="descname">diagind</code><span class="sig-paren">(</span><em>M</em><span class="optional">[</span>, <em>k</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#Base.diagind" title="Permalink to this definition">¶</a></dt>
<dd><p>A <code class="docutils literal"><span class="pre">Range</span></code> giving the indices of the <code class="docutils literal"><span class="pre">k</span></code>th diagonal of the matrix <code class="docutils literal"><span class="pre">M</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.diag">
<code class="descname">diag</code><span class="sig-paren">(</span><em>M</em><span class="optional">[</span>, <em>k</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#Base.diag" title="Permalink to this definition">¶</a></dt>
<dd><p>The <code class="docutils literal"><span class="pre">k</span></code>th diagonal of a matrix, as a vector. Use <code class="docutils literal"><span class="pre">diagm</span></code> to construct a diagonal matrix.</p>
</dd></dl>

<dl class="function">
<dt id="Base.diagm">
<code class="descname">diagm</code><span class="sig-paren">(</span><em>v</em><span class="optional">[</span>, <em>k</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#Base.diagm" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a diagonal matrix and place <code class="docutils literal"><span class="pre">v</span></code> on the <code class="docutils literal"><span class="pre">k</span></code>th diagonal.</p>
</dd></dl>

<dl class="function">
<dt id="Base.scale">
<code class="descname">scale</code><span class="sig-paren">(</span><em>A</em>, <em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.scale" title="Permalink to this definition">¶</a></dt>
<dt>
<code class="descname">scale</code><span class="sig-paren">(</span><em>b</em>, <em>A</em><span class="sig-paren">)</span></dt>
<dd><p>Scale an array <code class="docutils literal"><span class="pre">A</span></code> by a scalar <code class="docutils literal"><span class="pre">b</span></code>, returning a new array.</p>
<p>If <code class="docutils literal"><span class="pre">A</span></code> is a matrix and <code class="docutils literal"><span class="pre">b</span></code> is a vector, then <code class="docutils literal"><span class="pre">scale(A,b)</span></code> scales each column <code class="docutils literal"><span class="pre">i</span></code> of <code class="docutils literal"><span class="pre">A</span></code> by <code class="docutils literal"><span class="pre">b[i]</span></code> (similar to <code class="docutils literal"><span class="pre">A*diagm(b)</span></code>), while <code class="docutils literal"><span class="pre">scale(b,A)</span></code> scales each row <code class="docutils literal"><span class="pre">i</span></code> of <code class="docutils literal"><span class="pre">A</span></code> by <code class="docutils literal"><span class="pre">b[i]</span></code> (similar to <code class="docutils literal"><span class="pre">diagm(b)*A</span></code>), returning a new array.</p>
<p>Note: for large <code class="docutils literal"><span class="pre">A</span></code>, <code class="docutils literal"><span class="pre">scale</span></code> can be much faster than <code class="docutils literal"><span class="pre">A</span> <span class="pre">.*</span> <span class="pre">b</span></code> or <code class="docutils literal"><span class="pre">b</span> <span class="pre">.*</span> <span class="pre">A</span></code>, due to the use of BLAS.</p>
</dd></dl>

<dl class="function">
<dt id="Base.scale!">
<code class="descname">scale!</code><span class="sig-paren">(</span><em>A</em>, <em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.scale!" title="Permalink to this definition">¶</a></dt>
<dt>
<code class="descname">scale!</code><span class="sig-paren">(</span><em>b</em>, <em>A</em><span class="sig-paren">)</span></dt>
<dd><p>Scale an array <code class="docutils literal"><span class="pre">A</span></code> by a scalar <code class="docutils literal"><span class="pre">b</span></code>, similar to <a class="reference internal" href="#Base.scale" title="Base.scale"><code class="xref jl jl-func docutils literal"><span class="pre">scale()</span></code></a> but
overwriting <code class="docutils literal"><span class="pre">A</span></code> in-place.</p>
<p>If <code class="docutils literal"><span class="pre">A</span></code> is a matrix and <code class="docutils literal"><span class="pre">b</span></code> is a vector, then <code class="docutils literal"><span class="pre">scale!(A,b)</span></code>
scales each column <code class="docutils literal"><span class="pre">i</span></code> of <code class="docutils literal"><span class="pre">A</span></code> by <code class="docutils literal"><span class="pre">b[i]</span></code> (similar to
<code class="docutils literal"><span class="pre">A*diagm(b)</span></code>), while <code class="docutils literal"><span class="pre">scale!(b,A)</span></code> scales each row <code class="docutils literal"><span class="pre">i</span></code> of
<code class="docutils literal"><span class="pre">A</span></code> by <code class="docutils literal"><span class="pre">b[i]</span></code> (similar to <code class="docutils literal"><span class="pre">diagm(b)*A</span></code>), again operating in-place
on <code class="docutils literal"><span class="pre">A</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.Tridiagonal">
<code class="descname">Tridiagonal</code><span class="sig-paren">(</span><em>dl</em>, <em>d</em>, <em>du</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.Tridiagonal" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a tridiagonal matrix from the lower diagonal, diagonal, and upper diagonal, respectively.  The result is of type <code class="docutils literal"><span class="pre">Tridiagonal</span></code> and provides efficient specialized linear solvers, but may be converted into a regular matrix with <a class="reference internal" href="#Base.full" title="Base.full"><code class="xref jl jl-func docutils literal"><span class="pre">full()</span></code></a>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.Bidiagonal">
<code class="descname">Bidiagonal</code><span class="sig-paren">(</span><em>dv</em>, <em>ev</em>, <em>isupper</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.Bidiagonal" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs an upper (<code class="docutils literal"><span class="pre">isupper=true</span></code>) or lower (<code class="docutils literal"><span class="pre">isupper=false</span></code>) bidiagonal matrix
using the given diagonal (<code class="docutils literal"><span class="pre">dv</span></code>) and off-diagonal (<code class="docutils literal"><span class="pre">ev</span></code>) vectors.  The result is of type <code class="docutils literal"><span class="pre">Bidiagonal</span></code> and provides efficient specialized linear solvers, but may be converted into a regular matrix with <a class="reference internal" href="#Base.full" title="Base.full"><code class="xref jl jl-func docutils literal"><span class="pre">full()</span></code></a>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.SymTridiagonal">
<code class="descname">SymTridiagonal</code><span class="sig-paren">(</span><em>d</em>, <em>du</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.SymTridiagonal" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a real symmetric tridiagonal matrix from the diagonal and upper diagonal, respectively. The result is of type <code class="docutils literal"><span class="pre">SymTridiagonal</span></code> and provides efficient specialized eigensolvers, but may be converted into a regular matrix with <a class="reference internal" href="#Base.full" title="Base.full"><code class="xref jl jl-func docutils literal"><span class="pre">full()</span></code></a>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.rank">
<code class="descname">rank</code><span class="sig-paren">(</span><em>M</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.rank" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the rank of a matrix.</p>
</dd></dl>

<dl class="function">
<dt id="Base.norm">
<code class="descname">norm</code><span class="sig-paren">(</span><em>A</em><span class="optional">[</span>, <em>p</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#Base.norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the <code class="docutils literal"><span class="pre">p</span></code>-norm of a vector or the operator norm of a matrix <code class="docutils literal"><span class="pre">A</span></code>, defaulting to the <code class="docutils literal"><span class="pre">p=2</span></code>-norm.</p>
<p>For vectors, <code class="docutils literal"><span class="pre">p</span></code> can assume any numeric value (even though not all values produce a mathematically valid vector norm). In particular, <code class="docutils literal"><span class="pre">norm(A,</span> <span class="pre">Inf)</span></code> returns the largest value in <code class="docutils literal"><span class="pre">abs(A)</span></code>, whereas <code class="docutils literal"><span class="pre">norm(A,</span> <span class="pre">-Inf)</span></code> returns the smallest.</p>
<p>For matrices, the matrix norm induced by the vector <code class="docutils literal"><span class="pre">p</span></code>-norm is used, where valid values of <code class="docutils literal"><span class="pre">p</span></code> are <code class="docutils literal"><span class="pre">1</span></code>, <code class="docutils literal"><span class="pre">2</span></code>, or <code class="docutils literal"><span class="pre">Inf</span></code>. (Note that for sparse matrices, <code class="docutils literal"><span class="pre">p=2</span></code> is currently not implemented.) Use <a class="reference internal" href="#Base.vecnorm" title="Base.vecnorm"><code class="xref jl jl-func docutils literal"><span class="pre">vecnorm()</span></code></a> to compute the Frobenius norm.</p>
</dd></dl>

<dl class="function">
<dt id="Base.vecnorm">
<code class="descname">vecnorm</code><span class="sig-paren">(</span><em>A</em><span class="optional">[</span>, <em>p</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#Base.vecnorm" title="Permalink to this definition">¶</a></dt>
<dd><p>For any iterable container <code class="docutils literal"><span class="pre">A</span></code> (including arrays of any dimension) of numbers (or any element type for which <code class="docutils literal"><span class="pre">norm</span></code> is defined), compute the <code class="docutils literal"><span class="pre">p</span></code>-norm (defaulting to <code class="docutils literal"><span class="pre">p=2</span></code>) as if <code class="docutils literal"><span class="pre">A</span></code> were a vector of the corresponding length.</p>
<p>For example, if <code class="docutils literal"><span class="pre">A</span></code> is a matrix and <code class="docutils literal"><span class="pre">p=2</span></code>, then this is equivalent to the Frobenius norm.</p>
</dd></dl>

<dl class="function">
<dt id="Base.cond">
<code class="descname">cond</code><span class="sig-paren">(</span><em>M</em><span class="optional">[</span>, <em>p</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#Base.cond" title="Permalink to this definition">¶</a></dt>
<dd><p>Condition number of the matrix <code class="docutils literal"><span class="pre">M</span></code>, computed using the operator <code class="docutils literal"><span class="pre">p</span></code>-norm. Valid values for <code class="docutils literal"><span class="pre">p</span></code> are <code class="docutils literal"><span class="pre">1</span></code>, <code class="docutils literal"><span class="pre">2</span></code> (default), or <code class="docutils literal"><span class="pre">Inf</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.condskeel">
<code class="descname">condskeel</code><span class="sig-paren">(</span><em>M</em><span class="optional">[</span>, <em>x</em>, <em>p</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#Base.condskeel" title="Permalink to this definition">¶</a></dt>
<dd><div class="math">
\[\begin{split}\kappa_S(M, p) &amp; = \left\Vert \left\vert M \right\vert \left\vert M^{-1} \right\vert  \right\Vert_p \\
\kappa_S(M, x, p) &amp; = \left\Vert \left\vert M \right\vert \left\vert M^{-1} \right\vert \left\vert x \right\vert \right\Vert_p\end{split}\]</div>
<p>Skeel condition number <span class="math">\(\kappa_S\)</span> of the matrix <code class="docutils literal"><span class="pre">M</span></code>, optionally with respect to the vector <code class="docutils literal"><span class="pre">x</span></code>, as computed using the operator <code class="docutils literal"><span class="pre">p</span></code>-norm. <code class="docutils literal"><span class="pre">p</span></code> is <code class="docutils literal"><span class="pre">Inf</span></code> by default, if not provided. Valid values for <code class="docutils literal"><span class="pre">p</span></code> are <code class="docutils literal"><span class="pre">1</span></code>, <code class="docutils literal"><span class="pre">2</span></code>, or <code class="docutils literal"><span class="pre">Inf</span></code>.</p>
<p>This quantity is also known in the literature as the Bauer condition number, relative condition number, or componentwise relative condition number.</p>
</dd></dl>

<dl class="function">
<dt id="Base.trace">
<code class="descname">trace</code><span class="sig-paren">(</span><em>M</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.trace" title="Permalink to this definition">¶</a></dt>
<dd><p>Matrix trace</p>
</dd></dl>

<dl class="function">
<dt id="Base.det">
<code class="descname">det</code><span class="sig-paren">(</span><em>M</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.det" title="Permalink to this definition">¶</a></dt>
<dd><p>Matrix determinant</p>
</dd></dl>

<dl class="function">
<dt id="Base.logdet">
<code class="descname">logdet</code><span class="sig-paren">(</span><em>M</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.logdet" title="Permalink to this definition">¶</a></dt>
<dd><p>Log of matrix determinant. Equivalent to <code class="docutils literal"><span class="pre">log(det(M))</span></code>, but may provide increased accuracy and/or speed.</p>
</dd></dl>

<dl class="function">
<dt id="Base.logabsdet">
<code class="descname">logabsdet</code><span class="sig-paren">(</span><em>M</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.logabsdet" title="Permalink to this definition">¶</a></dt>
<dd><p>Log of absolute value of determinant of real matrix. Equivalent to <code class="docutils literal"><span class="pre">(log(abs(det(M))),</span> <span class="pre">sign(det(M)))</span></code>, but may provide increased accuracy and/or speed.</p>
</dd></dl>

<dl class="function">
<dt id="Base.inv">
<code class="descname">inv</code><span class="sig-paren">(</span><em>M</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.inv" title="Permalink to this definition">¶</a></dt>
<dd><p>Matrix inverse</p>
</dd></dl>

<dl class="function">
<dt id="Base.pinv">
<code class="descname">pinv</code><span class="sig-paren">(</span><em>M</em><span class="optional">[</span>, <em>tol</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#Base.pinv" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the Moore-Penrose pseudoinverse.</p>
<p>For matrices <code class="docutils literal"><span class="pre">M</span></code> with floating point elements, it is convenient to compute
the pseudoinverse by inverting only singular values above a given threshold,
<code class="docutils literal"><span class="pre">tol</span></code>.</p>
<p>The optimal choice of <code class="docutils literal"><span class="pre">tol</span></code> varies both with the value of <code class="docutils literal"><span class="pre">M</span></code>
and the intended application of the pseudoinverse. The default value of
<code class="docutils literal"><span class="pre">tol</span></code> is <code class="docutils literal"><span class="pre">eps(real(float(one(eltype(M)))))*maximum(size(A))</span></code>,
which is essentially machine epsilon for the real part of a matrix element
multiplied by the larger matrix dimension.
For inverting dense ill-conditioned matrices in a least-squares sense,
<code class="docutils literal"><span class="pre">tol</span> <span class="pre">=</span> <span class="pre">sqrt(eps(real(float(one(eltype(M))))))</span></code> is recommended.</p>
<p>For more information, see <a class="reference internal" href="#issue8859" id="id5">[issue8859]</a>, <a class="reference internal" href="#b96" id="id6">[B96]</a>, <a class="reference internal" href="#s84" id="id7">[S84]</a>, <a class="reference internal" href="#ky88" id="id8">[KY88]</a>.</p>
<table class="docutils citation" frame="void" id="issue8859" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[issue8859]</a></td><td>Issue 8859, &#8220;Fix least squares&#8221;, <a class="reference external" href="https://github.com/JuliaLang/julia/pull/8859">https://github.com/JuliaLang/julia/pull/8859</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="b96" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[B96]</a></td><td>Åke Björck, &#8220;Numerical Methods for Least Squares Problems&#8221;,
SIAM Press, Philadelphia, 1996, &#8220;Other Titles in Applied Mathematics&#8221;, Vol. 51.
<a class="reference external" href="http://epubs.siam.org/doi/book/10.1137/1.9781611971484">doi:10.1137/1.9781611971484</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="s84" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7">[S84]</a></td><td>G. W. Stewart, &#8220;Rank Degeneracy&#8221;, SIAM Journal on
Scientific and Statistical Computing, 5(2), 1984, 403-413.
<a class="reference external" href="http://epubs.siam.org/doi/abs/10.1137/0905030">doi:10.1137/0905030</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="ky88" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8">[KY88]</a></td><td>Konstantinos Konstantinides and Kung Yao, &#8220;Statistical analysis
of effective singular values in matrix rank determination&#8221;, IEEE
Transactions on Acoustics, Speech and Signal Processing, 36(5), 1988,
757-763.
<a class="reference external" href="http://dx.doi.org/10.1109/29.1585">doi:10.1109/29.1585</a></td></tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Base.nullspace">
<code class="descname">nullspace</code><span class="sig-paren">(</span><em>M</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.nullspace" title="Permalink to this definition">¶</a></dt>
<dd><p>Basis for nullspace of <code class="docutils literal"><span class="pre">M</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.repmat">
<code class="descname">repmat</code><span class="sig-paren">(</span><em>A</em>, <em>n</em>, <em>m</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.repmat" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a matrix by repeating the given matrix <code class="docutils literal"><span class="pre">n</span></code> times in dimension 1 and <code class="docutils literal"><span class="pre">m</span></code> times in dimension 2.</p>
</dd></dl>

<dl class="function">
<dt id="Base.repeat">
<code class="descname">repeat</code><span class="sig-paren">(</span><em>A</em>, <em>inner = Int[]</em>, <em>outer = Int[]</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.repeat" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct an array by repeating the entries of <code class="docutils literal"><span class="pre">A</span></code>. The i-th element of <code class="docutils literal"><span class="pre">inner</span></code> specifies the number of times that the individual entries of the i-th dimension of <code class="docutils literal"><span class="pre">A</span></code> should be repeated. The i-th element of <code class="docutils literal"><span class="pre">outer</span></code> specifies the number of times that a slice along the i-th dimension of <code class="docutils literal"><span class="pre">A</span></code> should be repeated.</p>
</dd></dl>

<dl class="function">
<dt id="Base.kron">
<code class="descname">kron</code><span class="sig-paren">(</span><em>A</em>, <em>B</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.kron" title="Permalink to this definition">¶</a></dt>
<dd><p>Kronecker tensor product of two vectors or two matrices.</p>
</dd></dl>

<dl class="function">
<dt id="Base.blkdiag">
<code class="descname">blkdiag</code><span class="sig-paren">(</span><em>A...</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.blkdiag" title="Permalink to this definition">¶</a></dt>
<dd><p>Concatenate matrices block-diagonally. Currently only implemented for sparse matrices.</p>
</dd></dl>

<dl class="function">
<dt id="Base.linreg">
<code class="descname">linreg</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span> &rarr; a, b<a class="headerlink" href="#Base.linreg" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform linear regression. Returns <code class="docutils literal"><span class="pre">a</span></code> and <code class="docutils literal"><span class="pre">b</span></code> such that <code class="docutils literal"><span class="pre">a</span> <span class="pre">+</span> <span class="pre">b*x</span></code> is the closest straight line to the given points <code class="docutils literal"><span class="pre">(x,</span> <span class="pre">y)</span></code>, i.e., such that the squared error between <code class="docutils literal"><span class="pre">y</span></code> and <code class="docutils literal"><span class="pre">a</span> <span class="pre">+</span> <span class="pre">b*x</span></code> is minimized.</p>
<p><strong>Example</strong>:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="n">PyPlot</span>
<span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="o">:</span><span class="mf">12.0</span><span class="p">;]</span>
<span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="mf">5.5</span><span class="p">,</span> <span class="mf">6.3</span><span class="p">,</span> <span class="mf">7.6</span><span class="p">,</span> <span class="mf">8.8</span><span class="p">,</span> <span class="mf">10.9</span><span class="p">,</span> <span class="mf">11.79</span><span class="p">,</span> <span class="mf">13.48</span><span class="p">,</span> <span class="mf">15.02</span><span class="p">,</span> <span class="mf">17.77</span><span class="p">,</span> <span class="mf">20.81</span><span class="p">,</span> <span class="mf">22.0</span><span class="p">,</span> <span class="mf">22.99</span><span class="p">]</span>
<span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">linreg</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>          <span class="c"># Linear regression</span>
<span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s">&quot;o&quot;</span><span class="p">)</span>              <span class="c"># Plot (x, y) points</span>
<span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">[</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="o">*</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="kp">in</span> <span class="n">x</span><span class="p">])</span>  <span class="c"># Plot line determined by linear regression</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">linreg</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>w</em><span class="sig-paren">)</span></dt>
<dd><p>Weighted least-squares linear regression.</p>
</dd></dl>

<dl class="function">
<dt id="Base.expm">
<code class="descname">expm</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.expm" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the matrix exponential of <code class="docutils literal"><span class="pre">A</span></code>, defined by</p>
<div class="math">
\[e^A = \sum_{n=0}^{\infty} \frac{A^n}{n!}.\]</div>
<p>For symmetric or Hermitian <code class="docutils literal"><span class="pre">A</span></code>, an eigendecomposition (<a class="reference internal" href="#Base.eigfact" title="Base.eigfact"><code class="xref jl jl-func docutils literal"><span class="pre">eigfact()</span></code></a>) is used, otherwise the scaling and squaring algorithm (see <a class="reference internal" href="#h05" id="id9">[H05]</a>) is chosen.</p>
<table class="docutils citation" frame="void" id="h05" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id9">[H05]</a></td><td>Nicholas J. Higham, &#8220;The squaring and scaling method for the matrix
exponential revisited&#8221;, SIAM Journal on Matrix Analysis and Applications,
26(4), 2005, 1179-1193.
<a class="reference external" href="http://dx.doi.org/10.1137/090768539">doi:10.1137/090768539</a></td></tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Base.logm">
<code class="descname">logm</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.logm" title="Permalink to this definition">¶</a></dt>
<dd><p>If <code class="docutils literal"><span class="pre">A</span></code> has no negative real eigenvalue, compute the principal matrix logarithm of <code class="docutils literal"><span class="pre">A</span></code>, i.e. the unique matrix <span class="math">\(X\)</span> such that <span class="math">\(e^X = A\)</span> and <span class="math">\(-\pi &lt; Im(\lambda) &lt; \pi\)</span> for all the eigenvalues <span class="math">\(\lambda\)</span> of <span class="math">\(X\)</span>. If <code class="docutils literal"><span class="pre">A</span></code> has nonpositive eigenvalues, a warning is printed and whenever possible a nonprincipal matrix function is returned.</p>
<p>If <code class="docutils literal"><span class="pre">A</span></code> is symmetric or Hermitian, its eigendecomposition (<a class="reference internal" href="#Base.eigfact" title="Base.eigfact"><code class="xref jl jl-func docutils literal"><span class="pre">eigfact()</span></code></a>) is used, if <code class="docutils literal"><span class="pre">A</span></code> is triangular an improved version of the inverse scaling and squaring method is employed (see <a class="reference internal" href="#ah12" id="id10">[AH12]</a> and <a class="reference internal" href="#ahr13" id="id11">[AHR13]</a>). For general matrices, the complex Schur form (<a class="reference internal" href="#Base.schur" title="Base.schur"><code class="xref jl jl-func docutils literal"><span class="pre">schur()</span></code></a>) is computed and the triangular algorithm is used on the triangular factor.</p>
<table class="docutils citation" frame="void" id="ah12" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id10">[AH12]</a></td><td>Awad H. Al-Mohy and Nicholas J. Higham, &#8220;Improved inverse  scaling
and squaring algorithms for the matrix logarithm&#8221;, SIAM Journal on
Scientific Computing, 34(4), 2012, C153-C169.
<a class="reference external" href="http://dx.doi.org/10.1137/110852553">doi:10.1137/110852553</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="ahr13" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id11">[AHR13]</a></td><td>Awad H. Al-Mohy, Nicholas J. Higham and Samuel D. Relton,
&#8220;Computing the Fréchet derivative of the matrix logarithm and estimating
the condition number&#8221;, SIAM Journal on Scientific Computing, 35(4), 2013,
C394-C410.
<a class="reference external" href="http://dx.doi.org/10.1137/120885991">doi:10.1137/120885991</a></td></tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Base.sqrtm">
<code class="descname">sqrtm</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.sqrtm" title="Permalink to this definition">¶</a></dt>
<dd><p>If <code class="docutils literal"><span class="pre">A</span></code> has no negative real eigenvalues, compute the principal matrix square root of <code class="docutils literal"><span class="pre">A</span></code>, that is the unique matrix <span class="math">\(X\)</span> with eigenvalues having positive real part such that <span class="math">\(X^2 = A\)</span>. Otherwise, a nonprincipal square root is returned.</p>
<p>If <code class="docutils literal"><span class="pre">A</span></code> is symmetric or Hermitian, its eigendecomposition (<a class="reference internal" href="#Base.eigfact" title="Base.eigfact"><code class="xref jl jl-func docutils literal"><span class="pre">eigfact()</span></code></a>) is used to compute the square root. Otherwise, the square root is determined by means of the Björck-Hammarling method, which computes the complex Schur form (<a class="reference internal" href="#Base.schur" title="Base.schur"><code class="xref jl jl-func docutils literal"><span class="pre">schur()</span></code></a>) and then the complex square root of the triangular factor.</p>
<table class="docutils citation" frame="void" id="bh83" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[BH83]</td><td>Åke Björck and Sven Hammarling, &#8220;A Schur method for the square root
of a matrix&#8221;, Linear Algebra and its Applications, 52-53, 1983, 127-140.
<a class="reference external" href="http://dx.doi.org/10.1016/0024-3795(83)80010-X">doi:10.1016/0024-3795(83)80010-X</a></td></tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Base.lyap">
<code class="descname">lyap</code><span class="sig-paren">(</span><em>A</em>, <em>C</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.lyap" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the solution <code class="docutils literal"><span class="pre">X</span></code> to the continuous Lyapunov equation <code class="docutils literal"><span class="pre">AX</span> <span class="pre">+</span> <span class="pre">XA'</span> <span class="pre">+</span> <span class="pre">C</span> <span class="pre">=</span> <span class="pre">0</span></code>, where no eigenvalue of <code class="docutils literal"><span class="pre">A</span></code> has a zero real part and no two eigenvalues are negative complex conjugates of each other.</p>
</dd></dl>

<dl class="function">
<dt id="Base.sylvester">
<code class="descname">sylvester</code><span class="sig-paren">(</span><em>A</em>, <em>B</em>, <em>C</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.sylvester" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the solution <code class="docutils literal"><span class="pre">X</span></code> to the Sylvester equation <code class="docutils literal"><span class="pre">AX</span> <span class="pre">+</span> <span class="pre">XB</span> <span class="pre">+</span> <span class="pre">C</span> <span class="pre">=</span> <span class="pre">0</span></code>, where <code class="docutils literal"><span class="pre">A</span></code>, <code class="docutils literal"><span class="pre">B</span></code> and <code class="docutils literal"><span class="pre">C</span></code> have compatible dimensions and <code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">-B</span></code> have no eigenvalues with equal real part.</p>
</dd></dl>

<dl class="function">
<dt id="Base.issym">
<code class="descname">issym</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span> &rarr; Bool<a class="headerlink" href="#Base.issym" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether a matrix is symmetric.</p>
</dd></dl>

<dl class="function">
<dt id="Base.isposdef">
<code class="descname">isposdef</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span> &rarr; Bool<a class="headerlink" href="#Base.isposdef" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether a matrix is positive definite.</p>
</dd></dl>

<dl class="function">
<dt id="Base.isposdef!">
<code class="descname">isposdef!</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span> &rarr; Bool<a class="headerlink" href="#Base.isposdef!" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether a matrix is positive definite, overwriting <code class="docutils literal"><span class="pre">A</span></code> in the processes.</p>
</dd></dl>

<dl class="function">
<dt id="Base.istril">
<code class="descname">istril</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span> &rarr; Bool<a class="headerlink" href="#Base.istril" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether a matrix is lower triangular.</p>
</dd></dl>

<dl class="function">
<dt id="Base.istriu">
<code class="descname">istriu</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span> &rarr; Bool<a class="headerlink" href="#Base.istriu" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether a matrix is upper triangular.</p>
</dd></dl>

<dl class="function">
<dt id="Base.isdiag">
<code class="descname">isdiag</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span> &rarr; Bool<a class="headerlink" href="#Base.isdiag" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether a matrix is diagonal.</p>
</dd></dl>

<dl class="function">
<dt id="Base.ishermitian">
<code class="descname">ishermitian</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span> &rarr; Bool<a class="headerlink" href="#Base.ishermitian" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether a matrix is Hermitian.</p>
</dd></dl>

<dl class="function">
<dt id="Base.transpose">
<code class="descname">transpose</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.transpose" title="Permalink to this definition">¶</a></dt>
<dd><p>The transposition operator (<code class="docutils literal"><span class="pre">.'</span></code>).</p>
</dd></dl>

<dl class="function">
<dt id="Base.transpose!">
<code class="descname">transpose!</code><span class="sig-paren">(</span><em>dest</em>, <em>src</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.transpose!" title="Permalink to this definition">¶</a></dt>
<dd><p>Transpose array <code class="docutils literal"><span class="pre">src</span></code> and store the result in the preallocated array <code class="docutils literal"><span class="pre">dest</span></code>, which should have a size corresponding to <code class="docutils literal"><span class="pre">(size(src,2),size(src,1))</span></code>. No in-place transposition is supported and unexpected results will happen if <code class="docutils literal"><span class="pre">src</span></code> and <code class="docutils literal"><span class="pre">dest</span></code> have overlapping memory regions.</p>
</dd></dl>

<dl class="function">
<dt id="Base.ctranspose">
<code class="descname">ctranspose</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.ctranspose" title="Permalink to this definition">¶</a></dt>
<dd><p>The conjugate transposition operator (<code class="docutils literal"><span class="pre">'</span></code>).</p>
</dd></dl>

<dl class="function">
<dt id="Base.ctranspose!">
<code class="descname">ctranspose!</code><span class="sig-paren">(</span><em>dest</em>, <em>src</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.ctranspose!" title="Permalink to this definition">¶</a></dt>
<dd><p>Conjugate transpose array <code class="docutils literal"><span class="pre">src</span></code> and store the result in the preallocated array <code class="docutils literal"><span class="pre">dest</span></code>, which should have a size corresponding to <code class="docutils literal"><span class="pre">(size(src,2),size(src,1))</span></code>. No in-place transposition is supported and unexpected results will happen if <code class="docutils literal"><span class="pre">src</span></code> and <code class="docutils literal"><span class="pre">dest</span></code> have overlapping memory regions.</p>
</dd></dl>

<dl class="function">
<dt id="Base.eigs">
<code class="descname">eigs</code><span class="sig-paren">(</span><em>A; nev=6</em>, <em>ncv=max(20</em>, <em>2*nev+1)</em>, <em>which=&quot;LM&quot;</em>, <em>tol=0.0</em>, <em>maxiter=300</em>, <em>sigma=nothing</em>, <em>ritzvec=true</em>, <em>v0=zeros((0</em>, <em>))</em><span class="sig-paren">)</span> &rarr; (d,[v,],nconv,niter,nmult,resid)<a class="headerlink" href="#Base.eigs" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes eigenvalues <code class="docutils literal"><span class="pre">d</span></code> of <code class="docutils literal"><span class="pre">A</span></code> using Lanczos or Arnoldi iterations for
real symmetric or general nonsymmetric matrices respectively.</p>
<p>The following keyword arguments are supported:</p>
<ul>
<li><p class="first"><code class="docutils literal"><span class="pre">nev</span></code>: Number of eigenvalues</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">ncv</span></code>: Number of Krylov vectors used in the computation; should satisfy <code class="docutils literal"><span class="pre">nev+1</span> <span class="pre">&lt;=</span> <span class="pre">ncv</span> <span class="pre">&lt;=</span> <span class="pre">n</span></code> for real symmetric problems and <code class="docutils literal"><span class="pre">nev+2</span> <span class="pre">&lt;=</span> <span class="pre">ncv</span> <span class="pre">&lt;=</span> <span class="pre">n</span></code> for other problems, where <code class="docutils literal"><span class="pre">n</span></code> is the size of the input matrix <code class="docutils literal"><span class="pre">A</span></code>. The default is <code class="docutils literal"><span class="pre">ncv</span> <span class="pre">=</span> <span class="pre">max(20,2*nev+1)</span></code>.
Note that these restrictions limit the input matrix <code class="docutils literal"><span class="pre">A</span></code> to be of dimension at least 2.</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">which</span></code>: type of eigenvalues to compute. See the note below.</p>
<table border="1" class="docutils">
<colgroup>
<col width="7%" />
<col width="93%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><code class="docutils literal"><span class="pre">which</span></code></th>
<th class="head">type of eigenvalues</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">:LM</span></code></td>
<td>eigenvalues of largest magnitude (default)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">:SM</span></code></td>
<td>eigenvalues of smallest magnitude</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">:LR</span></code></td>
<td>eigenvalues of largest real part</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">:SR</span></code></td>
<td>eigenvalues of smallest real part</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">:LI</span></code></td>
<td>eigenvalues of largest imaginary part (nonsymmetric or complex <code class="docutils literal"><span class="pre">A</span></code> only)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">:SI</span></code></td>
<td>eigenvalues of smallest imaginary part (nonsymmetric or complex <code class="docutils literal"><span class="pre">A</span></code> only)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">:BE</span></code></td>
<td>compute half of the eigenvalues from each end of the spectrum, biased in favor of the high end. (real symmetric <code class="docutils literal"><span class="pre">A</span></code> only)</td>
</tr>
</tbody>
</table>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">tol</span></code>: tolerance (<span class="math">\(tol \le 0.0\)</span> defaults to <code class="docutils literal"><span class="pre">DLAMCH('EPS')</span></code>)</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">maxiter</span></code>: Maximum number of iterations (default = 300)</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">sigma</span></code>: Specifies the level shift used in inverse iteration. If <code class="docutils literal"><span class="pre">nothing</span></code> (default), defaults to ordinary (forward) iterations. Otherwise, find eigenvalues close to <code class="docutils literal"><span class="pre">sigma</span></code> using shift and invert iterations.</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">ritzvec</span></code>: Returns the Ritz vectors <code class="docutils literal"><span class="pre">v</span></code> (eigenvectors) if <code class="docutils literal"><span class="pre">true</span></code></p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">v0</span></code>: starting vector from which to start the iterations</p>
</li>
</ul>
<p><code class="docutils literal"><span class="pre">eigs</span></code> returns the <code class="docutils literal"><span class="pre">nev</span></code> requested eigenvalues in <code class="docutils literal"><span class="pre">d</span></code>, the corresponding Ritz vectors <code class="docutils literal"><span class="pre">v</span></code> (only if <code class="docutils literal"><span class="pre">ritzvec=true</span></code>), the number of converged eigenvalues <code class="docutils literal"><span class="pre">nconv</span></code>, the number of iterations <code class="docutils literal"><span class="pre">niter</span></code> and the number of matrix vector multiplications <code class="docutils literal"><span class="pre">nmult</span></code>, as well as the final residual vector <code class="docutils literal"><span class="pre">resid</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>The <code class="docutils literal"><span class="pre">sigma</span></code> and <code class="docutils literal"><span class="pre">which</span></code> keywords interact: the description of eigenvalues searched for by <code class="docutils literal"><span class="pre">which</span></code> do _not_ necessarily refer to the eigenvalues of <code class="docutils literal"><span class="pre">A</span></code>, but rather the linear operator constructed by the specification of the iteration mode implied by <code class="docutils literal"><span class="pre">sigma</span></code>.</p>
<table border="1" class="last docutils">
<colgroup>
<col width="18%" />
<col width="41%" />
<col width="41%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><code class="docutils literal"><span class="pre">sigma</span></code></th>
<th class="head">iteration mode</th>
<th class="head"><code class="docutils literal"><span class="pre">which</span></code> refers to eigenvalues of</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">nothing</span></code></td>
<td>ordinary (forward)</td>
<td><span class="math">\(A\)</span></td>
</tr>
<tr class="row-odd"><td>real or complex</td>
<td>inverse with level shift <code class="docutils literal"><span class="pre">sigma</span></code></td>
<td><span class="math">\((A - \sigma I )^{-1}\)</span></td>
</tr>
</tbody>
</table>
</div>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">eigs</code><span class="sig-paren">(</span><em>A</em>, <em>B; nev=6</em>, <em>ncv=max(20</em>, <em>2*nev+1)</em>, <em>which=&quot;LM&quot;</em>, <em>tol=0.0</em>, <em>maxiter=300</em>, <em>sigma=nothing</em>, <em>ritzvec=true</em>, <em>v0=zeros((0</em>, <em>))</em><span class="sig-paren">)</span> &rarr; (d,[v,],nconv,niter,nmult,resid)</dt>
<dd><p>Computes generalized eigenvalues <code class="docutils literal"><span class="pre">d</span></code> of <code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">B</span></code> using Lanczos or Arnoldi iterations for
real symmetric or general nonsymmetric matrices respectively.</p>
<p>The following keyword arguments are supported:</p>
<ul>
<li><p class="first"><code class="docutils literal"><span class="pre">nev</span></code>: Number of eigenvalues</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">ncv</span></code>: Number of Krylov vectors used in the computation; should satisfy <code class="docutils literal"><span class="pre">nev+1</span> <span class="pre">&lt;=</span> <span class="pre">ncv</span> <span class="pre">&lt;=</span> <span class="pre">n</span></code> for real symmetric problems and <code class="docutils literal"><span class="pre">nev+2</span> <span class="pre">&lt;=</span> <span class="pre">ncv</span> <span class="pre">&lt;=</span> <span class="pre">n</span></code> for other problems, where <code class="docutils literal"><span class="pre">n</span></code> is the size of the input matrices <code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">B</span></code>. The default is <code class="docutils literal"><span class="pre">ncv</span> <span class="pre">=</span> <span class="pre">max(20,2*nev+1)</span></code>.
Note that these restrictions limit the input matrix <code class="docutils literal"><span class="pre">A</span></code> to be of dimension at least 2.</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">which</span></code>: type of eigenvalues to compute. See the note below.</p>
<table border="1" class="docutils">
<colgroup>
<col width="7%" />
<col width="93%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><code class="docutils literal"><span class="pre">which</span></code></th>
<th class="head">type of eigenvalues</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">:LM</span></code></td>
<td>eigenvalues of largest magnitude (default)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">:SM</span></code></td>
<td>eigenvalues of smallest magnitude</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">:LR</span></code></td>
<td>eigenvalues of largest real part</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">:SR</span></code></td>
<td>eigenvalues of smallest real part</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">:LI</span></code></td>
<td>eigenvalues of largest imaginary part (nonsymmetric or complex <code class="docutils literal"><span class="pre">A</span></code> only)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">:SI</span></code></td>
<td>eigenvalues of smallest imaginary part (nonsymmetric or complex <code class="docutils literal"><span class="pre">A</span></code> only)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">:BE</span></code></td>
<td>compute half of the eigenvalues from each end of the spectrum, biased in favor of the high end. (real symmetric <code class="docutils literal"><span class="pre">A</span></code> only)</td>
</tr>
</tbody>
</table>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">tol</span></code>: tolerance (<span class="math">\(tol \le 0.0\)</span> defaults to <code class="docutils literal"><span class="pre">DLAMCH('EPS')</span></code>)</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">maxiter</span></code>: Maximum number of iterations (default = 300)</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">sigma</span></code>: Specifies the level shift used in inverse iteration. If <code class="docutils literal"><span class="pre">nothing</span></code> (default), defaults to ordinary (forward) iterations. Otherwise, find eigenvalues close to <code class="docutils literal"><span class="pre">sigma</span></code> using shift and invert iterations.</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">ritzvec</span></code>: Returns the Ritz vectors <code class="docutils literal"><span class="pre">v</span></code> (eigenvectors) if <code class="docutils literal"><span class="pre">true</span></code></p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">v0</span></code>: starting vector from which to start the iterations</p>
</li>
</ul>
<p><code class="docutils literal"><span class="pre">eigs</span></code> returns the <code class="docutils literal"><span class="pre">nev</span></code> requested eigenvalues in <code class="docutils literal"><span class="pre">d</span></code>, the corresponding Ritz vectors <code class="docutils literal"><span class="pre">v</span></code> (only if <code class="docutils literal"><span class="pre">ritzvec=true</span></code>), the number of converged eigenvalues <code class="docutils literal"><span class="pre">nconv</span></code>, the number of iterations <code class="docutils literal"><span class="pre">niter</span></code> and the number of matrix vector multiplications <code class="docutils literal"><span class="pre">nmult</span></code>, as well as the final residual vector <code class="docutils literal"><span class="pre">resid</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>The <code class="docutils literal"><span class="pre">sigma</span></code> and <code class="docutils literal"><span class="pre">which</span></code> keywords interact: the description of eigenvalues searched for by <code class="docutils literal"><span class="pre">which</span></code> do _not_ necessarily refer to the eigenvalue problem <span class="math">\(Av = Bv\lambda\)</span>, but rather the linear operator constructed by the specification of the iteration mode implied by <code class="docutils literal"><span class="pre">sigma</span></code>.</p>
<table border="1" class="last docutils">
<colgroup>
<col width="18%" />
<col width="40%" />
<col width="42%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><code class="docutils literal"><span class="pre">sigma</span></code></th>
<th class="head">iteration mode</th>
<th class="head"><code class="docutils literal"><span class="pre">which</span></code> refers to the problem</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">nothing</span></code></td>
<td>ordinary (forward)</td>
<td><span class="math">\(Av = Bv\lambda\)</span></td>
</tr>
<tr class="row-odd"><td>real or complex</td>
<td>inverse with level shift <code class="docutils literal"><span class="pre">sigma</span></code></td>
<td><span class="math">\((A - \sigma B )^{-1}B = v\nu\)</span></td>
</tr>
</tbody>
</table>
</div>
</dd></dl>

<dl class="function">
<dt id="Base.svds">
<code class="descname">svds</code><span class="sig-paren">(</span><em>A; nsv=6</em>, <em>ritzvec=true</em>, <em>tol=0.0</em>, <em>maxiter=1000</em><span class="sig-paren">)</span> &rarr; (left_sv, s, right_sv, nconv, niter, nmult, resid)<a class="headerlink" href="#Base.svds" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal"><span class="pre">svds</span></code> computes largest singular values <code class="docutils literal"><span class="pre">s</span></code> of <code class="docutils literal"><span class="pre">A</span></code> using Lanczos or Arnoldi iterations.
Uses <a class="reference internal" href="#Base.eigs" title="Base.eigs"><code class="xref jl jl-func docutils literal"><span class="pre">eigs()</span></code></a> underneath.</p>
<p>Inputs are:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">A</span></code>: Linear operator. It can either subtype of <code class="docutils literal"><span class="pre">AbstractArray</span></code> (e.g., sparse matrix) or duck typed. For duck typing <code class="docutils literal"><span class="pre">A</span></code> has to support <code class="docutils literal"><span class="pre">size(A)</span></code>, <code class="docutils literal"><span class="pre">eltype(A)</span></code>, <code class="docutils literal"><span class="pre">A</span> <span class="pre">*</span> <span class="pre">vector</span></code> and <code class="docutils literal"><span class="pre">A'</span> <span class="pre">*</span> <span class="pre">vector</span></code>.</li>
<li><code class="docutils literal"><span class="pre">nsv</span></code>: Number of singular values.</li>
<li><code class="docutils literal"><span class="pre">ritzvec</span></code>: Whether to return the left and right singular vectors <code class="docutils literal"><span class="pre">left_sv</span></code> and <code class="docutils literal"><span class="pre">right_sv</span></code>, default is <code class="docutils literal"><span class="pre">true</span></code>. If <code class="docutils literal"><span class="pre">false</span></code> the singular vectors are omitted from the output.</li>
<li><code class="docutils literal"><span class="pre">tol</span></code>: tolerance, see <a class="reference internal" href="#Base.eigs" title="Base.eigs"><code class="xref jl jl-func docutils literal"><span class="pre">eigs()</span></code></a>.</li>
<li><code class="docutils literal"><span class="pre">maxiter</span></code>: Maximum number of iterations, see <a class="reference internal" href="#Base.eigs" title="Base.eigs"><code class="xref jl jl-func docutils literal"><span class="pre">eigs()</span></code></a>.</li>
</ul>
<p><strong>Example</strong>:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">X</span> <span class="o">=</span> <span class="n">sprand</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">)</span>
<span class="n">svds</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">nsv</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="Base.peakflops">
<code class="descname">peakflops</code><span class="sig-paren">(</span><em>n; parallel=false</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.peakflops" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal"><span class="pre">peakflops</span></code> computes the peak flop rate of the computer by using double precision <a class="reference internal" href="#Base.LinAlg.BLAS.gemm!" title="Base.LinAlg.BLAS.gemm!"><code class="xref jl jl-func docutils literal"><span class="pre">Base.LinAlg.BLAS.gemm!()</span></code></a>. By default, if no arguments are specified, it multiplies a matrix of size <code class="docutils literal"><span class="pre">n</span> <span class="pre">x</span> <span class="pre">n</span></code>, where <code class="docutils literal"><span class="pre">n</span> <span class="pre">=</span> <span class="pre">2000</span></code>. If the underlying BLAS is using multiple threads, higher flop rates are realized. The number of BLAS threads can be set with <code class="docutils literal"><span class="pre">blas_set_num_threads(n)</span></code>.</p>
<p>If the keyword argument <code class="docutils literal"><span class="pre">parallel</span></code> is set to <code class="docutils literal"><span class="pre">true</span></code>, <code class="docutils literal"><span class="pre">peakflops</span></code> is run in parallel on all the worker processors. The flop rate of the entire parallel computer is returned. When running in parallel, only 1 BLAS thread is used. The argument <code class="docutils literal"><span class="pre">n</span></code> still refers to the size of the problem that is solved on each processor.</p>
</dd></dl>

</div>
<div class="section" id="module-Base.LinAlg.BLAS">
<span id="blas-functions"></span><h2>BLAS Functions<a class="headerlink" href="#module-Base.LinAlg.BLAS" title="Permalink to this headline">¶</a></h2>
<p><a class="reference internal" href="#module-Base.LinAlg.BLAS" title="Base.LinAlg.BLAS"><code class="xref jl jl-mod docutils literal"><span class="pre">Base.LinAlg.BLAS</span></code></a> provides wrappers for some of the BLAS functions for
linear algebra.  Those BLAS functions that overwrite one of the input
arrays have names ending in <code class="docutils literal"><span class="pre">'!'</span></code>.</p>
<p>Usually a function has 4 methods defined, one each for <code class="docutils literal"><span class="pre">Float64</span></code>,
<code class="docutils literal"><span class="pre">Float32</span></code>, <code class="docutils literal"><span class="pre">Complex128</span></code> and <code class="docutils literal"><span class="pre">Complex64</span></code> arrays.</p>
<dl class="function">
<dt id="Base.LinAlg.BLAS.dot">
<code class="descname">dot</code><span class="sig-paren">(</span><em>n</em>, <em>X</em>, <em>incx</em>, <em>Y</em>, <em>incy</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.BLAS.dot" title="Permalink to this definition">¶</a></dt>
<dd><p>Dot product of two vectors consisting of <code class="docutils literal"><span class="pre">n</span></code> elements of array <code class="docutils literal"><span class="pre">X</span></code> with stride <code class="docutils literal"><span class="pre">incx</span></code> and <code class="docutils literal"><span class="pre">n</span></code> elements of array <code class="docutils literal"><span class="pre">Y</span></code> with stride <code class="docutils literal"><span class="pre">incy</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.dotu">
<code class="descname">dotu</code><span class="sig-paren">(</span><em>n</em>, <em>X</em>, <em>incx</em>, <em>Y</em>, <em>incy</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.BLAS.dotu" title="Permalink to this definition">¶</a></dt>
<dd><p>Dot function for two complex vectors.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.dotc">
<code class="descname">dotc</code><span class="sig-paren">(</span><em>n</em>, <em>X</em>, <em>incx</em>, <em>U</em>, <em>incy</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.BLAS.dotc" title="Permalink to this definition">¶</a></dt>
<dd><p>Dot function for two complex vectors conjugating the first vector.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.blascopy!">
<code class="descname">blascopy!</code><span class="sig-paren">(</span><em>n</em>, <em>X</em>, <em>incx</em>, <em>Y</em>, <em>incy</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.BLAS.blascopy!" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy <code class="docutils literal"><span class="pre">n</span></code> elements of array <code class="docutils literal"><span class="pre">X</span></code> with stride <code class="docutils literal"><span class="pre">incx</span></code> to array <code class="docutils literal"><span class="pre">Y</span></code> with stride <code class="docutils literal"><span class="pre">incy</span></code>. Returns <code class="docutils literal"><span class="pre">Y</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.nrm2">
<code class="descname">nrm2</code><span class="sig-paren">(</span><em>n</em>, <em>X</em>, <em>incx</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.BLAS.nrm2" title="Permalink to this definition">¶</a></dt>
<dd><p>2-norm of a vector consisting of <code class="docutils literal"><span class="pre">n</span></code> elements of array <code class="docutils literal"><span class="pre">X</span></code> with stride <code class="docutils literal"><span class="pre">incx</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.asum">
<code class="descname">asum</code><span class="sig-paren">(</span><em>n</em>, <em>X</em>, <em>incx</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.BLAS.asum" title="Permalink to this definition">¶</a></dt>
<dd><p>sum of the absolute values of the first <code class="docutils literal"><span class="pre">n</span></code> elements of array <code class="docutils literal"><span class="pre">X</span></code> with stride <code class="docutils literal"><span class="pre">incx</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.axpy!">
<code class="descname">axpy!</code><span class="sig-paren">(</span><em>a</em>, <em>X</em>, <em>Y</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.BLAS.axpy!" title="Permalink to this definition">¶</a></dt>
<dd><p>Overwrite <code class="docutils literal"><span class="pre">Y</span></code> with <code class="docutils literal"><span class="pre">a*X</span> <span class="pre">+</span> <span class="pre">Y</span></code>. Returns <code class="docutils literal"><span class="pre">Y</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.scal!">
<code class="descname">scal!</code><span class="sig-paren">(</span><em>n</em>, <em>a</em>, <em>X</em>, <em>incx</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.BLAS.scal!" title="Permalink to this definition">¶</a></dt>
<dd><p>Overwrite <code class="docutils literal"><span class="pre">X</span></code> with <code class="docutils literal"><span class="pre">a*X</span></code>. Returns <code class="docutils literal"><span class="pre">X</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.scal">
<code class="descname">scal</code><span class="sig-paren">(</span><em>n</em>, <em>a</em>, <em>X</em>, <em>incx</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.BLAS.scal" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">a*X</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.ger!">
<code class="descname">ger!</code><span class="sig-paren">(</span><em>alpha</em>, <em>x</em>, <em>y</em>, <em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.BLAS.ger!" title="Permalink to this definition">¶</a></dt>
<dd><p>Rank-1 update of the matrix <code class="docutils literal"><span class="pre">A</span></code> with vectors <code class="docutils literal"><span class="pre">x</span></code> and <code class="docutils literal"><span class="pre">y</span></code> as <code class="docutils literal"><span class="pre">alpha*x*y'</span> <span class="pre">+</span> <span class="pre">A</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.syr!">
<code class="descname">syr!</code><span class="sig-paren">(</span><em>uplo</em>, <em>alpha</em>, <em>x</em>, <em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.BLAS.syr!" title="Permalink to this definition">¶</a></dt>
<dd><p>Rank-1 update of the symmetric matrix <code class="docutils literal"><span class="pre">A</span></code> with vector <code class="docutils literal"><span class="pre">x</span></code> as <code class="docutils literal"><span class="pre">alpha*x*x.'</span> <span class="pre">+</span> <span class="pre">A</span></code>. When <code class="docutils literal"><span class="pre">uplo</span></code> is &#8216;U&#8217; the upper triangle of <code class="docutils literal"><span class="pre">A</span></code> is updated (&#8216;L&#8217; for lower triangle). Returns <code class="docutils literal"><span class="pre">A</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.syrk!">
<code class="descname">syrk!</code><span class="sig-paren">(</span><em>uplo</em>, <em>trans</em>, <em>alpha</em>, <em>A</em>, <em>beta</em>, <em>C</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.BLAS.syrk!" title="Permalink to this definition">¶</a></dt>
<dd><p>Rank-k update of the symmetric matrix <code class="docutils literal"><span class="pre">C</span></code> as <code class="docutils literal"><span class="pre">alpha*A*A.'</span> <span class="pre">+</span> <span class="pre">beta*C</span></code> or <code class="docutils literal"><span class="pre">alpha*A.'*A</span> <span class="pre">+</span> <span class="pre">beta*C</span></code> according to whether <code class="docutils literal"><span class="pre">trans</span></code> is &#8216;N&#8217; or &#8216;T&#8217;. When <code class="docutils literal"><span class="pre">uplo</span></code> is &#8216;U&#8217; the upper triangle of <code class="docutils literal"><span class="pre">C</span></code> is updated (&#8216;L&#8217; for lower triangle). Returns <code class="docutils literal"><span class="pre">C</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.syrk">
<code class="descname">syrk</code><span class="sig-paren">(</span><em>uplo</em>, <em>trans</em>, <em>alpha</em>, <em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.BLAS.syrk" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns either the upper triangle or the lower triangle, according to <code class="docutils literal"><span class="pre">uplo</span></code> (&#8216;U&#8217; or &#8216;L&#8217;), of <code class="docutils literal"><span class="pre">alpha*A*A.'</span></code> or <code class="docutils literal"><span class="pre">alpha*A.'*A</span></code>, according to <code class="docutils literal"><span class="pre">trans</span></code> (&#8216;N&#8217; or &#8216;T&#8217;).</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.her!">
<code class="descname">her!</code><span class="sig-paren">(</span><em>uplo</em>, <em>alpha</em>, <em>x</em>, <em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.BLAS.her!" title="Permalink to this definition">¶</a></dt>
<dd><p>Methods for complex arrays only. Rank-1 update of the Hermitian matrix <code class="docutils literal"><span class="pre">A</span></code> with vector <code class="docutils literal"><span class="pre">x</span></code> as <code class="docutils literal"><span class="pre">alpha*x*x'</span> <span class="pre">+</span> <span class="pre">A</span></code>. When <code class="docutils literal"><span class="pre">uplo</span></code> is &#8216;U&#8217; the upper triangle of <code class="docutils literal"><span class="pre">A</span></code> is updated (&#8216;L&#8217; for lower triangle). Returns <code class="docutils literal"><span class="pre">A</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.herk!">
<code class="descname">herk!</code><span class="sig-paren">(</span><em>uplo</em>, <em>trans</em>, <em>alpha</em>, <em>A</em>, <em>beta</em>, <em>C</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.BLAS.herk!" title="Permalink to this definition">¶</a></dt>
<dd><p>Methods for complex arrays only. Rank-k update of the Hermitian matrix <code class="docutils literal"><span class="pre">C</span></code> as <code class="docutils literal"><span class="pre">alpha*A*A'</span> <span class="pre">+</span> <span class="pre">beta*C</span></code> or <code class="docutils literal"><span class="pre">alpha*A'*A</span> <span class="pre">+</span> <span class="pre">beta*C</span></code> according to whether <code class="docutils literal"><span class="pre">trans</span></code> is &#8216;N&#8217; or &#8216;T&#8217;. When <code class="docutils literal"><span class="pre">uplo</span></code> is &#8216;U&#8217; the upper triangle of <code class="docutils literal"><span class="pre">C</span></code> is updated (&#8216;L&#8217; for lower triangle). Returns <code class="docutils literal"><span class="pre">C</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.herk">
<code class="descname">herk</code><span class="sig-paren">(</span><em>uplo</em>, <em>trans</em>, <em>alpha</em>, <em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.BLAS.herk" title="Permalink to this definition">¶</a></dt>
<dd><p>Methods for complex arrays only. Returns either the upper triangle or the lower triangle, according to <code class="docutils literal"><span class="pre">uplo</span></code> (&#8216;U&#8217; or &#8216;L&#8217;), of <code class="docutils literal"><span class="pre">alpha*A*A'</span></code> or <code class="docutils literal"><span class="pre">alpha*A'*A</span></code>, according to <code class="docutils literal"><span class="pre">trans</span></code> (&#8216;N&#8217; or &#8216;T&#8217;).</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.gbmv!">
<code class="descname">gbmv!</code><span class="sig-paren">(</span><em>trans</em>, <em>m</em>, <em>kl</em>, <em>ku</em>, <em>alpha</em>, <em>A</em>, <em>x</em>, <em>beta</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.BLAS.gbmv!" title="Permalink to this definition">¶</a></dt>
<dd><p>Update vector <code class="docutils literal"><span class="pre">y</span></code> as <code class="docutils literal"><span class="pre">alpha*A*x</span> <span class="pre">+</span> <span class="pre">beta*y</span></code> or <code class="docutils literal"><span class="pre">alpha*A'*x</span> <span class="pre">+</span> <span class="pre">beta*y</span></code> according to <code class="docutils literal"><span class="pre">trans</span></code> (&#8216;N&#8217; or &#8216;T&#8217;). The matrix <code class="docutils literal"><span class="pre">A</span></code> is a general band matrix of dimension <code class="docutils literal"><span class="pre">m</span></code> by <code class="docutils literal"><span class="pre">size(A,2)</span></code> with <code class="docutils literal"><span class="pre">kl</span></code> sub-diagonals and <code class="docutils literal"><span class="pre">ku</span></code> super-diagonals. Returns the updated <code class="docutils literal"><span class="pre">y</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.gbmv">
<code class="descname">gbmv</code><span class="sig-paren">(</span><em>trans</em>, <em>m</em>, <em>kl</em>, <em>ku</em>, <em>alpha</em>, <em>A</em>, <em>x</em>, <em>beta</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.BLAS.gbmv" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">alpha*A*x</span></code> or <code class="docutils literal"><span class="pre">alpha*A'*x</span></code> according to <code class="docutils literal"><span class="pre">trans</span></code> (&#8216;N&#8217; or &#8216;T&#8217;). The matrix <code class="docutils literal"><span class="pre">A</span></code> is a general band matrix of dimension <code class="docutils literal"><span class="pre">m</span></code> by <code class="docutils literal"><span class="pre">size(A,2)</span></code> with <code class="docutils literal"><span class="pre">kl</span></code> sub-diagonals and <code class="docutils literal"><span class="pre">ku</span></code> super-diagonals.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.sbmv!">
<code class="descname">sbmv!</code><span class="sig-paren">(</span><em>uplo</em>, <em>k</em>, <em>alpha</em>, <em>A</em>, <em>x</em>, <em>beta</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.BLAS.sbmv!" title="Permalink to this definition">¶</a></dt>
<dd><p>Update vector <code class="docutils literal"><span class="pre">y</span></code> as <code class="docutils literal"><span class="pre">alpha*A*x</span> <span class="pre">+</span> <span class="pre">beta*y</span></code> where <code class="docutils literal"><span class="pre">A</span></code> is a a symmetric band matrix of order <code class="docutils literal"><span class="pre">size(A,2)</span></code> with <code class="docutils literal"><span class="pre">k</span></code> super-diagonals stored in the argument <code class="docutils literal"><span class="pre">A</span></code>. The storage layout for <code class="docutils literal"><span class="pre">A</span></code> is described the reference BLAS module, level-2 BLAS at &lt;<a class="reference external" href="http://www.netlib.org/lapack/explore-html/">http://www.netlib.org/lapack/explore-html/</a>&gt;.</p>
<p>Returns the updated <code class="docutils literal"><span class="pre">y</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.sbmv">
<code class="descname">sbmv</code><span class="sig-paren">(</span><em>uplo</em>, <em>k</em>, <em>alpha</em>, <em>A</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.BLAS.sbmv" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">alpha*A*x</span></code> where <code class="docutils literal"><span class="pre">A</span></code> is a symmetric band matrix of order <code class="docutils literal"><span class="pre">size(A,2)</span></code> with <code class="docutils literal"><span class="pre">k</span></code> super-diagonals stored in the argument <code class="docutils literal"><span class="pre">A</span></code>.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">sbmv</code><span class="sig-paren">(</span><em>uplo</em>, <em>k</em>, <em>A</em>, <em>x</em><span class="sig-paren">)</span></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">A*x</span></code> where <code class="docutils literal"><span class="pre">A</span></code> is a symmetric band matrix of order <code class="docutils literal"><span class="pre">size(A,2)</span></code> with <code class="docutils literal"><span class="pre">k</span></code> super-diagonals stored in the argument <code class="docutils literal"><span class="pre">A</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.gemm!">
<code class="descname">gemm!</code><span class="sig-paren">(</span><em>tA</em>, <em>tB</em>, <em>alpha</em>, <em>A</em>, <em>B</em>, <em>beta</em>, <em>C</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.BLAS.gemm!" title="Permalink to this definition">¶</a></dt>
<dd><p>Update <code class="docutils literal"><span class="pre">C</span></code> as <code class="docutils literal"><span class="pre">alpha*A*B</span> <span class="pre">+</span> <span class="pre">beta*C</span></code> or the other three variants according to <code class="docutils literal"><span class="pre">tA</span></code> (transpose <code class="docutils literal"><span class="pre">A</span></code>) and <code class="docutils literal"><span class="pre">tB</span></code>. Returns the updated <code class="docutils literal"><span class="pre">C</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.gemm">
<code class="descname">gemm</code><span class="sig-paren">(</span><em>tA</em>, <em>tB</em>, <em>alpha</em>, <em>A</em>, <em>B</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.BLAS.gemm" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">alpha*A*B</span></code> or the other three variants according to <code class="docutils literal"><span class="pre">tA</span></code> (transpose <code class="docutils literal"><span class="pre">A</span></code>) and <code class="docutils literal"><span class="pre">tB</span></code>.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">gemm</code><span class="sig-paren">(</span><em>tA</em>, <em>tB</em>, <em>A</em>, <em>B</em><span class="sig-paren">)</span></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">A*B</span></code> or the other three variants according to <code class="docutils literal"><span class="pre">tA</span></code> (transpose <code class="docutils literal"><span class="pre">A</span></code>) and <code class="docutils literal"><span class="pre">tB</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.gemv!">
<code class="descname">gemv!</code><span class="sig-paren">(</span><em>tA</em>, <em>alpha</em>, <em>A</em>, <em>x</em>, <em>beta</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.BLAS.gemv!" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the vector <code class="docutils literal"><span class="pre">y</span></code> as <code class="docutils literal"><span class="pre">alpha*A*x</span> <span class="pre">+</span> <span class="pre">beta*y</span></code> or <code class="docutils literal"><span class="pre">alpha*A'x</span> <span class="pre">+</span> <span class="pre">beta*y</span></code> according to <code class="docutils literal"><span class="pre">tA</span></code> (transpose <code class="docutils literal"><span class="pre">A</span></code>). Returns the updated <code class="docutils literal"><span class="pre">y</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.gemv">
<code class="descname">gemv</code><span class="sig-paren">(</span><em>tA</em>, <em>alpha</em>, <em>A</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.BLAS.gemv" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">alpha*A*x</span></code> or <code class="docutils literal"><span class="pre">alpha*A'x</span></code> according to <code class="docutils literal"><span class="pre">tA</span></code> (transpose <code class="docutils literal"><span class="pre">A</span></code>).</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">gemv</code><span class="sig-paren">(</span><em>tA</em>, <em>A</em>, <em>x</em><span class="sig-paren">)</span></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">A*x</span></code> or <code class="docutils literal"><span class="pre">A'x</span></code> according to <code class="docutils literal"><span class="pre">tA</span></code> (transpose <code class="docutils literal"><span class="pre">A</span></code>).</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.symm!">
<code class="descname">symm!</code><span class="sig-paren">(</span><em>side</em>, <em>ul</em>, <em>alpha</em>, <em>A</em>, <em>B</em>, <em>beta</em>, <em>C</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.BLAS.symm!" title="Permalink to this definition">¶</a></dt>
<dd><p>Update <code class="docutils literal"><span class="pre">C</span></code> as <code class="docutils literal"><span class="pre">alpha*A*B</span> <span class="pre">+</span> <span class="pre">beta*C</span></code> or <code class="docutils literal"><span class="pre">alpha*B*A</span> <span class="pre">+</span> <span class="pre">beta*C</span></code> according to <code class="docutils literal"><span class="pre">side</span></code>. <code class="docutils literal"><span class="pre">A</span></code> is assumed to be symmetric. Only the <code class="docutils literal"><span class="pre">ul</span></code> triangle of <code class="docutils literal"><span class="pre">A</span></code> is used. Returns the updated <code class="docutils literal"><span class="pre">C</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.symm">
<code class="descname">symm</code><span class="sig-paren">(</span><em>side</em>, <em>ul</em>, <em>alpha</em>, <em>A</em>, <em>B</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.BLAS.symm" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">alpha*A*B</span></code> or <code class="docutils literal"><span class="pre">alpha*B*A</span></code> according to <code class="docutils literal"><span class="pre">side</span></code>. <code class="docutils literal"><span class="pre">A</span></code> is assumed to be symmetric. Only the <code class="docutils literal"><span class="pre">ul</span></code> triangle of <code class="docutils literal"><span class="pre">A</span></code> is used.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">symm</code><span class="sig-paren">(</span><em>side</em>, <em>ul</em>, <em>A</em>, <em>B</em><span class="sig-paren">)</span></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">A*B</span></code> or <code class="docutils literal"><span class="pre">B*A</span></code> according to <code class="docutils literal"><span class="pre">side</span></code>. <code class="docutils literal"><span class="pre">A</span></code> is assumed to be symmetric. Only the <code class="docutils literal"><span class="pre">ul</span></code> triangle of <code class="docutils literal"><span class="pre">A</span></code> is used.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">symm</code><span class="sig-paren">(</span><em>tA</em>, <em>tB</em>, <em>alpha</em>, <em>A</em>, <em>B</em><span class="sig-paren">)</span></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">alpha*A*B</span></code> or the other three variants according to <code class="docutils literal"><span class="pre">tA</span></code> (transpose <code class="docutils literal"><span class="pre">A</span></code>) and <code class="docutils literal"><span class="pre">tB</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.symv!">
<code class="descname">symv!</code><span class="sig-paren">(</span><em>ul</em>, <em>alpha</em>, <em>A</em>, <em>x</em>, <em>beta</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.BLAS.symv!" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the vector <code class="docutils literal"><span class="pre">y</span></code> as <code class="docutils literal"><span class="pre">alpha*A*x</span> <span class="pre">+</span> <span class="pre">beta*y</span></code>. <code class="docutils literal"><span class="pre">A</span></code> is assumed to be symmetric. Only the <code class="docutils literal"><span class="pre">ul</span></code> triangle of <code class="docutils literal"><span class="pre">A</span></code> is used. Returns the updated <code class="docutils literal"><span class="pre">y</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.symv">
<code class="descname">symv</code><span class="sig-paren">(</span><em>ul</em>, <em>alpha</em>, <em>A</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.BLAS.symv" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">alpha*A*x</span></code>. <code class="docutils literal"><span class="pre">A</span></code> is assumed to be symmetric. Only the <code class="docutils literal"><span class="pre">ul</span></code> triangle of <code class="docutils literal"><span class="pre">A</span></code> is used.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">symv</code><span class="sig-paren">(</span><em>ul</em>, <em>A</em>, <em>x</em><span class="sig-paren">)</span></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">A*x</span></code>. <code class="docutils literal"><span class="pre">A</span></code> is assumed to be symmetric. Only the <code class="docutils literal"><span class="pre">ul</span></code> triangle of <code class="docutils literal"><span class="pre">A</span></code> is used.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.trmm!">
<code class="descname">trmm!</code><span class="sig-paren">(</span><em>side</em>, <em>ul</em>, <em>tA</em>, <em>dA</em>, <em>alpha</em>, <em>A</em>, <em>B</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.BLAS.trmm!" title="Permalink to this definition">¶</a></dt>
<dd><p>Update <code class="docutils literal"><span class="pre">B</span></code> as <code class="docutils literal"><span class="pre">alpha*A*B</span></code> or one of the other three variants determined by <code class="docutils literal"><span class="pre">side</span></code> (<code class="docutils literal"><span class="pre">A</span></code> on left or right) and <code class="docutils literal"><span class="pre">tA</span></code> (transpose <code class="docutils literal"><span class="pre">A</span></code>). Only the <code class="docutils literal"><span class="pre">ul</span></code> triangle of <code class="docutils literal"><span class="pre">A</span></code> is used. <code class="docutils literal"><span class="pre">dA</span></code> indicates if <code class="docutils literal"><span class="pre">A</span></code> is unit-triangular (the diagonal is assumed to be all ones). Returns the updated <code class="docutils literal"><span class="pre">B</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.trmm">
<code class="descname">trmm</code><span class="sig-paren">(</span><em>side</em>, <em>ul</em>, <em>tA</em>, <em>dA</em>, <em>alpha</em>, <em>A</em>, <em>B</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.BLAS.trmm" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">alpha*A*B</span></code> or one of the other three variants determined by <code class="docutils literal"><span class="pre">side</span></code> (<code class="docutils literal"><span class="pre">A</span></code> on left or right) and <code class="docutils literal"><span class="pre">tA</span></code> (transpose <code class="docutils literal"><span class="pre">A</span></code>). Only the <code class="docutils literal"><span class="pre">ul</span></code> triangle of <code class="docutils literal"><span class="pre">A</span></code> is used. <code class="docutils literal"><span class="pre">dA</span></code> indicates if <code class="docutils literal"><span class="pre">A</span></code> is unit-triangular (the diagonal is assumed to be all ones).</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.trsm!">
<code class="descname">trsm!</code><span class="sig-paren">(</span><em>side</em>, <em>ul</em>, <em>tA</em>, <em>dA</em>, <em>alpha</em>, <em>A</em>, <em>B</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.BLAS.trsm!" title="Permalink to this definition">¶</a></dt>
<dd><p>Overwrite <code class="docutils literal"><span class="pre">B</span></code> with the solution to <code class="docutils literal"><span class="pre">A*X</span> <span class="pre">=</span> <span class="pre">alpha*B</span></code> or one of the other three variants determined by <code class="docutils literal"><span class="pre">side</span></code> (<code class="docutils literal"><span class="pre">A</span></code> on left or right of <code class="docutils literal"><span class="pre">X</span></code>) and <code class="docutils literal"><span class="pre">tA</span></code> (transpose <code class="docutils literal"><span class="pre">A</span></code>). Only the <code class="docutils literal"><span class="pre">ul</span></code> triangle of <code class="docutils literal"><span class="pre">A</span></code> is used. <code class="docutils literal"><span class="pre">dA</span></code> indicates if <code class="docutils literal"><span class="pre">A</span></code> is unit-triangular (the diagonal is assumed to be all ones). Returns the updated <code class="docutils literal"><span class="pre">B</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.trsm">
<code class="descname">trsm</code><span class="sig-paren">(</span><em>side</em>, <em>ul</em>, <em>tA</em>, <em>dA</em>, <em>alpha</em>, <em>A</em>, <em>B</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.BLAS.trsm" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the solution to <code class="docutils literal"><span class="pre">A*X</span> <span class="pre">=</span> <span class="pre">alpha*B</span></code> or one of the other three variants determined by <code class="docutils literal"><span class="pre">side</span></code> (<code class="docutils literal"><span class="pre">A</span></code> on left or right of <code class="docutils literal"><span class="pre">X</span></code>) and <code class="docutils literal"><span class="pre">tA</span></code> (transpose <code class="docutils literal"><span class="pre">A</span></code>). Only the <code class="docutils literal"><span class="pre">ul</span></code> triangle of <code class="docutils literal"><span class="pre">A</span></code> is used. <code class="docutils literal"><span class="pre">dA</span></code> indicates if <code class="docutils literal"><span class="pre">A</span></code> is unit-triangular (the diagonal is assumed to be all ones).</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.trmv!">
<code class="descname">trmv!</code><span class="sig-paren">(</span><em>side</em>, <em>ul</em>, <em>tA</em>, <em>dA</em>, <em>alpha</em>, <em>A</em>, <em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.BLAS.trmv!" title="Permalink to this definition">¶</a></dt>
<dd><p>Update <code class="docutils literal"><span class="pre">b</span></code> as <code class="docutils literal"><span class="pre">alpha*A*b</span></code> or one of the other three variants determined by <code class="docutils literal"><span class="pre">side</span></code> (<code class="docutils literal"><span class="pre">A</span></code> on left or right) and <code class="docutils literal"><span class="pre">tA</span></code> (transpose <code class="docutils literal"><span class="pre">A</span></code>). Only the <code class="docutils literal"><span class="pre">ul</span></code> triangle of <code class="docutils literal"><span class="pre">A</span></code> is used. <code class="docutils literal"><span class="pre">dA</span></code> indicates if <code class="docutils literal"><span class="pre">A</span></code> is unit-triangular (the diagonal is assumed to be all ones). Returns the updated <code class="docutils literal"><span class="pre">b</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.trmv">
<code class="descname">trmv</code><span class="sig-paren">(</span><em>side</em>, <em>ul</em>, <em>tA</em>, <em>dA</em>, <em>alpha</em>, <em>A</em>, <em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.BLAS.trmv" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">alpha*A*b</span></code> or one of the other three variants determined by <code class="docutils literal"><span class="pre">side</span></code> (<code class="docutils literal"><span class="pre">A</span></code> on left or right) and <code class="docutils literal"><span class="pre">tA</span></code> (transpose <code class="docutils literal"><span class="pre">A</span></code>). Only the <code class="docutils literal"><span class="pre">ul</span></code> triangle of <code class="docutils literal"><span class="pre">A</span></code> is used. <code class="docutils literal"><span class="pre">dA</span></code> indicates if <code class="docutils literal"><span class="pre">A</span></code> is unit-triangular (the diagonal is assumed to be all ones).</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.trsv!">
<code class="descname">trsv!</code><span class="sig-paren">(</span><em>ul</em>, <em>tA</em>, <em>dA</em>, <em>A</em>, <em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.BLAS.trsv!" title="Permalink to this definition">¶</a></dt>
<dd><p>Overwrite <code class="docutils literal"><span class="pre">b</span></code> with the solution to <code class="docutils literal"><span class="pre">A*x</span> <span class="pre">=</span> <span class="pre">b</span></code> or one of the other two variants determined by <code class="docutils literal"><span class="pre">tA</span></code> (transpose <code class="docutils literal"><span class="pre">A</span></code>) and <code class="docutils literal"><span class="pre">ul</span></code> (triangle of <code class="docutils literal"><span class="pre">A</span></code> used). <code class="docutils literal"><span class="pre">dA</span></code> indicates if <code class="docutils literal"><span class="pre">A</span></code> is unit-triangular (the diagonal is assumed to be all ones). Returns the updated <code class="docutils literal"><span class="pre">b</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.trsv">
<code class="descname">trsv</code><span class="sig-paren">(</span><em>ul</em>, <em>tA</em>, <em>dA</em>, <em>A</em>, <em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.BLAS.trsv" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the solution to <code class="docutils literal"><span class="pre">A*x</span> <span class="pre">=</span> <span class="pre">b</span></code> or one of the other two variants determined by <code class="docutils literal"><span class="pre">tA</span></code> (transpose <code class="docutils literal"><span class="pre">A</span></code>) and <code class="docutils literal"><span class="pre">ul</span></code> (triangle of <code class="docutils literal"><span class="pre">A</span></code> is used.) <code class="docutils literal"><span class="pre">dA</span></code> indicates if <code class="docutils literal"><span class="pre">A</span></code> is unit-triangular (the diagonal is assumed to be all ones).</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.blas_set_num_threads">
<code class="descname">blas_set_num_threads</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.BLAS.blas_set_num_threads" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the number of threads the BLAS library should use.</p>
</dd></dl>

<dl class="data">
<dt id="Base.LinAlg.BLAS.I">
<code class="descname">I</code><a class="headerlink" href="#Base.LinAlg.BLAS.I" title="Permalink to this definition">¶</a></dt>
<dd><p>An object of type <code class="docutils literal"><span class="pre">UniformScaling</span></code>, representing an identity matrix of any size.</p>
</dd></dl>

</div>
<div class="section" id="module-Base.LinAlg.LAPACK">
<span id="lapack-functions"></span><h2>LAPACK Functions<a class="headerlink" href="#module-Base.LinAlg.LAPACK" title="Permalink to this headline">¶</a></h2>
<p><a class="reference internal" href="#module-Base.LinAlg.LAPACK" title="Base.LinAlg.LAPACK"><code class="xref jl jl-mod docutils literal"><span class="pre">Base.LinAlg.LAPACK</span></code></a> provides wrappers for some of the LAPACK functions for
linear algebra.  Those functions that overwrite one of the input
arrays have names ending in <code class="docutils literal"><span class="pre">'!'</span></code>.</p>
<p>Usually a function has 4 methods defined, one each for <code class="docutils literal"><span class="pre">Float64</span></code>,
<code class="docutils literal"><span class="pre">Float32</span></code>, <code class="docutils literal"><span class="pre">Complex128</span></code> and <code class="docutils literal"><span class="pre">Complex64</span></code> arrays.</p>
<p>Note that the LAPACK API provided by Julia can and will change in the future. Since
this API is not user-facing, there is no commitment to support/deprecate this specific
set of functions in future releases.</p>
<dl class="function">
<dt id="Base.LinAlg.LAPACK.gbtrf!">
<code class="descname">gbtrf!</code><span class="sig-paren">(</span><em>kl</em>, <em>ku</em>, <em>m</em>, <em>AB</em><span class="sig-paren">)</span> &rarr; (AB, ipiv)<a class="headerlink" href="#Base.LinAlg.LAPACK.gbtrf!" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the LU factorization of a banded matrix <code class="docutils literal"><span class="pre">AB</span></code>. <code class="docutils literal"><span class="pre">kl</span></code> is the first subdiagonal containing a nonzero band, <code class="docutils literal"><span class="pre">ku</span></code> is the last superdiagonal containing one, and <code class="docutils literal"><span class="pre">m</span></code> is the first dimension of the matrix <code class="docutils literal"><span class="pre">AB</span></code>. Returns the LU factorization in-place and <code class="docutils literal"><span class="pre">ipiv</span></code>, the vector of pivots used.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.gbtrs!">
<code class="descname">gbtrs!</code><span class="sig-paren">(</span><em>trans</em>, <em>kl</em>, <em>ku</em>, <em>m</em>, <em>AB</em>, <em>ipiv</em>, <em>B</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.LAPACK.gbtrs!" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve the equation <code class="docutils literal"><span class="pre">AB</span> <span class="pre">*</span> <span class="pre">X</span> <span class="pre">=</span> <span class="pre">B</span></code>. <code class="docutils literal"><span class="pre">trans</span></code> determines the orientation of <code class="docutils literal"><span class="pre">AB</span></code>. It may be <code class="docutils literal"><span class="pre">N</span></code> (no transpose), <code class="docutils literal"><span class="pre">T</span></code> (transpose), or <code class="docutils literal"><span class="pre">C</span></code> (conjugate transpose). <code class="docutils literal"><span class="pre">kl</span></code> is the first subdiagonal containing a nonzero band, <code class="docutils literal"><span class="pre">ku</span></code> is the last superdiagonal containing one, and <code class="docutils literal"><span class="pre">m</span></code> is the first dimension of the matrix <code class="docutils literal"><span class="pre">AB</span></code>. <code class="docutils literal"><span class="pre">ipiv</span></code> is the vector of pivots returned from <code class="docutils literal"><span class="pre">gbtrf!</span></code>. Returns the vector or matrix <code class="docutils literal"><span class="pre">X</span></code>, overwriting <code class="docutils literal"><span class="pre">B</span></code> in-place.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.gebal!">
<code class="descname">gebal!</code><span class="sig-paren">(</span><em>job</em>, <em>A</em><span class="sig-paren">)</span> &rarr; (ilo, ihi, scale)<a class="headerlink" href="#Base.LinAlg.LAPACK.gebal!" title="Permalink to this definition">¶</a></dt>
<dd><p>Balance the matrix <code class="docutils literal"><span class="pre">A</span></code> before computing its eigensystem or Schur factorization. <code class="docutils literal"><span class="pre">job</span></code> can be one of <code class="docutils literal"><span class="pre">N</span></code> (<code class="docutils literal"><span class="pre">A</span></code> will not be permuted or scaled), <code class="docutils literal"><span class="pre">P</span></code> (<code class="docutils literal"><span class="pre">A</span></code> will only be permuted), <code class="docutils literal"><span class="pre">S</span></code> (<code class="docutils literal"><span class="pre">A</span></code> will only be scaled), or <code class="docutils literal"><span class="pre">B</span></code> (<code class="docutils literal"><span class="pre">A</span></code> will be both permuted and scaled). Modifies <code class="docutils literal"><span class="pre">A</span></code> in-place and returns <code class="docutils literal"><span class="pre">ilo</span></code>, <code class="docutils literal"><span class="pre">ihi</span></code>, and <code class="docutils literal"><span class="pre">scale</span></code>. If permuting was turned on, <code class="docutils literal"><span class="pre">A[i,j]</span> <span class="pre">=</span> <span class="pre">0</span></code> if <code class="docutils literal"><span class="pre">j</span> <span class="pre">&gt;</span> <span class="pre">i</span></code> and <code class="docutils literal"><span class="pre">1</span> <span class="pre">&lt;</span> <span class="pre">j</span> <span class="pre">&lt;</span> <span class="pre">ilo</span></code> or <code class="docutils literal"><span class="pre">j</span> <span class="pre">&gt;</span> <span class="pre">ihi</span></code>. <code class="docutils literal"><span class="pre">scale</span></code> contains information about the scaling/permutations performed.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.gebak!">
<code class="descname">gebak!</code><span class="sig-paren">(</span><em>job</em>, <em>side</em>, <em>ilo</em>, <em>ihi</em>, <em>scale</em>, <em>V</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.LAPACK.gebak!" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform the eigenvectors <code class="docutils literal"><span class="pre">V</span></code> of a matrix balanced using <code class="docutils literal"><span class="pre">gebal!</span></code> to the unscaled/unpermuted eigenvectors of the original matrix. Modifies <code class="docutils literal"><span class="pre">V</span></code> in-place. <code class="docutils literal"><span class="pre">side</span></code> can be <code class="docutils literal"><span class="pre">L</span></code> (left eigenvectors are transformed) or <code class="docutils literal"><span class="pre">R</span></code> (right eigenvectors are transformed).</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.gebrd!">
<code class="descname">gebrd!</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span> &rarr; (A, d, e, tauq, taup)<a class="headerlink" href="#Base.LinAlg.LAPACK.gebrd!" title="Permalink to this definition">¶</a></dt>
<dd><p>Reduce <code class="docutils literal"><span class="pre">A</span></code> in-place to bidiagonal form <code class="docutils literal"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">QBP'</span></code>. Returns <code class="docutils literal"><span class="pre">A</span></code>, containing the bidiagonal matrix <code class="docutils literal"><span class="pre">B</span></code>; <code class="docutils literal"><span class="pre">d</span></code>, containing the diagonal elements of <code class="docutils literal"><span class="pre">B</span></code>; <code class="docutils literal"><span class="pre">e</span></code>, containing the off-diagonal elements of <code class="docutils literal"><span class="pre">B</span></code>; <code class="docutils literal"><span class="pre">tauq</span></code>, containing the elementary reflectors representing <code class="docutils literal"><span class="pre">Q</span></code>; and <code class="docutils literal"><span class="pre">taup</span></code>, containing the elementary reflectors representing <code class="docutils literal"><span class="pre">P</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.gelqf!">
<code class="descname">gelqf!</code><span class="sig-paren">(</span><em>A</em>, <em>tau</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.LAPACK.gelqf!" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the <code class="docutils literal"><span class="pre">LQ</span></code> factorization of <code class="docutils literal"><span class="pre">A</span></code>, <code class="docutils literal"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">LQ</span></code>. <code class="docutils literal"><span class="pre">tau</span></code> contains scalars which parameterize the elementary reflectors of the factorization. <code class="docutils literal"><span class="pre">tau</span></code> must have length greater than or equal to the smallest dimension of <code class="docutils literal"><span class="pre">A</span></code>.</p>
<p>Returns <code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">tau</span></code> modified in-place.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">gelqf!</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span> &rarr; (A, tau)</dt>
<dd><p>Compute the <code class="docutils literal"><span class="pre">LQ</span></code> factorization of <code class="docutils literal"><span class="pre">A</span></code>, <code class="docutils literal"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">LQ</span></code>.</p>
<p>Returns <code class="docutils literal"><span class="pre">A</span></code>, modified in-place, and <code class="docutils literal"><span class="pre">tau</span></code>, which contains scalars which parameterize the elementary reflectors of the factorization.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.geqlf!">
<code class="descname">geqlf!</code><span class="sig-paren">(</span><em>A</em>, <em>tau</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.LAPACK.geqlf!" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the <code class="docutils literal"><span class="pre">QL</span></code> factorization of <code class="docutils literal"><span class="pre">A</span></code>, <code class="docutils literal"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">QL</span></code>. <code class="docutils literal"><span class="pre">tau</span></code> contains scalars which parameterize the elementary reflectors of the factorization. <code class="docutils literal"><span class="pre">tau</span></code> must have length greater than or equal to the smallest dimension of <code class="docutils literal"><span class="pre">A</span></code>.</p>
<p>Returns <code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">tau</span></code> modified in-place.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">geqlf!</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span> &rarr; (A, tau)</dt>
<dd><p>Compute the <code class="docutils literal"><span class="pre">QL</span></code> factorization of <code class="docutils literal"><span class="pre">A</span></code>, <code class="docutils literal"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">QL</span></code>.</p>
<p>Returns <code class="docutils literal"><span class="pre">A</span></code>, modified in-place, and <code class="docutils literal"><span class="pre">tau</span></code>, which contains scalars which parameterize the elementary reflectors of the factorization.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.geqrf!">
<code class="descname">geqrf!</code><span class="sig-paren">(</span><em>A</em>, <em>tau</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.LAPACK.geqrf!" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the <code class="docutils literal"><span class="pre">QR</span></code> factorization of <code class="docutils literal"><span class="pre">A</span></code>, <code class="docutils literal"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">QR</span></code>. <code class="docutils literal"><span class="pre">tau</span></code> contains scalars which parameterize the elementary reflectors of the factorization. <code class="docutils literal"><span class="pre">tau</span></code> must have length greater than or equal to the smallest dimension of <code class="docutils literal"><span class="pre">A</span></code>.</p>
<p>Returns <code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">tau</span></code> modified in-place.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">geqrf!</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span> &rarr; (A, tau)</dt>
<dd><p>Compute the <code class="docutils literal"><span class="pre">QR</span></code> factorization of <code class="docutils literal"><span class="pre">A</span></code>, <code class="docutils literal"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">QR</span></code>.</p>
<p>Returns <code class="docutils literal"><span class="pre">A</span></code>, modified in-place, and <code class="docutils literal"><span class="pre">tau</span></code>, which contains scalars which parameterize the elementary reflectors of the factorization.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.geqp3!">
<code class="descname">geqp3!</code><span class="sig-paren">(</span><em>A</em>, <em>jpvt</em>, <em>tau</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.LAPACK.geqp3!" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the pivoted <code class="docutils literal"><span class="pre">QR</span></code> factorization of <code class="docutils literal"><span class="pre">A</span></code>, <code class="docutils literal"><span class="pre">AP</span> <span class="pre">=</span> <span class="pre">QR</span></code> using BLAS level 3. <code class="docutils literal"><span class="pre">P</span></code> is a pivoting matrix, represented by <code class="docutils literal"><span class="pre">jpvt</span></code>. <code class="docutils literal"><span class="pre">tau</span></code> stores the elementary reflectors. <code class="docutils literal"><span class="pre">jpvt</span></code> must have length length greater than or equal to <code class="docutils literal"><span class="pre">n</span></code> if <code class="docutils literal"><span class="pre">A</span></code> is an <code class="docutils literal"><span class="pre">(m</span> <span class="pre">x</span> <span class="pre">n)</span></code> matrix. <code class="docutils literal"><span class="pre">tau</span></code> must have length greater than or equal to the smallest dimension of <code class="docutils literal"><span class="pre">A</span></code>.</p>
<p><code class="docutils literal"><span class="pre">A</span></code>, <code class="docutils literal"><span class="pre">jpvt</span></code>, and <code class="docutils literal"><span class="pre">tau</span></code> are modified in-place.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">geqp3!</code><span class="sig-paren">(</span><em>A</em>, <em>jpvt</em><span class="sig-paren">)</span> &rarr; (A, jpvt, tau)</dt>
<dd><p>Compute the pivoted <code class="docutils literal"><span class="pre">QR</span></code> factorization of <code class="docutils literal"><span class="pre">A</span></code>, <code class="docutils literal"><span class="pre">AP</span> <span class="pre">=</span> <span class="pre">QR</span></code> using BLAS level 3. <code class="docutils literal"><span class="pre">P</span></code> is a pivoting matrix, represented by <code class="docutils literal"><span class="pre">jpvt</span></code>. <code class="docutils literal"><span class="pre">jpvt</span></code> must have length greater than or equal to <code class="docutils literal"><span class="pre">n</span></code> if <code class="docutils literal"><span class="pre">A</span></code> is an <code class="docutils literal"><span class="pre">(m</span> <span class="pre">x</span> <span class="pre">n)</span></code> matrix.</p>
<p>Returns <code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">jpvt</span></code>, modified in-place, and <code class="docutils literal"><span class="pre">tau</span></code>, which stores the elementary reflectors.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">geqp3!</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span> &rarr; (A, jpvt, tau)</dt>
<dd><p>Compute the pivoted <code class="docutils literal"><span class="pre">QR</span></code> factorization of <code class="docutils literal"><span class="pre">A</span></code>, <code class="docutils literal"><span class="pre">AP</span> <span class="pre">=</span> <span class="pre">QR</span></code> using BLAS level 3.</p>
<p>Returns <code class="docutils literal"><span class="pre">A</span></code>, modified in-place, <code class="docutils literal"><span class="pre">jpvt</span></code>, which represents the pivoting matrix <code class="docutils literal"><span class="pre">P</span></code>, and <code class="docutils literal"><span class="pre">tau</span></code>, which stores the elementary reflectors.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.gerqf!">
<code class="descname">gerqf!</code><span class="sig-paren">(</span><em>A</em>, <em>tau</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.LAPACK.gerqf!" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the <code class="docutils literal"><span class="pre">RQ</span></code> factorization of <code class="docutils literal"><span class="pre">A</span></code>, <code class="docutils literal"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">RQ</span></code>. <code class="docutils literal"><span class="pre">tau</span></code> contains scalars which parameterize the elementary reflectors of the factorization. <code class="docutils literal"><span class="pre">tau</span></code> must have length greater than or equal to the smallest dimension of <code class="docutils literal"><span class="pre">A</span></code>.</p>
<p>Returns <code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">tau</span></code> modified in-place.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">gerqf!</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span> &rarr; (A, tau)</dt>
<dd><p>Compute the <code class="docutils literal"><span class="pre">RQ</span></code> factorization of <code class="docutils literal"><span class="pre">A</span></code>, <code class="docutils literal"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">RQ</span></code>.</p>
<p>Returns <code class="docutils literal"><span class="pre">A</span></code>, modified in-place, and <code class="docutils literal"><span class="pre">tau</span></code>, which contains scalars which parameterize the elementary reflectors of the factorization.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.geqrt!">
<code class="descname">geqrt!</code><span class="sig-paren">(</span><em>A</em>, <em>T</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.LAPACK.geqrt!" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the blocked <code class="docutils literal"><span class="pre">QR</span></code> factorization of <code class="docutils literal"><span class="pre">A</span></code>, <code class="docutils literal"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">QR</span></code>. <code class="docutils literal"><span class="pre">T</span></code> contains upper triangular block reflectors which parameterize the elementary reflectors of the factorization. The first dimension of <code class="docutils literal"><span class="pre">T</span></code> sets the block size and it must be between 1 and <code class="docutils literal"><span class="pre">n</span></code>. The second dimension of <code class="docutils literal"><span class="pre">T</span></code> must equal the smallest dimension of <code class="docutils literal"><span class="pre">A</span></code>.</p>
<p>Returns <code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">T</span></code> modified in-place.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">geqrt!</code><span class="sig-paren">(</span><em>A</em>, <em>nb</em><span class="sig-paren">)</span> &rarr; (A, T)</dt>
<dd><p>Compute the blocked <code class="docutils literal"><span class="pre">QR</span></code> factorization of <code class="docutils literal"><span class="pre">A</span></code>, <code class="docutils literal"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">QR</span></code>. <code class="docutils literal"><span class="pre">nb</span></code> sets the block size and it must be between 1 and <code class="docutils literal"><span class="pre">n</span></code>, the second dimension of <code class="docutils literal"><span class="pre">A</span></code>.</p>
<p>Returns <code class="docutils literal"><span class="pre">A</span></code>, modified in-place, and <code class="docutils literal"><span class="pre">T</span></code>, which contains upper triangular block reflectors which parameterize the elementary reflectors of the factorization.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.geqrt3!">
<code class="descname">geqrt3!</code><span class="sig-paren">(</span><em>A</em>, <em>T</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.LAPACK.geqrt3!" title="Permalink to this definition">¶</a></dt>
<dd><p>Recursively computes the blocked <code class="docutils literal"><span class="pre">QR</span></code> factorization of <code class="docutils literal"><span class="pre">A</span></code>, <code class="docutils literal"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">QR</span></code>. <code class="docutils literal"><span class="pre">T</span></code> contains upper triangular block reflectors which parameterize the elementary reflectors of the factorization.  The first dimension of <code class="docutils literal"><span class="pre">T</span></code> sets the block size and it must be between 1 and <code class="docutils literal"><span class="pre">n</span></code>. The second dimension of <code class="docutils literal"><span class="pre">T</span></code> must equal the smallest dimension of <code class="docutils literal"><span class="pre">A</span></code>.</p>
<p>Returns <code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">T</span></code> modified in-place.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">geqrt3!</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span> &rarr; (A, T)</dt>
<dd><p>Recursively computes the blocked <code class="docutils literal"><span class="pre">QR</span></code> factorization of <code class="docutils literal"><span class="pre">A</span></code>, <code class="docutils literal"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">QR</span></code>.</p>
<p>Returns <code class="docutils literal"><span class="pre">A</span></code>, modified in-place, and <code class="docutils literal"><span class="pre">T</span></code>, which contains upper triangular block reflectors which parameterize the elementary reflectors of the factorization.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.getrf!">
<code class="descname">getrf!</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span> &rarr; (A, ipiv, info)<a class="headerlink" href="#Base.LinAlg.LAPACK.getrf!" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the pivoted <code class="docutils literal"><span class="pre">LU</span></code> factorization of <code class="docutils literal"><span class="pre">A</span></code>, <code class="docutils literal"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">LU</span></code>.</p>
<p>Returns <code class="docutils literal"><span class="pre">A</span></code>, modified in-place, <code class="docutils literal"><span class="pre">ipiv</span></code>, the pivoting information, and an <code class="docutils literal"><span class="pre">info</span></code> code which indicates success (<code class="docutils literal"><span class="pre">info</span> <span class="pre">=</span> <span class="pre">0</span></code>), a singular value in <code class="docutils literal"><span class="pre">U</span></code> (<code class="docutils literal"><span class="pre">info</span> <span class="pre">=</span> <span class="pre">i</span></code>, in which case <code class="docutils literal"><span class="pre">U[i,i]</span></code> is singular), or an error code (<code class="docutils literal"><span class="pre">info</span> <span class="pre">&lt;</span> <span class="pre">0</span></code>).</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.tzrzf!">
<code class="descname">tzrzf!</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span> &rarr; (A, tau)<a class="headerlink" href="#Base.LinAlg.LAPACK.tzrzf!" title="Permalink to this definition">¶</a></dt>
<dd><p>Transforms the upper trapezoidal matrix <code class="docutils literal"><span class="pre">A</span></code> to upper triangular form in-place. Returns <code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">tau</span></code>, the scalar parameters for the elementary reflectors of the transformation.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.ormrz!">
<code class="descname">ormrz!</code><span class="sig-paren">(</span><em>side</em>, <em>trans</em>, <em>A</em>, <em>tau</em>, <em>C</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.LAPACK.ormrz!" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiplies the matrix <code class="docutils literal"><span class="pre">C</span></code> by <code class="docutils literal"><span class="pre">Q</span></code> from the transformation supplied by <code class="docutils literal"><span class="pre">tzrzf!</span></code>. Depending on <code class="docutils literal"><span class="pre">side</span></code> or <code class="docutils literal"><span class="pre">trans</span></code> the multiplication can be left-sided (<code class="docutils literal"><span class="pre">side</span> <span class="pre">=</span> <span class="pre">L,</span> <span class="pre">Q*C</span></code>) or right-sided (<code class="docutils literal"><span class="pre">side</span> <span class="pre">=</span> <span class="pre">R,</span> <span class="pre">C*Q</span></code>) and <code class="docutils literal"><span class="pre">Q</span></code> can be unmodified (<code class="docutils literal"><span class="pre">trans</span> <span class="pre">=</span> <span class="pre">N</span></code>), transposed (<code class="docutils literal"><span class="pre">trans</span> <span class="pre">=</span> <span class="pre">T</span></code>), or conjugate transposed (<code class="docutils literal"><span class="pre">trans</span> <span class="pre">=</span> <span class="pre">C</span></code>). Returns matrix <code class="docutils literal"><span class="pre">C</span></code> which is modified in-place with the result of the multiplication.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.gels!">
<code class="descname">gels!</code><span class="sig-paren">(</span><em>trans</em>, <em>A</em>, <em>B</em><span class="sig-paren">)</span> &rarr; (F, B, ssr)<a class="headerlink" href="#Base.LinAlg.LAPACK.gels!" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves the linear equation <code class="docutils literal"><span class="pre">A</span> <span class="pre">*</span> <span class="pre">X</span> <span class="pre">=</span> <span class="pre">B</span></code>, <code class="docutils literal"><span class="pre">A.'</span> <span class="pre">*</span> <span class="pre">X</span> <span class="pre">=B</span></code>, or <code class="docutils literal"><span class="pre">A'</span> <span class="pre">*</span> <span class="pre">X</span> <span class="pre">=</span> <span class="pre">B</span></code> using a QR or LQ factorization. Modifies the matrix/vector <code class="docutils literal"><span class="pre">B</span></code> in place with the solution. <code class="docutils literal"><span class="pre">A</span></code> is overwritten with its <code class="docutils literal"><span class="pre">QR</span></code> or <code class="docutils literal"><span class="pre">LQ</span></code> factorization. <code class="docutils literal"><span class="pre">trans</span></code> may be one of <code class="docutils literal"><span class="pre">N</span></code> (no modification), <code class="docutils literal"><span class="pre">T</span></code> (transpose), or <code class="docutils literal"><span class="pre">C</span></code> (conjugate transpose). <code class="docutils literal"><span class="pre">gels!</span></code> searches for the minimum norm/least squares solution. <code class="docutils literal"><span class="pre">A</span></code> may be under or over determined. The solution is returned in <code class="docutils literal"><span class="pre">B</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.gesv!">
<code class="descname">gesv!</code><span class="sig-paren">(</span><em>A</em>, <em>B</em><span class="sig-paren">)</span> &rarr; (B, A, ipiv)<a class="headerlink" href="#Base.LinAlg.LAPACK.gesv!" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves the linear equation <code class="docutils literal"><span class="pre">A</span> <span class="pre">*</span> <span class="pre">X</span> <span class="pre">=</span> <span class="pre">B</span></code> where <code class="docutils literal"><span class="pre">A</span></code> is a square matrix using the <code class="docutils literal"><span class="pre">LU</span></code> factorization of <code class="docutils literal"><span class="pre">A</span></code>. <code class="docutils literal"><span class="pre">A</span></code> is overwritten with its <code class="docutils literal"><span class="pre">LU</span></code> factorization and <code class="docutils literal"><span class="pre">B</span></code> is overwritten with the solution <code class="docutils literal"><span class="pre">X</span></code>. <code class="docutils literal"><span class="pre">ipiv</span></code> contains the pivoting information for the <code class="docutils literal"><span class="pre">LU</span></code> factorization of <code class="docutils literal"><span class="pre">A</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.getrs!">
<code class="descname">getrs!</code><span class="sig-paren">(</span><em>trans</em>, <em>A</em>, <em>ipiv</em>, <em>B</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.LAPACK.getrs!" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves the linear equation <code class="docutils literal"><span class="pre">A</span> <span class="pre">*</span> <span class="pre">X</span> <span class="pre">=</span> <span class="pre">B</span></code>, <code class="docutils literal"><span class="pre">A.'</span> <span class="pre">*</span> <span class="pre">X</span> <span class="pre">=B</span></code>, or <code class="docutils literal"><span class="pre">A'</span> <span class="pre">*</span> <span class="pre">X</span> <span class="pre">=</span> <span class="pre">B</span></code> for square <code class="docutils literal"><span class="pre">A</span></code>. Modifies the matrix/vector <code class="docutils literal"><span class="pre">B</span></code> in place with the solution. <code class="docutils literal"><span class="pre">A</span></code> is the <code class="docutils literal"><span class="pre">LU</span></code> factorization from <code class="docutils literal"><span class="pre">getrf!</span></code>, with <code class="docutils literal"><span class="pre">ipiv</span></code> the pivoting information. <code class="docutils literal"><span class="pre">trans</span></code> may be one of <code class="docutils literal"><span class="pre">N</span></code> (no modification), <code class="docutils literal"><span class="pre">T</span></code> (transpose), or <code class="docutils literal"><span class="pre">C</span></code> (conjugate transpose).</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.getri!">
<code class="descname">getri!</code><span class="sig-paren">(</span><em>A</em>, <em>ipiv</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.LAPACK.getri!" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the inverse of <code class="docutils literal"><span class="pre">A</span></code>, using its <code class="docutils literal"><span class="pre">LU</span></code> factorization found by <code class="docutils literal"><span class="pre">getrf!</span></code>. <code class="docutils literal"><span class="pre">ipiv</span></code> is the pivot information output and <code class="docutils literal"><span class="pre">A</span></code> contains the <code class="docutils literal"><span class="pre">LU</span></code> factorization of <code class="docutils literal"><span class="pre">getrf!</span></code>. <code class="docutils literal"><span class="pre">A</span></code> is overwritten with its inverse.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.gesvx!">
<code class="descname">gesvx!</code><span class="sig-paren">(</span><em>fact</em>, <em>trans</em>, <em>A</em>, <em>AF</em>, <em>ipiv</em>, <em>equed</em>, <em>R</em>, <em>C</em>, <em>B</em><span class="sig-paren">)</span> &rarr; (X, equed, R, C, B, rcond, ferr, berr, work)<a class="headerlink" href="#Base.LinAlg.LAPACK.gesvx!" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves the linear equation <code class="docutils literal"><span class="pre">A</span> <span class="pre">*</span> <span class="pre">X</span> <span class="pre">=</span> <span class="pre">B</span></code> (<code class="docutils literal"><span class="pre">trans</span> <span class="pre">=</span> <span class="pre">N</span></code>), <code class="docutils literal"><span class="pre">A.'</span> <span class="pre">*</span> <span class="pre">X</span> <span class="pre">=B</span></code> (<code class="docutils literal"><span class="pre">trans</span> <span class="pre">=</span> <span class="pre">T</span></code>), or <code class="docutils literal"><span class="pre">A'</span> <span class="pre">*</span> <span class="pre">X</span> <span class="pre">=</span> <span class="pre">B</span></code> (<code class="docutils literal"><span class="pre">trans</span> <span class="pre">=</span> <span class="pre">C</span></code>) using the <code class="docutils literal"><span class="pre">LU</span></code> factorization of <code class="docutils literal"><span class="pre">A</span></code>. <code class="docutils literal"><span class="pre">fact</span></code> may be <code class="docutils literal"><span class="pre">E</span></code>, in which case <code class="docutils literal"><span class="pre">A</span></code> will be equilibrated and copied to <code class="docutils literal"><span class="pre">AF</span></code>; <code class="docutils literal"><span class="pre">F</span></code>, in which case <code class="docutils literal"><span class="pre">AF</span></code> and <code class="docutils literal"><span class="pre">ipiv</span></code> from a previous <code class="docutils literal"><span class="pre">LU</span></code> factorization are inputs; or <code class="docutils literal"><span class="pre">N</span></code>, in which case <code class="docutils literal"><span class="pre">A</span></code> will be copied to <code class="docutils literal"><span class="pre">AF</span></code> and then factored. If <code class="docutils literal"><span class="pre">fact</span> <span class="pre">=</span> <span class="pre">F</span></code>, <code class="docutils literal"><span class="pre">equed</span></code> may be <code class="docutils literal"><span class="pre">N</span></code>, meaning <code class="docutils literal"><span class="pre">A</span></code> has not been equilibrated; <code class="docutils literal"><span class="pre">R</span></code>, meaning <code class="docutils literal"><span class="pre">A</span></code> was multiplied by <code class="docutils literal"><span class="pre">diagm(R)</span></code> from the left; <code class="docutils literal"><span class="pre">C</span></code>, meaning <code class="docutils literal"><span class="pre">A</span></code> was multiplied by <code class="docutils literal"><span class="pre">diagm(C)</span></code> from the right; or <code class="docutils literal"><span class="pre">B</span></code>, meaning <code class="docutils literal"><span class="pre">A</span></code> was multiplied by <code class="docutils literal"><span class="pre">diagm(R)</span></code> from the left and <code class="docutils literal"><span class="pre">diagm(C)</span></code> from the right. If <code class="docutils literal"><span class="pre">fact</span> <span class="pre">=</span> <span class="pre">F</span></code> and <code class="docutils literal"><span class="pre">equed</span> <span class="pre">=</span> <span class="pre">R</span></code> or <code class="docutils literal"><span class="pre">B</span></code> the elements of <code class="docutils literal"><span class="pre">R</span></code> must all be positive. If <code class="docutils literal"><span class="pre">fact</span> <span class="pre">=</span> <span class="pre">F</span></code> and <code class="docutils literal"><span class="pre">equed</span> <span class="pre">=</span> <span class="pre">C</span></code> or <code class="docutils literal"><span class="pre">B</span></code> the elements of <code class="docutils literal"><span class="pre">C</span></code> must all be positive.</p>
<p>Returns the solution <code class="docutils literal"><span class="pre">X</span></code>; <code class="docutils literal"><span class="pre">equed</span></code>, which is an output if <code class="docutils literal"><span class="pre">fact</span></code> is not <code class="docutils literal"><span class="pre">N</span></code>, and describes the equilibration that was performed; <code class="docutils literal"><span class="pre">R</span></code>, the row equilibration diagonal; <code class="docutils literal"><span class="pre">C</span></code>, the column equilibration diagonal; <code class="docutils literal"><span class="pre">B</span></code>, which may be overwritten with its equilibrated form <code class="docutils literal"><span class="pre">diagm(R)*B</span></code> (if <code class="docutils literal"><span class="pre">trans</span> <span class="pre">=</span> <span class="pre">N</span></code> and <code class="docutils literal"><span class="pre">equed</span> <span class="pre">=</span> <span class="pre">R,B</span></code>) or <code class="docutils literal"><span class="pre">diagm(C)*B</span></code> (if <code class="docutils literal"><span class="pre">trans</span> <span class="pre">=</span> <span class="pre">T,C</span></code> and <code class="docutils literal"><span class="pre">equed</span> <span class="pre">=</span> <span class="pre">C,B</span></code>); <code class="docutils literal"><span class="pre">rcond</span></code>, the reciprocal condition number of <code class="docutils literal"><span class="pre">A</span></code> after equilbrating; <code class="docutils literal"><span class="pre">ferr</span></code>, the forward error bound for each solution vector in <code class="docutils literal"><span class="pre">X</span></code>; <code class="docutils literal"><span class="pre">berr</span></code>, the forward error bound for each solution vector in <code class="docutils literal"><span class="pre">X</span></code>; and <code class="docutils literal"><span class="pre">work</span></code>, the reciprocal pivot growth factor.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">gesvx!</code><span class="sig-paren">(</span><em>A</em>, <em>B</em><span class="sig-paren">)</span></dt>
<dd><p>The no-equilibration, no-transpose simplification of <code class="docutils literal"><span class="pre">gesvx!</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.gelsd!">
<code class="descname">gelsd!</code><span class="sig-paren">(</span><em>A</em>, <em>B</em>, <em>rcond</em><span class="sig-paren">)</span> &rarr; (B, rnk)<a class="headerlink" href="#Base.LinAlg.LAPACK.gelsd!" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the least norm solution of <code class="docutils literal"><span class="pre">A</span> <span class="pre">*</span> <span class="pre">X</span> <span class="pre">=</span> <span class="pre">B</span></code> by finding the <code class="docutils literal"><span class="pre">SVD</span></code> factorization of <code class="docutils literal"><span class="pre">A</span></code>, then dividing-and-conquering the problem. <code class="docutils literal"><span class="pre">B</span></code> is overwritten with the solution <code class="docutils literal"><span class="pre">X</span></code>. Singular values below <code class="docutils literal"><span class="pre">rcond</span></code> will be treated as zero. Returns the solution in <code class="docutils literal"><span class="pre">B</span></code> and the effective rank of <code class="docutils literal"><span class="pre">A</span></code> in <code class="docutils literal"><span class="pre">rnk</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.gelsy!">
<code class="descname">gelsy!</code><span class="sig-paren">(</span><em>A</em>, <em>B</em>, <em>rcond</em><span class="sig-paren">)</span> &rarr; (B, rnk)<a class="headerlink" href="#Base.LinAlg.LAPACK.gelsy!" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the least norm solution of <code class="docutils literal"><span class="pre">A</span> <span class="pre">*</span> <span class="pre">X</span> <span class="pre">=</span> <span class="pre">B</span></code> by finding the full <code class="docutils literal"><span class="pre">QR</span></code> factorization of <code class="docutils literal"><span class="pre">A</span></code>, then dividing-and-conquering the problem. <code class="docutils literal"><span class="pre">B</span></code> is overwritten with the solution <code class="docutils literal"><span class="pre">X</span></code>. Singular values below <code class="docutils literal"><span class="pre">rcond</span></code> will be treated as zero. Returns the solution in <code class="docutils literal"><span class="pre">B</span></code> and the effective rank of <code class="docutils literal"><span class="pre">A</span></code> in <code class="docutils literal"><span class="pre">rnk</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.gglse!">
<code class="descname">gglse!</code><span class="sig-paren">(</span><em>A</em>, <em>c</em>, <em>B</em>, <em>d</em><span class="sig-paren">)</span> &rarr; (X,res)<a class="headerlink" href="#Base.LinAlg.LAPACK.gglse!" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves the equation <code class="docutils literal"><span class="pre">A</span> <span class="pre">*</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">c</span></code> where <code class="docutils literal"><span class="pre">x</span></code> is subject to the equality constraint <code class="docutils literal"><span class="pre">B</span> <span class="pre">*</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">d</span></code>. Uses the formula <code class="docutils literal"><span class="pre">||c</span> <span class="pre">-</span> <span class="pre">A*x||^2</span> <span class="pre">=</span> <span class="pre">0</span></code> to solve. Returns <code class="docutils literal"><span class="pre">X</span></code> and the residual sum-of-squares.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.geev!">
<code class="descname">geev!</code><span class="sig-paren">(</span><em>jobvl</em>, <em>jobvr</em>, <em>A</em><span class="sig-paren">)</span> &rarr; (W, VL, VR)<a class="headerlink" href="#Base.LinAlg.LAPACK.geev!" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the eigensystem of <code class="docutils literal"><span class="pre">A</span></code>. If <code class="docutils literal"><span class="pre">jobvl</span> <span class="pre">=</span> <span class="pre">N</span></code>, the left eigenvectors of <code class="docutils literal"><span class="pre">A</span></code> aren&#8217;t computed. If <code class="docutils literal"><span class="pre">jobvr</span> <span class="pre">=</span> <span class="pre">N</span></code>, the right eigenvectors of <code class="docutils literal"><span class="pre">A</span></code> aren&#8217;t computed. If <code class="docutils literal"><span class="pre">jobvl</span> <span class="pre">=</span> <span class="pre">V</span></code> or <code class="docutils literal"><span class="pre">jobvr</span> <span class="pre">=</span> <span class="pre">V</span></code>, the corresponding eigenvectors are computed. Returns the eigenvalues in <code class="docutils literal"><span class="pre">W</span></code>, the right eigenvectors in <code class="docutils literal"><span class="pre">VR</span></code>, and the left eigenvectors in <code class="docutils literal"><span class="pre">VL</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.gesdd!">
<code class="descname">gesdd!</code><span class="sig-paren">(</span><em>job</em>, <em>A</em><span class="sig-paren">)</span> &rarr; (U, S, VT)<a class="headerlink" href="#Base.LinAlg.LAPACK.gesdd!" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the singular value decomposition of <code class="docutils literal"><span class="pre">A</span></code>, <code class="docutils literal"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">U</span> <span class="pre">*</span> <span class="pre">S</span> <span class="pre">*</span> <span class="pre">V'</span></code>, using a divide and conquer approach. If <code class="docutils literal"><span class="pre">job</span> <span class="pre">=</span> <span class="pre">A</span></code>, all the columns of <code class="docutils literal"><span class="pre">U</span></code> and the rows of <code class="docutils literal"><span class="pre">V'</span></code> are computed. If <code class="docutils literal"><span class="pre">job</span> <span class="pre">=</span> <span class="pre">N</span></code>, no columns of <code class="docutils literal"><span class="pre">U</span></code> or rows of <code class="docutils literal"><span class="pre">V'</span></code> are computed. If <code class="docutils literal"><span class="pre">job</span> <span class="pre">=</span> <span class="pre">O</span></code>, <code class="docutils literal"><span class="pre">A</span></code> is overwritten with the columns of (thin) <code class="docutils literal"><span class="pre">U</span></code> and the rows of (thin) <code class="docutils literal"><span class="pre">V'</span></code>. If <code class="docutils literal"><span class="pre">job</span> <span class="pre">=</span> <span class="pre">S</span></code>, the columns of (thin) <code class="docutils literal"><span class="pre">U</span></code> and the rows of (thin) <code class="docutils literal"><span class="pre">V'</span></code> are computed and returned separately.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.gesvd!">
<code class="descname">gesvd!</code><span class="sig-paren">(</span><em>jobu</em>, <em>jobvt</em>, <em>A</em><span class="sig-paren">)</span> &rarr; (U, S, VT)<a class="headerlink" href="#Base.LinAlg.LAPACK.gesvd!" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the singular value decomposition of <code class="docutils literal"><span class="pre">A</span></code>, <code class="docutils literal"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">U</span> <span class="pre">*</span> <span class="pre">S</span> <span class="pre">*</span> <span class="pre">V'</span></code>. If <code class="docutils literal"><span class="pre">jobu</span> <span class="pre">=</span> <span class="pre">A</span></code>, all the columns of <code class="docutils literal"><span class="pre">U</span></code> are computed. If <code class="docutils literal"><span class="pre">jobvt</span> <span class="pre">=</span> <span class="pre">A</span></code> all the rows of <code class="docutils literal"><span class="pre">V'</span></code> are computed. If <code class="docutils literal"><span class="pre">jobu</span> <span class="pre">=</span> <span class="pre">N</span></code>, no columns of <code class="docutils literal"><span class="pre">U</span></code> are computed. If <code class="docutils literal"><span class="pre">jobvt</span> <span class="pre">=</span> <span class="pre">N</span></code> no rows of <code class="docutils literal"><span class="pre">V'</span></code> are computed. If <code class="docutils literal"><span class="pre">jobu</span> <span class="pre">=</span> <span class="pre">O</span></code>, <code class="docutils literal"><span class="pre">A</span></code> is overwritten with the columns of (thin) <code class="docutils literal"><span class="pre">U</span></code>. If <code class="docutils literal"><span class="pre">jobvt</span> <span class="pre">=</span> <span class="pre">O</span></code>, <code class="docutils literal"><span class="pre">A</span></code> is overwritten with the rows of (thin) <code class="docutils literal"><span class="pre">V'</span></code>. If <code class="docutils literal"><span class="pre">jobu</span> <span class="pre">=</span> <span class="pre">S</span></code>, the columns of (thin) <code class="docutils literal"><span class="pre">U</span></code> are computed and returned separately. If <code class="docutils literal"><span class="pre">jobvt</span> <span class="pre">=</span> <span class="pre">S</span></code> the rows of (thin) <code class="docutils literal"><span class="pre">V'</span></code> are computed and returned separately. <code class="docutils literal"><span class="pre">jobu</span></code> and <code class="docutils literal"><span class="pre">jobvt</span></code> can&#8217;t both be <code class="docutils literal"><span class="pre">O</span></code>.</p>
<p>Returns <code class="docutils literal"><span class="pre">U</span></code>, <code class="docutils literal"><span class="pre">S</span></code>, and <code class="docutils literal"><span class="pre">Vt</span></code>, where <code class="docutils literal"><span class="pre">S</span></code> are the singular values of <code class="docutils literal"><span class="pre">A</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.ggsvd!">
<code class="descname">ggsvd!</code><span class="sig-paren">(</span><em>jobu</em>, <em>jobv</em>, <em>jobq</em>, <em>A</em>, <em>B</em><span class="sig-paren">)</span> &rarr; (U, V, Q, alpha, beta, k, l, R)<a class="headerlink" href="#Base.LinAlg.LAPACK.ggsvd!" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the generalized singular value decomposition of <code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">B</span></code>, <code class="docutils literal"><span class="pre">U'*A*Q</span> <span class="pre">=</span> <span class="pre">D1*R</span></code> and <code class="docutils literal"><span class="pre">V'*B*Q</span> <span class="pre">=</span> <span class="pre">D2*R</span></code>. <code class="docutils literal"><span class="pre">D1</span></code> has <code class="docutils literal"><span class="pre">alpha</span></code> on its diagonal and <code class="docutils literal"><span class="pre">D2</span></code> has <code class="docutils literal"><span class="pre">beta</span></code> on its diagonal. If <code class="docutils literal"><span class="pre">jobu</span> <span class="pre">=</span> <span class="pre">U</span></code>, the orthogonal/unitary matrix <code class="docutils literal"><span class="pre">U</span></code> is computed. If <code class="docutils literal"><span class="pre">jobv</span> <span class="pre">=</span> <span class="pre">V</span></code> the orthogonal/unitary matrix <code class="docutils literal"><span class="pre">V</span></code> is computed. If <code class="docutils literal"><span class="pre">jobq</span> <span class="pre">=</span> <span class="pre">Q</span></code>, the orthogonal/unitary matrix <code class="docutils literal"><span class="pre">Q</span></code> is computed. If <code class="docutils literal"><span class="pre">jobu</span></code>, <code class="docutils literal"><span class="pre">jobv</span></code> or <code class="docutils literal"><span class="pre">jobq</span></code> is <code class="docutils literal"><span class="pre">N</span></code>, that matrix is not computed. This function is only available in LAPACK versions prior to 3.6.0.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.ggsvd3!">
<code class="descname">ggsvd3!</code><span class="sig-paren">(</span><em>jobu</em>, <em>jobv</em>, <em>jobq</em>, <em>A</em>, <em>B</em><span class="sig-paren">)</span> &rarr; (U, V, Q, alpha, beta, k, l, R)<a class="headerlink" href="#Base.LinAlg.LAPACK.ggsvd3!" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the generalized singular value decomposition of <code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">B</span></code>, <code class="docutils literal"><span class="pre">U'*A*Q</span> <span class="pre">=</span> <span class="pre">D1*R</span></code> and <code class="docutils literal"><span class="pre">V'*B*Q</span> <span class="pre">=</span> <span class="pre">D2*R</span></code>. <code class="docutils literal"><span class="pre">D1</span></code> has <code class="docutils literal"><span class="pre">alpha</span></code> on its diagonal and <code class="docutils literal"><span class="pre">D2</span></code> has <code class="docutils literal"><span class="pre">beta</span></code> on its diagonal. If <code class="docutils literal"><span class="pre">jobu</span> <span class="pre">=</span> <span class="pre">U</span></code>, the orthogonal/unitary matrix <code class="docutils literal"><span class="pre">U</span></code> is computed. If <code class="docutils literal"><span class="pre">jobv</span> <span class="pre">=</span> <span class="pre">V</span></code> the orthogonal/unitary matrix <code class="docutils literal"><span class="pre">V</span></code> is computed. If <code class="docutils literal"><span class="pre">jobq</span> <span class="pre">=</span> <span class="pre">Q</span></code>, the orthogonal/unitary matrix <code class="docutils literal"><span class="pre">Q</span></code> is computed. If <code class="docutils literal"><span class="pre">jobu</span></code>, <code class="docutils literal"><span class="pre">jobv</span></code>, or <code class="docutils literal"><span class="pre">jobq</span></code> is <code class="docutils literal"><span class="pre">N</span></code>, that matrix is not computed. This function requires LAPACK 3.6.0.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.geevx!">
<code class="descname">geevx!</code><span class="sig-paren">(</span><em>balanc</em>, <em>jobvl</em>, <em>jobvr</em>, <em>sense</em>, <em>A</em><span class="sig-paren">)</span> &rarr; (A, w, VL, VR, ilo, ihi, scale, abnrm, rconde, rcondv)<a class="headerlink" href="#Base.LinAlg.LAPACK.geevx!" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the eigensystem of <code class="docutils literal"><span class="pre">A</span></code> with matrix balancing. If <code class="docutils literal"><span class="pre">jobvl</span> <span class="pre">=</span> <span class="pre">N</span></code>, the left eigenvectors of <code class="docutils literal"><span class="pre">A</span></code> aren&#8217;t computed. If <code class="docutils literal"><span class="pre">jobvr</span> <span class="pre">=</span> <span class="pre">N</span></code>, the right eigenvectors of <code class="docutils literal"><span class="pre">A</span></code> aren&#8217;t computed. If <code class="docutils literal"><span class="pre">jobvl</span> <span class="pre">=</span> <span class="pre">V</span></code> or <code class="docutils literal"><span class="pre">jobvr</span> <span class="pre">=</span> <span class="pre">V</span></code>, the corresponding eigenvectors are computed. If <code class="docutils literal"><span class="pre">balanc</span> <span class="pre">=</span> <span class="pre">N</span></code>, no balancing is performed. If <code class="docutils literal"><span class="pre">balanc</span> <span class="pre">=</span> <span class="pre">P</span></code>, <code class="docutils literal"><span class="pre">A</span></code> is permuted but not scaled. If <code class="docutils literal"><span class="pre">balanc</span> <span class="pre">=</span> <span class="pre">S</span></code>, <code class="docutils literal"><span class="pre">A</span></code> is scaled but not permuted. If <code class="docutils literal"><span class="pre">balanc</span> <span class="pre">=</span> <span class="pre">B</span></code>, <code class="docutils literal"><span class="pre">A</span></code> is permuted and scaled. If <code class="docutils literal"><span class="pre">sense</span> <span class="pre">=</span> <span class="pre">N</span></code>, no reciprocal condition numbers are computed. If <code class="docutils literal"><span class="pre">sense</span> <span class="pre">=</span> <span class="pre">E</span></code>, reciprocal condition numbers are computed for the eigenvalues only. If <code class="docutils literal"><span class="pre">sense</span> <span class="pre">=</span> <span class="pre">V</span></code>, reciprocal condition numbers are computed for the right eigenvectors only. If <code class="docutils literal"><span class="pre">sense</span> <span class="pre">=</span> <span class="pre">B</span></code>, reciprocal condition numbers are computed for the right eigenvectors and the eigenvectors. If <code class="docutils literal"><span class="pre">sense</span> <span class="pre">=</span> <span class="pre">E,B</span></code>, the right and left eigenvectors must be computed.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.ggev!">
<code class="descname">ggev!</code><span class="sig-paren">(</span><em>jobvl</em>, <em>jobvr</em>, <em>A</em>, <em>B</em><span class="sig-paren">)</span> &rarr; (alpha, beta, vl, vr)<a class="headerlink" href="#Base.LinAlg.LAPACK.ggev!" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the generalized eigendecomposition of <code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">B</span></code>. If <code class="docutils literal"><span class="pre">jobvl</span> <span class="pre">=</span> <span class="pre">N</span></code>, the left eigenvectors aren&#8217;t computed. If <code class="docutils literal"><span class="pre">jobvr</span> <span class="pre">=</span> <span class="pre">N</span></code>, the right eigenvectors aren&#8217;t computed. If <code class="docutils literal"><span class="pre">jobvl</span> <span class="pre">=</span> <span class="pre">V</span></code> or <code class="docutils literal"><span class="pre">jobvr</span> <span class="pre">=</span> <span class="pre">V</span></code>, the corresponding eigenvectors are computed.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.gtsv!">
<code class="descname">gtsv!</code><span class="sig-paren">(</span><em>dl</em>, <em>d</em>, <em>du</em>, <em>B</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.LAPACK.gtsv!" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves the equation <code class="docutils literal"><span class="pre">A</span> <span class="pre">*</span> <span class="pre">X</span> <span class="pre">=</span> <span class="pre">B</span></code> where <code class="docutils literal"><span class="pre">A</span></code> is a tridiagonal matrix with <code class="docutils literal"><span class="pre">dl</span></code> on the subdiagonal, <code class="docutils literal"><span class="pre">d</span></code> on the diagonal, and <code class="docutils literal"><span class="pre">du</span></code> on the superdiagonal.</p>
<p>Overwrites <code class="docutils literal"><span class="pre">B</span></code> with the solution <code class="docutils literal"><span class="pre">X</span></code> and returns it.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.gttrf!">
<code class="descname">gttrf!</code><span class="sig-paren">(</span><em>dl</em>, <em>d</em>, <em>du</em><span class="sig-paren">)</span> &rarr; (dl, d, du, du2, ipiv)<a class="headerlink" href="#Base.LinAlg.LAPACK.gttrf!" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the <code class="docutils literal"><span class="pre">LU</span></code> factorization of a tridiagonal matrix with <code class="docutils literal"><span class="pre">dl</span></code> on the subdiagonal, <code class="docutils literal"><span class="pre">d</span></code> on the diagonal, and <code class="docutils literal"><span class="pre">du</span></code> on the superdiagonal.</p>
<p>Modifies <code class="docutils literal"><span class="pre">dl</span></code>, <code class="docutils literal"><span class="pre">d</span></code>, and <code class="docutils literal"><span class="pre">du</span></code> in-place and returns them and the second superdiagonal <code class="docutils literal"><span class="pre">du2</span></code> and the pivoting vector <code class="docutils literal"><span class="pre">ipiv</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.gttrs!">
<code class="descname">gttrs!</code><span class="sig-paren">(</span><em>trans</em>, <em>dl</em>, <em>d</em>, <em>du</em>, <em>du2</em>, <em>ipiv</em>, <em>B</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.LAPACK.gttrs!" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves the equation <code class="docutils literal"><span class="pre">A</span> <span class="pre">*</span> <span class="pre">X</span> <span class="pre">=</span> <span class="pre">B</span></code> (<code class="docutils literal"><span class="pre">trans</span> <span class="pre">=</span> <span class="pre">N</span></code>), <code class="docutils literal"><span class="pre">A.'</span> <span class="pre">*</span> <span class="pre">X</span> <span class="pre">=</span> <span class="pre">B</span></code> (<code class="docutils literal"><span class="pre">trans</span> <span class="pre">=</span> <span class="pre">T</span></code>), or <code class="docutils literal"><span class="pre">A'</span> <span class="pre">*</span> <span class="pre">X</span> <span class="pre">=</span> <span class="pre">B</span></code> (<code class="docutils literal"><span class="pre">trans</span> <span class="pre">=</span> <span class="pre">C</span></code>) using the <code class="docutils literal"><span class="pre">LU</span></code> factorization computed by <code class="docutils literal"><span class="pre">gttrf!</span></code>. <code class="docutils literal"><span class="pre">B</span></code> is overwritten with the solution <code class="docutils literal"><span class="pre">X</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.orglq!">
<code class="descname">orglq!</code><span class="sig-paren">(</span><em>A</em>, <em>tau</em>, <em>k = length(tau)</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.LAPACK.orglq!" title="Permalink to this definition">¶</a></dt>
<dd><p>Explicitly finds the matrix <code class="docutils literal"><span class="pre">Q</span></code> of a <code class="docutils literal"><span class="pre">LQ</span></code> factorization after calling <code class="docutils literal"><span class="pre">gelqf!</span></code> on <code class="docutils literal"><span class="pre">A</span></code>. Uses the output of <code class="docutils literal"><span class="pre">gelqf!</span></code>. <code class="docutils literal"><span class="pre">A</span></code> is overwritten by <code class="docutils literal"><span class="pre">Q</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.orgqr!">
<code class="descname">orgqr!</code><span class="sig-paren">(</span><em>A</em>, <em>tau</em>, <em>k = length(tau)</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.LAPACK.orgqr!" title="Permalink to this definition">¶</a></dt>
<dd><p>Explicitly finds the matrix <code class="docutils literal"><span class="pre">Q</span></code> of a <code class="docutils literal"><span class="pre">QR</span></code> factorization after calling <code class="docutils literal"><span class="pre">geqrf!</span></code> on <code class="docutils literal"><span class="pre">A</span></code>. Uses the output of <code class="docutils literal"><span class="pre">geqrf!</span></code>. <code class="docutils literal"><span class="pre">A</span></code> is overwritten by <code class="docutils literal"><span class="pre">Q</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.ormlq!">
<code class="descname">ormlq!</code><span class="sig-paren">(</span><em>side</em>, <em>trans</em>, <em>A</em>, <em>tau</em>, <em>C</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.LAPACK.ormlq!" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes <code class="docutils literal"><span class="pre">Q</span> <span class="pre">*</span> <span class="pre">C</span></code> (<code class="docutils literal"><span class="pre">trans</span> <span class="pre">=</span> <span class="pre">N</span></code>), <code class="docutils literal"><span class="pre">Q.'</span> <span class="pre">*</span> <span class="pre">C</span></code> (<code class="docutils literal"><span class="pre">trans</span> <span class="pre">=</span> <span class="pre">T</span></code>), <code class="docutils literal"><span class="pre">Q'</span> <span class="pre">*</span> <span class="pre">C</span></code> (<code class="docutils literal"><span class="pre">trans</span> <span class="pre">=</span> <span class="pre">C</span></code>) for <code class="docutils literal"><span class="pre">side</span> <span class="pre">=</span> <span class="pre">L</span></code> or the equivalent right-sided multiplication for <code class="docutils literal"><span class="pre">side</span> <span class="pre">=</span> <span class="pre">R</span></code> using <code class="docutils literal"><span class="pre">Q</span></code> from a <code class="docutils literal"><span class="pre">LQ</span></code> factorization of <code class="docutils literal"><span class="pre">A</span></code> computed using <code class="docutils literal"><span class="pre">gelqf!</span></code>. <code class="docutils literal"><span class="pre">C</span></code> is overwritten.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.ormqr!">
<code class="descname">ormqr!</code><span class="sig-paren">(</span><em>side</em>, <em>trans</em>, <em>A</em>, <em>tau</em>, <em>C</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.LAPACK.ormqr!" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes <code class="docutils literal"><span class="pre">Q</span> <span class="pre">*</span> <span class="pre">C</span></code> (<code class="docutils literal"><span class="pre">trans</span> <span class="pre">=</span> <span class="pre">N</span></code>), <code class="docutils literal"><span class="pre">Q.'</span> <span class="pre">*</span> <span class="pre">C</span></code> (<code class="docutils literal"><span class="pre">trans</span> <span class="pre">=</span> <span class="pre">T</span></code>), <code class="docutils literal"><span class="pre">Q'</span> <span class="pre">*</span> <span class="pre">C</span></code> (<code class="docutils literal"><span class="pre">trans</span> <span class="pre">=</span> <span class="pre">C</span></code>) for <code class="docutils literal"><span class="pre">side</span> <span class="pre">=</span> <span class="pre">L</span></code> or the equivalent right-sided multiplication for <code class="docutils literal"><span class="pre">side</span> <span class="pre">=</span> <span class="pre">R</span></code> using <code class="docutils literal"><span class="pre">Q</span></code> from a <code class="docutils literal"><span class="pre">QR</span></code> factorization of <code class="docutils literal"><span class="pre">A</span></code> computed using <code class="docutils literal"><span class="pre">geqrf!</span></code>. <code class="docutils literal"><span class="pre">C</span></code> is overwritten.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.gemqrt!">
<code class="descname">gemqrt!</code><span class="sig-paren">(</span><em>side</em>, <em>trans</em>, <em>V</em>, <em>T</em>, <em>C</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.LAPACK.gemqrt!" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes <code class="docutils literal"><span class="pre">Q</span> <span class="pre">*</span> <span class="pre">C</span></code> (<code class="docutils literal"><span class="pre">trans</span> <span class="pre">=</span> <span class="pre">N</span></code>), <code class="docutils literal"><span class="pre">Q.'</span> <span class="pre">*</span> <span class="pre">C</span></code> (<code class="docutils literal"><span class="pre">trans</span> <span class="pre">=</span> <span class="pre">T</span></code>), <code class="docutils literal"><span class="pre">Q'</span> <span class="pre">*</span> <span class="pre">C</span></code> (<code class="docutils literal"><span class="pre">trans</span> <span class="pre">=</span> <span class="pre">C</span></code>) for <code class="docutils literal"><span class="pre">side</span> <span class="pre">=</span> <span class="pre">L</span></code> or the equivalent right-sided multiplication for <code class="docutils literal"><span class="pre">side</span> <span class="pre">=</span> <span class="pre">R</span></code> using <code class="docutils literal"><span class="pre">Q</span></code> from a <code class="docutils literal"><span class="pre">QR</span></code> factorization of <code class="docutils literal"><span class="pre">A</span></code> computed using <code class="docutils literal"><span class="pre">geqrt!</span></code>. <code class="docutils literal"><span class="pre">C</span></code> is overwritten.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.posv!">
<code class="descname">posv!</code><span class="sig-paren">(</span><em>uplo</em>, <em>A</em>, <em>B</em><span class="sig-paren">)</span> &rarr; (A, B)<a class="headerlink" href="#Base.LinAlg.LAPACK.posv!" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the solution to <code class="docutils literal"><span class="pre">A</span> <span class="pre">*</span> <span class="pre">X</span> <span class="pre">=</span> <span class="pre">B</span></code> where <code class="docutils literal"><span class="pre">A</span></code> is a symmetric or Hermitian positive definite matrix. If <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">U</span></code> the upper Cholesky decomposition of <code class="docutils literal"><span class="pre">A</span></code> is computed. If <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">L</span></code> the lower Cholesky decomposition of <code class="docutils literal"><span class="pre">A</span></code> is computed. <code class="docutils literal"><span class="pre">A</span></code> is overwritten by its Cholesky decomposition. <code class="docutils literal"><span class="pre">B</span></code> is overwritten with the solution <code class="docutils literal"><span class="pre">X</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.potrf!">
<code class="descname">potrf!</code><span class="sig-paren">(</span><em>uplo</em>, <em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.LAPACK.potrf!" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the Cholesky (upper if <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">U</span></code>, lower if <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">L</span></code>) decomposition of positive-definite matrix <code class="docutils literal"><span class="pre">A</span></code>. <code class="docutils literal"><span class="pre">A</span></code> is overwritten and returned with an info code.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.potri!">
<code class="descname">potri!</code><span class="sig-paren">(</span><em>uplo</em>, <em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.LAPACK.potri!" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the inverse of positive-definite matrix <code class="docutils literal"><span class="pre">A</span></code> after calling <code class="docutils literal"><span class="pre">potrf!</span></code> to find its (upper if <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">U</span></code>, lower if <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">L</span></code>) Cholesky decomposition.</p>
<p><code class="docutils literal"><span class="pre">A</span></code> is overwritten by its inverse and returned.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.potrs!">
<code class="descname">potrs!</code><span class="sig-paren">(</span><em>uplo</em>, <em>A</em>, <em>B</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.LAPACK.potrs!" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the solution to <code class="docutils literal"><span class="pre">A</span> <span class="pre">*</span> <span class="pre">X</span> <span class="pre">=</span> <span class="pre">B</span></code> where <code class="docutils literal"><span class="pre">A</span></code> is a symmetric or Hermitian positive definite matrix whose Cholesky decomposition was computed by <code class="docutils literal"><span class="pre">potrf!</span></code>. If <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">U</span></code> the upper Cholesky decomposition of <code class="docutils literal"><span class="pre">A</span></code> was computed. If <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">L</span></code> the lower Cholesky decomposition of <code class="docutils literal"><span class="pre">A</span></code> was computed. <code class="docutils literal"><span class="pre">B</span></code> is overwritten with the solution <code class="docutils literal"><span class="pre">X</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.pstrf!">
<code class="descname">pstrf!</code><span class="sig-paren">(</span><em>uplo</em>, <em>A</em>, <em>tol</em><span class="sig-paren">)</span> &rarr; (A, piv, rank, info)<a class="headerlink" href="#Base.LinAlg.LAPACK.pstrf!" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the (upper if <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">U</span></code>, lower if <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">L</span></code>) pivoted Cholesky decomposition of positive-definite matrix <code class="docutils literal"><span class="pre">A</span></code> with a user-set tolerance <code class="docutils literal"><span class="pre">tol</span></code>. <code class="docutils literal"><span class="pre">A</span></code> is overwritten by its Cholesky decomposition.</p>
<p>Returns <code class="docutils literal"><span class="pre">A</span></code>, the pivots <code class="docutils literal"><span class="pre">piv</span></code>, the rank of <code class="docutils literal"><span class="pre">A</span></code>, and an <code class="docutils literal"><span class="pre">info</span></code> code. If <code class="docutils literal"><span class="pre">info</span> <span class="pre">=</span> <span class="pre">0</span></code>, the factorization succeeded. If <code class="docutils literal"><span class="pre">info</span> <span class="pre">=</span> <span class="pre">i</span> <span class="pre">&gt;</span> <span class="pre">0</span> <span class="pre">`,</span> <span class="pre">then</span> <span class="pre">`A</span></code> is indefinite or rank-deficient.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.ptsv!">
<code class="descname">ptsv!</code><span class="sig-paren">(</span><em>D</em>, <em>E</em>, <em>B</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.LAPACK.ptsv!" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves <code class="docutils literal"><span class="pre">A</span> <span class="pre">*</span> <span class="pre">X</span> <span class="pre">=</span> <span class="pre">B</span></code> for positive-definite tridiagonal <code class="docutils literal"><span class="pre">A</span></code>. <code class="docutils literal"><span class="pre">D</span></code> is the diagonal of <code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">E</span></code> is the off-diagonal. <code class="docutils literal"><span class="pre">B</span></code> is overwritten with the solution <code class="docutils literal"><span class="pre">X</span></code> and returned.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.pttrf!">
<code class="descname">pttrf!</code><span class="sig-paren">(</span><em>D</em>, <em>E</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.LAPACK.pttrf!" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the LDLt factorization of a positive-definite tridiagonal matrix with <code class="docutils literal"><span class="pre">D</span></code> as diagonal and <code class="docutils literal"><span class="pre">E</span></code> as off-diagonal. <code class="docutils literal"><span class="pre">D</span></code> and <code class="docutils literal"><span class="pre">E</span></code> are overwritten and returned.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.pttrs!">
<code class="descname">pttrs!</code><span class="sig-paren">(</span><em>D</em>, <em>E</em>, <em>B</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.LAPACK.pttrs!" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves <code class="docutils literal"><span class="pre">A</span> <span class="pre">*</span> <span class="pre">X</span> <span class="pre">=</span> <span class="pre">B</span></code> for positive-definite tridiagonal <code class="docutils literal"><span class="pre">A</span></code> with diagonal <code class="docutils literal"><span class="pre">D</span></code> and off-diagonal <code class="docutils literal"><span class="pre">E</span></code> after computing <code class="docutils literal"><span class="pre">A</span></code>&#8216;s LDLt factorization using <code class="docutils literal"><span class="pre">pttrf!</span></code>. <code class="docutils literal"><span class="pre">B</span></code> is overwritten with the solution <code class="docutils literal"><span class="pre">X</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.trtri!">
<code class="descname">trtri!</code><span class="sig-paren">(</span><em>uplo</em>, <em>diag</em>, <em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.LAPACK.trtri!" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the inverse of (upper if <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">U</span></code>, lower if <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">L</span></code>) triangular matrix <code class="docutils literal"><span class="pre">A</span></code>. If <code class="docutils literal"><span class="pre">diag</span> <span class="pre">=</span> <span class="pre">N</span></code>, <code class="docutils literal"><span class="pre">A</span></code> has non-unit diagonal elements. If <code class="docutils literal"><span class="pre">diag</span> <span class="pre">=</span> <span class="pre">U</span></code>, all diagonal elements of <code class="docutils literal"><span class="pre">A</span></code> are one. <code class="docutils literal"><span class="pre">A</span></code> is overwritten with its inverse.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.trtrs!">
<code class="descname">trtrs!</code><span class="sig-paren">(</span><em>uplo</em>, <em>trans</em>, <em>diag</em>, <em>A</em>, <em>B</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.LAPACK.trtrs!" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves <code class="docutils literal"><span class="pre">A</span> <span class="pre">*</span> <span class="pre">X</span> <span class="pre">=</span> <span class="pre">B</span></code> (<code class="docutils literal"><span class="pre">trans</span> <span class="pre">=</span> <span class="pre">N</span></code>), <code class="docutils literal"><span class="pre">A.'</span> <span class="pre">*</span> <span class="pre">X</span> <span class="pre">=</span> <span class="pre">B</span></code> (<code class="docutils literal"><span class="pre">trans</span> <span class="pre">=</span> <span class="pre">T</span></code>), or <code class="docutils literal"><span class="pre">A'</span> <span class="pre">*</span> <span class="pre">X</span> <span class="pre">=</span> <span class="pre">B</span></code> (<code class="docutils literal"><span class="pre">trans</span> <span class="pre">=</span> <span class="pre">C</span></code>) for (upper if <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">U</span></code>, lower if <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">L</span></code>) triangular matrix <code class="docutils literal"><span class="pre">A</span></code>. If <code class="docutils literal"><span class="pre">diag</span> <span class="pre">=</span> <span class="pre">N</span></code>, <code class="docutils literal"><span class="pre">A</span></code> has non-unit diagonal elements. If <code class="docutils literal"><span class="pre">diag</span> <span class="pre">=</span> <span class="pre">U</span></code>, all diagonal elements of <code class="docutils literal"><span class="pre">A</span></code> are one. <code class="docutils literal"><span class="pre">B</span></code> is overwritten with the solution <code class="docutils literal"><span class="pre">X</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.trcon!">
<code class="descname">trcon!</code><span class="sig-paren">(</span><em>norm</em>, <em>uplo</em>, <em>diag</em>, <em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.LAPACK.trcon!" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the reciprocal condition number of (upper if <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">U</span></code>, lower if <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">L</span></code>) triangular matrix <code class="docutils literal"><span class="pre">A</span></code>. If <code class="docutils literal"><span class="pre">diag</span> <span class="pre">=</span> <span class="pre">N</span></code>, <code class="docutils literal"><span class="pre">A</span></code> has non-unit diagonal elements. If <code class="docutils literal"><span class="pre">diag</span> <span class="pre">=</span> <span class="pre">U</span></code>, all diagonal elements of <code class="docutils literal"><span class="pre">A</span></code> are one. If <code class="docutils literal"><span class="pre">norm</span> <span class="pre">=</span> <span class="pre">I</span></code>, the condition number is found in the infinity norm. If <code class="docutils literal"><span class="pre">norm</span> <span class="pre">=</span> <span class="pre">O</span></code> or <code class="docutils literal"><span class="pre">1</span></code>, the condition number is found in the one norm.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.trevc!">
<code class="descname">trevc!</code><span class="sig-paren">(</span><em>side</em>, <em>howmny</em>, <em>select</em>, <em>T</em>, <em>VL = similar(T)</em>, <em>VR = similar(T)</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.LAPACK.trevc!" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the eigensystem of an upper triangular matrix <code class="docutils literal"><span class="pre">T</span></code>. If <code class="docutils literal"><span class="pre">side</span> <span class="pre">=</span> <span class="pre">R</span></code>, the right eigenvectors are computed. If <code class="docutils literal"><span class="pre">side</span> <span class="pre">=</span> <span class="pre">L</span></code>, the left eigenvectors are computed. If <code class="docutils literal"><span class="pre">side</span> <span class="pre">=</span> <span class="pre">B</span></code>, both sets are computed. If <code class="docutils literal"><span class="pre">howmny</span> <span class="pre">=</span> <span class="pre">A</span></code>, all eigenvectors are found. If <code class="docutils literal"><span class="pre">howmny</span> <span class="pre">=</span> <span class="pre">B</span></code>, all eigenvectors are found and backtransformed using <code class="docutils literal"><span class="pre">VL</span></code> and <code class="docutils literal"><span class="pre">VR</span></code>. If <code class="docutils literal"><span class="pre">howmny</span> <span class="pre">=</span> <span class="pre">S</span></code>, only the eigenvectors corresponding to the values in <code class="docutils literal"><span class="pre">select</span></code> are computed.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.trrfs!">
<code class="descname">trrfs!</code><span class="sig-paren">(</span><em>uplo</em>, <em>trans</em>, <em>diag</em>, <em>A</em>, <em>B</em>, <em>X</em>, <em>Ferr</em>, <em>Berr</em><span class="sig-paren">)</span> &rarr; (Ferr, Berr)<a class="headerlink" href="#Base.LinAlg.LAPACK.trrfs!" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimates the error in the solution to <code class="docutils literal"><span class="pre">A</span> <span class="pre">*</span> <span class="pre">X</span> <span class="pre">=</span> <span class="pre">B</span></code> (<code class="docutils literal"><span class="pre">trans</span> <span class="pre">=</span> <span class="pre">N</span></code>), <code class="docutils literal"><span class="pre">A.'</span> <span class="pre">*</span> <span class="pre">X</span> <span class="pre">=</span> <span class="pre">B</span></code> (<code class="docutils literal"><span class="pre">trans</span> <span class="pre">=</span> <span class="pre">T</span></code>), <code class="docutils literal"><span class="pre">A'</span> <span class="pre">*</span> <span class="pre">X</span> <span class="pre">=</span> <span class="pre">B</span></code> (<code class="docutils literal"><span class="pre">trans</span> <span class="pre">=</span> <span class="pre">C</span></code>) for <code class="docutils literal"><span class="pre">side</span> <span class="pre">=</span> <span class="pre">L</span></code>, or the equivalent equations a right-handed <code class="docutils literal"><span class="pre">side</span> <span class="pre">=</span> <span class="pre">R</span></code> <code class="docutils literal"><span class="pre">X</span> <span class="pre">*</span> <span class="pre">A</span></code> after computing <code class="docutils literal"><span class="pre">X</span></code> using <code class="docutils literal"><span class="pre">trtrs!</span></code>. If <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">U</span></code>, <code class="docutils literal"><span class="pre">A</span></code> is upper triangular. If <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">L</span></code>, <code class="docutils literal"><span class="pre">A</span></code> is lower triangular. If <code class="docutils literal"><span class="pre">diag</span> <span class="pre">=</span> <span class="pre">N</span></code>, <code class="docutils literal"><span class="pre">A</span></code> has non-unit diagonal elements. If <code class="docutils literal"><span class="pre">diag</span> <span class="pre">=</span> <span class="pre">U</span></code>, all diagonal elements of <code class="docutils literal"><span class="pre">A</span></code> are one. <code class="docutils literal"><span class="pre">Ferr</span></code> and <code class="docutils literal"><span class="pre">Berr</span></code> are optional inputs. <code class="docutils literal"><span class="pre">Ferr</span></code> is the forward error and <code class="docutils literal"><span class="pre">Berr</span></code> is the backward error, each component-wise.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.stev!">
<code class="descname">stev!</code><span class="sig-paren">(</span><em>job</em>, <em>dv</em>, <em>ev</em><span class="sig-paren">)</span> &rarr; (dv, Zmat)<a class="headerlink" href="#Base.LinAlg.LAPACK.stev!" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the eigensystem for a symmetric tridiagonal matrix with <code class="docutils literal"><span class="pre">dv</span></code> as diagonal and <code class="docutils literal"><span class="pre">ev</span></code> as off-diagonal. If <code class="docutils literal"><span class="pre">job</span> <span class="pre">=</span> <span class="pre">N</span></code> only the eigenvalues are found and returned in <code class="docutils literal"><span class="pre">dv</span></code>. If <code class="docutils literal"><span class="pre">job</span> <span class="pre">=</span> <span class="pre">V</span></code> then the eigenvectors are also found and returned in <code class="docutils literal"><span class="pre">Zmat</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.stebz!">
<code class="descname">stebz!</code><span class="sig-paren">(</span><em>range</em>, <em>order</em>, <em>vl</em>, <em>vu</em>, <em>il</em>, <em>iu</em>, <em>abstol</em>, <em>dv</em>, <em>ev</em><span class="sig-paren">)</span> &rarr; (dv, iblock, isplit)<a class="headerlink" href="#Base.LinAlg.LAPACK.stebz!" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the eigenvalues for a symmetric tridiagonal matrix with <code class="docutils literal"><span class="pre">dv</span></code> as diagonal and <code class="docutils literal"><span class="pre">ev</span></code> as off-diagonal. If <code class="docutils literal"><span class="pre">range</span> <span class="pre">=</span> <span class="pre">A</span></code>, all the eigenvalues are found. If <code class="docutils literal"><span class="pre">range</span> <span class="pre">=</span> <span class="pre">V</span></code>, the eigenvalues in the half-open interval <code class="docutils literal"><span class="pre">(vl,</span> <span class="pre">vu]</span></code> are found. If <code class="docutils literal"><span class="pre">range</span> <span class="pre">=</span> <span class="pre">I</span></code>, the eigenvalues with indices between <code class="docutils literal"><span class="pre">il</span></code> and <code class="docutils literal"><span class="pre">iu</span></code> are found. If <code class="docutils literal"><span class="pre">order</span> <span class="pre">=</span> <span class="pre">B</span></code>, eigvalues are ordered within a block. If <code class="docutils literal"><span class="pre">order</span> <span class="pre">=</span> <span class="pre">E</span></code>, they are ordered across all the blocks. <code class="docutils literal"><span class="pre">abstol</span></code> can be set as a tolerance for convergence.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.stegr!">
<code class="descname">stegr!</code><span class="sig-paren">(</span><em>jobz</em>, <em>range</em>, <em>dv</em>, <em>ev</em>, <em>vl</em>, <em>vu</em>, <em>il</em>, <em>iu</em><span class="sig-paren">)</span> &rarr; (w, Z)<a class="headerlink" href="#Base.LinAlg.LAPACK.stegr!" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the eigenvalues (<code class="docutils literal"><span class="pre">jobz</span> <span class="pre">=</span> <span class="pre">N</span></code>) or eigenvalues and eigenvectors (<code class="docutils literal"><span class="pre">jobz</span> <span class="pre">=</span> <span class="pre">V</span></code>) for a symmetric tridiagonal matrix with <code class="docutils literal"><span class="pre">dv</span></code> as diagonal and <code class="docutils literal"><span class="pre">ev</span></code> as off-diagonal. If <code class="docutils literal"><span class="pre">range</span> <span class="pre">=</span> <span class="pre">A</span></code>, all the eigenvalues are found. If <code class="docutils literal"><span class="pre">range</span> <span class="pre">=</span> <span class="pre">V</span></code>, the eigenvalues in the half-open interval <code class="docutils literal"><span class="pre">(vl,</span> <span class="pre">vu]</span></code> are found. If <code class="docutils literal"><span class="pre">range</span> <span class="pre">=</span> <span class="pre">I</span></code>, the eigenvalues with indices between <code class="docutils literal"><span class="pre">il</span></code> and <code class="docutils literal"><span class="pre">iu</span></code> are found. The eigenvalues are returned in <code class="docutils literal"><span class="pre">w</span></code> and the eigenvectors in <code class="docutils literal"><span class="pre">Z</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.stein!">
<code class="descname">stein!</code><span class="sig-paren">(</span><em>dv</em>, <em>ev_in</em>, <em>w_in</em>, <em>iblock_in</em>, <em>isplit_in</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.LAPACK.stein!" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the eigenvectors for a symmetric tridiagonal matrix with <code class="docutils literal"><span class="pre">dv</span></code> as diagonal and <code class="docutils literal"><span class="pre">ev_in</span></code> as off-diagonal. <code class="docutils literal"><span class="pre">w_in</span></code> specifies the input eigenvalues for which to find corresponding eigenvectors. <code class="docutils literal"><span class="pre">iblock_in</span></code> specifies the submatrices corresponding to the eigenvalues in <code class="docutils literal"><span class="pre">w_in</span></code>. <code class="docutils literal"><span class="pre">isplit_in</span></code> specifies the splitting points between the submatrix blocks.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.syconv!">
<code class="descname">syconv!</code><span class="sig-paren">(</span><em>uplo</em>, <em>A</em>, <em>ipiv</em><span class="sig-paren">)</span> &rarr; (A, work)<a class="headerlink" href="#Base.LinAlg.LAPACK.syconv!" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts a symmetric matrix <code class="docutils literal"><span class="pre">A</span></code> (which has been factorized into a triangular matrix) into two matrices <code class="docutils literal"><span class="pre">L</span></code> and <code class="docutils literal"><span class="pre">D</span></code>. If <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">U</span></code>, <code class="docutils literal"><span class="pre">A</span></code> is upper triangular. If <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">L</span></code>, it is lower triangular. <code class="docutils literal"><span class="pre">ipiv</span></code> is the pivot vector from the triangular factorization. <code class="docutils literal"><span class="pre">A</span></code> is overwritten by <code class="docutils literal"><span class="pre">L</span></code> and <code class="docutils literal"><span class="pre">D</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.sysv!">
<code class="descname">sysv!</code><span class="sig-paren">(</span><em>uplo</em>, <em>A</em>, <em>B</em><span class="sig-paren">)</span> &rarr; (B, A, ipiv)<a class="headerlink" href="#Base.LinAlg.LAPACK.sysv!" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the solution to <code class="docutils literal"><span class="pre">A</span> <span class="pre">*</span> <span class="pre">X</span> <span class="pre">=</span> <span class="pre">B</span></code> for symmetric matrix <code class="docutils literal"><span class="pre">A</span></code>. If <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">U</span></code>, the upper half of <code class="docutils literal"><span class="pre">A</span></code> is stored. If <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">L</span></code>, the lower half is stored. <code class="docutils literal"><span class="pre">B</span></code> is overwritten by the solution <code class="docutils literal"><span class="pre">X</span></code>. <code class="docutils literal"><span class="pre">A</span></code> is overwritten by its Bunch-Kaufman factorization. <code class="docutils literal"><span class="pre">ipiv</span></code> contains pivoting information about the factorization.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.sytrf!">
<code class="descname">sytrf!</code><span class="sig-paren">(</span><em>uplo</em>, <em>A</em><span class="sig-paren">)</span> &rarr; (A, ipiv)<a class="headerlink" href="#Base.LinAlg.LAPACK.sytrf!" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the Bunch-Kaufman factorization of a symmetric matrix <code class="docutils literal"><span class="pre">A</span></code>. If <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">U</span></code>, the upper half of <code class="docutils literal"><span class="pre">A</span></code> is stored. If <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">L</span></code>, the lower half is stored.</p>
<p>Returns <code class="docutils literal"><span class="pre">A</span></code>, overwritten by the factorization, and a pivot vector <code class="docutils literal"><span class="pre">ipiv</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.sytri!">
<code class="descname">sytri!</code><span class="sig-paren">(</span><em>uplo</em>, <em>A</em>, <em>ipiv</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.LAPACK.sytri!" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the inverse of a symmetric matrix <code class="docutils literal"><span class="pre">A</span></code> using the results of <code class="docutils literal"><span class="pre">sytrf!</span></code>. If <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">U</span></code>, the upper half of <code class="docutils literal"><span class="pre">A</span></code> is stored. If <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">L</span></code>, the lower half is stored. <code class="docutils literal"><span class="pre">A</span></code> is overwritten by its inverse.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.sytrs!">
<code class="descname">sytrs!</code><span class="sig-paren">(</span><em>uplo</em>, <em>A</em>, <em>ipiv</em>, <em>B</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.LAPACK.sytrs!" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves the equation <code class="docutils literal"><span class="pre">A</span> <span class="pre">*</span> <span class="pre">X</span> <span class="pre">=</span> <span class="pre">B</span></code> for a symmetric matrix <code class="docutils literal"><span class="pre">A</span></code> using the results of <code class="docutils literal"><span class="pre">sytrf!</span></code>. If <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">U</span></code>, the upper half of <code class="docutils literal"><span class="pre">A</span></code> is stored. If <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">L</span></code>, the lower half is stored. <code class="docutils literal"><span class="pre">B</span></code> is overwritten by the solution <code class="docutils literal"><span class="pre">X</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.hesv!">
<code class="descname">hesv!</code><span class="sig-paren">(</span><em>uplo</em>, <em>A</em>, <em>B</em><span class="sig-paren">)</span> &rarr; (B, A, ipiv)<a class="headerlink" href="#Base.LinAlg.LAPACK.hesv!" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the solution to <code class="docutils literal"><span class="pre">A</span> <span class="pre">*</span> <span class="pre">X</span> <span class="pre">=</span> <span class="pre">B</span></code> for Hermitian matrix <code class="docutils literal"><span class="pre">A</span></code>. If <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">U</span></code>, the upper half of <code class="docutils literal"><span class="pre">A</span></code> is stored. If <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">L</span></code>, the lower half is stored. <code class="docutils literal"><span class="pre">B</span></code> is overwritten by the solution <code class="docutils literal"><span class="pre">X</span></code>. <code class="docutils literal"><span class="pre">A</span></code> is overwritten by its Bunch-Kaufman factorization. <code class="docutils literal"><span class="pre">ipiv</span></code> contains pivoting information about the factorization.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.hetrf!">
<code class="descname">hetrf!</code><span class="sig-paren">(</span><em>uplo</em>, <em>A</em><span class="sig-paren">)</span> &rarr; (A, ipiv)<a class="headerlink" href="#Base.LinAlg.LAPACK.hetrf!" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the Bunch-Kaufman factorization of a Hermitian matrix <code class="docutils literal"><span class="pre">A</span></code>. If <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">U</span></code>, the upper half of <code class="docutils literal"><span class="pre">A</span></code> is stored. If <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">L</span></code>, the lower half is stored.</p>
<p>Returns <code class="docutils literal"><span class="pre">A</span></code>, overwritten by the factorization, and a pivot vector.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.hetri!">
<code class="descname">hetri!</code><span class="sig-paren">(</span><em>uplo</em>, <em>A</em>, <em>ipiv</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.LAPACK.hetri!" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the inverse of a Hermitian matrix <code class="docutils literal"><span class="pre">A</span></code> using the results of <code class="docutils literal"><span class="pre">sytrf!</span></code>. If <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">U</span></code>, the upper half of <code class="docutils literal"><span class="pre">A</span></code> is stored. If <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">L</span></code>, the lower half is stored. <code class="docutils literal"><span class="pre">A</span></code> is overwritten by its inverse.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.hetrs!">
<code class="descname">hetrs!</code><span class="sig-paren">(</span><em>uplo</em>, <em>A</em>, <em>ipiv</em>, <em>B</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.LAPACK.hetrs!" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves the equation <code class="docutils literal"><span class="pre">A</span> <span class="pre">*</span> <span class="pre">X</span> <span class="pre">=</span> <span class="pre">B</span></code> for a Hermitian matrix <code class="docutils literal"><span class="pre">A</span></code> using the results of <code class="docutils literal"><span class="pre">sytrf!</span></code>. If <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">U</span></code>, the upper half of <code class="docutils literal"><span class="pre">A</span></code> is stored. If <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">L</span></code>, the lower half is stored. <code class="docutils literal"><span class="pre">B</span></code> is overwritten by the solution <code class="docutils literal"><span class="pre">X</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.syev!">
<code class="descname">syev!</code><span class="sig-paren">(</span><em>jobz</em>, <em>uplo</em>, <em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.LAPACK.syev!" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the eigenvalues (<code class="docutils literal"><span class="pre">jobz</span> <span class="pre">=</span> <span class="pre">N</span></code>) or eigenvalues and eigenvectors (<code class="docutils literal"><span class="pre">jobz</span> <span class="pre">=</span> <span class="pre">V</span></code>) of a symmetric matrix <code class="docutils literal"><span class="pre">A</span></code>. If <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">U</span></code>, the upper triangle of <code class="docutils literal"><span class="pre">A</span></code> is used. If <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">L</span></code>, the lower triangle of <code class="docutils literal"><span class="pre">A</span></code> is used.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.syevr!">
<code class="descname">syevr!</code><span class="sig-paren">(</span><em>jobz</em>, <em>range</em>, <em>uplo</em>, <em>A</em>, <em>vl</em>, <em>vu</em>, <em>il</em>, <em>iu</em>, <em>abstol</em><span class="sig-paren">)</span> &rarr; (W, Z)<a class="headerlink" href="#Base.LinAlg.LAPACK.syevr!" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the eigenvalues (<code class="docutils literal"><span class="pre">jobz</span> <span class="pre">=</span> <span class="pre">N</span></code>) or eigenvalues and eigenvectors (<code class="docutils literal"><span class="pre">jobz</span> <span class="pre">=</span> <span class="pre">V</span></code>) of a symmetric matrix <code class="docutils literal"><span class="pre">A</span></code>. If <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">U</span></code>, the upper triangle of <code class="docutils literal"><span class="pre">A</span></code> is used. If <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">L</span></code>, the lower triangle of <code class="docutils literal"><span class="pre">A</span></code> is used. If <code class="docutils literal"><span class="pre">range</span> <span class="pre">=</span> <span class="pre">A</span></code>, all the eigenvalues are found. If <code class="docutils literal"><span class="pre">range</span> <span class="pre">=</span> <span class="pre">V</span></code>, the eigenvalues in the half-open interval <code class="docutils literal"><span class="pre">(vl,</span> <span class="pre">vu]</span></code> are found. If <code class="docutils literal"><span class="pre">range</span> <span class="pre">=</span> <span class="pre">I</span></code>, the eigenvalues with indices between <code class="docutils literal"><span class="pre">il</span></code> and <code class="docutils literal"><span class="pre">iu</span></code> are found. <code class="docutils literal"><span class="pre">abstol</span></code> can be set as a tolerance for convergence.</p>
<p>The eigenvalues are returned in <code class="docutils literal"><span class="pre">W</span></code> and the eigenvectors in <code class="docutils literal"><span class="pre">Z</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.sygvd!">
<code class="descname">sygvd!</code><span class="sig-paren">(</span><em>jobz</em>, <em>range</em>, <em>uplo</em>, <em>A</em>, <em>vl</em>, <em>vu</em>, <em>il</em>, <em>iu</em>, <em>abstol</em><span class="sig-paren">)</span> &rarr; (w, A, B)<a class="headerlink" href="#Base.LinAlg.LAPACK.sygvd!" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the generalized eigenvalues (<code class="docutils literal"><span class="pre">jobz</span> <span class="pre">=</span> <span class="pre">N</span></code>) or eigenvalues and eigenvectors (<code class="docutils literal"><span class="pre">jobz</span> <span class="pre">=</span> <span class="pre">V</span></code>) of a symmetric matrix <code class="docutils literal"><span class="pre">A</span></code> and symmetric positive-definite matrix <code class="docutils literal"><span class="pre">B</span></code>. If <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">U</span></code>, the upper triangles of <code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">B</span></code> are used. If <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">L</span></code>, the lower triangles of <code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">B</span></code> are used. If <code class="docutils literal"><span class="pre">itype</span> <span class="pre">=</span> <span class="pre">1</span></code>, the problem to solve is <code class="docutils literal"><span class="pre">A</span> <span class="pre">*</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">lambda</span> <span class="pre">*</span> <span class="pre">B</span> <span class="pre">*</span> <span class="pre">x</span></code>. If <code class="docutils literal"><span class="pre">itype</span> <span class="pre">=</span> <span class="pre">2</span></code>, the problem to solve is <code class="docutils literal"><span class="pre">A</span> <span class="pre">*</span> <span class="pre">B</span> <span class="pre">*</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">lambda</span> <span class="pre">*</span> <span class="pre">x</span></code>. If <code class="docutils literal"><span class="pre">itype</span> <span class="pre">=</span> <span class="pre">3</span></code>, the problem to solve is <code class="docutils literal"><span class="pre">B</span> <span class="pre">*</span> <span class="pre">A</span> <span class="pre">*</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">lambda</span> <span class="pre">*</span> <span class="pre">x</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.bdsqr!">
<code class="descname">bdsqr!</code><span class="sig-paren">(</span><em>uplo</em>, <em>d</em>, <em>e_</em>, <em>Vt</em>, <em>U</em>, <em>C</em><span class="sig-paren">)</span> &rarr; (d, Vt, U, C)<a class="headerlink" href="#Base.LinAlg.LAPACK.bdsqr!" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the singular value decomposition of a bidiagonal matrix with <code class="docutils literal"><span class="pre">d</span></code> on the diagonal and <code class="docutils literal"><span class="pre">e_</span></code> on the off-diagonal. If <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">U</span></code>, <code class="docutils literal"><span class="pre">e_</span></code> is the superdiagonal. If <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">L</span></code>, <code class="docutils literal"><span class="pre">e_</span></code> is the subdiagonal. Can optionally also compute the product <code class="docutils literal"><span class="pre">Q'</span> <span class="pre">*</span> <span class="pre">C</span></code>.</p>
<p>Returns the singular values in <code class="docutils literal"><span class="pre">d</span></code>, and the matrix <code class="docutils literal"><span class="pre">C</span></code> overwritten with <code class="docutils literal"><span class="pre">Q'</span> <span class="pre">*</span> <span class="pre">C</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.bdsdc!">
<code class="descname">bdsdc!</code><span class="sig-paren">(</span><em>uplo</em>, <em>compq</em>, <em>d</em>, <em>e_</em><span class="sig-paren">)</span> &rarr; (d, e, u, vt, q, iq)<a class="headerlink" href="#Base.LinAlg.LAPACK.bdsdc!" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the singular value decomposition of a bidiagonal matrix with <code class="docutils literal"><span class="pre">d</span></code> on the diagonal and <code class="docutils literal"><span class="pre">e_</span></code> on the off-diagonal using a divide and conqueq method. If <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">U</span></code>, <code class="docutils literal"><span class="pre">e_</span></code> is the superdiagonal. If <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">L</span></code>, <code class="docutils literal"><span class="pre">e_</span></code> is the subdiagonal. If <code class="docutils literal"><span class="pre">compq</span> <span class="pre">=</span> <span class="pre">N</span></code>, only the singular values are found. If <code class="docutils literal"><span class="pre">compq</span> <span class="pre">=</span> <span class="pre">I</span></code>, the singular values and vectors are found. If <code class="docutils literal"><span class="pre">compq</span> <span class="pre">=</span> <span class="pre">P</span></code>, the singular values and vectors are found in compact form. Only works for real types.</p>
<p>Returns the singular values in <code class="docutils literal"><span class="pre">d</span></code>, and if <code class="docutils literal"><span class="pre">compq</span> <span class="pre">=</span> <span class="pre">P</span></code>, the compact singular vectors in <code class="docutils literal"><span class="pre">iq</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.gecon!">
<code class="descname">gecon!</code><span class="sig-paren">(</span><em>normtype</em>, <em>A</em>, <em>anorm</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.LAPACK.gecon!" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the reciprocal condition number of matrix <code class="docutils literal"><span class="pre">A</span></code>. If <code class="docutils literal"><span class="pre">normtype</span> <span class="pre">=</span> <span class="pre">I</span></code>, the condition number is found in the infinity norm. If <code class="docutils literal"><span class="pre">normtype</span> <span class="pre">=</span> <span class="pre">O</span></code> or <code class="docutils literal"><span class="pre">1</span></code>, the condition number is found in the one norm. <code class="docutils literal"><span class="pre">A</span></code> must be the result of <code class="docutils literal"><span class="pre">getrf!</span></code> and <code class="docutils literal"><span class="pre">anorm</span></code> is the norm of <code class="docutils literal"><span class="pre">A</span></code> in the relevant norm.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.gehrd!">
<code class="descname">gehrd!</code><span class="sig-paren">(</span><em>ilo</em>, <em>ihi</em>, <em>A</em><span class="sig-paren">)</span> &rarr; (A, tau)<a class="headerlink" href="#Base.LinAlg.LAPACK.gehrd!" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts a matrix <code class="docutils literal"><span class="pre">A</span></code> to Hessenberg form. If <code class="docutils literal"><span class="pre">A</span></code> is balanced with <code class="docutils literal"><span class="pre">gebal!</span></code> then <code class="docutils literal"><span class="pre">ilo</span></code> and <code class="docutils literal"><span class="pre">ihi</span></code> are the outputs of <code class="docutils literal"><span class="pre">gebal!</span></code>. Otherwise they should be <code class="docutils literal"><span class="pre">ilo</span> <span class="pre">=</span> <span class="pre">1</span></code> and <code class="docutils literal"><span class="pre">ihi</span> <span class="pre">=</span> <span class="pre">size(A,2)</span></code>. <code class="docutils literal"><span class="pre">tau</span></code> contains the elementary reflectors of the factorization.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.orghr!">
<code class="descname">orghr!</code><span class="sig-paren">(</span><em>ilo</em>, <em>ihi</em>, <em>A</em>, <em>tau</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.LAPACK.orghr!" title="Permalink to this definition">¶</a></dt>
<dd><p>Explicitly finds <code class="docutils literal"><span class="pre">Q</span></code>, the orthogonal/unitary matrix from <code class="docutils literal"><span class="pre">gehrd!</span></code>. <code class="docutils literal"><span class="pre">ilo</span></code>, <code class="docutils literal"><span class="pre">ihi</span></code>, <code class="docutils literal"><span class="pre">A</span></code>, and <code class="docutils literal"><span class="pre">tau</span></code> must correspond to the input/output to <code class="docutils literal"><span class="pre">gehrd!</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.gees!">
<code class="descname">gees!</code><span class="sig-paren">(</span><em>jobvs</em>, <em>A</em><span class="sig-paren">)</span> &rarr; (A, vs, w)<a class="headerlink" href="#Base.LinAlg.LAPACK.gees!" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the eigenvalues (<code class="docutils literal"><span class="pre">jobvs</span> <span class="pre">=</span> <span class="pre">N</span></code>) or the eigenvalues and Schur vectors (<code class="docutils literal"><span class="pre">jobvs</span> <span class="pre">=</span> <span class="pre">V</span></code>) of matrix <code class="docutils literal"><span class="pre">A</span></code>. <code class="docutils literal"><span class="pre">A</span></code> is overwritten by its Schur form.</p>
<p>Returns <code class="docutils literal"><span class="pre">A</span></code>, <code class="docutils literal"><span class="pre">vs</span></code> containing the Schur vectors, and <code class="docutils literal"><span class="pre">w</span></code>, containing the eigenvalues.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.gges!">
<code class="descname">gges!</code><span class="sig-paren">(</span><em>jobvsl</em>, <em>jobvsr</em>, <em>A</em>, <em>B</em><span class="sig-paren">)</span> &rarr; (A, B, alpha, beta, vsl, vsr)<a class="headerlink" href="#Base.LinAlg.LAPACK.gges!" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the generalized eigenvalues, generalized Schur form, left Schur vectors (<code class="docutils literal"><span class="pre">jobsvl</span> <span class="pre">=</span> <span class="pre">V</span></code>), or right Schur vectors (<code class="docutils literal"><span class="pre">jobvsr</span> <span class="pre">=</span> <span class="pre">V</span></code>) of <code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">B</span></code>.</p>
<p>The generalized eigenvalues are returned in <code class="docutils literal"><span class="pre">alpha</span></code> and <code class="docutils literal"><span class="pre">beta</span></code>. The left Schur vectors are returned in <code class="docutils literal"><span class="pre">vsl</span></code> and the right Schur vectors are returned in <code class="docutils literal"><span class="pre">vsr</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.trsen!">
<code class="descname">trsen!</code><span class="sig-paren">(</span><em>compq</em>, <em>job</em>, <em>select</em>, <em>T</em>, <em>Q</em><span class="sig-paren">)</span> &rarr; (T, Q, w)<a class="headerlink" href="#Base.LinAlg.LAPACK.trsen!" title="Permalink to this definition">¶</a></dt>
<dd><p>Reorder the Schur factorization of a matrix and optionally finds reciprocal condition numbers. If <code class="docutils literal"><span class="pre">job</span> <span class="pre">=</span> <span class="pre">N</span></code>, no condition numbers are found. If <code class="docutils literal"><span class="pre">job</span> <span class="pre">=</span> <span class="pre">E</span></code>, only the condition number for this cluster of eigenvalues is found. If <code class="docutils literal"><span class="pre">job</span> <span class="pre">=</span> <span class="pre">V</span></code>, only the condition number for the invariant subspace is found. If <code class="docutils literal"><span class="pre">job</span> <span class="pre">=</span> <span class="pre">B</span></code> then the condition numbers for the cluster and subspace are found. If <code class="docutils literal"><span class="pre">compq</span> <span class="pre">=</span> <span class="pre">V</span></code> the Schur vectors <code class="docutils literal"><span class="pre">Q</span></code> are updated. If <code class="docutils literal"><span class="pre">compq</span> <span class="pre">=</span> <span class="pre">N</span></code> the Schur vectors are not modified. <code class="docutils literal"><span class="pre">select</span></code> determines which eigenvalues are in the cluster.</p>
<p>Returns <code class="docutils literal"><span class="pre">T</span></code>, <code class="docutils literal"><span class="pre">Q</span></code>, and reordered eigenvalues in <code class="docutils literal"><span class="pre">w</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.tgsen!">
<code class="descname">tgsen!</code><span class="sig-paren">(</span><em>select</em>, <em>S</em>, <em>T</em>, <em>Q</em>, <em>Z</em><span class="sig-paren">)</span> &rarr; (S, T, alpha, beta, Q, Z)<a class="headerlink" href="#Base.LinAlg.LAPACK.tgsen!" title="Permalink to this definition">¶</a></dt>
<dd><p>Reorders the vectors of a generalized Schur decomposition. <code class="docutils literal"><span class="pre">select</span></code> specifices the eigenvalues in each cluster.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.trsyl!">
<code class="descname">trsyl!</code><span class="sig-paren">(</span><em>transa</em>, <em>transb</em>, <em>A</em>, <em>B</em>, <em>C</em>, <em>isgn=1</em><span class="sig-paren">)</span> &rarr; (C, scale)<a class="headerlink" href="#Base.LinAlg.LAPACK.trsyl!" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves the Sylvester matrix equation <code class="docutils literal"><span class="pre">A</span> <span class="pre">*</span> <span class="pre">X</span> <span class="pre">+/-</span> <span class="pre">X</span> <span class="pre">*</span> <span class="pre">B</span> <span class="pre">=</span> <span class="pre">scale*C</span></code> where <code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">B</span></code> are both quasi-upper triangular. If <code class="docutils literal"><span class="pre">transa</span> <span class="pre">=</span> <span class="pre">N</span></code>, <code class="docutils literal"><span class="pre">A</span></code> is not modified. If <code class="docutils literal"><span class="pre">transa</span> <span class="pre">=</span> <span class="pre">T</span></code>, <code class="docutils literal"><span class="pre">A</span></code> is transposed. If <code class="docutils literal"><span class="pre">transa</span> <span class="pre">=</span> <span class="pre">C</span></code>, <code class="docutils literal"><span class="pre">A</span></code> is conjugate transposed. Similarly for <code class="docutils literal"><span class="pre">transb</span></code> and <code class="docutils literal"><span class="pre">B</span></code>. If <code class="docutils literal"><span class="pre">isgn</span> <span class="pre">=</span> <span class="pre">1</span></code>, the equation <code class="docutils literal"><span class="pre">A</span> <span class="pre">*</span> <span class="pre">X</span> <span class="pre">+</span> <span class="pre">X</span> <span class="pre">*</span> <span class="pre">B</span> <span class="pre">=</span> <span class="pre">scale</span> <span class="pre">*</span> <span class="pre">C</span></code> is solved. If <code class="docutils literal"><span class="pre">isgn</span> <span class="pre">=</span> <span class="pre">-1</span></code>, the equation <code class="docutils literal"><span class="pre">A</span> <span class="pre">*</span> <span class="pre">X</span> <span class="pre">-</span> <span class="pre">X</span> <span class="pre">*</span> <span class="pre">B</span> <span class="pre">=</span> <span class="pre">scale</span> <span class="pre">*</span> <span class="pre">C</span></code> is solved.</p>
<p>Returns <code class="docutils literal"><span class="pre">X</span></code> (overwriting <code class="docutils literal"><span class="pre">C</span></code>) and <code class="docutils literal"><span class="pre">scale</span></code>.</p>
</dd></dl>

</div>
</div>


          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../constants/" class="btn btn-neutral float-right" title="Constants">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../parallel/" class="btn btn-neutral" title="Tasks and Parallel Computing"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
    </p>
  </div>

  <a href="https://github.com/snide/sphinx_rtd_theme">Sphinx theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>
</footer>
        </div>
      </div>

    </section>

  </div>
  

  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'0.4.8-pre',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>