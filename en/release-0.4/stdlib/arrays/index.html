

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Arrays &mdash; Julia Language 0.4.8-pre documentation</title>
  

  
  

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/julia.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../../_static/julia.css" type="text/css" />
  
    <link rel="top" title="Julia Language 0.4.8-pre documentation" href="../../"/>
        <link rel="next" title="Tasks and Parallel Computing" href="../parallel/"/>
        <link rel="prev" title="Strings" href="../strings/"/> 

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div style="text-align:center; background-color:pink; padding:5px 0; font-size:14px; height:30px;">
    This is document is for an old version of Julia.
    Please checkout the
    <a href="https://docs.julialang.org/en/stable/"
       style="color: #2980B9;">
      current stable release
    </a>.
  </div>

  <div class="wy-grid-for-nav" style="top: 30px;">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        <a href="http://julialang.org/"><img src="../../_static/julia-logo.svg" class="logo"></a>
        <!--
        <a href="../../" class="fa fa-home"> Julia Language</a>
        -->
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search/" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
        
            <ul>
<li class="toctree-l1"><a class="reference internal" href="../../manual/introduction/">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/getting-started/">Getting Started</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/getting-started/#resources">Resources</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/variables/">Variables</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/variables/#allowed-variable-names">Allowed Variable Names</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/variables/#stylistic-conventions">Stylistic Conventions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/integers-and-floating-point-numbers/">Integers and Floating-Point Numbers</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/integers-and-floating-point-numbers/#integers">Integers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/integers-and-floating-point-numbers/#floating-point-numbers">Floating-Point Numbers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/integers-and-floating-point-numbers/#arbitrary-precision-arithmetic">Arbitrary Precision Arithmetic</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/integers-and-floating-point-numbers/#numeric-literal-coefficients">Numeric Literal Coefficients</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/integers-and-floating-point-numbers/#literal-zero-and-one">Literal zero and one</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/mathematical-operations/">Mathematical Operations and Elementary Functions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/mathematical-operations/#arithmetic-operators">Arithmetic Operators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/mathematical-operations/#bitwise-operators">Bitwise Operators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/mathematical-operations/#updating-operators">Updating operators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/mathematical-operations/#numeric-comparisons">Numeric Comparisons</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/mathematical-operations/#numerical-conversions">Numerical Conversions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/complex-and-rational-numbers/">Complex and Rational Numbers</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/complex-and-rational-numbers/#complex-numbers">Complex Numbers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/complex-and-rational-numbers/#rational-numbers">Rational Numbers</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/strings/">Strings</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/strings/#characters">Characters</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/strings/#string-basics">String Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/strings/#unicode-and-utf-8">Unicode and UTF-8</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/strings/#interpolation">Interpolation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/strings/#triple-quoted-string-literals">Triple-Quoted String Literals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/strings/#common-operations">Common Operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/strings/#non-standard-string-literals">Non-Standard String Literals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/strings/#regular-expressions">Regular Expressions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/strings/#id3">Byte Array Literals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/strings/#version-number-literals">Version Number Literals</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/functions/">Functions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/functions/#argument-passing-behavior">Argument Passing Behavior</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/functions/#the-return-keyword">The <code class="docutils literal"><span class="pre">return</span></code> Keyword</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/functions/#operators-are-functions">Operators Are Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/functions/#operators-with-special-names">Operators With Special Names</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/functions/#anonymous-functions">Anonymous Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/functions/#multiple-return-values">Multiple Return Values</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/functions/#varargs-functions">Varargs Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/functions/#optional-arguments">Optional Arguments</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/functions/#keyword-arguments">Keyword Arguments</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/functions/#evaluation-scope-of-default-values">Evaluation Scope of Default Values</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/functions/#do-block-syntax-for-function-arguments">Do-Block Syntax for Function Arguments</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/functions/#further-reading">Further Reading</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/control-flow/">Control Flow</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/control-flow/#compound-expressions">Compound Expressions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/control-flow/#conditional-evaluation">Conditional Evaluation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/control-flow/#short-circuit-evaluation">Short-Circuit Evaluation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/control-flow/#repeated-evaluation-loops">Repeated Evaluation: Loops</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/control-flow/#exception-handling">Exception Handling</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/control-flow/#tasks-aka-coroutines">Tasks (aka Coroutines)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/variables-and-scoping/">Scope of Variables</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/variables-and-scoping/#global-scope">Global Scope</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/variables-and-scoping/#local-scope">Local Scope</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/variables-and-scoping/#constants">Constants</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/types/">Types</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/types/#type-declarations">Type Declarations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/types/#abstract-types">Abstract Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/types/#bits-types">Bits Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/types/#composite-types">Composite Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/types/#immutable-composite-types">Immutable Composite Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/types/#declared-types">Declared Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/types/#type-unions">Type Unions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/types/#man-parametric-types">Parametric Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/types/#type-aliases">Type Aliases</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/types/#operations-on-types">Operations on Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/types/#value-types">&#8220;Value types&#8221;</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/types/#nullable-types-representing-missing-values">Nullable Types: Representing Missing Values</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/methods/">Methods</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/methods/#defining-methods">Defining Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/methods/#method-ambiguities">Method Ambiguities</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/methods/#parametric-methods">Parametric Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/methods/#note-on-optional-and-keyword-arguments">Note on Optional and keyword Arguments</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/methods/#call-overloading-and-function-like-objects">Call overloading and function-like objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/methods/#empty-generic-functions">Empty generic functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/constructors/">Constructors</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/constructors/#outer-constructor-methods">Outer Constructor Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/constructors/#inner-constructor-methods">Inner Constructor Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/constructors/#incomplete-initialization">Incomplete Initialization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/constructors/#parametric-constructors">Parametric Constructors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/constructors/#case-study-rational">Case Study: Rational</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/constructors/#constructors-call-and-conversion">Constructors, Call, and Conversion</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/constructors/#outer-only-constructors">Outer-only constructors</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/conversion-and-promotion/">Conversion and Promotion</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/conversion-and-promotion/#conversion">Conversion</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/conversion-and-promotion/#promotion">Promotion</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/interfaces/">Interfaces</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/interfaces/#iteration">Iteration</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/interfaces/#indexing">Indexing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/interfaces/#abstract-arrays">Abstract Arrays</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/modules/">Modules</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/modules/#summary-of-module-usage">Summary of module usage</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/documentation/">Documentation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/documentation/#accessing-documentation">Accessing Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/documentation/#functions-methods">Functions &amp; Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/documentation/#advanced-usage">Advanced Usage</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/documentation/#syntax-guide">Syntax Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/documentation/#markdown-syntax-notes">Markdown Syntax Notes</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/metaprogramming/">Metaprogramming</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/metaprogramming/#program-representation">Program representation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/metaprogramming/#expressions-and-evaluation">Expressions and evaluation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/metaprogramming/#macros">Macros</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/metaprogramming/#code-generation">Code Generation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/metaprogramming/#non-standard-string-literals">Non-Standard String Literals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/metaprogramming/#generated-functions">Generated functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/arrays/">Multi-dimensional Arrays</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/arrays/#arrays">Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/arrays/#sparse-matrices">Sparse Matrices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/linear-algebra/">Linear algebra</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/linear-algebra/#matrix-factorizations">Matrix factorizations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/linear-algebra/#special-matrices">Special matrices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/networking-and-streams/">Networking and Streams</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/networking-and-streams/#basic-stream-i-o">Basic Stream I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/networking-and-streams/#text-i-o">Text I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/networking-and-streams/#working-with-files">Working with Files</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/networking-and-streams/#a-simple-tcp-example">A simple TCP example</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/networking-and-streams/#resolving-ip-addresses">Resolving IP Addresses</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/parallel-computing/">Parallel Computing</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/parallel-computing/#code-availability-and-loading-packages">Code Availability and Loading Packages</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/parallel-computing/#data-movement">Data Movement</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/parallel-computing/#parallel-map-and-loops">Parallel Map and Loops</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/parallel-computing/#synchronization-with-remote-references">Synchronization With Remote References</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/parallel-computing/#scheduling">Scheduling</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/parallel-computing/#channels">Channels</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/parallel-computing/#remoterefs-and-abstractchannels">RemoteRefs and AbstractChannels</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/parallel-computing/#shared-arrays">Shared Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/parallel-computing/#distributed-garbage-collection">Distributed Garbage Collection</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/parallel-computing/#clustermanagers">ClusterManagers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/parallel-computing/#cluster-managers-with-custom-transports">Cluster Managers with custom transports</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/parallel-computing/#specifying-network-topology-experimental">Specifying network topology (Experimental)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/dates/">Date and DateTime</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/dates/#constructors">Constructors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/dates/#durations-comparisons">Durations/Comparisons</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/dates/#accessor-functions">Accessor Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/dates/#query-functions">Query Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/dates/#timetype-period-arithmetic">TimeType-Period Arithmetic</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/dates/#adjuster-functions">Adjuster Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/dates/#period-types">Period Types</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/running-external-programs/">Running External Programs</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/running-external-programs/#interpolation">Interpolation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/running-external-programs/#quoting">Quoting</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/running-external-programs/#pipelines">Pipelines</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/calling-c-and-fortran-code/">Calling C and Fortran Code</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/calling-c-and-fortran-code/#creating-c-compatible-julia-function-pointers">Creating C-Compatible Julia Function Pointers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/calling-c-and-fortran-code/#mapping-c-types-to-julia">Mapping C Types to Julia</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/calling-c-and-fortran-code/#mapping-c-functions-to-julia">Mapping C Functions to Julia</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/calling-c-and-fortran-code/#garbage-collection-safety">Garbage Collection Safety</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/calling-c-and-fortran-code/#non-constant-function-specifications">Non-constant Function Specifications</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/calling-c-and-fortran-code/#indirect-calls">Indirect Calls</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/calling-c-and-fortran-code/#calling-convention">Calling Convention</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/calling-c-and-fortran-code/#accessing-global-variables">Accessing Global Variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/calling-c-and-fortran-code/#accessing-data-through-a-pointer">Accessing Data through a Pointer</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/calling-c-and-fortran-code/#thread-safety">Thread-safety</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/calling-c-and-fortran-code/#more-about-callbacks">More About Callbacks</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/calling-c-and-fortran-code/#c">C++</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/calling-c-and-fortran-code/#handling-operating-system-variation">Handling Operating System Variation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/interacting-with-julia/">Interacting With Julia</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/interacting-with-julia/#the-different-prompt-modes">The different prompt modes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/interacting-with-julia/#key-bindings">Key bindings</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/interacting-with-julia/#tab-completion">Tab completion</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/embedding/">Embedding Julia</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/embedding/#high-level-embedding">High-Level Embedding</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/embedding/#converting-types">Converting Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/embedding/#calling-julia-functions">Calling Julia Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/embedding/#memory-management">Memory Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/embedding/#working-with-arrays">Working with Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/embedding/#exceptions">Exceptions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/packages/">Packages</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/packages/#package-status">Package Status</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/packages/#adding-and-removing-packages">Adding and Removing Packages</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/packages/#offline-installation-of-packages">Offline Installation of Packages</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/packages/#installing-unregistered-packages">Installing Unregistered Packages</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/packages/#updating-packages">Updating Packages</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/packages/#checkout-pin-and-free">Checkout, Pin and Free</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/packages/#custom-metadata-repository">Custom METADATA Repository</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/packages/#package-development">Package Development</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/packages/#initial-setup">Initial Setup</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/packages/#making-changes-to-an-existing-package">Making changes to an existing package</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/packages/#creating-a-new-package">Creating a new Package</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/packages/#fixing-package-requirements">Fixing Package Requirements</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/packages/#man-package-requirements">Requirements Specification</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/profile/">Profiling</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/profile/#basic-usage">Basic usage</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/profile/#accumulation-and-clearing">Accumulation and clearing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/profile/#options-for-controlling-the-display-of-profile-results">Options for controlling the display of profile results</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/profile/#configuration">Configuration</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/profile/#memory-allocation-analysis">Memory allocation analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/performance-tips/">Performance Tips</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#avoid-global-variables">Avoid global variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#measure-performance-with-time-and-pay-attention-to-memory-allocation">Measure performance with <code class="docutils literal"><span class="pre">&#64;time</span></code> and pay attention to memory allocation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#tools">Tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#avoid-containers-with-abstract-type-parameters">Avoid containers with abstract type parameters</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#type-declarations">Type declarations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#break-functions-into-multiple-definitions">Break functions into multiple definitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#write-type-stable-functions">Write &#8220;type-stable&#8221; functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#avoid-changing-the-type-of-a-variable">Avoid changing the type of a variable</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#separate-kernel-functions">Separate kernel functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#access-arrays-in-memory-order-along-columns">Access arrays in memory order, along columns</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#pre-allocating-outputs">Pre-allocating outputs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#avoid-string-interpolation-for-i-o">Avoid string interpolation for I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#optimize-network-i-o-during-parallel-execution">Optimize network I/O during parallel execution</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#fix-deprecation-warnings">Fix deprecation warnings</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#tweaks">Tweaks</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#performance-annotations">Performance Annotations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#treat-subnormal-numbers-as-zeros">Treat Subnormal Numbers as Zeros</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#code-warntype"><code class="docutils literal"><span class="pre">&#64;code_warntype</span></code></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/workflow-tips/">Workflow Tips</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/workflow-tips/#repl-based-workflow">REPL-based workflow</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/workflow-tips/#browser-based-workflow">Browser-based workflow</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/style-guide/">Style Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#write-functions-not-just-scripts">Write functions, not just scripts</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#avoid-writing-overly-specific-types">Avoid writing overly-specific types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#handle-excess-argument-diversity-in-the-caller">Handle excess argument diversity in the caller</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#append-to-names-of-functions-that-modify-their-arguments">Append <code class="docutils literal"><span class="pre">!</span></code> to names of functions that modify their arguments</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#avoid-strange-type-unions">Avoid strange type Unions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#avoid-type-unions-in-fields">Avoid type Unions in fields</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#avoid-elaborate-container-types">Avoid elaborate container types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#use-naming-conventions-consistent-with-julia-s-base">Use naming conventions consistent with Julia&#8217;s <code class="docutils literal"><span class="pre">base/</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#don-t-overuse-try-catch">Don&#8217;t overuse try-catch</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#don-t-parenthesize-conditions">Don&#8217;t parenthesize conditions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#don-t-overuse">Don&#8217;t overuse ...</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#don-t-use-unnecessary-static-parameters">Don&#8217;t use unnecessary static parameters</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#avoid-confusion-about-whether-something-is-an-instance-or-a-type">Avoid confusion about whether something is an instance or a type</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#don-t-overuse-macros">Don&#8217;t overuse macros</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#don-t-expose-unsafe-operations-at-the-interface-level">Don&#8217;t expose unsafe operations at the interface level</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#don-t-overload-methods-of-base-container-types">Don&#8217;t overload methods of base container types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#be-careful-with-type-equality">Be careful with type equality</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#do-not-write-x-f-x">Do not write <code class="docutils literal"><span class="pre">x-&gt;f(x)</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#avoid-using-floats-for-numeric-literals-in-generic-code-when-possible">Avoid using floats for numeric literals in generic code when possible</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/faq/">Frequently Asked Questions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/faq/#sessions-and-the-repl">Sessions and the REPL</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/faq/#functions">Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/faq/#types-type-declarations-and-constructors">Types, type declarations, and constructors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/faq/#packages-and-modules">Packages and Modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/faq/#nothingness-and-missing-values">Nothingness and missing values</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/faq/#memory">Memory</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/faq/#asynchronous-io-and-concurrent-synchronous-writes">Asynchronous IO and concurrent synchronous writes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/faq/#julia-releases">Julia Releases</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/noteworthy-differences/">Noteworthy Differences from other Languages</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/noteworthy-differences/#noteworthy-differences-from-matlab">Noteworthy differences from MATLAB</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/noteworthy-differences/#noteworthy-differences-from-r">Noteworthy differences from R</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/noteworthy-differences/#noteworthy-differences-from-python">Noteworthy differences from Python</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/noteworthy-differences/#noteworthy-differences-from-c-c">Noteworthy differences from C/C++</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/unicode-input/">Unicode Input</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../base/">Essentials</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../base/#introduction">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../base/#getting-around">Getting Around</a></li>
<li class="toctree-l2"><a class="reference internal" href="../base/#all-objects">All Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="../base/#types">Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../base/#generic-functions">Generic Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../base/#syntax">Syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="../base/#nullables">Nullables</a></li>
<li class="toctree-l2"><a class="reference internal" href="../base/#system">System</a></li>
<li class="toctree-l2"><a class="reference internal" href="../base/#errors">Errors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../base/#events">Events</a></li>
<li class="toctree-l2"><a class="reference internal" href="../base/#reflection">Reflection</a></li>
<li class="toctree-l2"><a class="reference internal" href="../base/#internals">Internals</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../collections/">Collections and Data Structures</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../collections/#iteration">Iteration</a></li>
<li class="toctree-l2"><a class="reference internal" href="../collections/#general-collections">General Collections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../collections/#iterable-collections">Iterable Collections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../collections/#indexable-collections">Indexable Collections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../collections/#associative-collections">Associative Collections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../collections/#set-like-collections">Set-Like Collections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../collections/#dequeues">Dequeues</a></li>
<li class="toctree-l2"><a class="reference internal" href="../collections/#priorityqueue">PriorityQueue</a></li>
<li class="toctree-l2"><a class="reference internal" href="../collections/#heap-functions">Heap Functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../math/">Mathematics</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../math/#mathematical-operators">Mathematical Operators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../math/#mathematical-functions">Mathematical Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../math/#statistics">Statistics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../math/#signal-processing">Signal Processing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../math/#numerical-integration">Numerical Integration</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../numbers/">Numbers</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../numbers/#standard-numeric-types">Standard Numeric Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../numbers/#data-formats">Data Formats</a></li>
<li class="toctree-l2"><a class="reference internal" href="../numbers/#general-number-functions-and-constants">General Number Functions and Constants</a></li>
<li class="toctree-l2"><a class="reference internal" href="../numbers/#bigfloats">BigFloats</a></li>
<li class="toctree-l2"><a class="reference internal" href="../numbers/#random-numbers">Random Numbers</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../strings/">Strings</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Arrays</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#basic-functions">Basic functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#constructors">Constructors</a></li>
<li class="toctree-l2"><a class="reference internal" href="#mathematical-operators-and-functions">Mathematical operators and functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#indexing-assignment-and-concatenation">Indexing, Assignment, and Concatenation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#array-functions">Array functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#combinatorics">Combinatorics</a></li>
<li class="toctree-l2"><a class="reference internal" href="#bitarrays">BitArrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="#sparse-matrices">Sparse Matrices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../parallel/">Tasks and Parallel Computing</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../parallel/#tasks">Tasks</a></li>
<li class="toctree-l2"><a class="reference internal" href="../parallel/#general-parallel-computing-support">General Parallel Computing Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../parallel/#shared-arrays">Shared Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="../parallel/#cluster-manager-interface">Cluster Manager Interface</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../linalg/">Linear Algebra</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../linalg/#module-Base.LinAlg">Standard Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../linalg/#module-Base.LinAlg.BLAS">BLAS Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../linalg/#module-Base.LinAlg.LAPACK">LAPACK Functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../constants/">Constants</a></li>
<li class="toctree-l1"><a class="reference internal" href="../file/">Filesystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../io-network/">I/O and Network</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../io-network/#general-i-o">General I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../io-network/#text-i-o">Text I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../io-network/#multimedia-i-o">Multimedia I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../io-network/#memory-mapped-i-o">Memory-mapped I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../io-network/#network-i-o">Network I/O</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../punctuation/">Punctuation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sort/">Sorting and Related Functions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../sort/#sorting-functions">Sorting Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sort/#order-related-functions">Order-Related Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sort/#sorting-algorithms">Sorting Algorithms</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../pkg/">Package Manager Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dates/">Dates and Time</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../dates/#dates-and-time-types">Dates and Time Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dates/#dates-functions">Dates Functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../test/">Unit and Functional Testing</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../test/#testing-base-julia">Testing Base Julia</a></li>
<li class="toctree-l2"><a class="reference internal" href="../test/#test-framework">Test Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="../test/#handlers">Handlers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../test/#macros">Macros</a></li>
<li class="toctree-l2"><a class="reference internal" href="../test/#functions">Functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../c/">C Interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../c/#llvm-interface">LLVM Interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../libc/">C Standard Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="../libdl/">Dynamic Linker</a></li>
<li class="toctree-l1"><a class="reference internal" href="../profile/">Profiling</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../devdocs/reflection/">Reflection and introspection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../devdocs/julia/">Documentation of Julia&#8217;s Internals</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/init/">Initialization of the Julia runtime</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/eval/">Eval of Julia code</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/ast/">Julia ASTs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/types/">More about types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/object/">Memory layout of Julia Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/cartesian/">Base.Cartesian</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/meta/">Talking to the compiler (the <code class="docutils literal"><span class="pre">:meta</span></code> mechanism)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/subarrays/">SubArrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/sysimg/">System Image Building</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/llvm/">Working with LLVM</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/stdio/">printf() and stdio in the Julia runtime</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/promote-op/">Operator-sensitive promotion</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../devdocs/C/">Developing/debugging Julia&#8217;s C code</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/backtraces/">Reporting and analyzing crashes (segfaults)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/debuggingtips/">gdb debugging tips</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/valgrind/">Using Valgrind with Julia</a></li>
</ul>
</li>
</ul>

        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../">Julia Language</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../">Docs</a> &raquo;</li>
      
    <li>Arrays</li>
      <li class="wy-breadcrumbs-aside">
        
          <a href="../../_sources/stdlib/arrays.txt" rel="nofollow"> View page source</a>
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document">
            
  <div class="section" id="arrays">
<span id="stdlib-arrays"></span><h1>Arrays<a class="headerlink" href="#arrays" title="Permalink to this headline">¶</a></h1>
<div class="section" id="basic-functions">
<h2>Basic functions<a class="headerlink" href="#basic-functions" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="Base.ndims">
<code class="descname">ndims</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span> &rarr; Integer<a class="headerlink" href="#Base.ndims" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of dimensions of <code class="docutils literal"><span class="pre">A</span></code></p>
</dd></dl>

<dl class="function">
<dt id="Base.size">
<code class="descname">size</code><span class="sig-paren">(</span><em>A</em><span class="optional">[</span>, <em>dim...</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#Base.size" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a tuple containing the dimensions of <code class="docutils literal"><span class="pre">A</span></code>. Optionally you can specify the dimension(s) you want the length of, and get the length of that dimension, or a tuple of the lengths of dimensions you asked for.:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="n">rand</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">);</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">size</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="mi">3</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">size</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="Base.iseltype">
<code class="descname">iseltype</code><span class="sig-paren">(</span><em>A</em>, <em>T</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.iseltype" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests whether <code class="docutils literal"><span class="pre">A</span></code> or its elements are of type <code class="docutils literal"><span class="pre">T</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.length">
<code class="descname">length</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span> &rarr; Integer<a class="headerlink" href="#Base.length" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of elements in <code class="docutils literal"><span class="pre">A</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.eachindex">
<code class="descname">eachindex</code><span class="sig-paren">(</span><em>A...</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.eachindex" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates an iterable object for visiting each index of an AbstractArray <code class="docutils literal"><span class="pre">A</span></code> in an efficient manner. For array types that have opted into fast linear indexing (like <code class="docutils literal"><span class="pre">Array</span></code>), this is simply the range <code class="docutils literal"><span class="pre">1:length(A)</span></code>. For other array types, this returns a specialized Cartesian range to efficiently index into the array with indices specified for every dimension. For other iterables, including strings and dictionaries, this returns an iterator object supporting arbitrary index types (e.g. unevenly spaced or non-integer indices).</p>
<p>Example for a sparse 2-d array:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="n">sparse</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="p">])</span>
<span class="mi">2</span><span class="n">x3</span> <span class="n">sparse</span> <span class="n">matrix</span> <span class="n">with</span> <span class="mi">3</span> <span class="kt">Int64</span> <span class="n">entries</span><span class="o">:</span>
        <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>  <span class="o">=</span>  <span class="mi">1</span>
        <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>  <span class="o">=</span>  <span class="o">-</span><span class="mi">5</span>
        <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>  <span class="o">=</span>  <span class="mi">2</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">iter</span> <span class="kp">in</span> <span class="n">eachindex</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
           <span class="nd">@show</span> <span class="n">iter</span><span class="o">.</span><span class="nb">I</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">iter</span><span class="o">.</span><span class="nb">I</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
           <span class="nd">@show</span> <span class="n">A</span><span class="p">[</span><span class="n">iter</span><span class="p">]</span>
       <span class="k">end</span>
<span class="p">(</span><span class="n">iter</span><span class="o">.</span><span class="nb">I</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">iter</span><span class="o">.</span><span class="nb">I</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">A</span><span class="p">[</span><span class="n">iter</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="p">(</span><span class="n">iter</span><span class="o">.</span><span class="nb">I</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">iter</span><span class="o">.</span><span class="nb">I</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">A</span><span class="p">[</span><span class="n">iter</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">5</span>
<span class="p">(</span><span class="n">iter</span><span class="o">.</span><span class="nb">I</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">iter</span><span class="o">.</span><span class="nb">I</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">A</span><span class="p">[</span><span class="n">iter</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="p">(</span><span class="n">iter</span><span class="o">.</span><span class="nb">I</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">iter</span><span class="o">.</span><span class="nb">I</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">A</span><span class="p">[</span><span class="n">iter</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="p">(</span><span class="n">iter</span><span class="o">.</span><span class="nb">I</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">iter</span><span class="o">.</span><span class="nb">I</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="n">A</span><span class="p">[</span><span class="n">iter</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
<span class="p">(</span><span class="n">iter</span><span class="o">.</span><span class="nb">I</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">iter</span><span class="o">.</span><span class="nb">I</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="n">A</span><span class="p">[</span><span class="n">iter</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
</pre></div>
</div>
<p>If you supply more than one <code class="docutils literal"><span class="pre">AbstractArray</span></code> argument, <code class="docutils literal"><span class="pre">eachindex</span></code> will create an iterable object that is fast for all arguments (a <code class="docutils literal"><span class="pre">UnitRange</span></code> if all inputs have fast linear indexing, a CartesianRange otherwise).  If the arrays have different sizes and/or dimensionalities, <code class="docutils literal"><span class="pre">eachindex</span></code> returns an iterable that spans the largest range along each dimension.</p>
</dd></dl>

<dl class="function">
<dt id="Base.Base.linearindexing">
<code class="descclassname">Base.</code><code class="descname">linearindexing</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.Base.linearindexing" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal"><span class="pre">linearindexing</span></code> defines how an AbstractArray most efficiently accesses its elements. If <code class="docutils literal"><span class="pre">Base.linearindexing(A)</span></code> returns <code class="docutils literal"><span class="pre">Base.LinearFast()</span></code>, this means that linear indexing with only one index is an efficient operation. If it instead returns <code class="docutils literal"><span class="pre">Base.LinearSlow()</span></code> (by default), this means that the array intrinsically accesses its elements with indices specified for every dimension. Since converting a linear index to multiple indexing subscripts is typically very expensive, this provides a traits-based mechanism to enable efficient generic code for all array types.</p>
<p>An abstract array subtype <code class="docutils literal"><span class="pre">MyArray</span></code> that wishes to opt into fast linear indexing behaviors should define <code class="docutils literal"><span class="pre">linearindexing</span></code> in the type-domain:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">Base</span><span class="o">.</span><span class="n">linearindexing</span><span class="p">{</span><span class="n">T</span><span class="o">&lt;:</span><span class="n">MyArray</span><span class="p">}(</span><span class="o">::</span><span class="kt">Type</span><span class="p">{</span><span class="n">T</span><span class="p">})</span> <span class="o">=</span> <span class="n">Base</span><span class="o">.</span><span class="n">LinearFast</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="Base.countnz">
<code class="descname">countnz</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.countnz" title="Permalink to this definition">¶</a></dt>
<dd><p>Counts the number of nonzero values in array <code class="docutils literal"><span class="pre">A</span></code> (dense or sparse). Note that this is not a constant-time operation. For sparse matrices, one should usually use <code class="docutils literal"><span class="pre">nnz</span></code>, which returns the number of stored values.</p>
</dd></dl>

<dl class="function">
<dt id="Base.conj!">
<code class="descname">conj!</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.conj!" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert an array to its complex conjugate in-place</p>
</dd></dl>

<dl class="function">
<dt id="Base.stride">
<code class="descname">stride</code><span class="sig-paren">(</span><em>A</em>, <em>k</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.stride" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the distance in memory (in number of elements) between adjacent elements in dimension <code class="docutils literal"><span class="pre">k</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.strides">
<code class="descname">strides</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.strides" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a tuple of the memory strides in each dimension</p>
</dd></dl>

<dl class="function">
<dt id="Base.ind2sub">
<code class="descname">ind2sub</code><span class="sig-paren">(</span><em>dims</em>, <em>index</em><span class="sig-paren">)</span> &rarr; subscripts<a class="headerlink" href="#Base.ind2sub" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a tuple of subscripts into an array with dimensions <code class="docutils literal"><span class="pre">dims</span></code>, corresponding to the linear index <code class="docutils literal"><span class="pre">index</span></code>.</p>
<p><strong>Example</strong>: <code class="docutils literal"><span class="pre">i,</span> <span class="pre">j,</span> <span class="pre">...</span> <span class="pre">=</span> <span class="pre">ind2sub(size(A),</span> <span class="pre">indmax(A))</span></code> provides the indices of the maximum element</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">ind2sub</code><span class="sig-paren">(</span><em>a</em>, <em>index</em><span class="sig-paren">)</span> &rarr; subscripts</dt>
<dd><p>Returns a tuple of subscripts into array <code class="docutils literal"><span class="pre">a</span></code> corresponding to the linear index <code class="docutils literal"><span class="pre">index</span></code></p>
</dd></dl>

<dl class="function">
<dt id="Base.sub2ind">
<code class="descname">sub2ind</code><span class="sig-paren">(</span><em>dims</em>, <em>i</em>, <em>j</em>, <em>k...</em><span class="sig-paren">)</span> &rarr; index<a class="headerlink" href="#Base.sub2ind" title="Permalink to this definition">¶</a></dt>
<dd><p>The inverse of <code class="docutils literal"><span class="pre">ind2sub</span></code>, returns the linear index corresponding to the provided subscripts</p>
</dd></dl>

</div>
<div class="section" id="constructors">
<h2>Constructors<a class="headerlink" href="#constructors" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="Base.Array">
<code class="descname">Array</code><span class="sig-paren">(</span><em>dims</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.Array" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal"><span class="pre">Array{T}(dims)</span></code> constructs an uninitialized dense array with element type <code class="docutils literal"><span class="pre">T</span></code>. <code class="docutils literal"><span class="pre">dims</span></code> may be a tuple or a series of integer arguments. The syntax <code class="docutils literal"><span class="pre">Array(T,</span> <span class="pre">dims)</span></code> is also available, but deprecated.</p>
</dd></dl>

<dl class="function">
<dt id="Base.getindex">
<code class="descname">getindex</code><span class="sig-paren">(</span><em>type</em><span class="optional">[</span>, <em>elements...</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#Base.getindex" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a 1-d array of the specified type. This is usually called with the syntax <code class="docutils literal"><span class="pre">Type[]</span></code>. Element values can be specified using <code class="docutils literal"><span class="pre">Type[a,b,c,...]</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.cell">
<code class="descname">cell</code><span class="sig-paren">(</span><em>dims</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.cell" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct an uninitialized cell array (heterogeneous array). <code class="docutils literal"><span class="pre">dims</span></code> can be either a tuple or a series of integer arguments.</p>
</dd></dl>

<dl class="function">
<dt id="Base.zeros">
<code class="descname">zeros</code><span class="sig-paren">(</span><em>type</em>, <em>dims</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.zeros" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an array of all zeros of specified type. The type defaults to Float64 if not specified.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">zeros</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span></dt>
<dd><p>Create an array of all zeros with the same element type and shape as <code class="docutils literal"><span class="pre">A</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.ones">
<code class="descname">ones</code><span class="sig-paren">(</span><em>type</em>, <em>dims</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.ones" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an array of all ones of specified type. The type defaults to <code class="docutils literal"><span class="pre">Float64</span></code> if not specified.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">ones</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span></dt>
<dd><p>Create an array of all ones with the same element type and shape as <code class="docutils literal"><span class="pre">A</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.trues">
<code class="descname">trues</code><span class="sig-paren">(</span><em>dims</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.trues" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a <code class="docutils literal"><span class="pre">BitArray</span></code> with all values set to <code class="docutils literal"><span class="pre">true</span></code>.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">trues</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span></dt>
<dd><p>Create a <code class="docutils literal"><span class="pre">BitArray</span></code> with all values set to <code class="docutils literal"><span class="pre">true</span></code> of the same shape as <code class="docutils literal"><span class="pre">A</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.falses">
<code class="descname">falses</code><span class="sig-paren">(</span><em>dims</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.falses" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a <code class="docutils literal"><span class="pre">BitArray</span></code> with all values set to <code class="docutils literal"><span class="pre">false</span></code>.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">falses</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span></dt>
<dd><p>Create a <code class="docutils literal"><span class="pre">BitArray</span></code> with all values set to <code class="docutils literal"><span class="pre">false</span></code> of the same shape as <code class="docutils literal"><span class="pre">A</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.fill">
<code class="descname">fill</code><span class="sig-paren">(</span><em>x</em>, <em>dims</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.fill" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an array filled with the value <code class="docutils literal"><span class="pre">x</span></code>. For example, <code class="docutils literal"><span class="pre">fill(1.0,</span> <span class="pre">(10,10))</span></code> returns a 10x10 array of floats, with each element initialized to <code class="docutils literal"><span class="pre">1.0</span></code>.</p>
<p>If <code class="docutils literal"><span class="pre">x</span></code> is an object reference, all elements will refer to the same object. <code class="docutils literal"><span class="pre">fill(Foo(),</span> <span class="pre">dims)</span></code> will return an array filled with the result of evaluating <code class="docutils literal"><span class="pre">Foo()</span></code> once.</p>
</dd></dl>

<dl class="function">
<dt id="Base.fill!">
<code class="descname">fill!</code><span class="sig-paren">(</span><em>A</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.fill!" title="Permalink to this definition">¶</a></dt>
<dd><p>Fill array <code class="docutils literal"><span class="pre">A</span></code> with the value <code class="docutils literal"><span class="pre">x</span></code>. If <code class="docutils literal"><span class="pre">x</span></code> is an object reference, all elements will refer to the same object. <code class="docutils literal"><span class="pre">fill!(A,</span> <span class="pre">Foo())</span></code> will return <code class="docutils literal"><span class="pre">A</span></code> filled with the result of evaluating <code class="docutils literal"><span class="pre">Foo()</span></code> once.</p>
</dd></dl>

<dl class="function">
<dt id="Base.reshape">
<code class="descname">reshape</code><span class="sig-paren">(</span><em>A</em>, <em>dims</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.reshape" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an array with the same data as the given array, but with different dimensions. An implementation for a particular type of array may choose whether the data is copied or shared.</p>
</dd></dl>

<dl class="function">
<dt id="Base.similar">
<code class="descname">similar</code><span class="sig-paren">(</span><em>array</em><span class="optional">[</span>, <em>element_type=eltype(array)</em><span class="optional">]</span><span class="optional">[</span>, <em>dims=size(array)</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#Base.similar" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an uninitialized mutable array with the given element type and size, based upon the given source array. The second and third arguments are both optional, defaulting to the given array&#8217;s <code class="docutils literal"><span class="pre">eltype</span></code> and <code class="docutils literal"><span class="pre">size</span></code>. The dimensions may be specified either as a single tuple argument or as a series of integer arguments.</p>
<p>Custom AbstractArray subtypes may choose which specific array type is best-suited to return for the given element type and dimensionality. If they do not specialize this method, the default is an <code class="docutils literal"><span class="pre">Array(element_type,</span> <span class="pre">dims...)</span></code>.</p>
<p>For example, <code class="docutils literal"><span class="pre">similar(1:10,</span> <span class="pre">1,</span> <span class="pre">4)</span></code> returns an uninitialized <code class="docutils literal"><span class="pre">Array{Int,2}</span></code> since ranges are neither mutable nor support 2 dimensions:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">similar</span><span class="p">(</span><span class="mi">1</span><span class="o">:</span><span class="mi">10</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="mi">1</span><span class="n">x4</span> <span class="kt">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">2</span><span class="p">}</span><span class="o">:</span>
 <span class="mi">4419743872</span>  <span class="mi">4374413872</span>  <span class="mi">4419743888</span>  <span class="mi">0</span>
</pre></div>
</div>
<p>Conversely, <code class="docutils literal"><span class="pre">similar(trues(10,10),</span> <span class="pre">2)</span></code> returns an uninitialized <code class="docutils literal"><span class="pre">BitVector</span></code> with two elements since <code class="docutils literal"><span class="pre">BitArray</span></code>s are both mutable and can support 1-dimensional arrays:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">similar</span><span class="p">(</span><span class="n">trues</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
<span class="mi">2</span><span class="o">-</span><span class="n">element</span> <span class="kt">BitArray</span><span class="p">{</span><span class="mi">1</span><span class="p">}</span><span class="o">:</span>
 <span class="kc">false</span>
 <span class="kc">false</span>
</pre></div>
</div>
<p>Since <code class="docutils literal"><span class="pre">BitArray</span></code>s can only store elements of type <code class="docutils literal"><span class="pre">Bool</span></code>, however, if you request a different element type it will create a regular <code class="docutils literal"><span class="pre">Array</span></code> instead:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">similar</span><span class="p">(</span><span class="n">falses</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span> <span class="kt">Float64</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="mi">2</span><span class="n">x4</span> <span class="kt">Array</span><span class="p">{</span><span class="kt">Float64</span><span class="p">,</span><span class="mi">2</span><span class="p">}</span><span class="o">:</span>
 <span class="mf">2.18425e-314</span>  <span class="mf">2.18425e-314</span>  <span class="mf">2.18425e-314</span>  <span class="mf">2.18425e-314</span>
 <span class="mf">2.18425e-314</span>  <span class="mf">2.18425e-314</span>  <span class="mf">2.18425e-314</span>  <span class="mf">2.18425e-314</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="Base.reinterpret">
<code class="descname">reinterpret</code><span class="sig-paren">(</span><em>type</em>, <em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.reinterpret" title="Permalink to this definition">¶</a></dt>
<dd><p>Change the type-interpretation of a block of memory. For example, <code class="docutils literal"><span class="pre">reinterpret(Float32,</span> <span class="pre">UInt32(7))</span></code> interprets the 4 bytes corresponding to <code class="docutils literal"><span class="pre">UInt32(7)</span></code> as a <code class="docutils literal"><span class="pre">Float32</span></code>. For arrays, this constructs an array with the same binary data as the given array, but with the specified element type.</p>
</dd></dl>

<dl class="function">
<dt id="Base.eye">
<code class="descname">eye</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.eye" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal"><span class="pre">n</span></code>-by-<code class="docutils literal"><span class="pre">n</span></code> identity matrix</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">eye</code><span class="sig-paren">(</span><em>m</em>, <em>n</em><span class="sig-paren">)</span></dt>
<dd><p><code class="docutils literal"><span class="pre">m</span></code>-by-<code class="docutils literal"><span class="pre">n</span></code> identity matrix</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">eye</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span></dt>
<dd><p>Constructs an identity matrix of the same dimensions and type as <code class="docutils literal"><span class="pre">A</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.linspace">
<code class="descname">linspace</code><span class="sig-paren">(</span><em>start</em>, <em>stop</em>, <em>n=100</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.linspace" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a range of <code class="docutils literal"><span class="pre">n</span></code> linearly spaced elements from <code class="docutils literal"><span class="pre">start</span></code> to <code class="docutils literal"><span class="pre">stop</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.logspace">
<code class="descname">logspace</code><span class="sig-paren">(</span><em>start</em>, <em>stop</em>, <em>n=50</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.logspace" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a vector of <code class="docutils literal"><span class="pre">n</span></code> logarithmically spaced numbers from <code class="docutils literal"><span class="pre">10^start</span></code> to <code class="docutils literal"><span class="pre">10^stop</span></code>.</p>
</dd></dl>

</div>
<div class="section" id="mathematical-operators-and-functions">
<h2>Mathematical operators and functions<a class="headerlink" href="#mathematical-operators-and-functions" title="Permalink to this headline">¶</a></h2>
<p>All mathematical operations and functions are supported for arrays</p>
<dl class="function">
<dt id="Base.broadcast">
<code class="descname">broadcast</code><span class="sig-paren">(</span><em>f</em>, <em>As...</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.broadcast" title="Permalink to this definition">¶</a></dt>
<dd><p>Broadcasts the arrays <code class="docutils literal"><span class="pre">As</span></code> to a common size by expanding singleton dimensions, and returns an array of the results <code class="docutils literal"><span class="pre">f(as...)</span></code> for each position.</p>
</dd></dl>

<dl class="function">
<dt id="Base.broadcast!">
<code class="descname">broadcast!</code><span class="sig-paren">(</span><em>f</em>, <em>dest</em>, <em>As...</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.broadcast!" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <code class="docutils literal"><span class="pre">broadcast</span></code>, but store the result of <code class="docutils literal"><span class="pre">broadcast(f,</span> <span class="pre">As...)</span></code> in the <code class="docutils literal"><span class="pre">dest</span></code> array. Note that <code class="docutils literal"><span class="pre">dest</span></code> is only used to store the result, and does not supply arguments to <code class="docutils literal"><span class="pre">f</span></code> unless it is also listed in the <code class="docutils literal"><span class="pre">As</span></code>, as in <code class="docutils literal"><span class="pre">broadcast!(f,</span> <span class="pre">A,</span> <span class="pre">A,</span> <span class="pre">B)</span></code> to perform <code class="docutils literal"><span class="pre">A[:]</span> <span class="pre">=</span> <span class="pre">broadcast(f,</span> <span class="pre">A,</span> <span class="pre">B)</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.bitbroadcast">
<code class="descname">bitbroadcast</code><span class="sig-paren">(</span><em>f</em>, <em>As...</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.bitbroadcast" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <code class="docutils literal"><span class="pre">broadcast</span></code>, but allocates a <code class="docutils literal"><span class="pre">BitArray</span></code> to store the result, rather then an <code class="docutils literal"><span class="pre">Array</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.broadcast_function">
<code class="descname">broadcast_function</code><span class="sig-paren">(</span><em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.broadcast_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a function <code class="docutils literal"><span class="pre">broadcast_f</span></code> such that <code class="docutils literal"><span class="pre">broadcast_function(f)(As...)</span> <span class="pre">===</span> <span class="pre">broadcast(f,</span> <span class="pre">As...)</span></code>. Most useful in the form <code class="docutils literal"><span class="pre">const</span> <span class="pre">broadcast_f</span> <span class="pre">=</span> <span class="pre">broadcast_function(f)</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.broadcast!_function">
<code class="descname">broadcast!_function</code><span class="sig-paren">(</span><em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.broadcast!_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <code class="docutils literal"><span class="pre">broadcast_function</span></code>, but for <code class="docutils literal"><span class="pre">broadcast!</span></code>.</p>
</dd></dl>

</div>
<div class="section" id="indexing-assignment-and-concatenation">
<h2>Indexing, Assignment, and Concatenation<a class="headerlink" href="#indexing-assignment-and-concatenation" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt>
<code class="descname">getindex</code><span class="sig-paren">(</span><em>A</em>, <em>inds...</em><span class="sig-paren">)</span></dt>
<dd><p>Returns a subset of array <code class="docutils literal"><span class="pre">A</span></code> as specified by <code class="docutils literal"><span class="pre">inds</span></code>, where each <code class="docutils literal"><span class="pre">ind</span></code> may be an <code class="docutils literal"><span class="pre">Int</span></code>, a <code class="docutils literal"><span class="pre">Range</span></code>, or a <code class="docutils literal"><span class="pre">Vector</span></code>. See the manual section on <a class="reference internal" href="../../manual/arrays/#man-array-indexing"><span class="std std-ref">array indexing</span></a> for details.</p>
</dd></dl>

<dl class="function">
<dt id="Base.sub">
<code class="descname">sub</code><span class="sig-paren">(</span><em>A</em>, <em>inds...</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.sub" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <a class="reference internal" href="../collections/#Base.getindex" title="Base.getindex"><code class="xref jl jl-func docutils literal"><span class="pre">getindex()</span></code></a>, but returns a view into the parent array <code class="docutils literal"><span class="pre">A</span></code> with the given indices instead of making a copy.  Calling <a class="reference internal" href="../collections/#Base.getindex" title="Base.getindex"><code class="xref jl jl-func docutils literal"><span class="pre">getindex()</span></code></a> or <a class="reference internal" href="../collections/#Base.setindex!" title="Base.setindex!"><code class="xref jl jl-func docutils literal"><span class="pre">setindex!()</span></code></a> on the returned <code class="xref jl jl-obj docutils literal"><span class="pre">SubArray</span></code> computes the indices to the parent array on the fly without checking bounds.</p>
</dd></dl>

<dl class="function">
<dt id="Base.parent">
<code class="descname">parent</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.parent" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the &#8220;parent array&#8221; of an array view type (e.g., <code class="docutils literal"><span class="pre">SubArray</span></code>), or the array itself if it is not a view</p>
</dd></dl>

<dl class="function">
<dt id="Base.parentindexes">
<code class="descname">parentindexes</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.parentindexes" title="Permalink to this definition">¶</a></dt>
<dd><p>From an array view <code class="docutils literal"><span class="pre">A</span></code>, returns the corresponding indexes in the parent</p>
</dd></dl>

<dl class="function">
<dt id="Base.slicedim">
<code class="descname">slicedim</code><span class="sig-paren">(</span><em>A</em>, <em>d</em>, <em>i</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.slicedim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return all the data of <code class="docutils literal"><span class="pre">A</span></code> where the index for dimension <code class="docutils literal"><span class="pre">d</span></code> equals <code class="docutils literal"><span class="pre">i</span></code>. Equivalent to <code class="docutils literal"><span class="pre">A[:,:,...,i,:,:,...]</span></code> where <code class="docutils literal"><span class="pre">i</span></code> is in position <code class="docutils literal"><span class="pre">d</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.slice">
<code class="descname">slice</code><span class="sig-paren">(</span><em>A</em>, <em>inds...</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.slice" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a view of array <code class="docutils literal"><span class="pre">A</span></code> with the given indices like <a class="reference internal" href="#Base.sub" title="Base.sub"><code class="xref jl jl-func docutils literal"><span class="pre">sub()</span></code></a>, but drops all dimensions indexed with scalars.</p>
</dd></dl>

<dl class="function">
<dt id="Base.setindex!">
<code class="descname">setindex!</code><span class="sig-paren">(</span><em>A</em>, <em>X</em>, <em>inds...</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.setindex!" title="Permalink to this definition">¶</a></dt>
<dd><p>Store values from array <code class="docutils literal"><span class="pre">X</span></code> within some subset of <code class="docutils literal"><span class="pre">A</span></code> as specified by <code class="docutils literal"><span class="pre">inds</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.broadcast_getindex">
<code class="descname">broadcast_getindex</code><span class="sig-paren">(</span><em>A</em>, <em>inds...</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.broadcast_getindex" title="Permalink to this definition">¶</a></dt>
<dd><p>Broadcasts the <code class="docutils literal"><span class="pre">inds</span></code> arrays to a common size like <code class="docutils literal"><span class="pre">broadcast</span></code>, and returns an array of the results <code class="docutils literal"><span class="pre">A[ks...]</span></code>, where <code class="docutils literal"><span class="pre">ks</span></code> goes over the positions in the broadcast.</p>
</dd></dl>

<dl class="function">
<dt id="Base.broadcast_setindex!">
<code class="descname">broadcast_setindex!</code><span class="sig-paren">(</span><em>A</em>, <em>X</em>, <em>inds...</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.broadcast_setindex!" title="Permalink to this definition">¶</a></dt>
<dd><p>Broadcasts the <code class="docutils literal"><span class="pre">X</span></code> and <code class="docutils literal"><span class="pre">inds</span></code> arrays to a common size and stores the value from each position in <code class="docutils literal"><span class="pre">X</span></code> at the indices given by the same positions in <code class="docutils literal"><span class="pre">inds</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.cat">
<code class="descname">cat</code><span class="sig-paren">(</span><em>dims</em>, <em>A...</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.cat" title="Permalink to this definition">¶</a></dt>
<dd><p>Concatenate the input arrays along the specified dimensions in the iterable <code class="docutils literal"><span class="pre">dims</span></code>. For dimensions not in <code class="docutils literal"><span class="pre">dims</span></code>, all input arrays should have the same size, which will also be the size of the output array along that dimension. For dimensions in <code class="docutils literal"><span class="pre">dims</span></code>, the size of the output array is the sum of the sizes of the input arrays along that dimension. If <code class="docutils literal"><span class="pre">dims</span></code> is a single number, the different arrays are tightly stacked along that dimension. If <code class="docutils literal"><span class="pre">dims</span></code> is an iterable containing several dimensions, this allows one to construct block diagonal matrices and their higher-dimensional analogues by simultaneously increasing several dimensions for every new input array and putting zero blocks elsewhere. For example, <code class="docutils literal"><span class="pre">cat([1,2],</span> <span class="pre">matrices...)</span></code> builds a block diagonal matrix, i.e. a block matrix with <code class="docutils literal"><span class="pre">matrices[1]</span></code>, <code class="docutils literal"><span class="pre">matrices[2]</span></code>, ... as diagonal blocks and matching zero blocks away from the diagonal.</p>
</dd></dl>

<dl class="function">
<dt id="Base.vcat">
<code class="descname">vcat</code><span class="sig-paren">(</span><em>A...</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.vcat" title="Permalink to this definition">¶</a></dt>
<dd><p>Concatenate along dimension 1</p>
</dd></dl>

<dl class="function">
<dt id="Base.hcat">
<code class="descname">hcat</code><span class="sig-paren">(</span><em>A...</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.hcat" title="Permalink to this definition">¶</a></dt>
<dd><p>Concatenate along dimension 2</p>
</dd></dl>

<dl class="function">
<dt id="Base.hvcat">
<code class="descname">hvcat</code><span class="sig-paren">(</span><em>rows::Tuple{Vararg{Int}}</em>, <em>values...</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.hvcat" title="Permalink to this definition">¶</a></dt>
<dd><p>Horizontal and vertical concatenation in one call. This function is called for block matrix syntax. The first argument specifies the number of arguments to concatenate in each block row.</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="nb">e</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span>
<span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="p">[</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="p">;</span> <span class="n">d</span> <span class="nb">e</span> <span class="n">f</span><span class="p">]</span>
<span class="mi">2</span><span class="n">x3</span> <span class="kt">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">2</span><span class="p">}</span><span class="o">:</span>
 <span class="mi">1</span>  <span class="mi">2</span>  <span class="mi">3</span>
 <span class="mi">4</span>  <span class="mi">5</span>  <span class="mi">6</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">hvcat</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">d</span><span class="p">,</span><span class="nb">e</span><span class="p">,</span><span class="n">f</span><span class="p">)</span>
<span class="mi">2</span><span class="n">x3</span> <span class="kt">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">2</span><span class="p">}</span><span class="o">:</span>
 <span class="mi">1</span>  <span class="mi">2</span>  <span class="mi">3</span>
 <span class="mi">4</span>  <span class="mi">5</span>  <span class="mi">6</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="p">[</span><span class="n">a</span> <span class="n">b</span><span class="p">;</span><span class="n">c</span> <span class="n">d</span><span class="p">;</span> <span class="nb">e</span> <span class="n">f</span><span class="p">]</span>
<span class="mi">3</span><span class="n">x2</span> <span class="kt">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">2</span><span class="p">}</span><span class="o">:</span>
 <span class="mi">1</span>  <span class="mi">2</span>
 <span class="mi">3</span>  <span class="mi">4</span>
 <span class="mi">5</span>  <span class="mi">6</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">hvcat</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">d</span><span class="p">,</span><span class="nb">e</span><span class="p">,</span><span class="n">f</span><span class="p">)</span>
<span class="mi">3</span><span class="n">x2</span> <span class="kt">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">2</span><span class="p">}</span><span class="o">:</span>
 <span class="mi">1</span>  <span class="mi">2</span>
 <span class="mi">3</span>  <span class="mi">4</span>
 <span class="mi">5</span>  <span class="mi">6</span>
</pre></div>
</div>
<p>If the first argument is a single integer <code class="docutils literal"><span class="pre">n</span></code>, then all block rows are assumed to have <code class="docutils literal"><span class="pre">n</span></code> block columns.</p>
</dd></dl>

<dl class="function">
<dt id="Base.flipdim">
<code class="descname">flipdim</code><span class="sig-paren">(</span><em>A</em>, <em>d</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.flipdim" title="Permalink to this definition">¶</a></dt>
<dd><p>Reverse <code class="docutils literal"><span class="pre">A</span></code> in dimension <code class="docutils literal"><span class="pre">d</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.circshift">
<code class="descname">circshift</code><span class="sig-paren">(</span><em>A</em>, <em>shifts</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.circshift" title="Permalink to this definition">¶</a></dt>
<dd><p>Circularly shift the data in an array. The second argument is a vector giving the amount to shift in each dimension.</p>
</dd></dl>

<dl class="function">
<dt id="Base.find">
<code class="descname">find</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.find" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a vector of the linear indexes of the non-zeros in <code class="docutils literal"><span class="pre">A</span></code> (determined by <code class="docutils literal"><span class="pre">A[i]!=0</span></code>). A common use of this is to convert a boolean array to an array of indexes of the <code class="docutils literal"><span class="pre">true</span></code> elements.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">find</code><span class="sig-paren">(</span><em>f</em>, <em>A</em><span class="sig-paren">)</span></dt>
<dd><p>Return a vector of the linear indexes of <code class="docutils literal"><span class="pre">A</span></code> where <code class="docutils literal"><span class="pre">f</span></code> returns <code class="docutils literal"><span class="pre">true</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.findn">
<code class="descname">findn</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.findn" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a vector of indexes for each dimension giving the locations of the non-zeros in <code class="docutils literal"><span class="pre">A</span></code> (determined by <code class="docutils literal"><span class="pre">A[i]!=0</span></code>).</p>
</dd></dl>

<dl class="function">
<dt id="Base.findnz">
<code class="descname">findnz</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.findnz" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a tuple <code class="docutils literal"><span class="pre">(I,</span> <span class="pre">J,</span> <span class="pre">V)</span></code> where <code class="docutils literal"><span class="pre">I</span></code> and <code class="docutils literal"><span class="pre">J</span></code> are the row and column indexes of the non-zero values in matrix <code class="docutils literal"><span class="pre">A</span></code>, and <code class="docutils literal"><span class="pre">V</span></code> is a vector of the non-zero values.</p>
</dd></dl>

<dl class="function">
<dt id="Base.findfirst">
<code class="descname">findfirst</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.findfirst" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index of the first non-zero value in <code class="docutils literal"><span class="pre">A</span></code> (determined by <code class="docutils literal"><span class="pre">A[i]!=0</span></code>).</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">findfirst</code><span class="sig-paren">(</span><em>A</em>, <em>v</em><span class="sig-paren">)</span></dt>
<dd><p>Return the index of the first element equal to <code class="docutils literal"><span class="pre">v</span></code> in <code class="docutils literal"><span class="pre">A</span></code>.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">findfirst</code><span class="sig-paren">(</span><em>predicate</em>, <em>A</em><span class="sig-paren">)</span></dt>
<dd><p>Return the index of the first element of <code class="docutils literal"><span class="pre">A</span></code> for which <code class="docutils literal"><span class="pre">predicate</span></code> returns <code class="docutils literal"><span class="pre">true</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.findlast">
<code class="descname">findlast</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.findlast" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index of the last non-zero value in <code class="docutils literal"><span class="pre">A</span></code> (determined by <code class="docutils literal"><span class="pre">A[i]!=0</span></code>).</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">findlast</code><span class="sig-paren">(</span><em>A</em>, <em>v</em><span class="sig-paren">)</span></dt>
<dd><p>Return the index of the last element equal to <code class="docutils literal"><span class="pre">v</span></code> in <code class="docutils literal"><span class="pre">A</span></code>.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">findlast</code><span class="sig-paren">(</span><em>predicate</em>, <em>A</em><span class="sig-paren">)</span></dt>
<dd><p>Return the index of the last element of <code class="docutils literal"><span class="pre">A</span></code> for which <code class="docutils literal"><span class="pre">predicate</span></code> returns <code class="docutils literal"><span class="pre">true</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.findnext">
<code class="descname">findnext</code><span class="sig-paren">(</span><em>A</em>, <em>i</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.findnext" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the next index &gt;= <code class="docutils literal"><span class="pre">i</span></code> of a non-zero element of <code class="docutils literal"><span class="pre">A</span></code>, or <code class="docutils literal"><span class="pre">0</span></code> if not found.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">findnext</code><span class="sig-paren">(</span><em>predicate</em>, <em>A</em>, <em>i</em><span class="sig-paren">)</span></dt>
<dd><p>Find the next index &gt;= <code class="docutils literal"><span class="pre">i</span></code> of an element of <code class="docutils literal"><span class="pre">A</span></code> for which <code class="docutils literal"><span class="pre">predicate</span></code> returns <code class="docutils literal"><span class="pre">true</span></code>, or <code class="docutils literal"><span class="pre">0</span></code> if not found.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">findnext</code><span class="sig-paren">(</span><em>A</em>, <em>v</em>, <em>i</em><span class="sig-paren">)</span></dt>
<dd><p>Find the next index &gt;= <code class="docutils literal"><span class="pre">i</span></code> of an element of <code class="docutils literal"><span class="pre">A</span></code> equal to <code class="docutils literal"><span class="pre">v</span></code> (using <code class="docutils literal"><span class="pre">==</span></code>), or <code class="docutils literal"><span class="pre">0</span></code> if not found.</p>
</dd></dl>

<dl class="function">
<dt id="Base.findprev">
<code class="descname">findprev</code><span class="sig-paren">(</span><em>A</em>, <em>i</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.findprev" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the previous index &lt;= <code class="docutils literal"><span class="pre">i</span></code> of a non-zero element of <code class="docutils literal"><span class="pre">A</span></code>, or <code class="docutils literal"><span class="pre">0</span></code> if not found.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">findprev</code><span class="sig-paren">(</span><em>predicate</em>, <em>A</em>, <em>i</em><span class="sig-paren">)</span></dt>
<dd><p>Find the previous index &lt;= <code class="docutils literal"><span class="pre">i</span></code> of an element of <code class="docutils literal"><span class="pre">A</span></code> for which <code class="docutils literal"><span class="pre">predicate</span></code> returns <code class="docutils literal"><span class="pre">true</span></code>, or <code class="docutils literal"><span class="pre">0</span></code> if not found.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">findprev</code><span class="sig-paren">(</span><em>A</em>, <em>v</em>, <em>i</em><span class="sig-paren">)</span></dt>
<dd><p>Find the previous index &lt;= <code class="docutils literal"><span class="pre">i</span></code> of an element of <code class="docutils literal"><span class="pre">A</span></code> equal to <code class="docutils literal"><span class="pre">v</span></code> (using <code class="docutils literal"><span class="pre">==</span></code>), or <code class="docutils literal"><span class="pre">0</span></code> if not found.</p>
</dd></dl>

<dl class="function">
<dt id="Base.permutedims">
<code class="descname">permutedims</code><span class="sig-paren">(</span><em>A</em>, <em>perm</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.permutedims" title="Permalink to this definition">¶</a></dt>
<dd><p>Permute the dimensions of array <code class="docutils literal"><span class="pre">A</span></code>. <code class="docutils literal"><span class="pre">perm</span></code> is a vector specifying a permutation of length <code class="docutils literal"><span class="pre">ndims(A)</span></code>. This is a generalization of transpose for multi-dimensional arrays. Transpose is equivalent to <code class="docutils literal"><span class="pre">permutedims(A,</span> <span class="pre">[2,1])</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.ipermutedims">
<code class="descname">ipermutedims</code><span class="sig-paren">(</span><em>A</em>, <em>perm</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.ipermutedims" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <a class="reference internal" href="#Base.permutedims" title="Base.permutedims"><code class="xref jl jl-func docutils literal"><span class="pre">permutedims()</span></code></a>, except the inverse of the given permutation is applied.</p>
</dd></dl>

<dl class="function">
<dt id="Base.permutedims!">
<code class="descname">permutedims!</code><span class="sig-paren">(</span><em>dest</em>, <em>src</em>, <em>perm</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.permutedims!" title="Permalink to this definition">¶</a></dt>
<dd><p>Permute the dimensions of array <code class="docutils literal"><span class="pre">src</span></code> and store the result in the array <code class="docutils literal"><span class="pre">dest</span></code>. <code class="docutils literal"><span class="pre">perm</span></code> is a vector specifying a permutation of length <code class="docutils literal"><span class="pre">ndims(src)</span></code>. The preallocated array <code class="docutils literal"><span class="pre">dest</span></code> should have <code class="docutils literal"><span class="pre">size(dest)</span> <span class="pre">==</span> <span class="pre">size(src)[perm]</span></code> and is completely overwritten. No in-place permutation is supported and unexpected results will happen if <code class="docutils literal"><span class="pre">src</span></code> and <code class="docutils literal"><span class="pre">dest</span></code> have overlapping memory regions.</p>
</dd></dl>

<dl class="function">
<dt id="Base.squeeze">
<code class="descname">squeeze</code><span class="sig-paren">(</span><em>A</em>, <em>dims</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.squeeze" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the dimensions specified by <code class="docutils literal"><span class="pre">dims</span></code> from array <code class="docutils literal"><span class="pre">A</span></code>. Elements of <code class="docutils literal"><span class="pre">dims</span></code> must be unique and within the range <code class="docutils literal"><span class="pre">1:ndims(A)</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.vec">
<code class="descname">vec</code><span class="sig-paren">(</span><em>Array</em><span class="sig-paren">)</span> &rarr; Vector<a class="headerlink" href="#Base.vec" title="Permalink to this definition">¶</a></dt>
<dd><p>Vectorize an array using column-major convention.</p>
</dd></dl>

<dl class="function">
<dt id="Base.promote_shape">
<code class="descname">promote_shape</code><span class="sig-paren">(</span><em>s1</em>, <em>s2</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.promote_shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Check two array shapes for compatibility, allowing trailing singleton dimensions, and return whichever shape has more dimensions.</p>
</dd></dl>

<dl class="function">
<dt id="Base.checkbounds">
<code class="descname">checkbounds</code><span class="sig-paren">(</span><em>array</em>, <em>indexes...</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.checkbounds" title="Permalink to this definition">¶</a></dt>
<dd><p>Throw an error if the specified indexes are not in bounds for the given array. Subtypes of <code class="docutils literal"><span class="pre">AbstractArray</span></code> should specialize this method if they need to provide custom bounds checking behaviors.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">checkbounds</code><span class="sig-paren">(</span><em>::Type{Bool}</em>, <em>dimlength::Integer</em>, <em>index</em><span class="sig-paren">)</span></dt>
<dd><p>Return a <code class="docutils literal"><span class="pre">Bool</span></code> describing if the given index is within the bounds of the given dimension length. Custom types that would like to behave as indices for all arrays can extend this method in order to provide a specialized bounds checking implementation.</p>
</dd></dl>

<dl class="function">
<dt id="Base.randsubseq">
<code class="descname">randsubseq</code><span class="sig-paren">(</span><em>A</em>, <em>p</em><span class="sig-paren">)</span> &rarr; Vector<a class="headerlink" href="#Base.randsubseq" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a vector consisting of a random subsequence of the given array <code class="docutils literal"><span class="pre">A</span></code>, where each element of <code class="docutils literal"><span class="pre">A</span></code> is included (in order) with independent probability <code class="docutils literal"><span class="pre">p</span></code>. (Complexity is linear in <code class="docutils literal"><span class="pre">p*length(A)</span></code>, so this function is efficient even if <code class="docutils literal"><span class="pre">p</span></code> is small and <code class="docutils literal"><span class="pre">A</span></code> is large.) Technically, this process is known as &#8220;Bernoulli sampling&#8221; of <code class="docutils literal"><span class="pre">A</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.randsubseq!">
<code class="descname">randsubseq!</code><span class="sig-paren">(</span><em>S</em>, <em>A</em>, <em>p</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.randsubseq!" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <code class="docutils literal"><span class="pre">randsubseq</span></code>, but the results are stored in <code class="docutils literal"><span class="pre">S</span></code> (which is resized as needed).</p>
</dd></dl>

</div>
<div class="section" id="array-functions">
<h2>Array functions<a class="headerlink" href="#array-functions" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="Base.cumprod">
<code class="descname">cumprod</code><span class="sig-paren">(</span><em>A</em><span class="optional">[</span>, <em>dim</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#Base.cumprod" title="Permalink to this definition">¶</a></dt>
<dd><p>Cumulative product along a dimension <code class="docutils literal"><span class="pre">dim</span></code> (defaults to 1).
See also <a class="reference internal" href="#Base.cumprod!" title="Base.cumprod!"><code class="xref jl jl-func docutils literal"><span class="pre">cumprod!()</span></code></a> to use a preallocated output array,
both for performance and to control the precision of the
output (e.g. to avoid overflow).</p>
</dd></dl>

<dl class="function">
<dt id="Base.cumprod!">
<code class="descname">cumprod!</code><span class="sig-paren">(</span><em>B</em>, <em>A</em><span class="optional">[</span>, <em>dim</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#Base.cumprod!" title="Permalink to this definition">¶</a></dt>
<dd><p>Cumulative product of <code class="docutils literal"><span class="pre">A</span></code> along a dimension, storing the result in <code class="docutils literal"><span class="pre">B</span></code>. The dimension defaults to 1.</p>
</dd></dl>

<dl class="function">
<dt id="Base.cumsum">
<code class="descname">cumsum</code><span class="sig-paren">(</span><em>A</em><span class="optional">[</span>, <em>dim</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#Base.cumsum" title="Permalink to this definition">¶</a></dt>
<dd><p>Cumulative sum along a dimension <code class="docutils literal"><span class="pre">dim</span></code> (defaults to 1).
See also <a class="reference internal" href="#Base.cumsum!" title="Base.cumsum!"><code class="xref jl jl-func docutils literal"><span class="pre">cumsum!()</span></code></a> to use a preallocated output array,
both for performance and to control the precision of the
output (e.g. to avoid overflow).</p>
</dd></dl>

<dl class="function">
<dt id="Base.cumsum!">
<code class="descname">cumsum!</code><span class="sig-paren">(</span><em>B</em>, <em>A</em><span class="optional">[</span>, <em>dim</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#Base.cumsum!" title="Permalink to this definition">¶</a></dt>
<dd><p>Cumulative sum of <code class="docutils literal"><span class="pre">A</span></code> along a dimension, storing the result in <code class="docutils literal"><span class="pre">B</span></code>. The dimension defaults to 1.</p>
</dd></dl>

<dl class="function">
<dt id="Base.cumsum_kbn">
<code class="descname">cumsum_kbn</code><span class="sig-paren">(</span><em>A</em><span class="optional">[</span>, <em>dim</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#Base.cumsum_kbn" title="Permalink to this definition">¶</a></dt>
<dd><p>Cumulative sum along a dimension, using the Kahan-Babuska-Neumaier compensated summation algorithm for additional accuracy. The dimension defaults to 1.</p>
</dd></dl>

<dl class="function">
<dt id="Base.cummin">
<code class="descname">cummin</code><span class="sig-paren">(</span><em>A</em><span class="optional">[</span>, <em>dim</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#Base.cummin" title="Permalink to this definition">¶</a></dt>
<dd><p>Cumulative minimum along a dimension. The dimension defaults to 1.</p>
</dd></dl>

<dl class="function">
<dt id="Base.cummax">
<code class="descname">cummax</code><span class="sig-paren">(</span><em>A</em><span class="optional">[</span>, <em>dim</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#Base.cummax" title="Permalink to this definition">¶</a></dt>
<dd><p>Cumulative maximum along a dimension. The dimension defaults to 1.</p>
</dd></dl>

<dl class="function">
<dt id="Base.diff">
<code class="descname">diff</code><span class="sig-paren">(</span><em>A</em><span class="optional">[</span>, <em>dim</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#Base.diff" title="Permalink to this definition">¶</a></dt>
<dd><p>Finite difference operator of matrix or vector.</p>
</dd></dl>

<dl class="function">
<dt id="Base.gradient">
<code class="descname">gradient</code><span class="sig-paren">(</span><em>F</em><span class="optional">[</span>, <em>h</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#Base.gradient" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute differences along vector <code class="docutils literal"><span class="pre">F</span></code>, using <code class="docutils literal"><span class="pre">h</span></code> as the spacing between points. The default spacing is one.</p>
</dd></dl>

<dl class="function">
<dt id="Base.rot180">
<code class="descname">rot180</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.rot180" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotate matrix <code class="docutils literal"><span class="pre">A</span></code> 180 degrees.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">rot180</code><span class="sig-paren">(</span><em>A</em>, <em>k</em><span class="sig-paren">)</span></dt>
<dd><p>Rotate matrix <code class="docutils literal"><span class="pre">A</span></code> 180 degrees an integer <code class="docutils literal"><span class="pre">k</span></code> number of times. If <code class="docutils literal"><span class="pre">k</span></code> is even, this is equivalent to a <code class="docutils literal"><span class="pre">copy</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.rotl90">
<code class="descname">rotl90</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.rotl90" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotate matrix <code class="docutils literal"><span class="pre">A</span></code> left 90 degrees.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">rotl90</code><span class="sig-paren">(</span><em>A</em>, <em>k</em><span class="sig-paren">)</span></dt>
<dd><p>Rotate matrix <code class="docutils literal"><span class="pre">A</span></code> left 90 degrees an integer <code class="docutils literal"><span class="pre">k</span></code> number of times. If <code class="docutils literal"><span class="pre">k</span></code> is zero or a multiple of four, this is equivalent to a <code class="docutils literal"><span class="pre">copy</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.rotr90">
<code class="descname">rotr90</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.rotr90" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotate matrix <code class="docutils literal"><span class="pre">A</span></code> right 90 degrees.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">rotr90</code><span class="sig-paren">(</span><em>A</em>, <em>k</em><span class="sig-paren">)</span></dt>
<dd><p>Rotate matrix <code class="docutils literal"><span class="pre">A</span></code> right 90 degrees an integer <code class="docutils literal"><span class="pre">k</span></code> number of times. If <code class="docutils literal"><span class="pre">k</span></code> is zero or a multiple of four, this is equivalent to a <code class="docutils literal"><span class="pre">copy</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.reducedim">
<code class="descname">reducedim</code><span class="sig-paren">(</span><em>f</em>, <em>A</em>, <em>dims</em><span class="optional">[</span>, <em>initial</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#Base.reducedim" title="Permalink to this definition">¶</a></dt>
<dd><p>Reduce 2-argument function <code class="docutils literal"><span class="pre">f</span></code> along dimensions of <code class="docutils literal"><span class="pre">A</span></code>. <code class="docutils literal"><span class="pre">dims</span></code> is a vector specifying the dimensions to reduce, and <code class="docutils literal"><span class="pre">initial</span></code> is the initial value to use in the reductions. For <code class="docutils literal"><span class="pre">+</span></code>, <code class="docutils literal"><span class="pre">*</span></code>, <code class="docutils literal"><span class="pre">max</span></code> and <code class="docutils literal"><span class="pre">min</span></code> the <code class="docutils literal"><span class="pre">initial</span></code> argument is optional.</p>
<p>The associativity of the reduction is implementation-dependent; if you need a particular associativity, e.g. left-to-right, you should write your own loop. See documentation for <code class="docutils literal"><span class="pre">reduce</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.mapreducedim">
<code class="descname">mapreducedim</code><span class="sig-paren">(</span><em>f</em>, <em>op</em>, <em>A</em>, <em>dims</em><span class="optional">[</span>, <em>initial</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#Base.mapreducedim" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluates to the same as <code class="docutils literal"><span class="pre">reducedim(op,</span> <span class="pre">map(f,</span> <span class="pre">A),</span> <span class="pre">dims,</span> <span class="pre">f(initial))</span></code>, but is generally faster because the intermediate array is avoided.</p>
</dd></dl>

<dl class="function">
<dt id="Base.mapslices">
<code class="descname">mapslices</code><span class="sig-paren">(</span><em>f</em>, <em>A</em>, <em>dims</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.mapslices" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform the given dimensions of array <code class="docutils literal"><span class="pre">A</span></code> using function <code class="docutils literal"><span class="pre">f</span></code>. <code class="docutils literal"><span class="pre">f</span></code> is called on each slice of <code class="docutils literal"><span class="pre">A</span></code> of the form <code class="docutils literal"><span class="pre">A[...,:,...,:,...]</span></code>. <code class="docutils literal"><span class="pre">dims</span></code> is an integer vector specifying where the colons go in this expression. The results are concatenated along the remaining dimensions. For example, if <code class="docutils literal"><span class="pre">dims</span></code> is <code class="docutils literal"><span class="pre">[1,2]</span></code> and <code class="docutils literal"><span class="pre">A</span></code> is 4-dimensional, <code class="docutils literal"><span class="pre">f</span></code> is called on <code class="docutils literal"><span class="pre">A[:,:,i,j]</span></code> for all <code class="docutils literal"><span class="pre">i</span></code> and <code class="docutils literal"><span class="pre">j</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.sum_kbn">
<code class="descname">sum_kbn</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.sum_kbn" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the sum of all array elements, using the Kahan-Babuska-Neumaier compensated summation algorithm for additional accuracy.</p>
</dd></dl>

</div>
<div class="section" id="combinatorics">
<h2>Combinatorics<a class="headerlink" href="#combinatorics" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="Base.nthperm">
<code class="descname">nthperm</code><span class="sig-paren">(</span><em>v</em>, <em>k</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.nthperm" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the kth lexicographic permutation of a vector.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">nthperm</code><span class="sig-paren">(</span><em>p</em><span class="sig-paren">)</span></dt>
<dd><p>Return the <code class="docutils literal"><span class="pre">k</span></code> that generated permutation <code class="docutils literal"><span class="pre">p</span></code>. Note that <code class="docutils literal"><span class="pre">nthperm(nthperm([1:n],</span> <span class="pre">k))</span> <span class="pre">==</span> <span class="pre">k</span></code> for <code class="docutils literal"><span class="pre">1</span> <span class="pre">&lt;=</span> <span class="pre">k</span> <span class="pre">&lt;=</span> <span class="pre">factorial(n)</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.nthperm!">
<code class="descname">nthperm!</code><span class="sig-paren">(</span><em>v</em>, <em>k</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.nthperm!" title="Permalink to this definition">¶</a></dt>
<dd><p>In-place version of <a class="reference internal" href="#Base.nthperm" title="Base.nthperm"><code class="xref jl jl-func docutils literal"><span class="pre">nthperm()</span></code></a>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.randperm">
<code class="descname">randperm</code><span class="sig-paren">(</span><span class="optional">[</span><em>rng</em>, <span class="optional">]</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.randperm" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a random permutation of length <code class="docutils literal"><span class="pre">n</span></code>. The optional <code class="docutils literal"><span class="pre">rng</span></code> argument
specifies a random number generator, see <a class="reference internal" href="../numbers/#random-numbers"><span class="std std-ref">Random Numbers</span></a>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.invperm">
<code class="descname">invperm</code><span class="sig-paren">(</span><em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.invperm" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the inverse permutation of v.</p>
</dd></dl>

<dl class="function">
<dt id="Base.isperm">
<code class="descname">isperm</code><span class="sig-paren">(</span><em>v</em><span class="sig-paren">)</span> &rarr; Bool<a class="headerlink" href="#Base.isperm" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">true</span></code> if <code class="docutils literal"><span class="pre">v</span></code> is a valid permutation.</p>
</dd></dl>

<dl class="function">
<dt id="Base.permute!">
<code class="descname">permute!</code><span class="sig-paren">(</span><em>v</em>, <em>p</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.permute!" title="Permalink to this definition">¶</a></dt>
<dd><p>Permute vector <code class="docutils literal"><span class="pre">v</span></code> in-place, according to permutation <code class="docutils literal"><span class="pre">p</span></code>. No checking is done to verify that <code class="docutils literal"><span class="pre">p</span></code> is a permutation.</p>
<p>To return a new permutation, use <code class="docutils literal"><span class="pre">v[p]</span></code>. Note that this is generally faster than <code class="docutils literal"><span class="pre">permute!(v,p)</span></code> for large vectors.</p>
</dd></dl>

<dl class="function">
<dt id="Base.ipermute!">
<code class="descname">ipermute!</code><span class="sig-paren">(</span><em>v</em>, <em>p</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.ipermute!" title="Permalink to this definition">¶</a></dt>
<dd><p>Like permute!, but the inverse of the given permutation is applied.</p>
</dd></dl>

<dl class="function">
<dt id="Base.randcycle">
<code class="descname">randcycle</code><span class="sig-paren">(</span><span class="optional">[</span><em>rng</em>, <span class="optional">]</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.randcycle" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a random cyclic permutation of length <code class="docutils literal"><span class="pre">n</span></code>. The optional <code class="docutils literal"><span class="pre">rng</span></code>
argument specifies a random number generator, see <a class="reference internal" href="../numbers/#random-numbers"><span class="std std-ref">Random Numbers</span></a>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.shuffle">
<code class="descname">shuffle</code><span class="sig-paren">(</span><span class="optional">[</span><em>rng</em>, <span class="optional">]</span><em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.shuffle" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a randomly permuted copy of <code class="docutils literal"><span class="pre">v</span></code>. The optional <code class="docutils literal"><span class="pre">rng</span></code> argument
specifies a random number generator, see <a class="reference internal" href="../numbers/#random-numbers"><span class="std std-ref">Random Numbers</span></a>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.shuffle!">
<code class="descname">shuffle!</code><span class="sig-paren">(</span><span class="optional">[</span><em>rng</em>, <span class="optional">]</span><em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.shuffle!" title="Permalink to this definition">¶</a></dt>
<dd><p>In-place version of <a class="reference internal" href="#Base.shuffle" title="Base.shuffle"><code class="xref jl jl-func docutils literal"><span class="pre">shuffle()</span></code></a>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.reverse">
<code class="descname">reverse</code><span class="sig-paren">(</span><em>v</em><span class="optional">[</span>, <em>start=1</em><span class="optional">[</span>, <em>stop=length(v)</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#Base.reverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy of <code class="docutils literal"><span class="pre">v</span></code> reversed from start to stop.</p>
</dd></dl>

<dl class="function">
<dt id="Base.reverseind">
<code class="descname">reverseind</code><span class="sig-paren">(</span><em>v</em>, <em>i</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.reverseind" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an index <code class="docutils literal"><span class="pre">i</span></code> in <code class="docutils literal"><span class="pre">reverse(v)</span></code>, return the corresponding index in <code class="docutils literal"><span class="pre">v</span></code> so that <code class="docutils literal"><span class="pre">v[reverseind(v,i)]</span> <span class="pre">==</span> <span class="pre">reverse(v)[i]</span></code>. (This can be nontrivial in the case where <code class="docutils literal"><span class="pre">v</span></code> is a Unicode string.)</p>
</dd></dl>

<dl class="function">
<dt id="Base.reverse!">
<code class="descname">reverse!</code><span class="sig-paren">(</span><em>v</em><span class="optional">[</span>, <em>start=1</em><span class="optional">[</span>, <em>stop=length(v)</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> &rarr; v<a class="headerlink" href="#Base.reverse!" title="Permalink to this definition">¶</a></dt>
<dd><p>In-place version of <a class="reference internal" href="../strings/#Base.reverse" title="Base.reverse"><code class="xref jl jl-func docutils literal"><span class="pre">reverse()</span></code></a>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.combinations">
<code class="descname">combinations</code><span class="sig-paren">(</span><em>array</em>, <em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.combinations" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate all combinations of <code class="docutils literal"><span class="pre">n</span></code> elements from an indexable object. Because the number of combinations can be very large, this function returns an iterator object. Use <code class="docutils literal"><span class="pre">collect(combinations(array,n))</span></code> to get an array of all combinations.</p>
</dd></dl>

<dl class="function">
<dt id="Base.permutations">
<code class="descname">permutations</code><span class="sig-paren">(</span><em>array</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.permutations" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate all permutations of an indexable object. Because the number of permutations can be very large, this function returns an iterator object. Use <code class="docutils literal"><span class="pre">collect(permutations(array))</span></code> to get an array of all permutations.</p>
</dd></dl>

<dl class="function">
<dt id="Base.partitions">
<code class="descname">partitions</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.partitions" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate all integer arrays that sum to <code class="docutils literal"><span class="pre">n</span></code>. Because the number of partitions can be very large, this function returns an iterator object. Use <code class="docutils literal"><span class="pre">collect(partitions(n))</span></code> to get an array of all partitions. The number of partitions to generate can be efficiently computed using <code class="docutils literal"><span class="pre">length(partitions(n))</span></code>.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">partitions</code><span class="sig-paren">(</span><em>n</em>, <em>m</em><span class="sig-paren">)</span></dt>
<dd><p>Generate all arrays of <code class="docutils literal"><span class="pre">m</span></code> integers that sum to <code class="docutils literal"><span class="pre">n</span></code>. Because the number of partitions can be very large, this function returns an iterator object. Use <code class="docutils literal"><span class="pre">collect(partitions(n,m))</span></code> to get an array of all partitions. The number of partitions to generate can be efficiently computed using <code class="docutils literal"><span class="pre">length(partitions(n,m))</span></code>.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">partitions</code><span class="sig-paren">(</span><em>array</em><span class="sig-paren">)</span></dt>
<dd><p>Generate all set partitions of the elements of an array, represented as arrays of arrays. Because the number of partitions can be very large, this function returns an iterator object. Use <code class="docutils literal"><span class="pre">collect(partitions(array))</span></code> to get an array of all partitions. The number of partitions to generate can be efficiently computed using <code class="docutils literal"><span class="pre">length(partitions(array))</span></code>.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">partitions</code><span class="sig-paren">(</span><em>array</em>, <em>m</em><span class="sig-paren">)</span></dt>
<dd><p>Generate all set partitions of the elements of an array into exactly m subsets, represented as arrays of arrays. Because the number of partitions can be very large, this function returns an iterator object. Use <code class="docutils literal"><span class="pre">collect(partitions(array,m))</span></code> to get an array of all partitions. The number of partitions into m subsets is equal to the Stirling number of the second kind and can be efficiently computed using <code class="docutils literal"><span class="pre">length(partitions(array,m))</span></code>.</p>
</dd></dl>

</div>
<div class="section" id="bitarrays">
<h2>BitArrays<a class="headerlink" href="#bitarrays" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="Base.bitpack">
<code class="descname">bitpack</code><span class="sig-paren">(</span><em>A::AbstractArray{T</em>, <em>N}</em><span class="sig-paren">)</span> &rarr; BitArray<a class="headerlink" href="#Base.bitpack" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts a numeric array to a packed boolean array</p>
</dd></dl>

<dl class="function">
<dt id="Base.bitunpack">
<code class="descname">bitunpack</code><span class="sig-paren">(</span><em>B::BitArray{N}</em><span class="sig-paren">)</span> &rarr; Array{Bool,N}<a class="headerlink" href="#Base.bitunpack" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts a packed boolean array to an array of booleans</p>
</dd></dl>

<dl class="function">
<dt id="Base.flipbits!">
<code class="descname">flipbits!</code><span class="sig-paren">(</span><em>B::BitArray{N}</em><span class="sig-paren">)</span> &rarr; BitArray{N}<a class="headerlink" href="#Base.flipbits!" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs a bitwise not operation on <code class="docutils literal"><span class="pre">B</span></code>. See <a class="reference internal" href="../math/#id33"><span class="std std-ref">~ operator</span></a>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.rol!">
<code class="descname">rol!</code><span class="sig-paren">(</span><em>dest::BitArray{1}</em>, <em>src::BitArray{1}</em>, <em>i::Integer</em><span class="sig-paren">)</span> &rarr; BitArray{1}<a class="headerlink" href="#Base.rol!" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs a left rotation operation on <code class="docutils literal"><span class="pre">src</span></code> and put the result into <code class="docutils literal"><span class="pre">dest</span></code>.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">rol!</code><span class="sig-paren">(</span><em>B::BitArray{1}</em>, <em>i::Integer</em><span class="sig-paren">)</span> &rarr; BitArray{1}</dt>
<dd><p>Performs a left rotation operation on <code class="docutils literal"><span class="pre">B</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.rol">
<code class="descname">rol</code><span class="sig-paren">(</span><em>B::BitArray{1}</em>, <em>i::Integer</em><span class="sig-paren">)</span> &rarr; BitArray{1}<a class="headerlink" href="#Base.rol" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs a left rotation operation.</p>
</dd></dl>

<dl class="function">
<dt id="Base.ror!">
<code class="descname">ror!</code><span class="sig-paren">(</span><em>dest::BitArray{1}</em>, <em>src::BitArray{1}</em>, <em>i::Integer</em><span class="sig-paren">)</span> &rarr; BitArray{1}<a class="headerlink" href="#Base.ror!" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs a right rotation operation on <code class="docutils literal"><span class="pre">src</span></code> and put the result into <code class="docutils literal"><span class="pre">dest</span></code>.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">ror!</code><span class="sig-paren">(</span><em>B::BitArray{1}</em>, <em>i::Integer</em><span class="sig-paren">)</span> &rarr; BitArray{1}</dt>
<dd><p>Performs a right rotation operation on <code class="docutils literal"><span class="pre">B</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.ror">
<code class="descname">ror</code><span class="sig-paren">(</span><em>B::BitArray{1}</em>, <em>i::Integer</em><span class="sig-paren">)</span> &rarr; BitArray{1}<a class="headerlink" href="#Base.ror" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs a right rotation operation.</p>
</dd></dl>

</div>
<div class="section" id="sparse-matrices">
<span id="stdlib-sparse"></span><h2>Sparse Matrices<a class="headerlink" href="#sparse-matrices" title="Permalink to this headline">¶</a></h2>
<p>Sparse matrices support much of the same set of operations as dense matrices. The following functions are specific to sparse matrices.</p>
<dl class="function">
<dt id="Base.sparse">
<code class="descname">sparse</code><span class="sig-paren">(</span><em>I</em>, <em>J</em>, <em>V</em><span class="optional">[</span>, <em>m</em>, <em>n</em>, <em>combine</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#Base.sparse" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a sparse matrix <code class="docutils literal"><span class="pre">S</span></code> of dimensions <code class="docutils literal"><span class="pre">m</span> <span class="pre">x</span> <span class="pre">n</span></code> such that <code class="docutils literal"><span class="pre">S[I[k],</span> <span class="pre">J[k]]</span> <span class="pre">=</span> <span class="pre">V[k]</span></code>. The <code class="docutils literal"><span class="pre">combine</span></code> function is used to combine duplicates. If <code class="docutils literal"><span class="pre">m</span></code> and <code class="docutils literal"><span class="pre">n</span></code> are not specified, they are set to <code class="docutils literal"><span class="pre">maximum(I)</span></code> and <code class="docutils literal"><span class="pre">maximum(J)</span></code> respectively. If the <code class="docutils literal"><span class="pre">combine</span></code> function is not supplied, duplicates are added by default. All elements of <code class="docutils literal"><span class="pre">I</span></code> must satisfy <code class="docutils literal"><span class="pre">1</span> <span class="pre">&lt;=</span> <span class="pre">I[k]</span> <span class="pre">&lt;=</span> <span class="pre">m</span></code>, and all elements of <code class="docutils literal"><span class="pre">J</span></code> must satisfy <code class="docutils literal"><span class="pre">1</span> <span class="pre">&lt;=</span> <span class="pre">J[k]</span> <span class="pre">&lt;=</span> <span class="pre">n</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.sparsevec">
<code class="descname">sparsevec</code><span class="sig-paren">(</span><em>I</em>, <em>V</em><span class="optional">[</span>, <em>m</em>, <em>combine</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#Base.sparsevec" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a sparse matrix <code class="docutils literal"><span class="pre">S</span></code> of size <code class="docutils literal"><span class="pre">m</span> <span class="pre">x</span> <span class="pre">1</span></code> such that <code class="docutils literal"><span class="pre">S[I[k]]</span> <span class="pre">=</span> <span class="pre">V[k]</span></code>. Duplicates are combined using the <code class="docutils literal"><span class="pre">combine</span></code> function, which defaults to <code class="docutils literal"><span class="pre">+</span></code> if it is not provided. In julia, sparse vectors are really just sparse matrices with one column. Given Julia&#8217;s Compressed Sparse Columns (CSC) storage format, a sparse column matrix with one column is sparse, whereas a sparse row matrix with one row ends up being dense.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">sparsevec</code><span class="sig-paren">(</span><em>D::Dict</em><span class="optional">[</span>, <em>m</em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>Create a sparse matrix of size <code class="docutils literal"><span class="pre">m</span> <span class="pre">x</span> <span class="pre">1</span></code> where the row values are keys from the dictionary, and the nonzero values are the values from the dictionary.</p>
</dd></dl>

<dl class="function">
<dt id="Base.issparse">
<code class="descname">issparse</code><span class="sig-paren">(</span><em>S</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.issparse" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">true</span></code> if <code class="docutils literal"><span class="pre">S</span></code> is sparse, and <code class="docutils literal"><span class="pre">false</span></code> otherwise.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">sparse</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span></dt>
<dd><p>Convert an AbstractMatrix <code class="docutils literal"><span class="pre">A</span></code> into a sparse matrix.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">sparsevec</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span></dt>
<dd><p>Convert a dense vector <code class="docutils literal"><span class="pre">A</span></code> into a sparse matrix of size <code class="docutils literal"><span class="pre">m</span> <span class="pre">x</span> <span class="pre">1</span></code>. In julia, sparse vectors are really just sparse matrices with one column.</p>
</dd></dl>

<dl class="function">
<dt id="Base.full">
<code class="descname">full</code><span class="sig-paren">(</span><em>S</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.full" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a sparse matrix <code class="docutils literal"><span class="pre">S</span></code> into a dense matrix.</p>
</dd></dl>

<dl class="function">
<dt id="Base.nnz">
<code class="descname">nnz</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.nnz" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of stored (filled) elements in a sparse matrix.</p>
</dd></dl>

<dl class="function">
<dt id="Base.spzeros">
<code class="descname">spzeros</code><span class="sig-paren">(</span><em>m</em>, <em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.spzeros" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a sparse matrix of size <code class="docutils literal"><span class="pre">m</span> <span class="pre">x</span> <span class="pre">n</span></code>. This sparse matrix will not contain any nonzero values. No storage will be allocated for nonzero values during construction.</p>
</dd></dl>

<dl class="function">
<dt id="Base.spones">
<code class="descname">spones</code><span class="sig-paren">(</span><em>S</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.spones" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a sparse matrix with the same structure as that of <code class="docutils literal"><span class="pre">S</span></code>, but with every nonzero element having the value <code class="docutils literal"><span class="pre">1.0</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.speye">
<code class="descname">speye</code><span class="sig-paren">(</span><em>type</em>, <em>m</em><span class="optional">[</span>, <em>n</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#Base.speye" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a sparse identity matrix of specified type of size <code class="docutils literal"><span class="pre">m</span> <span class="pre">x</span> <span class="pre">m</span></code>. In case <code class="docutils literal"><span class="pre">n</span></code> is supplied, create a sparse identity matrix of size <code class="docutils literal"><span class="pre">m</span> <span class="pre">x</span> <span class="pre">n</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.spdiagm">
<code class="descname">spdiagm</code><span class="sig-paren">(</span><em>B</em>, <em>d</em><span class="optional">[</span>, <em>m</em>, <em>n</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#Base.spdiagm" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a sparse diagonal matrix. <code class="docutils literal"><span class="pre">B</span></code> is a tuple of vectors containing the diagonals and <code class="docutils literal"><span class="pre">d</span></code> is a tuple containing the positions of the diagonals. In the case the input contains only one diagonal, <code class="docutils literal"><span class="pre">B</span></code> can be a vector (instead of a tuple) and <code class="docutils literal"><span class="pre">d</span></code> can be the diagonal position (instead of a tuple), defaulting to 0 (diagonal). Optionally, <code class="docutils literal"><span class="pre">m</span></code> and <code class="docutils literal"><span class="pre">n</span></code> specify the size of the resulting sparse matrix.</p>
</dd></dl>

<dl class="function">
<dt id="Base.sprand">
<code class="descname">sprand</code><span class="sig-paren">(</span><span class="optional">[</span><em>rng</em>, <span class="optional">]</span><em>m</em>, <em>n</em>, <em>p</em><span class="optional">[</span>, <em>rfn</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#Base.sprand" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a random <code class="docutils literal"><span class="pre">m</span></code> by <code class="docutils literal"><span class="pre">n</span></code> sparse matrix, in which the probability of any
element being nonzero is independently given by <code class="docutils literal"><span class="pre">p</span></code> (and hence the mean
density of nonzeros is also exactly <code class="docutils literal"><span class="pre">p</span></code>). Nonzero values are sampled from
the distribution specified by <code class="docutils literal"><span class="pre">rfn</span></code>. The uniform distribution is used in
case <code class="docutils literal"><span class="pre">rfn</span></code> is not specified. The optional <code class="docutils literal"><span class="pre">rng</span></code> argument specifies a
random number generator, see <a class="reference internal" href="../numbers/#random-numbers"><span class="std std-ref">Random Numbers</span></a>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.sprandn">
<code class="descname">sprandn</code><span class="sig-paren">(</span><em>m</em>, <em>n</em>, <em>p</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.sprandn" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a random <code class="docutils literal"><span class="pre">m</span></code> by <code class="docutils literal"><span class="pre">n</span></code> sparse matrix with the specified (independent) probability <code class="docutils literal"><span class="pre">p</span></code> of any entry being nonzero, where nonzero values are sampled from the normal distribution.</p>
</dd></dl>

<dl class="function">
<dt id="Base.sprandbool">
<code class="descname">sprandbool</code><span class="sig-paren">(</span><em>m</em>, <em>n</em>, <em>p</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.sprandbool" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a random <code class="docutils literal"><span class="pre">m</span></code> by <code class="docutils literal"><span class="pre">n</span></code> sparse boolean matrix with the specified (independent) probability <code class="docutils literal"><span class="pre">p</span></code> of any entry being <code class="docutils literal"><span class="pre">true</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.etree">
<code class="descname">etree</code><span class="sig-paren">(</span><em>A</em><span class="optional">[</span>, <em>post</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#Base.etree" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the elimination tree of a symmetric sparse matrix <code class="docutils literal"><span class="pre">A</span></code> from <code class="docutils literal"><span class="pre">triu(A)</span></code> and, optionally, its post-ordering permutation.</p>
</dd></dl>

<dl class="function">
<dt id="Base.symperm">
<code class="descname">symperm</code><span class="sig-paren">(</span><em>A</em>, <em>p</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.symperm" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the symmetric permutation of <code class="docutils literal"><span class="pre">A</span></code>, which is <code class="docutils literal"><span class="pre">A[p,p]</span></code>. <code class="docutils literal"><span class="pre">A</span></code> should be symmetric and sparse, where only the upper triangular part of the matrix is stored. This algorithm ignores the lower triangular part of the matrix. Only the upper triangular part of the result is returned as well.</p>
</dd></dl>

<dl class="function">
<dt id="Base.nonzeros">
<code class="descname">nonzeros</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.nonzeros" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a vector of the structural nonzero values in sparse matrix <code class="docutils literal"><span class="pre">A</span></code>. This includes zeros that are explicitly stored in the sparse matrix. The returned vector points directly to the internal nonzero storage of <code class="docutils literal"><span class="pre">A</span></code>, and any modifications to the returned vector will mutate <code class="docutils literal"><span class="pre">A</span></code> as well. See <code class="docutils literal"><span class="pre">rowvals(A)</span></code> and <code class="docutils literal"><span class="pre">nzrange(A,</span> <span class="pre">col)</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.rowvals">
<code class="descname">rowvals</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.rowvals" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a vector of the row indices of <code class="docutils literal"><span class="pre">A</span></code>, and any modifications to the returned vector will mutate <code class="docutils literal"><span class="pre">A</span></code> as well. Given the internal storage format of sparse matrices, providing access to how the row indices are stored internally can be useful in conjunction with iterating over structural nonzero values. See <code class="docutils literal"><span class="pre">nonzeros(A)</span></code> and <code class="docutils literal"><span class="pre">nzrange(A,</span> <span class="pre">col)</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.nzrange">
<code class="descname">nzrange</code><span class="sig-paren">(</span><em>A</em>, <em>col</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.nzrange" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the range of indices to the structural nonzero values of a sparse matrix column. In conjunction with <code class="docutils literal"><span class="pre">nonzeros(A)</span></code> and <code class="docutils literal"><span class="pre">rowvals(A)</span></code>, this allows for convenient iterating over a sparse matrix :</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">=</span> <span class="n">sparse</span><span class="p">(</span><span class="nb">I</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">V</span><span class="p">)</span>
<span class="n">rows</span> <span class="o">=</span> <span class="n">rowvals</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="n">vals</span> <span class="o">=</span> <span class="n">nonzeros</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">size</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">:</span><span class="n">n</span>
   <span class="k">for</span> <span class="n">j</span> <span class="kp">in</span> <span class="n">nzrange</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
      <span class="n">row</span> <span class="o">=</span> <span class="n">rows</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
      <span class="n">val</span> <span class="o">=</span> <span class="n">vals</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
      <span class="c"># perform sparse wizardry...</span>
   <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>


          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../parallel/" class="btn btn-neutral float-right" title="Tasks and Parallel Computing">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../strings/" class="btn btn-neutral" title="Strings"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
    </p>
  </div>

  <a href="https://github.com/snide/sphinx_rtd_theme">Sphinx theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>
</footer>
        </div>
      </div>

    </section>

  </div>
  

  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'0.4.8-pre',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>