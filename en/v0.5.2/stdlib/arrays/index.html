

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Arrays &mdash; Julia Language 0.5.1-pre documentation</title>
  

  
  

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/julia.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../../_static/julia.css" type="text/css" />
  
    <link rel="top" title="Julia Language 0.5.1-pre documentation" href="../../"/>
        <link rel="next" title="Tasks and Parallel Computing" href="../parallel/"/>
        <link rel="prev" title="Strings" href="../strings/"/> 

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        <a href="http://julialang.org/"><img src="../../_static/julia-logo.svg" class="logo"></a>
        <!--
        <a href="../../" class="fa fa-home"> Julia Language</a>
        -->
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search/" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
        
            <ul>
<li class="toctree-l1"><a class="reference internal" href="../../manual/introduction/">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/getting-started/">Getting Started</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/getting-started/#resources">Resources</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/variables/">Variables</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/variables/#allowed-variable-names">Allowed Variable Names</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/variables/#stylistic-conventions">Stylistic Conventions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/integers-and-floating-point-numbers/">Integers and Floating-Point Numbers</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/integers-and-floating-point-numbers/#integers">Integers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/integers-and-floating-point-numbers/#floating-point-numbers">Floating-Point Numbers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/integers-and-floating-point-numbers/#arbitrary-precision-arithmetic">Arbitrary Precision Arithmetic</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/integers-and-floating-point-numbers/#numeric-literal-coefficients">Numeric Literal Coefficients</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/integers-and-floating-point-numbers/#literal-zero-and-one">Literal zero and one</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/mathematical-operations/">Mathematical Operations and Elementary Functions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/mathematical-operations/#arithmetic-operators">Arithmetic Operators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/mathematical-operations/#bitwise-operators">Bitwise Operators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/mathematical-operations/#updating-operators">Updating operators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/mathematical-operations/#numeric-comparisons">Numeric Comparisons</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/mathematical-operations/#numerical-conversions">Numerical Conversions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/complex-and-rational-numbers/">Complex and Rational Numbers</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/complex-and-rational-numbers/#complex-numbers">Complex Numbers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/complex-and-rational-numbers/#rational-numbers">Rational Numbers</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/strings/">Strings</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/strings/#characters">Characters</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/strings/#string-basics">String Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/strings/#unicode-and-utf-8">Unicode and UTF-8</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/strings/#interpolation">Interpolation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/strings/#triple-quoted-string-literals">Triple-Quoted String Literals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/strings/#common-operations">Common Operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/strings/#non-standard-string-literals">Non-Standard String Literals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/strings/#regular-expressions">Regular Expressions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/strings/#id2">Byte Array Literals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/strings/#version-number-literals">Version Number Literals</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/functions/">Functions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/functions/#argument-passing-behavior">Argument Passing Behavior</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/functions/#the-return-keyword">The <code class="docutils literal"><span class="pre">return</span></code> Keyword</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/functions/#operators-are-functions">Operators Are Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/functions/#operators-with-special-names">Operators With Special Names</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/functions/#anonymous-functions">Anonymous Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/functions/#multiple-return-values">Multiple Return Values</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/functions/#varargs-functions">Varargs Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/functions/#optional-arguments">Optional Arguments</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/functions/#keyword-arguments">Keyword Arguments</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/functions/#evaluation-scope-of-default-values">Evaluation Scope of Default Values</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/functions/#do-block-syntax-for-function-arguments">Do-Block Syntax for Function Arguments</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/functions/#dot-syntax-for-vectorizing-functions">Dot Syntax for Vectorizing Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/functions/#further-reading">Further Reading</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/control-flow/">Control Flow</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/control-flow/#compound-expressions">Compound Expressions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/control-flow/#conditional-evaluation">Conditional Evaluation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/control-flow/#short-circuit-evaluation">Short-Circuit Evaluation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/control-flow/#repeated-evaluation-loops">Repeated Evaluation: Loops</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/control-flow/#exception-handling">Exception Handling</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/control-flow/#tasks-aka-coroutines">Tasks (aka Coroutines)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/variables-and-scoping/">Scope of Variables</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/variables-and-scoping/#global-scope">Global Scope</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/variables-and-scoping/#local-scope">Local Scope</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/variables-and-scoping/#constants">Constants</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/types/">Types</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/types/#type-declarations">Type Declarations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/types/#abstract-types">Abstract Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/types/#bits-types">Bits Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/types/#composite-types">Composite Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/types/#immutable-composite-types">Immutable Composite Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/types/#declared-types">Declared Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/types/#type-unions">Type Unions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/types/#man-parametric-types">Parametric Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/types/#type-aliases">Type Aliases</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/types/#operations-on-types">Operations on Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/types/#value-types">&#8220;Value types&#8221;</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/types/#nullable-types-representing-missing-values">Nullable Types: Representing Missing Values</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/methods/">Methods</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/methods/#defining-methods">Defining Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/methods/#method-ambiguities">Method Ambiguities</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/methods/#parametric-methods">Parametric Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/methods/#parametrically-constrained-varargs-methods">Parametrically-constrained Varargs methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/methods/#note-on-optional-and-keyword-arguments">Note on Optional and keyword Arguments</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/methods/#function-like-objects">Function-like objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/methods/#empty-generic-functions">Empty generic functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/constructors/">Constructors</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/constructors/#outer-constructor-methods">Outer Constructor Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/constructors/#inner-constructor-methods">Inner Constructor Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/constructors/#incomplete-initialization">Incomplete Initialization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/constructors/#parametric-constructors">Parametric Constructors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/constructors/#case-study-rational">Case Study: Rational</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/constructors/#constructors-and-conversion">Constructors and Conversion</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/constructors/#outer-only-constructors">Outer-only constructors</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/conversion-and-promotion/">Conversion and Promotion</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/conversion-and-promotion/#conversion">Conversion</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/conversion-and-promotion/#promotion">Promotion</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/interfaces/">Interfaces</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/interfaces/#iteration">Iteration</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/interfaces/#indexing">Indexing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/interfaces/#abstract-arrays">Abstract Arrays</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/modules/">Modules</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/modules/#summary-of-module-usage">Summary of module usage</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/documentation/">Documentation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/documentation/#accessing-documentation">Accessing Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/documentation/#functions-methods">Functions &amp; Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/documentation/#advanced-usage">Advanced Usage</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/documentation/#syntax-guide">Syntax Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/documentation/#markdown-syntax">Markdown syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/documentation/#markdown-syntax-extensions">Markdown Syntax Extensions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/metaprogramming/">Metaprogramming</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/metaprogramming/#program-representation">Program representation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/metaprogramming/#expressions-and-evaluation">Expressions and evaluation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/metaprogramming/#macros">Macros</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/metaprogramming/#code-generation">Code Generation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/metaprogramming/#non-standard-string-literals">Non-Standard String Literals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/metaprogramming/#generated-functions">Generated functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/arrays/">Multi-dimensional Arrays</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/arrays/#arrays">Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/arrays/#sparse-matrices">Sparse Matrices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/linear-algebra/">Linear algebra</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/linear-algebra/#matrix-factorizations">Matrix factorizations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/linear-algebra/#special-matrices">Special matrices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/networking-and-streams/">Networking and Streams</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/networking-and-streams/#basic-stream-i-o">Basic Stream I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/networking-and-streams/#text-i-o">Text I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/networking-and-streams/#io-output-contextual-properties">IO Output Contextual Properties</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/networking-and-streams/#working-with-files">Working with Files</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/networking-and-streams/#a-simple-tcp-example">A simple TCP example</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/networking-and-streams/#resolving-ip-addresses">Resolving IP Addresses</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/parallel-computing/">Parallel Computing</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/parallel-computing/#code-availability-and-loading-packages">Code Availability and Loading Packages</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/parallel-computing/#data-movement">Data Movement</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/parallel-computing/#parallel-map-and-loops">Parallel Map and Loops</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/parallel-computing/#synchronization-with-remote-references">Synchronization With Remote References</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/parallel-computing/#scheduling">Scheduling</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/parallel-computing/#channels">Channels</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/parallel-computing/#remote-references-and-abstractchannels">Remote references and AbstractChannels</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/parallel-computing/#remote-references-and-distributed-garbage-collection">Remote References and Distributed Garbage Collection</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/parallel-computing/#id2">Shared Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/parallel-computing/#shared-arrays-and-distributed-garbage-collection">Shared Arrays and Distributed Garbage Collection</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/parallel-computing/#clustermanagers">ClusterManagers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/parallel-computing/#cluster-managers-with-custom-transports">Cluster Managers with custom transports</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/parallel-computing/#network-requirements-for-localmanager-and-sshmanager">Network requirements for LocalManager and SSHManager</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/parallel-computing/#cluster-cookie">Cluster cookie</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/parallel-computing/#specifying-network-topology-experimental">Specifying network topology (Experimental)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/parallel-computing/#multi-threading-experimental">Multi-threading (Experimental)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/parallel-computing/#threadcall-experimental">&#64;threadcall (Experimental)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/dates/">Date and DateTime</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/dates/#constructors">Constructors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/dates/#durations-comparisons">Durations/Comparisons</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/dates/#accessor-functions">Accessor Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/dates/#query-functions">Query Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/dates/#timetype-period-arithmetic">TimeType-Period Arithmetic</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/dates/#adjuster-functions">Adjuster Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/dates/#period-types">Period Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/dates/#rounding">Rounding</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/running-external-programs/">Running External Programs</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/running-external-programs/#interpolation">Interpolation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/running-external-programs/#quoting">Quoting</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/running-external-programs/#pipelines">Pipelines</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/calling-c-and-fortran-code/">Calling C and Fortran Code</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/calling-c-and-fortran-code/#creating-c-compatible-julia-function-pointers">Creating C-Compatible Julia Function Pointers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/calling-c-and-fortran-code/#mapping-c-types-to-julia">Mapping C Types to Julia</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/calling-c-and-fortran-code/#mapping-c-functions-to-julia">Mapping C Functions to Julia</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/calling-c-and-fortran-code/#some-examples-of-c-wrappers">Some Examples of C Wrappers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/calling-c-and-fortran-code/#garbage-collection-safety">Garbage Collection Safety</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/calling-c-and-fortran-code/#non-constant-function-specifications">Non-constant Function Specifications</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/calling-c-and-fortran-code/#indirect-calls">Indirect Calls</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/calling-c-and-fortran-code/#calling-convention">Calling Convention</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/calling-c-and-fortran-code/#accessing-global-variables">Accessing Global Variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/calling-c-and-fortran-code/#accessing-data-through-a-pointer">Accessing Data through a Pointer</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/calling-c-and-fortran-code/#thread-safety">Thread-safety</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/calling-c-and-fortran-code/#more-about-callbacks">More About Callbacks</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/calling-c-and-fortran-code/#c">C++</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/handling-operating-system-variation/">Handling Operating System Variation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/interacting-with-julia/">Interacting With Julia</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/interacting-with-julia/#the-different-prompt-modes">The different prompt modes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/interacting-with-julia/#key-bindings">Key bindings</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/interacting-with-julia/#tab-completion">Tab completion</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/interacting-with-julia/#customizing-colors">Customizing Colors</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/embedding/">Embedding Julia</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/embedding/#high-level-embedding">High-Level Embedding</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/embedding/#converting-types">Converting Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/embedding/#calling-julia-functions">Calling Julia Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/embedding/#memory-management">Memory Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/embedding/#working-with-arrays">Working with Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/embedding/#exceptions">Exceptions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/packages/">Packages</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/packages/#package-status">Package Status</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/packages/#adding-and-removing-packages">Adding and Removing Packages</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/packages/#offline-installation-of-packages">Offline Installation of Packages</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/packages/#installing-unregistered-packages">Installing Unregistered Packages</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/packages/#updating-packages">Updating Packages</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/packages/#checkout-pin-and-free">Checkout, Pin and Free</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/packages/#custom-metadata-repository">Custom METADATA Repository</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/packages/#package-development">Package Development</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/packages/#initial-setup">Initial Setup</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/packages/#making-changes-to-an-existing-package">Making changes to an existing package</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/packages/#creating-a-new-package">Creating a new Package</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/packages/#fixing-package-requirements">Fixing Package Requirements</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/packages/#man-package-requirements">Requirements Specification</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/profile/">Profiling</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/profile/#basic-usage">Basic usage</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/profile/#accumulation-and-clearing">Accumulation and clearing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/profile/#options-for-controlling-the-display-of-profile-results">Options for controlling the display of profile results</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/profile/#configuration">Configuration</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/profile/#memory-allocation-analysis">Memory allocation analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/stacktraces/">Stack Traces</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/stacktraces/#viewing-a-stack-trace">Viewing a stack trace</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/stacktraces/#extracting-useful-information">Extracting useful information</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/stacktraces/#error-handling">Error handling</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/stacktraces/#comparison-with-backtrace">Comparison with <code class="docutils literal"><span class="pre">backtrace()</span></code></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/performance-tips/">Performance Tips</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#avoid-global-variables">Avoid global variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#measure-performance-with-time-and-pay-attention-to-memory-allocation">Measure performance with <code class="docutils literal"><span class="pre">&#64;time</span></code> and pay attention to memory allocation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#tools">Tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#avoid-containers-with-abstract-type-parameters">Avoid containers with abstract type parameters</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#type-declarations">Type declarations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#break-functions-into-multiple-definitions">Break functions into multiple definitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#write-type-stable-functions">Write &#8220;type-stable&#8221; functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#avoid-changing-the-type-of-a-variable">Avoid changing the type of a variable</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#separate-kernel-functions-aka-function-barriers">Separate kernel functions (aka, function barriers)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#types-with-values-as-parameters">Types with values-as-parameters</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#the-dangers-of-abusing-multiple-dispatch-aka-more-on-types-with-values-as-parameters">The dangers of abusing multiple dispatch (aka, more on types with values-as-parameters)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#access-arrays-in-memory-order-along-columns">Access arrays in memory order, along columns</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#pre-allocating-outputs">Pre-allocating outputs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#avoid-string-interpolation-for-i-o">Avoid string interpolation for I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#optimize-network-i-o-during-parallel-execution">Optimize network I/O during parallel execution</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#fix-deprecation-warnings">Fix deprecation warnings</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#tweaks">Tweaks</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#performance-annotations">Performance Annotations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#treat-subnormal-numbers-as-zeros">Treat Subnormal Numbers as Zeros</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#code-warntype"><code class="docutils literal"><span class="pre">&#64;code_warntype</span></code></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/workflow-tips/">Workflow Tips</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/workflow-tips/#repl-based-workflow">REPL-based workflow</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/workflow-tips/#browser-based-workflow">Browser-based workflow</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/style-guide/">Style Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#write-functions-not-just-scripts">Write functions, not just scripts</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#avoid-writing-overly-specific-types">Avoid writing overly-specific types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#handle-excess-argument-diversity-in-the-caller">Handle excess argument diversity in the caller</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#append-to-names-of-functions-that-modify-their-arguments">Append <code class="docutils literal"><span class="pre">!</span></code> to names of functions that modify their arguments</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#avoid-strange-type-unions">Avoid strange type Unions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#avoid-type-unions-in-fields">Avoid type Unions in fields</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#avoid-elaborate-container-types">Avoid elaborate container types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#use-naming-conventions-consistent-with-julia-s-base">Use naming conventions consistent with Julia&#8217;s <code class="docutils literal"><span class="pre">base/</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#don-t-overuse-try-catch">Don&#8217;t overuse try-catch</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#don-t-parenthesize-conditions">Don&#8217;t parenthesize conditions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#don-t-overuse">Don&#8217;t overuse ...</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#don-t-use-unnecessary-static-parameters">Don&#8217;t use unnecessary static parameters</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#avoid-confusion-about-whether-something-is-an-instance-or-a-type">Avoid confusion about whether something is an instance or a type</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#don-t-overuse-macros">Don&#8217;t overuse macros</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#don-t-expose-unsafe-operations-at-the-interface-level">Don&#8217;t expose unsafe operations at the interface level</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#don-t-overload-methods-of-base-container-types">Don&#8217;t overload methods of base container types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#be-careful-with-type-equality">Be careful with type equality</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#do-not-write-x-f-x">Do not write <code class="docutils literal"><span class="pre">x-&gt;f(x)</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#avoid-using-floats-for-numeric-literals-in-generic-code-when-possible">Avoid using floats for numeric literals in generic code when possible</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/faq/">Frequently Asked Questions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/faq/#sessions-and-the-repl">Sessions and the REPL</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/faq/#functions">Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/faq/#types-type-declarations-and-constructors">Types, type declarations, and constructors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/faq/#packages-and-modules">Packages and Modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/faq/#nothingness-and-missing-values">Nothingness and missing values</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/faq/#memory">Memory</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/faq/#asynchronous-io-and-concurrent-synchronous-writes">Asynchronous IO and concurrent synchronous writes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/faq/#julia-releases">Julia Releases</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/noteworthy-differences/">Noteworthy Differences from other Languages</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/noteworthy-differences/#noteworthy-differences-from-matlab">Noteworthy differences from MATLAB</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/noteworthy-differences/#noteworthy-differences-from-r">Noteworthy differences from R</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/noteworthy-differences/#noteworthy-differences-from-python">Noteworthy differences from Python</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/noteworthy-differences/#noteworthy-differences-from-c-c">Noteworthy differences from C/C++</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/unicode-input/">Unicode Input</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../base/">Essentials</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../base/#introduction">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../base/#getting-around">Getting Around</a></li>
<li class="toctree-l2"><a class="reference internal" href="../base/#all-objects">All Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="../base/#types">Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../base/#generic-functions">Generic Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../base/#syntax">Syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="../base/#nullables">Nullables</a></li>
<li class="toctree-l2"><a class="reference internal" href="../base/#system">System</a></li>
<li class="toctree-l2"><a class="reference internal" href="../base/#errors">Errors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../base/#events">Events</a></li>
<li class="toctree-l2"><a class="reference internal" href="../base/#reflection">Reflection</a></li>
<li class="toctree-l2"><a class="reference internal" href="../base/#internals">Internals</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../collections/">Collections and Data Structures</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../collections/#iteration">Iteration</a></li>
<li class="toctree-l2"><a class="reference internal" href="../collections/#general-collections">General Collections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../collections/#iterable-collections">Iterable Collections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../collections/#indexable-collections">Indexable Collections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../collections/#associative-collections">Associative Collections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../collections/#set-like-collections">Set-Like Collections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../collections/#dequeues">Dequeues</a></li>
<li class="toctree-l2"><a class="reference internal" href="../collections/#priorityqueue">PriorityQueue</a></li>
<li class="toctree-l2"><a class="reference internal" href="../collections/#heap-functions">Heap Functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../math/">Mathematics</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../math/#mathematical-operators">Mathematical Operators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../math/#mathematical-functions">Mathematical Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../math/#statistics">Statistics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../math/#signal-processing">Signal Processing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../math/#numerical-integration">Numerical Integration</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../numbers/">Numbers</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../numbers/#standard-numeric-types">Standard Numeric Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../numbers/#data-formats">Data Formats</a></li>
<li class="toctree-l2"><a class="reference internal" href="../numbers/#general-number-functions-and-constants">General Number Functions and Constants</a></li>
<li class="toctree-l2"><a class="reference internal" href="../numbers/#bigfloats">BigFloats</a></li>
<li class="toctree-l2"><a class="reference internal" href="../numbers/#random-numbers">Random Numbers</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../strings/">Strings</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="">Arrays</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#basic-functions">Basic functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#constructors">Constructors</a></li>
<li class="toctree-l2"><a class="reference internal" href="#mathematical-operators-and-functions">Mathematical operators and functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#indexing-assignment-and-concatenation">Indexing, Assignment, and Concatenation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#array-functions">Array functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#combinatorics">Combinatorics</a></li>
<li class="toctree-l2"><a class="reference internal" href="#bitarrays">BitArrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="#sparse-vectors-and-matrices">Sparse Vectors and Matrices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../parallel/">Tasks and Parallel Computing</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../parallel/#tasks">Tasks</a></li>
<li class="toctree-l2"><a class="reference internal" href="../parallel/#general-parallel-computing-support">General Parallel Computing Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../parallel/#shared-arrays">Shared Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="../parallel/#multi-threading">Multi-Threading</a></li>
<li class="toctree-l2"><a class="reference internal" href="../parallel/#ccall-using-a-threadpool-experimental">ccall using a threadpool (Experimental)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../parallel/#synchronization-primitives">Synchronization Primitives</a></li>
<li class="toctree-l2"><a class="reference internal" href="../parallel/#cluster-manager-interface">Cluster Manager Interface</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../linalg/">Linear Algebra</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../linalg/#module-Base.LinAlg">Standard Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../linalg/#low-level-matrix-operations">Low-level matrix operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../linalg/#module-Base.LinAlg.BLAS">BLAS Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../linalg/#module-Base.LinAlg.LAPACK">LAPACK Functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../constants/">Constants</a></li>
<li class="toctree-l1"><a class="reference internal" href="../file/">Filesystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../io-network/">I/O and Network</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../io-network/#general-i-o">General I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../io-network/#text-i-o">Text I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../io-network/#multimedia-i-o">Multimedia I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../io-network/#memory-mapped-i-o">Memory-mapped I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../io-network/#network-i-o">Network I/O</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../punctuation/">Punctuation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sort/">Sorting and Related Functions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../sort/#sorting-functions">Sorting Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sort/#order-related-functions">Order-Related Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sort/#sorting-algorithms">Sorting Algorithms</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../pkg/">Package Manager Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dates/">Dates and Time</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../dates/#dates-and-time-types">Dates and Time Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dates/#dates-functions">Dates Functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../test/">Unit Testing</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../test/#testing-base-julia">Testing Base Julia</a></li>
<li class="toctree-l2"><a class="reference internal" href="../test/#basic-unit-tests">Basic Unit Tests</a></li>
<li class="toctree-l2"><a class="reference internal" href="../test/#working-with-test-sets">Working with Test Sets</a></li>
<li class="toctree-l2"><a class="reference internal" href="../test/#other-test-macros">Other Test Macros</a></li>
<li class="toctree-l2"><a class="reference internal" href="../test/#broken-tests">Broken Tests</a></li>
<li class="toctree-l2"><a class="reference internal" href="../test/#creating-custom-abstracttestset-types">Creating Custom <code class="docutils literal"><span class="pre">AbstractTestSet</span></code> Types</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../c/">C Interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../c/#llvm-interface">LLVM Interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../libc/">C Standard Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="../libdl/">Dynamic Linker</a></li>
<li class="toctree-l1"><a class="reference internal" href="../profile/">Profiling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../stacktraces/">StackTraces</a></li>
<li class="toctree-l1"><a class="reference internal" href="../simd-types/">SIMD Support</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../devdocs/reflection/">Reflection and introspection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../devdocs/julia/">Documentation of Julia&#8217;s Internals</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/init/">Initialization of the Julia runtime</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/eval/">Eval of Julia code</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/ast/">Julia ASTs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/types/">More about types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/object/">Memory layout of Julia Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/functions/">Julia Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/callconv/">Calling Conventions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/cartesian/">Base.Cartesian</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/meta/">Talking to the compiler (the <code class="docutils literal"><span class="pre">:meta</span></code> mechanism)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/subarrays/">SubArrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/sysimg/">System Image Building</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/llvm/">Working with LLVM</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/stdio/">printf() and stdio in the Julia runtime</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/boundscheck/">Bounds checking</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/locks/">Proper maintenance and care of multi-threading locks</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/offset-arrays/">Arrays with custom indices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../devdocs/C/">Developing/debugging Julia&#8217;s C code</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/backtraces/">Reporting and analyzing crashes (segfaults)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/debuggingtips/">gdb debugging tips</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/valgrind/">Using Valgrind with Julia</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/sanitizers/">Sanitizer support</a></li>
</ul>
</li>
</ul>

        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../">Julia Language</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../">Docs</a> &raquo;</li>
      
    <li>Arrays</li>
      <li class="wy-breadcrumbs-aside">
        
          <a href="../../_sources/stdlib/arrays.txt" rel="nofollow"> View page source</a>
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document">
            
  <div class="section" id="arrays">
<span id="stdlib-arrays"></span><h1>Arrays<a class="headerlink" href="#arrays" title="Permalink to this headline"></a></h1>
<div class="section" id="basic-functions">
<h2>Basic functions<a class="headerlink" href="#basic-functions" title="Permalink to this headline"></a></h2>
<dl class="function">
<dt id="Base.ndims">
<code class="descname">ndims</code><span class="sig-paren">(</span><em>A::AbstractArray</em><span class="sig-paren">)</span> &rarr; Integer<a class="headerlink" href="#Base.ndims" title="Permalink to this definition"></a></dt>
<dd><p>Returns the number of dimensions of <code class="docutils literal"><span class="pre">A</span></code>.</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="n">ones</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">);</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">ndims</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="mi">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="Base.size">
<code class="descname">size</code><span class="sig-paren">(</span><em>A::AbstractArray</em><span class="optional">[</span>, <em>dim...</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#Base.size" title="Permalink to this definition"></a></dt>
<dd><p>Returns a tuple containing the dimensions of <code class="docutils literal"><span class="pre">A</span></code>. Optionally you can specify the dimension(s) you want the length of, and get the length of that dimension, or a tuple of the lengths of dimensions you asked for.</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="n">ones</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">);</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">size</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="mi">3</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">size</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="Base.indices">
<code class="descname">indices</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.indices" title="Permalink to this definition"></a></dt>
<dd><p>Returns the tuple of valid indices for array <code class="docutils literal"><span class="pre">A</span></code>.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">indices</code><span class="sig-paren">(</span><em>A</em>, <em>d</em><span class="sig-paren">)</span></dt>
<dd><p>Returns the valid range of indices for array <code class="docutils literal"><span class="pre">A</span></code> along dimension <code class="docutils literal"><span class="pre">d</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.length">
<code class="descname">length</code><span class="sig-paren">(</span><em>A::AbstractArray</em><span class="sig-paren">)</span> &rarr; Integer<a class="headerlink" href="#Base.length" title="Permalink to this definition"></a></dt>
<dd><p>Returns the number of elements in <code class="docutils literal"><span class="pre">A</span></code>.</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="n">ones</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">);</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">length</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="mi">60</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="Base.eachindex">
<code class="descname">eachindex</code><span class="sig-paren">(</span><em>A...</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.eachindex" title="Permalink to this definition"></a></dt>
<dd><p>Creates an iterable object for visiting each index of an AbstractArray <code class="docutils literal"><span class="pre">A</span></code> in an efficient manner. For array types that have opted into fast linear indexing (like <code class="docutils literal"><span class="pre">Array</span></code>), this is simply the range <code class="docutils literal"><span class="pre">1:length(A)</span></code>. For other array types, this returns a specialized Cartesian range to efficiently index into the array with indices specified for every dimension. For other iterables, including strings and dictionaries, this returns an iterator object supporting arbitrary index types (e.g. unevenly spaced or non-integer indices).</p>
<p>Example for a sparse 2-d array:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="n">sparse</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="p">])</span>
<span class="mi">2</span><span class="n">3</span> <span class="n">sparse</span> <span class="n">matrix</span> <span class="n">with</span> <span class="mi">3</span> <span class="kt">Int64</span> <span class="n">nonzero</span> <span class="n">entries</span><span class="p">:</span>
        <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>  <span class="o">=</span>  <span class="mi">1</span>
        <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>  <span class="o">=</span>  <span class="o">-</span><span class="mi">5</span>
        <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>  <span class="o">=</span>  <span class="mi">2</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">iter</span> <span class="k">in</span> <span class="n">eachindex</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
           <span class="p">@</span><span class="n">show</span> <span class="n">iter</span><span class="o">.</span><span class="n">I</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">iter</span><span class="o">.</span><span class="n">I</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
           <span class="p">@</span><span class="n">show</span> <span class="n">A</span><span class="p">[</span><span class="n">iter</span><span class="p">]</span>
       <span class="k">end</span>
<span class="p">(</span><span class="n">iter</span><span class="o">.</span><span class="n">I</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">iter</span><span class="o">.</span><span class="n">I</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">A</span><span class="p">[</span><span class="n">iter</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="p">(</span><span class="n">iter</span><span class="o">.</span><span class="n">I</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">iter</span><span class="o">.</span><span class="n">I</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">A</span><span class="p">[</span><span class="n">iter</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">5</span>
<span class="p">(</span><span class="n">iter</span><span class="o">.</span><span class="n">I</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">iter</span><span class="o">.</span><span class="n">I</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">A</span><span class="p">[</span><span class="n">iter</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="p">(</span><span class="n">iter</span><span class="o">.</span><span class="n">I</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">iter</span><span class="o">.</span><span class="n">I</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">A</span><span class="p">[</span><span class="n">iter</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="p">(</span><span class="n">iter</span><span class="o">.</span><span class="n">I</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">iter</span><span class="o">.</span><span class="n">I</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="n">A</span><span class="p">[</span><span class="n">iter</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
<span class="p">(</span><span class="n">iter</span><span class="o">.</span><span class="n">I</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">iter</span><span class="o">.</span><span class="n">I</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="n">A</span><span class="p">[</span><span class="n">iter</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
</pre></div>
</div>
<p>If you supply more than one <code class="docutils literal"><span class="pre">AbstractArray</span></code> argument, <code class="docutils literal"><span class="pre">eachindex</span></code> will create an iterable object that is fast for all arguments (a <code class="docutils literal"><span class="pre">UnitRange</span></code> if all inputs have fast linear indexing, a CartesianRange otherwise).  If the arrays have different sizes and/or dimensionalities, <code class="docutils literal"><span class="pre">eachindex</span></code> returns an iterable that spans the largest range along each dimension.</p>
</dd></dl>

<dl class="function">
<dt id="Base.linearindices">
<code class="descname">linearindices</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.linearindices" title="Permalink to this definition"></a></dt>
<dd><p>Returns a <code class="docutils literal"><span class="pre">UnitRange</span></code> specifying the valid range of indices for <code class="docutils literal"><span class="pre">A[i]</span></code> where <code class="docutils literal"><span class="pre">i</span></code> is an <code class="docutils literal"><span class="pre">Int</span></code>. For arrays with conventional indexing (indices start at 1), or any multidimensional array, this is <code class="docutils literal"><span class="pre">1:length(A)</span></code>; however, for one-dimensional arrays with unconventional indices, this is <code class="docutils literal"><span class="pre">indices(A,</span> <span class="pre">1)</span></code>.</p>
<p>Calling this function is the &#8220;safe&#8221; way to write algorithms that exploit linear indexing.</p>
</dd></dl>

<dl class="function">
<dt id="Base.Base.linearindexing">
<code class="descclassname">Base.</code><code class="descname">linearindexing</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.Base.linearindexing" title="Permalink to this definition"></a></dt>
<dd><p><code class="docutils literal"><span class="pre">linearindexing</span></code> defines how an AbstractArray most efficiently accesses its elements. If <code class="docutils literal"><span class="pre">Base.linearindexing(A)</span></code> returns <code class="docutils literal"><span class="pre">Base.LinearFast()</span></code>, this means that linear indexing with only one index is an efficient operation. If it instead returns <code class="docutils literal"><span class="pre">Base.LinearSlow()</span></code> (by default), this means that the array intrinsically accesses its elements with indices specified for every dimension. Since converting a linear index to multiple indexing subscripts is typically very expensive, this provides a traits-based mechanism to enable efficient generic code for all array types.</p>
<p>An abstract array subtype <code class="docutils literal"><span class="pre">MyArray</span></code> that wishes to opt into fast linear indexing behaviors should define <code class="docutils literal"><span class="pre">linearindexing</span></code> in the type-domain:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">Base</span><span class="o">.</span><span class="n">linearindexing</span><span class="p">{</span><span class="n">T</span><span class="o">&lt;:</span><span class="n">MyArray</span><span class="p">}(::</span><span class="n">Type</span><span class="p">{</span><span class="n">T</span><span class="p">})</span> <span class="o">=</span> <span class="n">Base</span><span class="o">.</span><span class="n">LinearFast</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="Base.countnz">
<code class="descname">countnz</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.countnz" title="Permalink to this definition"></a></dt>
<dd><p>Counts the number of nonzero values in array <code class="docutils literal"><span class="pre">A</span></code> (dense or sparse). Note that this is not a constant-time operation. For sparse matrices, one should usually use <code class="docutils literal"><span class="pre">nnz</span></code>, which returns the number of stored values.</p>
</dd></dl>

<dl class="function">
<dt id="Base.conj!">
<code class="descname">conj!</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.conj!" title="Permalink to this definition"></a></dt>
<dd><p>Convert an array to its complex conjugate in-place.</p>
</dd></dl>

<dl class="function">
<dt id="Base.stride">
<code class="descname">stride</code><span class="sig-paren">(</span><em>A</em>, <em>k::Integer</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.stride" title="Permalink to this definition"></a></dt>
<dd><p>Returns the distance in memory (in number of elements) between adjacent elements in dimension <code class="docutils literal"><span class="pre">k</span></code>.</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="n">ones</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">);</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">stride</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="mi">3</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">stride</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="mi">12</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="Base.strides">
<code class="descname">strides</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.strides" title="Permalink to this definition"></a></dt>
<dd><p>Returns a tuple of the memory strides in each dimension.</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="n">ones</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">);</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">strides</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">12</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="Base.ind2sub">
<code class="descname">ind2sub</code><span class="sig-paren">(</span><em>dims</em>, <em>index</em><span class="sig-paren">)</span> &rarr; subscripts<a class="headerlink" href="#Base.ind2sub" title="Permalink to this definition"></a></dt>
<dd><p>Returns a tuple of subscripts into an array with dimensions <code class="docutils literal"><span class="pre">dims</span></code>, corresponding to the linear index <code class="docutils literal"><span class="pre">index</span></code>.</p>
<p><strong>Example</strong>:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="o">...</span> <span class="o">=</span> <span class="n">ind2sub</span><span class="p">(</span><span class="n">size</span><span class="p">(</span><span class="n">A</span><span class="p">),</span> <span class="n">indmax</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
</pre></div>
</div>
<p>provides the indices of the maximum element.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">ind2sub</code><span class="sig-paren">(</span><em>a</em>, <em>index</em><span class="sig-paren">)</span> &rarr; subscripts</dt>
<dd><p>Returns a tuple of subscripts into array <code class="docutils literal"><span class="pre">a</span></code> corresponding to the linear index <code class="docutils literal"><span class="pre">index</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.sub2ind">
<code class="descname">sub2ind</code><span class="sig-paren">(</span><em>dims</em>, <em>i</em>, <em>j</em>, <em>k...</em><span class="sig-paren">)</span> &rarr; index<a class="headerlink" href="#Base.sub2ind" title="Permalink to this definition"></a></dt>
<dd><p>The inverse of <code class="docutils literal"><span class="pre">ind2sub</span></code>, returns the linear index corresponding to the provided subscripts.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.checksquare">
<code class="descclassname">LinAlg.</code><code class="descname">checksquare</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.checksquare" title="Permalink to this definition"></a></dt>
<dd><p>Check that a matrix is square, then return its common dimension. For multiple arguments, return a vector.</p>
</dd></dl>

</div>
<div class="section" id="constructors">
<h2>Constructors<a class="headerlink" href="#constructors" title="Permalink to this headline"></a></h2>
<dl class="function">
<dt id="Base.Array">
<code class="descname">Array</code><span class="sig-paren">(</span><em>dims</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.Array" title="Permalink to this definition"></a></dt>
<dd><p><code class="docutils literal"><span class="pre">Array{T}(dims)</span></code> constructs an uninitialized dense array with element type <code class="docutils literal"><span class="pre">T</span></code>. <code class="docutils literal"><span class="pre">dims</span></code> may be a tuple or a series of integer arguments. The syntax <code class="docutils literal"><span class="pre">Array(T,</span> <span class="pre">dims)</span></code> is also available, but deprecated.</p>
</dd></dl>

<dl class="function">
<dt id="Base.getindex">
<code class="descname">getindex</code><span class="sig-paren">(</span><em>type</em><span class="optional">[</span>, <em>elements...</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#Base.getindex" title="Permalink to this definition"></a></dt>
<dd><p>Construct a 1-d array of the specified type. This is usually called with the syntax <code class="docutils literal"><span class="pre">Type[]</span></code>. Element values can be specified using <code class="docutils literal"><span class="pre">Type[a,b,c,...]</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.zeros">
<code class="descname">zeros</code><span class="sig-paren">(</span><em>type</em>, <em>dims</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.zeros" title="Permalink to this definition"></a></dt>
<dd><p>Create an array of all zeros of specified type. The type defaults to Float64 if not specified.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">zeros</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span></dt>
<dd><p>Create an array of all zeros with the same element type and shape as <code class="docutils literal"><span class="pre">A</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.ones">
<code class="descname">ones</code><span class="sig-paren">(</span><em>type</em>, <em>dims</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.ones" title="Permalink to this definition"></a></dt>
<dd><p>Create an array of all ones of specified type. The type defaults to <code class="docutils literal"><span class="pre">Float64</span></code> if not specified.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">ones</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span></dt>
<dd><p>Create an array of all ones with the same element type and shape as <code class="docutils literal"><span class="pre">A</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.trues">
<code class="descname">trues</code><span class="sig-paren">(</span><em>dims</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.trues" title="Permalink to this definition"></a></dt>
<dd><p>Create a <code class="docutils literal"><span class="pre">BitArray</span></code> with all values set to <code class="docutils literal"><span class="pre">true</span></code>.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">trues</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span></dt>
<dd><p>Create a <code class="docutils literal"><span class="pre">BitArray</span></code> with all values set to <code class="docutils literal"><span class="pre">true</span></code> of the same shape as <code class="docutils literal"><span class="pre">A</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.falses">
<code class="descname">falses</code><span class="sig-paren">(</span><em>dims</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.falses" title="Permalink to this definition"></a></dt>
<dd><p>Create a <code class="docutils literal"><span class="pre">BitArray</span></code> with all values set to <code class="docutils literal"><span class="pre">false</span></code>.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">falses</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span></dt>
<dd><p>Create a <code class="docutils literal"><span class="pre">BitArray</span></code> with all values set to <code class="docutils literal"><span class="pre">false</span></code> of the same shape as <code class="docutils literal"><span class="pre">A</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.fill">
<code class="descname">fill</code><span class="sig-paren">(</span><em>x</em>, <em>dims</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.fill" title="Permalink to this definition"></a></dt>
<dd><p>Create an array filled with the value <code class="docutils literal"><span class="pre">x</span></code>. For example, <code class="docutils literal"><span class="pre">fill(1.0,</span> <span class="pre">(10,10))</span></code> returns a 1010 array of floats, with each element initialized to <code class="docutils literal"><span class="pre">1.0</span></code>.</p>
<p>If <code class="docutils literal"><span class="pre">x</span></code> is an object reference, all elements will refer to the same object. <code class="docutils literal"><span class="pre">fill(Foo(),</span> <span class="pre">dims)</span></code> will return an array filled with the result of evaluating <code class="docutils literal"><span class="pre">Foo()</span></code> once.</p>
</dd></dl>

<dl class="function">
<dt id="Base.fill!">
<code class="descname">fill!</code><span class="sig-paren">(</span><em>A</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.fill!" title="Permalink to this definition"></a></dt>
<dd><p>Fill array <code class="docutils literal"><span class="pre">A</span></code> with the value <code class="docutils literal"><span class="pre">x</span></code>. If <code class="docutils literal"><span class="pre">x</span></code> is an object reference, all elements will refer to the same object. <code class="docutils literal"><span class="pre">fill!(A,</span> <span class="pre">Foo())</span></code> will return <code class="docutils literal"><span class="pre">A</span></code> filled with the result of evaluating <code class="docutils literal"><span class="pre">Foo()</span></code> once.</p>
</dd></dl>

<dl class="function">
<dt id="Base.reshape">
<code class="descname">reshape</code><span class="sig-paren">(</span><em>A</em>, <em>dims</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.reshape" title="Permalink to this definition"></a></dt>
<dd><p>Create an array with the same data as the given array, but with different dimensions.</p>
</dd></dl>

<dl class="function">
<dt id="Base.similar">
<code class="descname">similar</code><span class="sig-paren">(</span><em>array</em><span class="optional">[</span>, <em>element_type=eltype(array)</em><span class="optional">]</span><span class="optional">[</span>, <em>dims=size(array)</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#Base.similar" title="Permalink to this definition"></a></dt>
<dd><p>Create an uninitialized mutable array with the given element type and size, based upon the given source array. The second and third arguments are both optional, defaulting to the given array&#8217;s <code class="docutils literal"><span class="pre">eltype</span></code> and <code class="docutils literal"><span class="pre">size</span></code>. The dimensions may be specified either as a single tuple argument or as a series of integer arguments.</p>
<p>Custom AbstractArray subtypes may choose which specific array type is best-suited to return for the given element type and dimensionality. If they do not specialize this method, the default is an <code class="docutils literal"><span class="pre">Array{element_type}(dims...)</span></code>.</p>
<p>For example, <code class="docutils literal"><span class="pre">similar(1:10,</span> <span class="pre">1,</span> <span class="pre">4)</span></code> returns an uninitialized <code class="docutils literal"><span class="pre">Array{Int,2}</span></code> since ranges are neither mutable nor support 2 dimensions:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">similar</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="mi">10</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="mi">1</span><span class="n">4</span> <span class="n">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">2</span><span class="p">}:</span>
 <span class="mi">4419743872</span>  <span class="mi">4374413872</span>  <span class="mi">4419743888</span>  <span class="mi">0</span>
</pre></div>
</div>
<p>Conversely, <code class="docutils literal"><span class="pre">similar(trues(10,10),</span> <span class="pre">2)</span></code> returns an uninitialized <code class="docutils literal"><span class="pre">BitVector</span></code> with two elements since <code class="docutils literal"><span class="pre">BitArray</span></code>s are both mutable and can support 1-dimensional arrays:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">similar</span><span class="p">(</span><span class="n">trues</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
<span class="mi">2</span><span class="o">-</span><span class="n">element</span> <span class="n">BitArray</span><span class="p">{</span><span class="mi">1</span><span class="p">}:</span>
 <span class="n">false</span>
 <span class="n">false</span>
</pre></div>
</div>
<p>Since <code class="docutils literal"><span class="pre">BitArray</span></code>s can only store elements of type <code class="docutils literal"><span class="pre">Bool</span></code>, however, if you request a different element type it will create a regular <code class="docutils literal"><span class="pre">Array</span></code> instead:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">similar</span><span class="p">(</span><span class="n">falses</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span> <span class="kt">Float64</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="mi">2</span><span class="n">4</span> <span class="n">Array</span><span class="p">{</span><span class="kt">Float64</span><span class="p">,</span><span class="mi">2</span><span class="p">}:</span>
 <span class="mf">2.18425e-314</span>  <span class="mf">2.18425e-314</span>  <span class="mf">2.18425e-314</span>  <span class="mf">2.18425e-314</span>
 <span class="mf">2.18425e-314</span>  <span class="mf">2.18425e-314</span>  <span class="mf">2.18425e-314</span>  <span class="mf">2.18425e-314</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">similar</code><span class="sig-paren">(</span><em>storagetype</em>, <em>indices</em><span class="sig-paren">)</span></dt>
<dd><p>Create an uninitialized mutable array analogous to that specified by <code class="docutils literal"><span class="pre">storagetype</span></code>, but with <code class="docutils literal"><span class="pre">indices</span></code> specified by the last argument. <code class="docutils literal"><span class="pre">storagetype</span></code> might be a type or a function.</p>
<p><strong>Examples</strong>:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">similar</span><span class="p">(</span><span class="n">Array</span><span class="p">{</span><span class="kt">Int</span><span class="p">},</span> <span class="n">indices</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
</pre></div>
</div>
<p>creates an array that &#8220;acts like&#8221; an <code class="docutils literal"><span class="pre">Array{Int}</span></code> (and might indeed be backed by one), but which is indexed identically to <code class="docutils literal"><span class="pre">A</span></code>. If <code class="docutils literal"><span class="pre">A</span></code> has conventional indexing, this will be identical to <code class="docutils literal"><span class="pre">Array{Int}(size(A))</span></code>, but if <code class="docutils literal"><span class="pre">A</span></code> has unconventional indexing then the indices of the result will match <code class="docutils literal"><span class="pre">A</span></code>.</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">similar</span><span class="p">(</span><span class="n">BitArray</span><span class="p">,</span> <span class="p">(</span><span class="n">indices</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="mi">2</span><span class="p">),))</span>
</pre></div>
</div>
<p>would create a 1-dimensional logical array whose indices match those of the columns of <code class="docutils literal"><span class="pre">A</span></code>.</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">similar</span><span class="p">(</span><span class="n">dims</span><span class="o">-&gt;</span><span class="n">zeros</span><span class="p">(</span><span class="kt">Int</span><span class="p">,</span> <span class="n">dims</span><span class="p">),</span> <span class="n">indices</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
</pre></div>
</div>
<p>would create an array of <code class="docutils literal"><span class="pre">Int</span></code>, initialized to zero, matching the indices of <code class="docutils literal"><span class="pre">A</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.reinterpret">
<code class="descname">reinterpret</code><span class="sig-paren">(</span><em>type</em>, <em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.reinterpret" title="Permalink to this definition"></a></dt>
<dd><p>Change the type-interpretation of a block of memory. For example, <code class="docutils literal"><span class="pre">reinterpret(Float32,</span> <span class="pre">UInt32(7))</span></code> interprets the 4 bytes corresponding to <code class="docutils literal"><span class="pre">UInt32(7)</span></code> as a <code class="docutils literal"><span class="pre">Float32</span></code>. For arrays, this constructs an array with the same binary data as the given array, but with the specified element type.</p>
</dd></dl>

<dl class="function">
<dt id="Base.eye">
<code class="descname">eye</code><span class="sig-paren">(</span><span class="optional">[</span><em>T::Type=Float64</em>, <span class="optional">]</span><em>n::Integer</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.eye" title="Permalink to this definition"></a></dt>
<dd><p><code class="docutils literal"><span class="pre">n</span></code>-by-<code class="docutils literal"><span class="pre">n</span></code> identity matrix. The default element type is <code class="docutils literal"><span class="pre">Float64</span></code>.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">eye</code><span class="sig-paren">(</span><span class="optional">[</span><em>T::Type=Float64</em>, <span class="optional">]</span><em>m::Integer</em>, <em>n::Integer</em><span class="sig-paren">)</span></dt>
<dd><p><code class="docutils literal"><span class="pre">m</span></code>-by-<code class="docutils literal"><span class="pre">n</span></code> identity matrix. The default element type is <code class="docutils literal"><span class="pre">Float64</span></code>.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">eye</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span></dt>
<dd><p>Constructs an identity matrix of the same dimensions and type as <code class="docutils literal"><span class="pre">A</span></code>.</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">;</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span><span class="p">;</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span><span class="p">]</span>
<span class="mi">3</span><span class="n">3</span> <span class="n">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">2</span><span class="p">}:</span>
 <span class="mi">1</span>  <span class="mi">2</span>  <span class="mi">3</span>
 <span class="mi">4</span>  <span class="mi">5</span>  <span class="mi">6</span>
 <span class="mi">7</span>  <span class="mi">8</span>  <span class="mi">9</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">eye</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="mi">3</span><span class="n">3</span> <span class="n">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">2</span><span class="p">}:</span>
 <span class="mi">1</span>  <span class="mi">0</span>  <span class="mi">0</span>
 <span class="mi">0</span>  <span class="mi">1</span>  <span class="mi">0</span>
 <span class="mi">0</span>  <span class="mi">0</span>  <span class="mi">1</span>
</pre></div>
</div>
<p>Note the difference from <a class="reference internal" href="#Base.ones" title="Base.ones"><code class="xref jl jl-func docutils literal"><span class="pre">ones()</span></code></a>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.linspace">
<code class="descname">linspace</code><span class="sig-paren">(</span><em>start</em>, <em>stop</em>, <em>n=50</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.linspace" title="Permalink to this definition"></a></dt>
<dd><p>Construct a range of <code class="docutils literal"><span class="pre">n</span></code> linearly spaced elements from <code class="docutils literal"><span class="pre">start</span></code> to <code class="docutils literal"><span class="pre">stop</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.logspace">
<code class="descname">logspace</code><span class="sig-paren">(</span><em>start</em>, <em>stop</em>, <em>n=50</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.logspace" title="Permalink to this definition"></a></dt>
<dd><p>Construct a vector of <code class="docutils literal"><span class="pre">n</span></code> logarithmically spaced numbers from <code class="docutils literal"><span class="pre">10^start</span></code> to <code class="docutils literal"><span class="pre">10^stop</span></code>.</p>
</dd></dl>

</div>
<div class="section" id="mathematical-operators-and-functions">
<h2>Mathematical operators and functions<a class="headerlink" href="#mathematical-operators-and-functions" title="Permalink to this headline"></a></h2>
<p>All mathematical operations and functions are supported for arrays</p>
<dl class="function">
<dt id="Base.broadcast">
<code class="descname">broadcast</code><span class="sig-paren">(</span><em>f</em>, <em>As...</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.broadcast" title="Permalink to this definition"></a></dt>
<dd><p>Broadcasts the arrays <code class="docutils literal"><span class="pre">As</span></code> to a common size by expanding singleton dimensions, and returns an array of the results <code class="docutils literal"><span class="pre">f(as...)</span></code> for each position.</p>
</dd></dl>

<dl class="function">
<dt id="Base.broadcast!">
<code class="descname">broadcast!</code><span class="sig-paren">(</span><em>f</em>, <em>dest</em>, <em>As...</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.broadcast!" title="Permalink to this definition"></a></dt>
<dd><p>Like <code class="docutils literal"><span class="pre">broadcast</span></code>, but store the result of <code class="docutils literal"><span class="pre">broadcast(f,</span> <span class="pre">As...)</span></code> in the <code class="docutils literal"><span class="pre">dest</span></code> array. Note that <code class="docutils literal"><span class="pre">dest</span></code> is only used to store the result, and does not supply arguments to <code class="docutils literal"><span class="pre">f</span></code> unless it is also listed in the <code class="docutils literal"><span class="pre">As</span></code>, as in <code class="docutils literal"><span class="pre">broadcast!(f,</span> <span class="pre">A,</span> <span class="pre">A,</span> <span class="pre">B)</span></code> to perform <code class="docutils literal"><span class="pre">A[:]</span> <span class="pre">=</span> <span class="pre">broadcast(f,</span> <span class="pre">A,</span> <span class="pre">B)</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.bitbroadcast">
<code class="descname">bitbroadcast</code><span class="sig-paren">(</span><em>f</em>, <em>As...</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.bitbroadcast" title="Permalink to this definition"></a></dt>
<dd><p>Like <code class="docutils literal"><span class="pre">broadcast</span></code>, but allocates a <code class="docutils literal"><span class="pre">BitArray</span></code> to store the result, rather then an <code class="docutils literal"><span class="pre">Array</span></code>.</p>
</dd></dl>

</div>
<div class="section" id="indexing-assignment-and-concatenation">
<h2>Indexing, Assignment, and Concatenation<a class="headerlink" href="#indexing-assignment-and-concatenation" title="Permalink to this headline"></a></h2>
<dl class="function">
<dt>
<code class="descname">getindex</code><span class="sig-paren">(</span><em>A</em>, <em>inds...</em><span class="sig-paren">)</span></dt>
<dd><p>Returns a subset of array <code class="docutils literal"><span class="pre">A</span></code> as specified by <code class="docutils literal"><span class="pre">inds</span></code>, where each <code class="docutils literal"><span class="pre">ind</span></code> may be an <code class="docutils literal"><span class="pre">Int</span></code>, a <code class="docutils literal"><span class="pre">Range</span></code>, or a <code class="docutils literal"><span class="pre">Vector</span></code>. See the manual section on <a class="reference internal" href="../../manual/arrays/#man-array-indexing"><span>array indexing</span></a> for details.</p>
</dd></dl>

<dl class="function">
<dt id="Base.view">
<code class="descname">view</code><span class="sig-paren">(</span><em>A</em>, <em>inds...</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.view" title="Permalink to this definition"></a></dt>
<dd><p>Like <a class="reference internal" href="../collections/#Base.getindex" title="Base.getindex"><code class="xref jl jl-func docutils literal"><span class="pre">getindex()</span></code></a>, but returns a view into the parent array <code class="docutils literal"><span class="pre">A</span></code> with the given indices instead of making a copy.  Calling <a class="reference internal" href="../collections/#Base.getindex" title="Base.getindex"><code class="xref jl jl-func docutils literal"><span class="pre">getindex()</span></code></a> or <a class="reference internal" href="../collections/#Base.setindex!" title="Base.setindex!"><code class="xref jl jl-func docutils literal"><span class="pre">setindex!()</span></code></a> on the returned <code class="xref jl jl-obj docutils literal"><span class="pre">SubArray</span></code> computes the indices to the parent array on the fly without checking bounds.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">&#64;view A[inds...]</code></dt>
<dd><p>Creates a <code class="docutils literal"><span class="pre">SubArray</span></code> from an indexing expression. This can only be applied directly to a reference expression (e.g. <code class="docutils literal"><span class="pre">&#64;view</span> <span class="pre">A[1,2:end]</span></code>), and should <em>not</em> be used as the target of an assignment (e.g. <code class="docutils literal"><span class="pre">&#64;view(A[1,2:end])</span> <span class="pre">=</span> <span class="pre">...</span></code>).</p>
</dd></dl>

<dl class="function">
<dt id="Base.parent">
<code class="descname">parent</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.parent" title="Permalink to this definition"></a></dt>
<dd><p>Returns the &#8220;parent array&#8221; of an array view type (e.g., <code class="docutils literal"><span class="pre">SubArray</span></code>), or the array itself if it is not a view.</p>
</dd></dl>

<dl class="function">
<dt id="Base.parentindexes">
<code class="descname">parentindexes</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.parentindexes" title="Permalink to this definition"></a></dt>
<dd><p>From an array view <code class="docutils literal"><span class="pre">A</span></code>, returns the corresponding indexes in the parent.</p>
</dd></dl>

<dl class="function">
<dt id="Base.slicedim">
<code class="descname">slicedim</code><span class="sig-paren">(</span><em>A</em>, <em>d</em>, <em>i</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.slicedim" title="Permalink to this definition"></a></dt>
<dd><p>Return all the data of <code class="docutils literal"><span class="pre">A</span></code> where the index for dimension <code class="docutils literal"><span class="pre">d</span></code> equals <code class="docutils literal"><span class="pre">i</span></code>. Equivalent to <code class="docutils literal"><span class="pre">A[:,:,...,i,:,:,...]</span></code> where <code class="docutils literal"><span class="pre">i</span></code> is in position <code class="docutils literal"><span class="pre">d</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.setindex!">
<code class="descname">setindex!</code><span class="sig-paren">(</span><em>A</em>, <em>X</em>, <em>inds...</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.setindex!" title="Permalink to this definition"></a></dt>
<dd><p>Store values from array <code class="docutils literal"><span class="pre">X</span></code> within some subset of <code class="docutils literal"><span class="pre">A</span></code> as specified by <code class="docutils literal"><span class="pre">inds</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.broadcast_getindex">
<code class="descname">broadcast_getindex</code><span class="sig-paren">(</span><em>A</em>, <em>inds...</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.broadcast_getindex" title="Permalink to this definition"></a></dt>
<dd><p>Broadcasts the <code class="docutils literal"><span class="pre">inds</span></code> arrays to a common size like <code class="docutils literal"><span class="pre">broadcast</span></code>, and returns an array of the results <code class="docutils literal"><span class="pre">A[ks...]</span></code>, where <code class="docutils literal"><span class="pre">ks</span></code> goes over the positions in the broadcast.</p>
</dd></dl>

<dl class="function">
<dt id="Base.broadcast_setindex!">
<code class="descname">broadcast_setindex!</code><span class="sig-paren">(</span><em>A</em>, <em>X</em>, <em>inds...</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.broadcast_setindex!" title="Permalink to this definition"></a></dt>
<dd><p>Broadcasts the <code class="docutils literal"><span class="pre">X</span></code> and <code class="docutils literal"><span class="pre">inds</span></code> arrays to a common size and stores the value from each position in <code class="docutils literal"><span class="pre">X</span></code> at the indices given by the same positions in <code class="docutils literal"><span class="pre">inds</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.isassigned">
<code class="descname">isassigned</code><span class="sig-paren">(</span><em>array</em>, <em>i</em><span class="sig-paren">)</span> &rarr; Bool<a class="headerlink" href="#Base.isassigned" title="Permalink to this definition"></a></dt>
<dd><p>Tests whether the given array has a value associated with index <code class="docutils literal"><span class="pre">i</span></code>. Returns <code class="docutils literal"><span class="pre">false</span></code> if the index is out of bounds, or has an undefined reference.</p>
</dd></dl>

<dl class="function">
<dt id="Base.cat">
<code class="descname">cat</code><span class="sig-paren">(</span><em>dims</em>, <em>A...</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.cat" title="Permalink to this definition"></a></dt>
<dd><p>Concatenate the input arrays along the specified dimensions in the iterable <code class="docutils literal"><span class="pre">dims</span></code>. For dimensions not in <code class="docutils literal"><span class="pre">dims</span></code>, all input arrays should have the same size, which will also be the size of the output array along that dimension. For dimensions in <code class="docutils literal"><span class="pre">dims</span></code>, the size of the output array is the sum of the sizes of the input arrays along that dimension. If <code class="docutils literal"><span class="pre">dims</span></code> is a single number, the different arrays are tightly stacked along that dimension. If <code class="docutils literal"><span class="pre">dims</span></code> is an iterable containing several dimensions, this allows one to construct block diagonal matrices and their higher-dimensional analogues by simultaneously increasing several dimensions for every new input array and putting zero blocks elsewhere. For example, <code class="docutils literal"><span class="pre">cat([1,2],</span> <span class="pre">matrices...)</span></code> builds a block diagonal matrix, i.e. a block matrix with <code class="docutils literal"><span class="pre">matrices[1]</span></code>, <code class="docutils literal"><span class="pre">matrices[2]</span></code>, ... as diagonal blocks and matching zero blocks away from the diagonal.</p>
</dd></dl>

<dl class="function">
<dt id="Base.vcat">
<code class="descname">vcat</code><span class="sig-paren">(</span><em>A...</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.vcat" title="Permalink to this definition"></a></dt>
<dd><p>Concatenate along dimension 1.</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">]</span>
<span class="mi">1</span><span class="n">5</span> <span class="n">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">2</span><span class="p">}:</span>
 <span class="mi">1</span>  <span class="mi">2</span>  <span class="mi">3</span>  <span class="mi">4</span>  <span class="mi">5</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span> <span class="mi">10</span><span class="p">;</span> <span class="mi">11</span> <span class="mi">12</span> <span class="mi">13</span> <span class="mi">14</span> <span class="mi">15</span><span class="p">]</span>
<span class="mi">2</span><span class="n">5</span> <span class="n">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">2</span><span class="p">}:</span>
  <span class="mi">6</span>   <span class="mi">7</span>   <span class="mi">8</span>   <span class="mi">9</span>  <span class="mi">10</span>
 <span class="mi">11</span>  <span class="mi">12</span>  <span class="mi">13</span>  <span class="mi">14</span>  <span class="mi">15</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">vcat</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
<span class="mi">3</span><span class="n">5</span> <span class="n">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">2</span><span class="p">}:</span>
  <span class="mi">1</span>   <span class="mi">2</span>   <span class="mi">3</span>   <span class="mi">4</span>   <span class="mi">5</span>
  <span class="mi">6</span>   <span class="mi">7</span>   <span class="mi">8</span>   <span class="mi">9</span>  <span class="mi">10</span>
 <span class="mi">11</span>  <span class="mi">12</span>  <span class="mi">13</span>  <span class="mi">14</span>  <span class="mi">15</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="p">([</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span><span class="p">])</span>
<span class="p">(</span>
<span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">],</span>

<span class="p">[</span><span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span><span class="p">])</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">vcat</span><span class="p">(</span><span class="n">c</span><span class="o">...</span><span class="p">)</span>
<span class="mi">2</span><span class="n">3</span> <span class="n">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">2</span><span class="p">}:</span>
 <span class="mi">1</span>  <span class="mi">2</span>  <span class="mi">3</span>
 <span class="mi">4</span>  <span class="mi">5</span>  <span class="mi">6</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="Base.hcat">
<code class="descname">hcat</code><span class="sig-paren">(</span><em>A...</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.hcat" title="Permalink to this definition"></a></dt>
<dd><p>Concatenate along dimension 2.</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span> <span class="mi">2</span><span class="p">;</span> <span class="mi">3</span><span class="p">;</span> <span class="mi">4</span><span class="p">;</span> <span class="mi">5</span><span class="p">]</span>
<span class="mi">5</span><span class="o">-</span><span class="n">element</span> <span class="n">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">1</span><span class="p">}:</span>
 <span class="mi">1</span>
 <span class="mi">2</span>
 <span class="mi">3</span>
 <span class="mi">4</span>
 <span class="mi">5</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="mi">6</span> <span class="mi">7</span><span class="p">;</span> <span class="mi">8</span> <span class="mi">9</span><span class="p">;</span> <span class="mi">10</span> <span class="mi">11</span><span class="p">;</span> <span class="mi">12</span> <span class="mi">13</span><span class="p">;</span> <span class="mi">14</span> <span class="mi">15</span><span class="p">]</span>
<span class="mi">5</span><span class="n">2</span> <span class="n">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">2</span><span class="p">}:</span>
  <span class="mi">6</span>   <span class="mi">7</span>
  <span class="mi">8</span>   <span class="mi">9</span>
 <span class="mi">10</span>  <span class="mi">11</span>
 <span class="mi">12</span>  <span class="mi">13</span>
 <span class="mi">14</span>  <span class="mi">15</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">hcat</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
<span class="mi">5</span><span class="n">3</span> <span class="n">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">2</span><span class="p">}:</span>
 <span class="mi">1</span>   <span class="mi">6</span>   <span class="mi">7</span>
 <span class="mi">2</span>   <span class="mi">8</span>   <span class="mi">9</span>
 <span class="mi">3</span>  <span class="mi">10</span>  <span class="mi">11</span>
 <span class="mi">4</span>  <span class="mi">12</span>  <span class="mi">13</span>
 <span class="mi">5</span>  <span class="mi">14</span>  <span class="mi">15</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="p">([</span><span class="mi">1</span><span class="p">;</span> <span class="mi">2</span><span class="p">;</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">;</span> <span class="mi">5</span><span class="p">;</span> <span class="mi">6</span><span class="p">])</span>
<span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">])</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">hcat</span><span class="p">(</span><span class="n">c</span><span class="o">...</span><span class="p">)</span>
<span class="mi">3</span><span class="n">2</span> <span class="n">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">2</span><span class="p">}:</span>
 <span class="mi">1</span>  <span class="mi">4</span>
 <span class="mi">2</span>  <span class="mi">5</span>
 <span class="mi">3</span>  <span class="mi">6</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="Base.hvcat">
<code class="descname">hvcat</code><span class="sig-paren">(</span><em>rows::Tuple{Vararg{Int}}</em>, <em>values...</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.hvcat" title="Permalink to this definition"></a></dt>
<dd><p>Horizontal and vertical concatenation in one call. This function is called for block matrix syntax. The first argument specifies the number of arguments to concatenate in each block row.</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span>
<span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="p">[</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="p">;</span> <span class="n">d</span> <span class="n">e</span> <span class="n">f</span><span class="p">]</span>
<span class="mi">2</span><span class="n">3</span> <span class="n">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">2</span><span class="p">}:</span>
 <span class="mi">1</span>  <span class="mi">2</span>  <span class="mi">3</span>
 <span class="mi">4</span>  <span class="mi">5</span>  <span class="mi">6</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">hvcat</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">d</span><span class="p">,</span><span class="n">e</span><span class="p">,</span><span class="n">f</span><span class="p">)</span>
<span class="mi">2</span><span class="n">3</span> <span class="n">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">2</span><span class="p">}:</span>
 <span class="mi">1</span>  <span class="mi">2</span>  <span class="mi">3</span>
 <span class="mi">4</span>  <span class="mi">5</span>  <span class="mi">6</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="p">[</span><span class="n">a</span> <span class="n">b</span><span class="p">;</span><span class="n">c</span> <span class="n">d</span><span class="p">;</span> <span class="n">e</span> <span class="n">f</span><span class="p">]</span>
<span class="mi">3</span><span class="n">2</span> <span class="n">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">2</span><span class="p">}:</span>
 <span class="mi">1</span>  <span class="mi">2</span>
 <span class="mi">3</span>  <span class="mi">4</span>
 <span class="mi">5</span>  <span class="mi">6</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">hvcat</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">d</span><span class="p">,</span><span class="n">e</span><span class="p">,</span><span class="n">f</span><span class="p">)</span>
<span class="mi">3</span><span class="n">2</span> <span class="n">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">2</span><span class="p">}:</span>
 <span class="mi">1</span>  <span class="mi">2</span>
 <span class="mi">3</span>  <span class="mi">4</span>
 <span class="mi">5</span>  <span class="mi">6</span>
</pre></div>
</div>
<p>If the first argument is a single integer <code class="docutils literal"><span class="pre">n</span></code>, then all block rows are assumed to have <code class="docutils literal"><span class="pre">n</span></code> block columns.</p>
</dd></dl>

<dl class="function">
<dt id="Base.flipdim">
<code class="descname">flipdim</code><span class="sig-paren">(</span><em>A</em>, <em>d</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.flipdim" title="Permalink to this definition"></a></dt>
<dd><p>Reverse <code class="docutils literal"><span class="pre">A</span></code> in dimension <code class="docutils literal"><span class="pre">d</span></code>.</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span><span class="p">;</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">]</span>
<span class="mi">2</span><span class="n">2</span> <span class="n">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">2</span><span class="p">}:</span>
 <span class="mi">1</span>  <span class="mi">2</span>
 <span class="mi">3</span>  <span class="mi">4</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">flipdim</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="mi">2</span><span class="n">2</span> <span class="n">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">2</span><span class="p">}:</span>
 <span class="mi">2</span>  <span class="mi">1</span>
 <span class="mi">4</span>  <span class="mi">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="Base.circshift">
<code class="descname">circshift</code><span class="sig-paren">(</span><em>A</em>, <em>shifts</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.circshift" title="Permalink to this definition"></a></dt>
<dd><p>Circularly shift the data in an array. The second argument is a vector giving the amount to shift in each dimension.</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">reshape</span><span class="p">(</span><span class="n">collect</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="mi">16</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="mi">4</span><span class="n">4</span> <span class="n">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">2</span><span class="p">}:</span>
 <span class="mi">1</span>  <span class="mi">5</span>   <span class="mi">9</span>  <span class="mi">13</span>
 <span class="mi">2</span>  <span class="mi">6</span>  <span class="mi">10</span>  <span class="mi">14</span>
 <span class="mi">3</span>  <span class="mi">7</span>  <span class="mi">11</span>  <span class="mi">15</span>
 <span class="mi">4</span>  <span class="mi">8</span>  <span class="mi">12</span>  <span class="mi">16</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">circshift</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="mi">4</span><span class="n">4</span> <span class="n">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">2</span><span class="p">}:</span>
  <span class="mi">9</span>  <span class="mi">13</span>  <span class="mi">1</span>  <span class="mi">5</span>
 <span class="mi">10</span>  <span class="mi">14</span>  <span class="mi">2</span>  <span class="mi">6</span>
 <span class="mi">11</span>  <span class="mi">15</span>  <span class="mi">3</span>  <span class="mi">7</span>
 <span class="mi">12</span>  <span class="mi">16</span>  <span class="mi">4</span>  <span class="mi">8</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">circshift</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
<span class="mi">4</span><span class="n">4</span> <span class="n">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">2</span><span class="p">}:</span>
 <span class="mi">2</span>  <span class="mi">6</span>  <span class="mi">10</span>  <span class="mi">14</span>
 <span class="mi">3</span>  <span class="mi">7</span>  <span class="mi">11</span>  <span class="mi">15</span>
 <span class="mi">4</span>  <span class="mi">8</span>  <span class="mi">12</span>  <span class="mi">16</span>
 <span class="mi">1</span>  <span class="mi">5</span>   <span class="mi">9</span>  <span class="mi">13</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="Base.find">
<code class="descname">find</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.find" title="Permalink to this definition"></a></dt>
<dd><p>Return a vector of the linear indexes of the non-zeros in <code class="docutils literal"><span class="pre">A</span></code> (determined by <code class="docutils literal"><span class="pre">A[i]!=0</span></code>). A common use of this is to convert a boolean array to an array of indexes of the <code class="docutils literal"><span class="pre">true</span></code> elements. If there are no non-zero elements of <code class="docutils literal"><span class="pre">A</span></code>, <code class="docutils literal"><span class="pre">find</span></code> returns an empty array.</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="n">true</span> <span class="n">false</span><span class="p">;</span> <span class="n">false</span> <span class="n">true</span><span class="p">]</span>
<span class="mi">2</span><span class="n">2</span> <span class="n">Array</span><span class="p">{</span><span class="kt">Bool</span><span class="p">,</span><span class="mi">2</span><span class="p">}:</span>
  <span class="n">true</span>  <span class="n">false</span>
 <span class="n">false</span>   <span class="n">true</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">find</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="mi">2</span><span class="o">-</span><span class="n">element</span> <span class="n">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">1</span><span class="p">}:</span>
 <span class="mi">1</span>
 <span class="mi">4</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">find</code><span class="sig-paren">(</span><em>f::Function</em>, <em>A</em><span class="sig-paren">)</span></dt>
<dd><p>Return a vector <code class="docutils literal"><span class="pre">I</span></code> of the linear indexes of <code class="docutils literal"><span class="pre">A</span></code> where <code class="docutils literal"><span class="pre">f(A[I])</span></code> returns <code class="docutils literal"><span class="pre">true</span></code>. If there are no such elements of <code class="docutils literal"><span class="pre">A</span></code>, find returns an empty array.</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span><span class="p">;</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">]</span>
<span class="mi">2</span><span class="n">2</span> <span class="n">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">2</span><span class="p">}:</span>
 <span class="mi">1</span>  <span class="mi">2</span>
 <span class="mi">3</span>  <span class="mi">4</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">find</span><span class="p">(</span><span class="n">isodd</span><span class="p">,</span><span class="n">A</span><span class="p">)</span>
<span class="mi">2</span><span class="o">-</span><span class="n">element</span> <span class="n">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">1</span><span class="p">}:</span>
 <span class="mi">1</span>
 <span class="mi">2</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="Base.findn">
<code class="descname">findn</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.findn" title="Permalink to this definition"></a></dt>
<dd><p>Return a vector of indexes for each dimension giving the locations of the non-zeros in <code class="docutils literal"><span class="pre">A</span></code> (determined by <code class="docutils literal"><span class="pre">A[i]!=0</span></code>). If there are no non-zero elements of <code class="docutils literal"><span class="pre">A</span></code>, <code class="docutils literal"><span class="pre">findn</span></code> returns a 2-tuple of empty arrays.</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">0</span><span class="p">;</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">3</span><span class="p">;</span> <span class="mi">0</span> <span class="mi">4</span> <span class="mi">0</span><span class="p">]</span>
<span class="mi">3</span><span class="n">3</span> <span class="n">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">2</span><span class="p">}:</span>
 <span class="mi">1</span>  <span class="mi">2</span>  <span class="mi">0</span>
 <span class="mi">0</span>  <span class="mi">0</span>  <span class="mi">3</span>
 <span class="mi">0</span>  <span class="mi">4</span>  <span class="mi">0</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">findn</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="mi">2</span><span class="n">2</span> <span class="n">Array</span><span class="p">{</span><span class="kt">Float64</span><span class="p">,</span><span class="mi">2</span><span class="p">}:</span>
 <span class="mf">0.0</span>  <span class="mf">0.0</span>
 <span class="mf">0.0</span>  <span class="mf">0.0</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">findn</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="p">(</span><span class="kt">Int64</span><span class="p">[],</span><span class="kt">Int64</span><span class="p">[])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="Base.findnz">
<code class="descname">findnz</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.findnz" title="Permalink to this definition"></a></dt>
<dd><p>Return a tuple <code class="docutils literal"><span class="pre">(I,</span> <span class="pre">J,</span> <span class="pre">V)</span></code> where <code class="docutils literal"><span class="pre">I</span></code> and <code class="docutils literal"><span class="pre">J</span></code> are the row and column indexes of the non-zero values in matrix <code class="docutils literal"><span class="pre">A</span></code>, and <code class="docutils literal"><span class="pre">V</span></code> is a vector of the non-zero values.</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">0</span><span class="p">;</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">3</span><span class="p">;</span> <span class="mi">0</span> <span class="mi">4</span> <span class="mi">0</span><span class="p">]</span>
<span class="mi">3</span><span class="n">3</span> <span class="n">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">2</span><span class="p">}:</span>
 <span class="mi">1</span>  <span class="mi">2</span>  <span class="mi">0</span>
 <span class="mi">0</span>  <span class="mi">0</span>  <span class="mi">3</span>
 <span class="mi">0</span>  <span class="mi">4</span>  <span class="mi">0</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">findnz</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="Base.findfirst">
<code class="descname">findfirst</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.findfirst" title="Permalink to this definition"></a></dt>
<dd><p>Return the linear index of the first non-zero value in <code class="docutils literal"><span class="pre">A</span></code> (determined by <code class="docutils literal"><span class="pre">A[i]!=0</span></code>). Returns <code class="docutils literal"><span class="pre">0</span></code> if no such value is found.</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="mi">0</span><span class="p">;</span> <span class="mi">1</span> <span class="mi">0</span><span class="p">]</span>
<span class="mi">2</span><span class="n">2</span> <span class="n">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">2</span><span class="p">}:</span>
 <span class="mi">0</span>  <span class="mi">0</span>
 <span class="mi">1</span>  <span class="mi">0</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">findfirst</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="mi">2</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">findfirst</code><span class="sig-paren">(</span><em>A</em>, <em>v</em><span class="sig-paren">)</span></dt>
<dd><p>Return the linear index of the first element equal to <code class="docutils literal"><span class="pre">v</span></code> in <code class="docutils literal"><span class="pre">A</span></code>. Returns <code class="docutils literal"><span class="pre">0</span></code> if <code class="docutils literal"><span class="pre">v</span></code> is not found.</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span> <span class="mi">6</span><span class="p">;</span> <span class="mi">2</span> <span class="mi">2</span><span class="p">]</span>
<span class="mi">2</span><span class="n">2</span> <span class="n">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">2</span><span class="p">}:</span>
 <span class="mi">4</span>  <span class="mi">6</span>
 <span class="mi">2</span>  <span class="mi">2</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">findfirst</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="mi">2</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">findfirst</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="mi">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">findfirst</code><span class="sig-paren">(</span><em>predicate::Function</em>, <em>A</em><span class="sig-paren">)</span></dt>
<dd><p>Return the linear index of the first element of <code class="docutils literal"><span class="pre">A</span></code> for which <code class="docutils literal"><span class="pre">predicate</span></code> returns <code class="docutils literal"><span class="pre">true</span></code>. Returns <code class="docutils literal"><span class="pre">0</span></code> if there is no such element.</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">4</span><span class="p">;</span> <span class="mi">2</span> <span class="mi">2</span><span class="p">]</span>
<span class="mi">2</span><span class="n">2</span> <span class="n">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">2</span><span class="p">}:</span>
 <span class="mi">1</span>  <span class="mi">4</span>
 <span class="mi">2</span>  <span class="mi">2</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">findfirst</span><span class="p">(</span><span class="n">iseven</span><span class="p">,</span> <span class="n">A</span><span class="p">)</span>
<span class="mi">2</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">findfirst</span><span class="p">(</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">&gt;</span><span class="mi">10</span><span class="p">,</span> <span class="n">A</span><span class="p">)</span>
<span class="mi">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="Base.findlast">
<code class="descname">findlast</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.findlast" title="Permalink to this definition"></a></dt>
<dd><p>Return the linear index of the last non-zero value in <code class="docutils literal"><span class="pre">A</span></code> (determined by <code class="docutils literal"><span class="pre">A[i]!=0</span></code>). Returns <code class="docutils literal"><span class="pre">0</span></code> if there is no non-zero value in <code class="docutils literal"><span class="pre">A</span></code>.</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">0</span><span class="p">;</span> <span class="mi">1</span> <span class="mi">0</span><span class="p">]</span>
<span class="mi">2</span><span class="n">2</span> <span class="n">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">2</span><span class="p">}:</span>
 <span class="mi">1</span>  <span class="mi">0</span>
 <span class="mi">1</span>  <span class="mi">0</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">findlast</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="mi">2</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="mi">2</span><span class="n">2</span> <span class="n">Array</span><span class="p">{</span><span class="kt">Float64</span><span class="p">,</span><span class="mi">2</span><span class="p">}:</span>
 <span class="mf">0.0</span>  <span class="mf">0.0</span>
 <span class="mf">0.0</span>  <span class="mf">0.0</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">findlast</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="mi">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">findlast</code><span class="sig-paren">(</span><em>A</em>, <em>v</em><span class="sig-paren">)</span></dt>
<dd><p>Return the linear index of the last element equal to <code class="docutils literal"><span class="pre">v</span></code> in <code class="docutils literal"><span class="pre">A</span></code>. Returns <code class="docutils literal"><span class="pre">0</span></code> if there is no element of <code class="docutils literal"><span class="pre">A</span></code> equal to <code class="docutils literal"><span class="pre">v</span></code>.</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span><span class="p">;</span> <span class="mi">2</span> <span class="mi">1</span><span class="p">]</span>
<span class="mi">2</span><span class="n">2</span> <span class="n">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">2</span><span class="p">}:</span>
 <span class="mi">1</span>  <span class="mi">2</span>
 <span class="mi">2</span>  <span class="mi">1</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">findlast</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="mi">4</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">findlast</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="mi">3</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">findlast</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="mi">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">findlast</code><span class="sig-paren">(</span><em>predicate::Function</em>, <em>A</em><span class="sig-paren">)</span></dt>
<dd><p>Return the linear index of the last element of <code class="docutils literal"><span class="pre">A</span></code> for which <code class="docutils literal"><span class="pre">predicate</span></code> returns <code class="docutils literal"><span class="pre">true</span></code>. Returns <code class="docutils literal"><span class="pre">0</span></code> if there is no such element.</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span><span class="p">;</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">]</span>
<span class="mi">2</span><span class="n">2</span> <span class="n">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">2</span><span class="p">}:</span>
 <span class="mi">1</span>  <span class="mi">2</span>
 <span class="mi">3</span>  <span class="mi">4</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">findlast</span><span class="p">(</span><span class="n">isodd</span><span class="p">,</span> <span class="n">A</span><span class="p">)</span>
<span class="mi">2</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">findlast</span><span class="p">(</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">,</span> <span class="n">A</span><span class="p">)</span>
<span class="mi">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="Base.findnext">
<code class="descname">findnext</code><span class="sig-paren">(</span><em>A</em>, <em>i::Integer</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.findnext" title="Permalink to this definition"></a></dt>
<dd><p>Find the next linear index &gt;= <code class="docutils literal"><span class="pre">i</span></code> of a non-zero element of <code class="docutils literal"><span class="pre">A</span></code>, or <code class="docutils literal"><span class="pre">0</span></code> if not found.</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="mi">0</span><span class="p">;</span> <span class="mi">1</span> <span class="mi">0</span><span class="p">]</span>
<span class="mi">2</span><span class="n">2</span> <span class="n">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">2</span><span class="p">}:</span>
 <span class="mi">0</span>  <span class="mi">0</span>
 <span class="mi">1</span>  <span class="mi">0</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">findnext</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="mi">2</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">findnext</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="mi">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">findnext</code><span class="sig-paren">(</span><em>predicate::Function</em>, <em>A</em>, <em>i::Integer</em><span class="sig-paren">)</span></dt>
<dd><p>Find the next linear index &gt;= <code class="docutils literal"><span class="pre">i</span></code> of an element of <code class="docutils literal"><span class="pre">A</span></code> for which <code class="docutils literal"><span class="pre">predicate</span></code> returns <code class="docutils literal"><span class="pre">true</span></code>, or <code class="docutils literal"><span class="pre">0</span></code> if not found.</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">4</span><span class="p">;</span> <span class="mi">2</span> <span class="mi">2</span><span class="p">]</span>
<span class="mi">2</span><span class="n">2</span> <span class="n">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">2</span><span class="p">}:</span>
 <span class="mi">1</span>  <span class="mi">4</span>
 <span class="mi">2</span>  <span class="mi">2</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">findnext</span><span class="p">(</span><span class="n">isodd</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="mi">1</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">findnext</span><span class="p">(</span><span class="n">isodd</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="mi">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">findnext</code><span class="sig-paren">(</span><em>A</em>, <em>v</em>, <em>i::Integer</em><span class="sig-paren">)</span></dt>
<dd><p>Find the next linear index &gt;= <code class="docutils literal"><span class="pre">i</span></code> of an element of <code class="docutils literal"><span class="pre">A</span></code> equal to <code class="docutils literal"><span class="pre">v</span></code> (using <code class="docutils literal"><span class="pre">==</span></code>), or <code class="docutils literal"><span class="pre">0</span></code> if not found.</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">4</span><span class="p">;</span> <span class="mi">2</span> <span class="mi">2</span><span class="p">]</span>
<span class="mi">2</span><span class="n">2</span> <span class="n">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">2</span><span class="p">}:</span>
 <span class="mi">1</span>  <span class="mi">4</span>
 <span class="mi">2</span>  <span class="mi">2</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">findnext</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="mi">0</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">findnext</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="mi">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="Base.findprev">
<code class="descname">findprev</code><span class="sig-paren">(</span><em>A</em>, <em>i::Integer</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.findprev" title="Permalink to this definition"></a></dt>
<dd><p>Find the previous linear index &lt;= <code class="docutils literal"><span class="pre">i</span></code> of a non-zero element of <code class="docutils literal"><span class="pre">A</span></code>, or <code class="docutils literal"><span class="pre">0</span></code> if not found.</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="mi">0</span><span class="p">;</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">]</span>
<span class="mi">2</span><span class="n">2</span> <span class="n">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">2</span><span class="p">}:</span>
 <span class="mi">0</span>  <span class="mi">0</span>
 <span class="mi">1</span>  <span class="mi">2</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">findprev</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="mi">2</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">findprev</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="mi">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">findprev</code><span class="sig-paren">(</span><em>predicate::Function</em>, <em>A</em>, <em>i::Integer</em><span class="sig-paren">)</span></dt>
<dd><p>Find the previous linear index &lt;= <code class="docutils literal"><span class="pre">i</span></code> of an element of <code class="docutils literal"><span class="pre">A</span></code> for which <code class="docutils literal"><span class="pre">predicate</span></code> returns <code class="docutils literal"><span class="pre">true</span></code>, or <code class="docutils literal"><span class="pre">0</span></code> if not found.</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span> <span class="mi">6</span><span class="p">;</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">]</span>
<span class="mi">2</span><span class="n">2</span> <span class="n">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">2</span><span class="p">}:</span>
 <span class="mi">4</span>  <span class="mi">6</span>
 <span class="mi">1</span>  <span class="mi">2</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">findprev</span><span class="p">(</span><span class="n">isodd</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="mi">0</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">findprev</span><span class="p">(</span><span class="n">isodd</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="mi">2</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">findprev</code><span class="sig-paren">(</span><em>A</em>, <em>v</em>, <em>i::Integer</em><span class="sig-paren">)</span></dt>
<dd><p>Find the previous linear index &lt;= <code class="docutils literal"><span class="pre">i</span></code> of an element of <code class="docutils literal"><span class="pre">A</span></code> equal to <code class="docutils literal"><span class="pre">v</span></code> (using <code class="docutils literal"><span class="pre">==</span></code>), or <code class="docutils literal"><span class="pre">0</span></code> if not found.</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="mi">0</span><span class="p">;</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">]</span>
<span class="mi">2</span><span class="n">2</span> <span class="n">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">2</span><span class="p">}:</span>
 <span class="mi">0</span>  <span class="mi">0</span>
 <span class="mi">1</span>  <span class="mi">2</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">findprev</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="mi">2</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">findprev</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="mi">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="Base.permutedims">
<code class="descname">permutedims</code><span class="sig-paren">(</span><em>A</em>, <em>perm</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.permutedims" title="Permalink to this definition"></a></dt>
<dd><p>Permute the dimensions of array <code class="docutils literal"><span class="pre">A</span></code>. <code class="docutils literal"><span class="pre">perm</span></code> is a vector specifying a permutation of length <code class="docutils literal"><span class="pre">ndims(A)</span></code>. This is a generalization of transpose for multi-dimensional arrays. Transpose is equivalent to <code class="docutils literal"><span class="pre">permutedims(A,</span> <span class="pre">[2,1])</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.ipermutedims">
<code class="descname">ipermutedims</code><span class="sig-paren">(</span><em>A</em>, <em>perm</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.ipermutedims" title="Permalink to this definition"></a></dt>
<dd><p>Like <a class="reference internal" href="#Base.permutedims" title="Base.permutedims"><code class="xref jl jl-func docutils literal"><span class="pre">permutedims()</span></code></a>, except the inverse of the given permutation is applied.</p>
</dd></dl>

<dl class="function">
<dt id="Base.permutedims!">
<code class="descname">permutedims!</code><span class="sig-paren">(</span><em>dest</em>, <em>src</em>, <em>perm</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.permutedims!" title="Permalink to this definition"></a></dt>
<dd><p>Permute the dimensions of array <code class="docutils literal"><span class="pre">src</span></code> and store the result in the array <code class="docutils literal"><span class="pre">dest</span></code>. <code class="docutils literal"><span class="pre">perm</span></code> is a vector specifying a permutation of length <code class="docutils literal"><span class="pre">ndims(src)</span></code>. The preallocated array <code class="docutils literal"><span class="pre">dest</span></code> should have <code class="docutils literal"><span class="pre">size(dest)</span> <span class="pre">==</span> <span class="pre">size(src)[perm]</span></code> and is completely overwritten. No in-place permutation is supported and unexpected results will happen if <code class="docutils literal"><span class="pre">src</span></code> and <code class="docutils literal"><span class="pre">dest</span></code> have overlapping memory regions.</p>
</dd></dl>

<dl class="function">
<dt id="Base.squeeze">
<code class="descname">squeeze</code><span class="sig-paren">(</span><em>A</em>, <em>dims</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.squeeze" title="Permalink to this definition"></a></dt>
<dd><p>Remove the dimensions specified by <code class="docutils literal"><span class="pre">dims</span></code> from array <code class="docutils literal"><span class="pre">A</span></code>. Elements of <code class="docutils literal"><span class="pre">dims</span></code> must be unique and within the range <code class="docutils literal"><span class="pre">1:ndims(A)</span></code>. <code class="docutils literal"><span class="pre">size(A,i)</span></code> must equal 1 for all <code class="docutils literal"><span class="pre">i</span></code> in <code class="docutils literal"><span class="pre">dims</span></code>.</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">reshape</span><span class="p">(</span><span class="n">collect</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="mi">2</span><span class="n">211</span> <span class="n">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">4</span><span class="p">}:</span>
<span class="p">[:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span>
 <span class="mi">1</span>  <span class="mi">3</span>
 <span class="mi">2</span>  <span class="mi">4</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">squeeze</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="mi">2</span><span class="n">21</span> <span class="n">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">3</span><span class="p">}:</span>
<span class="p">[:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span>
 <span class="mi">1</span>  <span class="mi">3</span>
 <span class="mi">2</span>  <span class="mi">4</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="Base.vec">
<code class="descname">vec</code><span class="sig-paren">(</span><em>a::AbstractArray</em><span class="sig-paren">)</span> &rarr; Vector<a class="headerlink" href="#Base.vec" title="Permalink to this definition"></a></dt>
<dd><p>Reshape array <code class="docutils literal"><span class="pre">a</span></code> as a one-dimensional column vector.</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">;</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span><span class="p">]</span>
<span class="mi">2</span><span class="n">3</span> <span class="n">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">2</span><span class="p">}:</span>
 <span class="mi">1</span>  <span class="mi">2</span>  <span class="mi">3</span>
 <span class="mi">4</span>  <span class="mi">5</span>  <span class="mi">6</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="mi">6</span><span class="o">-</span><span class="n">element</span> <span class="n">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">1</span><span class="p">}:</span>
 <span class="mi">1</span>
 <span class="mi">4</span>
 <span class="mi">2</span>
 <span class="mi">5</span>
 <span class="mi">3</span>
 <span class="mi">6</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="Base.promote_shape">
<code class="descname">promote_shape</code><span class="sig-paren">(</span><em>s1</em>, <em>s2</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.promote_shape" title="Permalink to this definition"></a></dt>
<dd><p>Check two array shapes for compatibility, allowing trailing singleton dimensions, and return whichever shape has more dimensions.</p>
</dd></dl>

<dl class="function">
<dt id="Base.checkbounds">
<code class="descname">checkbounds</code><span class="sig-paren">(</span><em>A</em>, <em>I...</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.checkbounds" title="Permalink to this definition"></a></dt>
<dd><p>Throw an error if the specified indices <code class="docutils literal"><span class="pre">I</span></code> are not in bounds for the given array <code class="docutils literal"><span class="pre">A</span></code>.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">checkbounds</code><span class="sig-paren">(</span><em>Bool</em>, <em>A</em>, <em>I...</em><span class="sig-paren">)</span></dt>
<dd><p>Return <code class="docutils literal"><span class="pre">true</span></code> if the specified indices <code class="docutils literal"><span class="pre">I</span></code> are in bounds for the given array <code class="docutils literal"><span class="pre">A</span></code>. Subtypes of <code class="docutils literal"><span class="pre">AbstractArray</span></code> should specialize this method if they need to provide custom bounds checking behaviors; however, in many cases one can rely on <code class="docutils literal"><span class="pre">A</span></code>&#8216;s indices and <code class="docutils literal"><span class="pre">checkindex</span></code>.</p>
<p>See also <code class="docutils literal"><span class="pre">checkindex</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.checkindex">
<code class="descname">checkindex</code><span class="sig-paren">(</span><em>Bool</em>, <em>inds::AbstractUnitRange</em>, <em>index</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.checkindex" title="Permalink to this definition"></a></dt>
<dd><p>Return <code class="docutils literal"><span class="pre">true</span></code> if the given <code class="docutils literal"><span class="pre">index</span></code> is within the bounds of <code class="docutils literal"><span class="pre">inds</span></code>. Custom types that would like to behave as indices for all arrays can extend this method in order to provide a specialized bounds checking implementation.</p>
</dd></dl>

<dl class="function">
<dt id="Base.randsubseq">
<code class="descname">randsubseq</code><span class="sig-paren">(</span><em>A</em>, <em>p</em><span class="sig-paren">)</span> &rarr; Vector<a class="headerlink" href="#Base.randsubseq" title="Permalink to this definition"></a></dt>
<dd><p>Return a vector consisting of a random subsequence of the given array <code class="docutils literal"><span class="pre">A</span></code>, where each element of <code class="docutils literal"><span class="pre">A</span></code> is included (in order) with independent probability <code class="docutils literal"><span class="pre">p</span></code>. (Complexity is linear in <code class="docutils literal"><span class="pre">p*length(A)</span></code>, so this function is efficient even if <code class="docutils literal"><span class="pre">p</span></code> is small and <code class="docutils literal"><span class="pre">A</span></code> is large.) Technically, this process is known as &#8220;Bernoulli sampling&#8221; of <code class="docutils literal"><span class="pre">A</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.randsubseq!">
<code class="descname">randsubseq!</code><span class="sig-paren">(</span><em>S</em>, <em>A</em>, <em>p</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.randsubseq!" title="Permalink to this definition"></a></dt>
<dd><p>Like <code class="docutils literal"><span class="pre">randsubseq</span></code>, but the results are stored in <code class="docutils literal"><span class="pre">S</span></code> (which is resized as needed).</p>
</dd></dl>

</div>
<div class="section" id="array-functions">
<h2>Array functions<a class="headerlink" href="#array-functions" title="Permalink to this headline"></a></h2>
<dl class="function">
<dt id="Base.cumprod">
<code class="descname">cumprod</code><span class="sig-paren">(</span><em>A</em>, <em>dim=1</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.cumprod" title="Permalink to this definition"></a></dt>
<dd><p>Cumulative product along a dimension <code class="docutils literal"><span class="pre">dim</span></code> (defaults to 1). See also <a class="reference internal" href="#Base.cumprod!" title="Base.cumprod!"><code class="xref jl jl-func docutils literal"><span class="pre">cumprod!()</span></code></a> to use a preallocated output array, both for performance and to control the precision of the output (e.g. to avoid overflow).</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">;</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span><span class="p">]</span>
<span class="mi">2</span><span class="n">3</span> <span class="n">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">2</span><span class="p">}:</span>
 <span class="mi">1</span>  <span class="mi">2</span>  <span class="mi">3</span>
 <span class="mi">4</span>  <span class="mi">5</span>  <span class="mi">6</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">cumprod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="mi">2</span><span class="n">3</span> <span class="n">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">2</span><span class="p">}:</span>
 <span class="mi">1</span>   <span class="mi">2</span>   <span class="mi">3</span>
 <span class="mi">4</span>  <span class="mi">10</span>  <span class="mi">18</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">cumprod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="mi">2</span><span class="n">3</span> <span class="n">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">2</span><span class="p">}:</span>
 <span class="mi">1</span>   <span class="mi">2</span>    <span class="mi">6</span>
 <span class="mi">4</span>  <span class="mi">20</span>  <span class="mi">120</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="Base.cumprod!">
<code class="descname">cumprod!</code><span class="sig-paren">(</span><em>B</em>, <em>A</em><span class="optional">[</span>, <em>dim</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#Base.cumprod!" title="Permalink to this definition"></a></dt>
<dd><p>Cumulative product of <code class="docutils literal"><span class="pre">A</span></code> along a dimension, storing the result in <code class="docutils literal"><span class="pre">B</span></code>. The dimension defaults to 1.</p>
</dd></dl>

<dl class="function">
<dt id="Base.cumsum">
<code class="descname">cumsum</code><span class="sig-paren">(</span><em>A</em>, <em>dim=1</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.cumsum" title="Permalink to this definition"></a></dt>
<dd><p>Cumulative sum along a dimension <code class="docutils literal"><span class="pre">dim</span></code> (defaults to 1). See also <a class="reference internal" href="#Base.cumsum!" title="Base.cumsum!"><code class="xref jl jl-func docutils literal"><span class="pre">cumsum!()</span></code></a> to use a preallocated output array, both for performance and to control the precision of the output (e.g. to avoid overflow).</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">;</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span><span class="p">]</span>
<span class="mi">2</span><span class="n">3</span> <span class="n">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">2</span><span class="p">}:</span>
 <span class="mi">1</span>  <span class="mi">2</span>  <span class="mi">3</span>
 <span class="mi">4</span>  <span class="mi">5</span>  <span class="mi">6</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">cumsum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="mi">2</span><span class="n">3</span> <span class="n">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">2</span><span class="p">}:</span>
 <span class="mi">1</span>  <span class="mi">2</span>  <span class="mi">3</span>
 <span class="mi">5</span>  <span class="mi">7</span>  <span class="mi">9</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">cumsum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="mi">2</span><span class="n">3</span> <span class="n">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">2</span><span class="p">}:</span>
 <span class="mi">1</span>  <span class="mi">3</span>   <span class="mi">6</span>
 <span class="mi">4</span>  <span class="mi">9</span>  <span class="mi">15</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="Base.cumsum!">
<code class="descname">cumsum!</code><span class="sig-paren">(</span><em>B</em>, <em>A</em><span class="optional">[</span>, <em>dim</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#Base.cumsum!" title="Permalink to this definition"></a></dt>
<dd><p>Cumulative sum of <code class="docutils literal"><span class="pre">A</span></code> along a dimension, storing the result in <code class="docutils literal"><span class="pre">B</span></code>. The dimension defaults to 1.</p>
</dd></dl>

<dl class="function">
<dt id="Base.cumsum_kbn">
<code class="descname">cumsum_kbn</code><span class="sig-paren">(</span><em>A</em><span class="optional">[</span>, <em>dim</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#Base.cumsum_kbn" title="Permalink to this definition"></a></dt>
<dd><p>Cumulative sum along a dimension, using the Kahan-Babuska-Neumaier compensated summation algorithm for additional accuracy. The dimension defaults to 1.</p>
</dd></dl>

<dl class="function">
<dt id="Base.cummin">
<code class="descname">cummin</code><span class="sig-paren">(</span><em>A</em><span class="optional">[</span>, <em>dim</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#Base.cummin" title="Permalink to this definition"></a></dt>
<dd><p>Cumulative minimum along a dimension. The dimension defaults to 1.</p>
</dd></dl>

<dl class="function">
<dt id="Base.cummax">
<code class="descname">cummax</code><span class="sig-paren">(</span><em>A</em><span class="optional">[</span>, <em>dim</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#Base.cummax" title="Permalink to this definition"></a></dt>
<dd><p>Cumulative maximum along a dimension. The dimension defaults to 1.</p>
</dd></dl>

<dl class="function">
<dt id="Base.diff">
<code class="descname">diff</code><span class="sig-paren">(</span><em>A</em><span class="optional">[</span>, <em>dim</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#Base.diff" title="Permalink to this definition"></a></dt>
<dd><p>Finite difference operator of matrix or vector.</p>
</dd></dl>

<dl class="function">
<dt id="Base.gradient">
<code class="descname">gradient</code><span class="sig-paren">(</span><em>F</em><span class="optional">[</span>, <em>h</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#Base.gradient" title="Permalink to this definition"></a></dt>
<dd><p>Compute differences along vector <code class="docutils literal"><span class="pre">F</span></code>, using <code class="docutils literal"><span class="pre">h</span></code> as the spacing between points. The default spacing is one.</p>
</dd></dl>

<dl class="function">
<dt id="Base.rot180">
<code class="descname">rot180</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.rot180" title="Permalink to this definition"></a></dt>
<dd><p>Rotate matrix <code class="docutils literal"><span class="pre">A</span></code> 180 degrees.</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span><span class="p">;</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">]</span>
<span class="mi">2</span><span class="n">2</span> <span class="n">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">2</span><span class="p">}:</span>
 <span class="mi">1</span>  <span class="mi">2</span>
 <span class="mi">3</span>  <span class="mi">4</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">rot180</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="mi">2</span><span class="n">2</span> <span class="n">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">2</span><span class="p">}:</span>
 <span class="mi">4</span>  <span class="mi">3</span>
 <span class="mi">2</span>  <span class="mi">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">rot180</code><span class="sig-paren">(</span><em>A</em>, <em>k</em><span class="sig-paren">)</span></dt>
<dd><p>Rotate matrix <code class="docutils literal"><span class="pre">A</span></code> 180 degrees an integer <code class="docutils literal"><span class="pre">k</span></code> number of times. If <code class="docutils literal"><span class="pre">k</span></code> is even, this is equivalent to a <code class="docutils literal"><span class="pre">copy</span></code>.</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span><span class="p">;</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">]</span>
<span class="mi">2</span><span class="n">2</span> <span class="n">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">2</span><span class="p">}:</span>
 <span class="mi">1</span>  <span class="mi">2</span>
 <span class="mi">3</span>  <span class="mi">4</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">rot180</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="mi">2</span><span class="n">2</span> <span class="n">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">2</span><span class="p">}:</span>
 <span class="mi">4</span>  <span class="mi">3</span>
 <span class="mi">2</span>  <span class="mi">1</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">rot180</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="mi">2</span><span class="n">2</span> <span class="n">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">2</span><span class="p">}:</span>
 <span class="mi">1</span>  <span class="mi">2</span>
 <span class="mi">3</span>  <span class="mi">4</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="Base.rotl90">
<code class="descname">rotl90</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.rotl90" title="Permalink to this definition"></a></dt>
<dd><p>Rotate matrix <code class="docutils literal"><span class="pre">A</span></code> left 90 degrees.</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span><span class="p">;</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">]</span>
<span class="mi">2</span><span class="n">2</span> <span class="n">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">2</span><span class="p">}:</span>
 <span class="mi">1</span>  <span class="mi">2</span>
 <span class="mi">3</span>  <span class="mi">4</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">rotl90</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="mi">2</span><span class="n">2</span> <span class="n">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">2</span><span class="p">}:</span>
 <span class="mi">2</span>  <span class="mi">4</span>
 <span class="mi">1</span>  <span class="mi">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">rotl90</code><span class="sig-paren">(</span><em>A</em>, <em>k</em><span class="sig-paren">)</span></dt>
<dd><p>Rotate matrix <code class="docutils literal"><span class="pre">A</span></code> left 90 degrees an integer <code class="docutils literal"><span class="pre">k</span></code> number of times. If <code class="docutils literal"><span class="pre">k</span></code> is zero or a multiple of four, this is equivalent to a <code class="docutils literal"><span class="pre">copy</span></code>.</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span><span class="p">;</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">]</span>
<span class="mi">2</span><span class="n">2</span> <span class="n">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">2</span><span class="p">}:</span>
 <span class="mi">1</span>  <span class="mi">2</span>
 <span class="mi">3</span>  <span class="mi">4</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">rotl90</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="mi">2</span><span class="n">2</span> <span class="n">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">2</span><span class="p">}:</span>
 <span class="mi">2</span>  <span class="mi">4</span>
 <span class="mi">1</span>  <span class="mi">3</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">rotl90</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="mi">2</span><span class="n">2</span> <span class="n">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">2</span><span class="p">}:</span>
 <span class="mi">4</span>  <span class="mi">3</span>
 <span class="mi">2</span>  <span class="mi">1</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">rotl90</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="mi">2</span><span class="n">2</span> <span class="n">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">2</span><span class="p">}:</span>
 <span class="mi">3</span>  <span class="mi">1</span>
 <span class="mi">4</span>  <span class="mi">2</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">rotl90</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="mi">2</span><span class="n">2</span> <span class="n">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">2</span><span class="p">}:</span>
 <span class="mi">1</span>  <span class="mi">2</span>
 <span class="mi">3</span>  <span class="mi">4</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="Base.rotr90">
<code class="descname">rotr90</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.rotr90" title="Permalink to this definition"></a></dt>
<dd><p>Rotate matrix <code class="docutils literal"><span class="pre">A</span></code> right 90 degrees.</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span><span class="p">;</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">]</span>
<span class="mi">2</span><span class="n">2</span> <span class="n">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">2</span><span class="p">}:</span>
 <span class="mi">1</span>  <span class="mi">2</span>
 <span class="mi">3</span>  <span class="mi">4</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">rotr90</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="mi">2</span><span class="n">2</span> <span class="n">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">2</span><span class="p">}:</span>
 <span class="mi">3</span>  <span class="mi">1</span>
 <span class="mi">4</span>  <span class="mi">2</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">rotr90</code><span class="sig-paren">(</span><em>A</em>, <em>k</em><span class="sig-paren">)</span></dt>
<dd><p>Rotate matrix <code class="docutils literal"><span class="pre">A</span></code> right 90 degrees an integer <code class="docutils literal"><span class="pre">k</span></code> number of times. If <code class="docutils literal"><span class="pre">k</span></code> is zero or a multiple of four, this is equivalent to a <code class="docutils literal"><span class="pre">copy</span></code>.</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span><span class="p">;</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">]</span>
<span class="mi">2</span><span class="n">2</span> <span class="n">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">2</span><span class="p">}:</span>
 <span class="mi">1</span>  <span class="mi">2</span>
 <span class="mi">3</span>  <span class="mi">4</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">rotr90</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="mi">2</span><span class="n">2</span> <span class="n">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">2</span><span class="p">}:</span>
 <span class="mi">3</span>  <span class="mi">1</span>
 <span class="mi">4</span>  <span class="mi">2</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">rotr90</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="mi">2</span><span class="n">2</span> <span class="n">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">2</span><span class="p">}:</span>
 <span class="mi">4</span>  <span class="mi">3</span>
 <span class="mi">2</span>  <span class="mi">1</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">rotr90</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="mi">2</span><span class="n">2</span> <span class="n">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">2</span><span class="p">}:</span>
 <span class="mi">2</span>  <span class="mi">4</span>
 <span class="mi">1</span>  <span class="mi">3</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">rotr90</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="mi">2</span><span class="n">2</span> <span class="n">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">2</span><span class="p">}:</span>
 <span class="mi">1</span>  <span class="mi">2</span>
 <span class="mi">3</span>  <span class="mi">4</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="Base.reducedim">
<code class="descname">reducedim</code><span class="sig-paren">(</span><em>f</em>, <em>A</em>, <em>region</em><span class="optional">[</span>, <em>v0</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#Base.reducedim" title="Permalink to this definition"></a></dt>
<dd><p>Reduce 2-argument function <code class="docutils literal"><span class="pre">f</span></code> along dimensions of <code class="docutils literal"><span class="pre">A</span></code>. <code class="docutils literal"><span class="pre">region</span></code> is a vector specifying the dimensions to reduce, and <code class="docutils literal"><span class="pre">v0</span></code> is the initial value to use in the reductions. For <code class="docutils literal"><span class="pre">+</span></code>, <code class="docutils literal"><span class="pre">*</span></code>, <code class="docutils literal"><span class="pre">max</span></code> and <code class="docutils literal"><span class="pre">min</span></code> the <code class="docutils literal"><span class="pre">v0</span></code> argument is optional.</p>
<p>The associativity of the reduction is implementation-dependent; if you need a particular associativity, e.g. left-to-right, you should write your own loop. See documentation for <a class="reference internal" href="../collections/#Base.reduce" title="Base.reduce"><code class="xref jl jl-func docutils literal"><span class="pre">reduce()</span></code></a>.</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">reshape</span><span class="p">(</span><span class="n">collect</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="mi">16</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="mi">4</span><span class="n">4</span> <span class="n">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">2</span><span class="p">}:</span>
 <span class="mi">1</span>  <span class="mi">5</span>   <span class="mi">9</span>  <span class="mi">13</span>
 <span class="mi">2</span>  <span class="mi">6</span>  <span class="mi">10</span>  <span class="mi">14</span>
 <span class="mi">3</span>  <span class="mi">7</span>  <span class="mi">11</span>  <span class="mi">15</span>
 <span class="mi">4</span>  <span class="mi">8</span>  <span class="mi">12</span>  <span class="mi">16</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">reducedim</span><span class="p">(</span><span class="n">max</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="mi">4</span><span class="n">1</span> <span class="n">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">2</span><span class="p">}:</span>
 <span class="mi">13</span>
 <span class="mi">14</span>
 <span class="mi">15</span>
 <span class="mi">16</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">reducedim</span><span class="p">(</span><span class="n">max</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="mi">1</span><span class="n">4</span> <span class="n">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">2</span><span class="p">}:</span>
 <span class="mi">4</span>  <span class="mi">8</span>  <span class="mi">12</span>  <span class="mi">16</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="Base.mapreducedim">
<code class="descname">mapreducedim</code><span class="sig-paren">(</span><em>f</em>, <em>op</em>, <em>A</em>, <em>region</em><span class="optional">[</span>, <em>v0</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#Base.mapreducedim" title="Permalink to this definition"></a></dt>
<dd><p>Evaluates to the same as <code class="docutils literal"><span class="pre">reducedim(op,</span> <span class="pre">map(f,</span> <span class="pre">A),</span> <span class="pre">region,</span> <span class="pre">f(v0))</span></code>, but is generally faster because the intermediate array is avoided.</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">reshape</span><span class="p">(</span><span class="n">collect</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="mi">16</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="mi">4</span><span class="n">4</span> <span class="n">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">2</span><span class="p">}:</span>
 <span class="mi">1</span>  <span class="mi">5</span>   <span class="mi">9</span>  <span class="mi">13</span>
 <span class="mi">2</span>  <span class="mi">6</span>  <span class="mi">10</span>  <span class="mi">14</span>
 <span class="mi">3</span>  <span class="mi">7</span>  <span class="mi">11</span>  <span class="mi">15</span>
 <span class="mi">4</span>  <span class="mi">8</span>  <span class="mi">12</span>  <span class="mi">16</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">mapreducedim</span><span class="p">(</span><span class="n">isodd</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="mi">1</span><span class="n">4</span> <span class="n">Array</span><span class="p">{</span><span class="kt">Bool</span><span class="p">,</span><span class="mi">2</span><span class="p">}:</span>
 <span class="n">false</span>  <span class="n">false</span>  <span class="n">false</span>  <span class="n">false</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">mapreducedim</span><span class="p">(</span><span class="n">isodd</span><span class="p">,</span> <span class="o">|</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">true</span><span class="p">)</span>
<span class="mi">1</span><span class="n">4</span> <span class="n">Array</span><span class="p">{</span><span class="kt">Bool</span><span class="p">,</span><span class="mi">2</span><span class="p">}:</span>
 <span class="n">true</span>  <span class="n">true</span>  <span class="n">true</span>  <span class="n">true</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="Base.mapslices">
<code class="descname">mapslices</code><span class="sig-paren">(</span><em>f</em>, <em>A</em>, <em>dims</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.mapslices" title="Permalink to this definition"></a></dt>
<dd><p>Transform the given dimensions of array <code class="docutils literal"><span class="pre">A</span></code> using function <code class="docutils literal"><span class="pre">f</span></code>. <code class="docutils literal"><span class="pre">f</span></code> is called on each slice of <code class="docutils literal"><span class="pre">A</span></code> of the form <code class="docutils literal"><span class="pre">A[...,:,...,:,...]</span></code>. <code class="docutils literal"><span class="pre">dims</span></code> is an integer vector specifying where the colons go in this expression. The results are concatenated along the remaining dimensions. For example, if <code class="docutils literal"><span class="pre">dims</span></code> is <code class="docutils literal"><span class="pre">[1,2]</span></code> and <code class="docutils literal"><span class="pre">A</span></code> is 4-dimensional, <code class="docutils literal"><span class="pre">f</span></code> is called on <code class="docutils literal"><span class="pre">A[:,:,i,j]</span></code> for all <code class="docutils literal"><span class="pre">i</span></code> and <code class="docutils literal"><span class="pre">j</span></code>.</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">reshape</span><span class="p">(</span><span class="n">collect</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="mi">16</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="mi">2</span><span class="n">222</span> <span class="n">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">4</span><span class="p">}:</span>
<span class="p">[:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span>
 <span class="mi">1</span>  <span class="mi">3</span>
 <span class="mi">2</span>  <span class="mi">4</span>

<span class="p">[:,</span> <span class="p">:,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span>
 <span class="mi">5</span>  <span class="mi">7</span>
 <span class="mi">6</span>  <span class="mi">8</span>

<span class="p">[:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span>
  <span class="mi">9</span>  <span class="mi">11</span>
 <span class="mi">10</span>  <span class="mi">12</span>

<span class="p">[:,</span> <span class="p">:,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span>
 <span class="mi">13</span>  <span class="mi">15</span>
 <span class="mi">14</span>  <span class="mi">16</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">mapslices</span><span class="p">(</span><span class="n">sum</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="mi">1</span><span class="n">122</span> <span class="n">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">4</span><span class="p">}:</span>
<span class="p">[:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span>
 <span class="mi">10</span>

<span class="p">[:,</span> <span class="p">:,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span>
 <span class="mi">26</span>

<span class="p">[:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span>
 <span class="mi">42</span>

<span class="p">[:,</span> <span class="p">:,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span>
 <span class="mi">58</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="Base.sum_kbn">
<code class="descname">sum_kbn</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.sum_kbn" title="Permalink to this definition"></a></dt>
<dd><p>Returns the sum of all array elements, using the Kahan-Babuska-Neumaier compensated summation algorithm for additional accuracy.</p>
</dd></dl>

</div>
<div class="section" id="combinatorics">
<h2>Combinatorics<a class="headerlink" href="#combinatorics" title="Permalink to this headline"></a></h2>
<dl class="function">
<dt id="Base.randperm">
<code class="descname">randperm</code><span class="sig-paren">(</span><span class="optional">[</span><em>rng</em>, <span class="optional">]</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.randperm" title="Permalink to this definition"></a></dt>
<dd><p>Construct a random permutation of length <code class="docutils literal"><span class="pre">n</span></code>. The optional <code class="docutils literal"><span class="pre">rng</span></code> argument specifies a random number generator (see <a class="reference internal" href="../numbers/#random-numbers"><span>Random Numbers</span></a>). To randomly permute a arbitrary vector, see <a class="reference internal" href="#Base.shuffle" title="Base.shuffle"><code class="xref jl jl-func docutils literal"><span class="pre">shuffle()</span></code></a> or <a class="reference internal" href="#Base.shuffle!" title="Base.shuffle!"><code class="xref jl jl-func docutils literal"><span class="pre">shuffle!()</span></code></a>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.invperm">
<code class="descname">invperm</code><span class="sig-paren">(</span><em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.invperm" title="Permalink to this definition"></a></dt>
<dd><p>Return the inverse permutation of <code class="docutils literal"><span class="pre">v</span></code></p>
</dd></dl>

<dl class="function">
<dt id="Base.isperm">
<code class="descname">isperm</code><span class="sig-paren">(</span><em>v</em><span class="sig-paren">)</span> &rarr; Bool<a class="headerlink" href="#Base.isperm" title="Permalink to this definition"></a></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">true</span></code> if <code class="docutils literal"><span class="pre">v</span></code> is a valid permutation.</p>
</dd></dl>

<dl class="function">
<dt id="Base.permute!">
<code class="descname">permute!</code><span class="sig-paren">(</span><em>v</em>, <em>p</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.permute!" title="Permalink to this definition"></a></dt>
<dd><p>Permute vector <code class="docutils literal"><span class="pre">v</span></code> in-place, according to permutation <code class="docutils literal"><span class="pre">p</span></code>. No checking is done to verify that <code class="docutils literal"><span class="pre">p</span></code> is a permutation.</p>
<p>To return a new permutation, use <code class="docutils literal"><span class="pre">v[p]</span></code>. Note that this is generally faster than <code class="docutils literal"><span class="pre">permute!(v,p)</span></code> for large vectors.</p>
</dd></dl>

<dl class="function">
<dt id="Base.ipermute!">
<code class="descname">ipermute!</code><span class="sig-paren">(</span><em>v</em>, <em>p</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.ipermute!" title="Permalink to this definition"></a></dt>
<dd><p>Like <code class="docutils literal"><span class="pre">permute!</span></code>, but the inverse of the given permutation is applied.</p>
</dd></dl>

<dl class="function">
<dt id="Base.randcycle">
<code class="descname">randcycle</code><span class="sig-paren">(</span><span class="optional">[</span><em>rng</em>, <span class="optional">]</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.randcycle" title="Permalink to this definition"></a></dt>
<dd><p>Construct a random cyclic permutation of length <code class="docutils literal"><span class="pre">n</span></code>. The optional <code class="docutils literal"><span class="pre">rng</span></code> argument specifies a random number generator, see <a class="reference internal" href="../numbers/#random-numbers"><span>Random Numbers</span></a>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.shuffle">
<code class="descname">shuffle</code><span class="sig-paren">(</span><span class="optional">[</span><em>rng</em>, <span class="optional">]</span><em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.shuffle" title="Permalink to this definition"></a></dt>
<dd><p>Return a randomly permuted copy of <code class="docutils literal"><span class="pre">v</span></code>. The optional <code class="docutils literal"><span class="pre">rng</span></code> argument specifies a random number generator (see <a class="reference internal" href="../numbers/#random-numbers"><span>Random Numbers</span></a>). To permute <code class="docutils literal"><span class="pre">v</span></code> in-place, see <a class="reference internal" href="#Base.shuffle!" title="Base.shuffle!"><code class="xref jl jl-func docutils literal"><span class="pre">shuffle!()</span></code></a>.  To obtain randomly permuted indices, see <a class="reference internal" href="#Base.randperm" title="Base.randperm"><code class="xref jl jl-func docutils literal"><span class="pre">randperm()</span></code></a>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.shuffle!">
<code class="descname">shuffle!</code><span class="sig-paren">(</span><span class="optional">[</span><em>rng</em>, <span class="optional">]</span><em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.shuffle!" title="Permalink to this definition"></a></dt>
<dd><p>In-place version of <a class="reference internal" href="#Base.shuffle" title="Base.shuffle"><code class="xref jl jl-func docutils literal"><span class="pre">shuffle()</span></code></a>: randomly permute the array <code class="docutils literal"><span class="pre">v</span></code> in-place, optionally supplying the random-number generator <code class="docutils literal"><span class="pre">rng</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.reverse">
<code class="descname">reverse</code><span class="sig-paren">(</span><em>v</em><span class="optional">[</span>, <em>start=1</em><span class="optional">[</span>, <em>stop=length(v)</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#Base.reverse" title="Permalink to this definition"></a></dt>
<dd><p>Return a copy of <code class="docutils literal"><span class="pre">v</span></code> reversed from start to stop.</p>
</dd></dl>

<dl class="function">
<dt id="Base.reverseind">
<code class="descname">reverseind</code><span class="sig-paren">(</span><em>v</em>, <em>i</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.reverseind" title="Permalink to this definition"></a></dt>
<dd><p>Given an index <code class="docutils literal"><span class="pre">i</span></code> in <code class="docutils literal"><span class="pre">reverse(v)</span></code>, return the corresponding index in <code class="docutils literal"><span class="pre">v</span></code> so that <code class="docutils literal"><span class="pre">v[reverseind(v,i)]</span> <span class="pre">==</span> <span class="pre">reverse(v)[i]</span></code>. (This can be nontrivial in the case where <code class="docutils literal"><span class="pre">v</span></code> is a Unicode string.)</p>
</dd></dl>

<dl class="function">
<dt id="Base.reverse!">
<code class="descname">reverse!</code><span class="sig-paren">(</span><em>v</em><span class="optional">[</span>, <em>start=1</em><span class="optional">[</span>, <em>stop=length(v)</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> &rarr; v<a class="headerlink" href="#Base.reverse!" title="Permalink to this definition"></a></dt>
<dd><p>In-place version of <a class="reference internal" href="../strings/#Base.reverse" title="Base.reverse"><code class="xref jl jl-func docutils literal"><span class="pre">reverse()</span></code></a>.</p>
</dd></dl>

</div>
<div class="section" id="bitarrays">
<h2>BitArrays<a class="headerlink" href="#bitarrays" title="Permalink to this headline"></a></h2>
<p>BitArrays are space-efficient &#8220;packed&#8221; boolean arrays, which store
one bit per boolean value.  They can be used similarly to <code class="docutils literal"><span class="pre">Array{Bool}</span></code>
arrays (which store one byte per boolean value), and can be converted
to/from the latter via <code class="docutils literal"><span class="pre">Array(bitarray)</span></code> and <code class="docutils literal"><span class="pre">BitArray(array)</span></code>, respectively.</p>
<dl class="function">
<dt id="Base.flipbits!">
<code class="descname">flipbits!</code><span class="sig-paren">(</span><em>B::BitArray{N}</em><span class="sig-paren">)</span> &rarr; BitArray{N}<a class="headerlink" href="#Base.flipbits!" title="Permalink to this definition"></a></dt>
<dd><p>Performs a bitwise not operation on <code class="docutils literal"><span class="pre">B</span></code>. See <a class="reference internal" href="../math/#id33"><span>~ operator</span></a>.</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="n">trues</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="mi">2</span><span class="n">2</span> <span class="n">BitArray</span><span class="p">{</span><span class="mi">2</span><span class="p">}:</span>
 <span class="n">true</span>  <span class="n">true</span>
 <span class="n">true</span>  <span class="n">true</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">flipbits!</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="mi">2</span><span class="n">2</span> <span class="n">BitArray</span><span class="p">{</span><span class="mi">2</span><span class="p">}:</span>
 <span class="n">false</span>  <span class="n">false</span>
 <span class="n">false</span>  <span class="n">false</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="Base.rol!">
<code class="descname">rol!</code><span class="sig-paren">(</span><em>dest::BitVector</em>, <em>src::BitVector</em>, <em>i::Integer</em><span class="sig-paren">)</span> &rarr; BitVector<a class="headerlink" href="#Base.rol!" title="Permalink to this definition"></a></dt>
<dd><p>Performs a left rotation operation on <code class="docutils literal"><span class="pre">src</span></code> and puts the result into <code class="docutils literal"><span class="pre">dest</span></code>. <code class="docutils literal"><span class="pre">i</span></code> controls how far to rotate the bits.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">rol!</code><span class="sig-paren">(</span><em>B::BitVector</em>, <em>i::Integer</em><span class="sig-paren">)</span> &rarr; BitVector</dt>
<dd><p>Performs a left rotation operation in-place on <code class="docutils literal"><span class="pre">B</span></code>. <code class="docutils literal"><span class="pre">i</span></code> controls how far to rotate the bits.</p>
</dd></dl>

<dl class="function">
<dt id="Base.rol">
<code class="descname">rol</code><span class="sig-paren">(</span><em>B::BitVector</em>, <em>i::Integer</em><span class="sig-paren">)</span> &rarr; BitVector<a class="headerlink" href="#Base.rol" title="Permalink to this definition"></a></dt>
<dd><p>Performs a left rotation operation, returning a new <code class="docutils literal"><span class="pre">BitVector</span></code>. <code class="docutils literal"><span class="pre">i</span></code> controls how far to rotate the bits. See also <a class="reference internal" href="#Base.rol!" title="Base.rol!"><code class="xref jl jl-func docutils literal"><span class="pre">rol!()</span></code></a>.</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="n">BitArray</span><span class="p">([</span><span class="n">true</span><span class="p">,</span> <span class="n">true</span><span class="p">,</span> <span class="n">false</span><span class="p">,</span> <span class="n">false</span><span class="p">,</span> <span class="n">true</span><span class="p">])</span>
<span class="mi">5</span><span class="o">-</span><span class="n">element</span> <span class="n">BitArray</span><span class="p">{</span><span class="mi">1</span><span class="p">}:</span>
  <span class="n">true</span>
  <span class="n">true</span>
 <span class="n">false</span>
 <span class="n">false</span>
  <span class="n">true</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">rol</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="mi">5</span><span class="o">-</span><span class="n">element</span> <span class="n">BitArray</span><span class="p">{</span><span class="mi">1</span><span class="p">}:</span>
  <span class="n">true</span>
 <span class="n">false</span>
 <span class="n">false</span>
  <span class="n">true</span>
  <span class="n">true</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">rol</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="mi">5</span><span class="o">-</span><span class="n">element</span> <span class="n">BitArray</span><span class="p">{</span><span class="mi">1</span><span class="p">}:</span>
 <span class="n">false</span>
 <span class="n">false</span>
  <span class="n">true</span>
  <span class="n">true</span>
  <span class="n">true</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">rol</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
<span class="mi">5</span><span class="o">-</span><span class="n">element</span> <span class="n">BitArray</span><span class="p">{</span><span class="mi">1</span><span class="p">}:</span>
  <span class="n">true</span>
  <span class="n">true</span>
 <span class="n">false</span>
 <span class="n">false</span>
  <span class="n">true</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="Base.ror!">
<code class="descname">ror!</code><span class="sig-paren">(</span><em>dest::BitVector</em>, <em>src::BitVector</em>, <em>i::Integer</em><span class="sig-paren">)</span> &rarr; BitVector<a class="headerlink" href="#Base.ror!" title="Permalink to this definition"></a></dt>
<dd><p>Performs a right rotation operation on <code class="docutils literal"><span class="pre">src</span></code> and puts the result into <code class="docutils literal"><span class="pre">dest</span></code>. <code class="docutils literal"><span class="pre">i</span></code> controls how far to rotate the bits.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">ror!</code><span class="sig-paren">(</span><em>B::BitVector</em>, <em>i::Integer</em><span class="sig-paren">)</span> &rarr; BitVector</dt>
<dd><p>Performs a right rotation operation in-place on <code class="docutils literal"><span class="pre">B</span></code>. <code class="docutils literal"><span class="pre">i</span></code> controls how far to rotate the bits.</p>
</dd></dl>

<dl class="function">
<dt id="Base.ror">
<code class="descname">ror</code><span class="sig-paren">(</span><em>B::BitVector</em>, <em>i::Integer</em><span class="sig-paren">)</span> &rarr; BitVector<a class="headerlink" href="#Base.ror" title="Permalink to this definition"></a></dt>
<dd><p>Performs a right rotation operation on <code class="docutils literal"><span class="pre">B</span></code>, returning a new <code class="docutils literal"><span class="pre">BitVector</span></code>. <code class="docutils literal"><span class="pre">i</span></code> controls how far to rotate the bits. See also <a class="reference internal" href="#Base.ror!" title="Base.ror!"><code class="xref jl jl-func docutils literal"><span class="pre">ror!()</span></code></a>.</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="n">BitArray</span><span class="p">([</span><span class="n">true</span><span class="p">,</span> <span class="n">true</span><span class="p">,</span> <span class="n">false</span><span class="p">,</span> <span class="n">false</span><span class="p">,</span> <span class="n">true</span><span class="p">])</span>
<span class="mi">5</span><span class="o">-</span><span class="n">element</span> <span class="n">BitArray</span><span class="p">{</span><span class="mi">1</span><span class="p">}:</span>
  <span class="n">true</span>
  <span class="n">true</span>
 <span class="n">false</span>
 <span class="n">false</span>
  <span class="n">true</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">ror</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="mi">5</span><span class="o">-</span><span class="n">element</span> <span class="n">BitArray</span><span class="p">{</span><span class="mi">1</span><span class="p">}:</span>
  <span class="n">true</span>
  <span class="n">true</span>
  <span class="n">true</span>
 <span class="n">false</span>
 <span class="n">false</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">ror</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="mi">5</span><span class="o">-</span><span class="n">element</span> <span class="n">BitArray</span><span class="p">{</span><span class="mi">1</span><span class="p">}:</span>
 <span class="n">false</span>
  <span class="n">true</span>
  <span class="n">true</span>
  <span class="n">true</span>
 <span class="n">false</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">ror</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
<span class="mi">5</span><span class="o">-</span><span class="n">element</span> <span class="n">BitArray</span><span class="p">{</span><span class="mi">1</span><span class="p">}:</span>
  <span class="n">true</span>
  <span class="n">true</span>
 <span class="n">false</span>
 <span class="n">false</span>
  <span class="n">true</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="sparse-vectors-and-matrices">
<span id="stdlib-sparse"></span><h2>Sparse Vectors and Matrices<a class="headerlink" href="#sparse-vectors-and-matrices" title="Permalink to this headline"></a></h2>
<p>Sparse vectors and matrices largely support the same set of operations as their
dense counterparts. The following functions are specific to sparse arrays.</p>
<dl class="function">
<dt id="Base.sparse">
<code class="descname">sparse</code><span class="sig-paren">(</span><em>I</em>, <em>J</em>, <em>V</em><span class="optional">[</span>, <em>m</em>, <em>n</em>, <em>combine</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#Base.sparse" title="Permalink to this definition"></a></dt>
<dd><p>Create a sparse matrix <code class="docutils literal"><span class="pre">S</span></code> of dimensions <code class="docutils literal"><span class="pre">m</span> <span class="pre">x</span> <span class="pre">n</span></code> such that <code class="docutils literal"><span class="pre">S[I[k],</span> <span class="pre">J[k]]</span> <span class="pre">=</span> <span class="pre">V[k]</span></code>. The <code class="docutils literal"><span class="pre">combine</span></code> function is used to combine duplicates. If <code class="docutils literal"><span class="pre">m</span></code> and <code class="docutils literal"><span class="pre">n</span></code> are not specified, they are set to <code class="docutils literal"><span class="pre">maximum(I)</span></code> and <code class="docutils literal"><span class="pre">maximum(J)</span></code> respectively. If the <code class="docutils literal"><span class="pre">combine</span></code> function is not supplied, <code class="docutils literal"><span class="pre">combine</span></code> defaults to <code class="docutils literal"><span class="pre">+</span></code> unless the elements of <code class="docutils literal"><span class="pre">V</span></code> are Booleans in which case <code class="docutils literal"><span class="pre">combine</span></code> defaults to <code class="docutils literal"><span class="pre">|</span></code>. All elements of <code class="docutils literal"><span class="pre">I</span></code> must satisfy <code class="docutils literal"><span class="pre">1</span> <span class="pre">&lt;=</span> <span class="pre">I[k]</span> <span class="pre">&lt;=</span> <span class="pre">m</span></code>, and all elements of <code class="docutils literal"><span class="pre">J</span></code> must satisfy <code class="docutils literal"><span class="pre">1</span> <span class="pre">&lt;=</span> <span class="pre">J[k]</span> <span class="pre">&lt;=</span> <span class="pre">n</span></code>. Numerical zeros in (<code class="docutils literal"><span class="pre">I</span></code>, <code class="docutils literal"><span class="pre">J</span></code>, <code class="docutils literal"><span class="pre">V</span></code>) are retained as structural nonzeros; to drop numerical zeros, use <a class="reference internal" href="#Base.dropzeros!" title="Base.dropzeros!"><code class="xref jl jl-func docutils literal"><span class="pre">dropzeros!()</span></code></a>.</p>
<p>For additional documentation and an expert driver, see <code class="docutils literal"><span class="pre">Base.SparseArrays.sparse!</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.sparsevec">
<code class="descname">sparsevec</code><span class="sig-paren">(</span><em>I</em>, <em>V</em><span class="optional">[</span>, <em>m</em>, <em>combine</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#Base.sparsevec" title="Permalink to this definition"></a></dt>
<dd><p>Create a sparse vector <code class="docutils literal"><span class="pre">S</span></code> of length <code class="docutils literal"><span class="pre">m</span></code> such that <code class="docutils literal"><span class="pre">S[I[k]]</span> <span class="pre">=</span> <span class="pre">V[k]</span></code>. Duplicates are combined using the <code class="docutils literal"><span class="pre">combine</span></code> function, which defaults to <code class="docutils literal"><span class="pre">+</span></code> if no <code class="docutils literal"><span class="pre">combine</span></code> argument is provided, unless the elements of <code class="docutils literal"><span class="pre">V</span></code> are Booleans in which case <code class="docutils literal"><span class="pre">combine</span></code> defaults to <code class="docutils literal"><span class="pre">|</span></code>.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">sparsevec</code><span class="sig-paren">(</span><em>D::Dict</em><span class="optional">[</span>, <em>m</em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>Create a sparse vector of length <code class="docutils literal"><span class="pre">m</span></code> where the nonzero indices are keys from the dictionary, and the nonzero values are the values from the dictionary.</p>
</dd></dl>

<dl class="function">
<dt id="Base.issparse">
<code class="descname">issparse</code><span class="sig-paren">(</span><em>S</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.issparse" title="Permalink to this definition"></a></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">true</span></code> if <code class="docutils literal"><span class="pre">S</span></code> is sparse, and <code class="docutils literal"><span class="pre">false</span></code> otherwise.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">sparse</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span></dt>
<dd><p>Convert an AbstractMatrix <code class="docutils literal"><span class="pre">A</span></code> into a sparse matrix.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">sparsevec</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span></dt>
<dd><p>Convert a vector <code class="docutils literal"><span class="pre">A</span></code> into a sparse vector of length <code class="docutils literal"><span class="pre">m</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.full">
<code class="descname">full</code><span class="sig-paren">(</span><em>S</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.full" title="Permalink to this definition"></a></dt>
<dd><p>Convert a sparse matrix or vector <code class="docutils literal"><span class="pre">S</span></code> into a dense matrix or vector.</p>
</dd></dl>

<dl class="function">
<dt id="Base.nnz">
<code class="descname">nnz</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.nnz" title="Permalink to this definition"></a></dt>
<dd><p>Returns the number of stored (filled) elements in a sparse array.</p>
</dd></dl>

<dl class="function">
<dt id="Base.spzeros">
<code class="descname">spzeros</code><span class="sig-paren">(</span><span class="optional">[</span><em>type</em>, <span class="optional">]</span><em>m</em><span class="optional">[</span>, <em>n</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#Base.spzeros" title="Permalink to this definition"></a></dt>
<dd><p>Create a sparse vector of length <code class="docutils literal"><span class="pre">m</span></code> or sparse matrix of size <code class="docutils literal"><span class="pre">m</span> <span class="pre">x</span> <span class="pre">n</span></code>. This sparse array will not contain any nonzero values. No storage will be allocated for nonzero values during construction. The type defaults to <code class="docutils literal"><span class="pre">Float64</span></code> if not specified.</p>
</dd></dl>

<dl class="function">
<dt id="Base.spones">
<code class="descname">spones</code><span class="sig-paren">(</span><em>S</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.spones" title="Permalink to this definition"></a></dt>
<dd><p>Create a sparse array with the same structure as that of <code class="docutils literal"><span class="pre">S</span></code>, but with every nonzero element having the value <code class="docutils literal"><span class="pre">1.0</span></code>.</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="n">sparse</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mf">5.</span><span class="p">,</span><span class="mf">4.</span><span class="p">,</span><span class="mf">3.</span><span class="p">,</span><span class="mf">2.</span><span class="p">])</span>
<span class="mi">4</span><span class="n">4</span> <span class="n">sparse</span> <span class="n">matrix</span> <span class="n">with</span> <span class="mi">4</span> <span class="kt">Float64</span> <span class="n">nonzero</span> <span class="n">entries</span><span class="p">:</span>
        <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>  <span class="o">=</span>  <span class="mf">2.0</span>
        <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>  <span class="o">=</span>  <span class="mf">5.0</span>
        <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>  <span class="o">=</span>  <span class="mf">3.0</span>
        <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>  <span class="o">=</span>  <span class="mf">4.0</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">spones</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="mi">4</span><span class="n">4</span> <span class="n">sparse</span> <span class="n">matrix</span> <span class="n">with</span> <span class="mi">4</span> <span class="kt">Float64</span> <span class="n">nonzero</span> <span class="n">entries</span><span class="p">:</span>
        <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>  <span class="o">=</span>  <span class="mf">1.0</span>
        <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>  <span class="o">=</span>  <span class="mf">1.0</span>
        <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>  <span class="o">=</span>  <span class="mf">1.0</span>
        <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>  <span class="o">=</span>  <span class="mf">1.0</span>
</pre></div>
</div>
<p>Note the difference from <a class="reference internal" href="#Base.speye" title="Base.speye"><code class="xref jl jl-func docutils literal"><span class="pre">speye()</span></code></a>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.speye">
<code class="descname">speye</code><span class="sig-paren">(</span><span class="optional">[</span><em>type</em>, <span class="optional">]</span><em>m</em><span class="optional">[</span>, <em>n</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#Base.speye" title="Permalink to this definition"></a></dt>
<dd><p>Create a sparse identity matrix of size <code class="docutils literal"><span class="pre">m</span> <span class="pre">x</span> <span class="pre">m</span></code>. When <code class="docutils literal"><span class="pre">n</span></code> is supplied, create a sparse identity matrix of size <code class="docutils literal"><span class="pre">m</span> <span class="pre">x</span> <span class="pre">n</span></code>. The type defaults to <code class="docutils literal"><span class="pre">Float64</span></code> if not specified.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">speye</code><span class="sig-paren">(</span><em>S</em><span class="sig-paren">)</span></dt>
<dd><p>Create a sparse identity matrix with the same size as <code class="docutils literal"><span class="pre">S</span></code>.</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="n">sparse</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mf">5.</span><span class="p">,</span><span class="mf">4.</span><span class="p">,</span><span class="mf">3.</span><span class="p">,</span><span class="mf">2.</span><span class="p">])</span>
<span class="mi">4</span><span class="n">4</span> <span class="n">sparse</span> <span class="n">matrix</span> <span class="n">with</span> <span class="mi">4</span> <span class="kt">Float64</span> <span class="n">nonzero</span> <span class="n">entries</span><span class="p">:</span>
        <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>  <span class="o">=</span>  <span class="mf">2.0</span>
        <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>  <span class="o">=</span>  <span class="mf">5.0</span>
        <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>  <span class="o">=</span>  <span class="mf">3.0</span>
        <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>  <span class="o">=</span>  <span class="mf">4.0</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">speye</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="mi">4</span><span class="n">4</span> <span class="n">sparse</span> <span class="n">matrix</span> <span class="n">with</span> <span class="mi">4</span> <span class="kt">Float64</span> <span class="n">nonzero</span> <span class="n">entries</span><span class="p">:</span>
        <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>  <span class="o">=</span>  <span class="mf">1.0</span>
        <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>  <span class="o">=</span>  <span class="mf">1.0</span>
        <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>  <span class="o">=</span>  <span class="mf">1.0</span>
        <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>  <span class="o">=</span>  <span class="mf">1.0</span>
</pre></div>
</div>
<p>Note the difference from <a class="reference internal" href="#Base.spones" title="Base.spones"><code class="xref jl jl-func docutils literal"><span class="pre">spones()</span></code></a>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.spdiagm">
<code class="descname">spdiagm</code><span class="sig-paren">(</span><em>B</em>, <em>d</em><span class="optional">[</span>, <em>m</em>, <em>n</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#Base.spdiagm" title="Permalink to this definition"></a></dt>
<dd><p>Construct a sparse diagonal matrix. <code class="docutils literal"><span class="pre">B</span></code> is a tuple of vectors containing the diagonals and <code class="docutils literal"><span class="pre">d</span></code> is a tuple containing the positions of the diagonals. In the case the input contains only one diagonal, <code class="docutils literal"><span class="pre">B</span></code> can be a vector (instead of a tuple) and <code class="docutils literal"><span class="pre">d</span></code> can be the diagonal position (instead of a tuple), defaulting to 0 (diagonal). Optionally, <code class="docutils literal"><span class="pre">m</span></code> and <code class="docutils literal"><span class="pre">n</span></code> specify the size of the resulting sparse matrix.</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">spdiagm</span><span class="p">(([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]),(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="mi">5</span><span class="n">5</span> <span class="n">sparse</span> <span class="n">matrix</span> <span class="n">with</span> <span class="mi">8</span> <span class="kt">Int64</span> <span class="n">nonzero</span> <span class="n">entries</span><span class="p">:</span>
        <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>  <span class="o">=</span>  <span class="mi">1</span>
        <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>  <span class="o">=</span>  <span class="mi">4</span>
        <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>  <span class="o">=</span>  <span class="mi">2</span>
        <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>  <span class="o">=</span>  <span class="mi">3</span>
        <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>  <span class="o">=</span>  <span class="mi">3</span>
        <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>  <span class="o">=</span>  <span class="mi">2</span>
        <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>  <span class="o">=</span>  <span class="mi">4</span>
        <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>  <span class="o">=</span>  <span class="mi">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="Base.sprand">
<code class="descname">sprand</code><span class="sig-paren">(</span><span class="optional">[</span><em>rng</em>, <span class="optional">]</span><span class="optional">[</span><em>type</em>, <span class="optional">]</span><em>m</em>, <span class="optional">[</span><em>n</em>, <span class="optional">]</span><em>p::AbstractFloat</em><span class="optional">[</span>, <em>rfn</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#Base.sprand" title="Permalink to this definition"></a></dt>
<dd><p>Create a random length <code class="docutils literal"><span class="pre">m</span></code> sparse vector or <code class="docutils literal"><span class="pre">m</span></code> by <code class="docutils literal"><span class="pre">n</span></code> sparse matrix, in which the probability of any element being nonzero is independently given by <code class="docutils literal"><span class="pre">p</span></code> (and hence the mean density of nonzeros is also exactly <code class="docutils literal"><span class="pre">p</span></code>). Nonzero values are sampled from the distribution specified by <code class="docutils literal"><span class="pre">rfn</span></code> and have the type <code class="docutils literal"><span class="pre">type</span></code>. The uniform distribution is used in case <code class="docutils literal"><span class="pre">rfn</span></code> is not specified. The optional <code class="docutils literal"><span class="pre">rng</span></code> argument specifies a random number generator, see <a class="reference internal" href="../numbers/#random-numbers"><span>Random Numbers</span></a>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.sprandn">
<code class="descname">sprandn</code><span class="sig-paren">(</span><span class="optional">[</span><em>rng</em>, <span class="optional">]</span><em>m</em>, <span class="optional">[</span><em>n</em>, <span class="optional">]</span><em>p::AbstractFloat</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.sprandn" title="Permalink to this definition"></a></dt>
<dd><p>Create a random sparse vector of length <code class="docutils literal"><span class="pre">m</span></code> or sparse matrix of size <code class="docutils literal"><span class="pre">m</span></code> by <code class="docutils literal"><span class="pre">n</span></code> with the specified (independent) probability <code class="docutils literal"><span class="pre">p</span></code> of any entry being nonzero, where nonzero values are sampled from the normal distribution. The optional <code class="docutils literal"><span class="pre">rng</span></code> argument specifies a random number generator, see <a class="reference internal" href="../numbers/#random-numbers"><span>Random Numbers</span></a>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.nonzeros">
<code class="descname">nonzeros</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.nonzeros" title="Permalink to this definition"></a></dt>
<dd><p>Return a vector of the structural nonzero values in sparse array <code class="docutils literal"><span class="pre">A</span></code>. This includes zeros that are explicitly stored in the sparse array. The returned vector points directly to the internal nonzero storage of <code class="docutils literal"><span class="pre">A</span></code>, and any modifications to the returned vector will mutate <code class="docutils literal"><span class="pre">A</span></code> as well. See <a class="reference internal" href="#Base.rowvals" title="Base.rowvals"><code class="xref jl jl-func docutils literal"><span class="pre">rowvals()</span></code></a> and <a class="reference internal" href="#Base.nzrange" title="Base.nzrange"><code class="xref jl jl-func docutils literal"><span class="pre">nzrange()</span></code></a>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.rowvals">
<code class="descname">rowvals</code><span class="sig-paren">(</span><em>A::SparseMatrixCSC</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.rowvals" title="Permalink to this definition"></a></dt>
<dd><p>Return a vector of the row indices of <code class="docutils literal"><span class="pre">A</span></code>. Any modifications to the returned vector will mutate <code class="docutils literal"><span class="pre">A</span></code> as well. Providing access to how the row indices are stored internally can be useful in conjunction with iterating over structural nonzero values. See also <a class="reference internal" href="#Base.nonzeros" title="Base.nonzeros"><code class="xref jl jl-func docutils literal"><span class="pre">nonzeros()</span></code></a> and <a class="reference internal" href="#Base.nzrange" title="Base.nzrange"><code class="xref jl jl-func docutils literal"><span class="pre">nzrange()</span></code></a>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.nzrange">
<code class="descname">nzrange</code><span class="sig-paren">(</span><em>A::SparseMatrixCSC</em>, <em>col</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.nzrange" title="Permalink to this definition"></a></dt>
<dd><p>Return the range of indices to the structural nonzero values of a sparse matrix column. In conjunction with <a class="reference internal" href="#Base.nonzeros" title="Base.nonzeros"><code class="xref jl jl-func docutils literal"><span class="pre">nonzeros()</span></code></a> and <a class="reference internal" href="#Base.rowvals" title="Base.rowvals"><code class="xref jl jl-func docutils literal"><span class="pre">rowvals()</span></code></a>, this allows for convenient iterating over a sparse matrix :</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">=</span> <span class="n">sparse</span><span class="p">(</span><span class="n">I</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">V</span><span class="p">)</span>
<span class="n">rows</span> <span class="o">=</span> <span class="n">rowvals</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="n">vals</span> <span class="o">=</span> <span class="n">nonzeros</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">size</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">:</span><span class="n">n</span>
   <span class="k">for</span> <span class="n">j</span> <span class="k">in</span> <span class="n">nzrange</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
      <span class="n">row</span> <span class="o">=</span> <span class="n">rows</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
      <span class="n">val</span> <span class="o">=</span> <span class="n">vals</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
      <span class="c"># perform sparse wizardry...</span>
   <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="Base.dropzeros!">
<code class="descname">dropzeros!</code><span class="sig-paren">(</span><em>A::SparseMatrixCSC</em>, <em>trim::Bool = true</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.dropzeros!" title="Permalink to this definition"></a></dt>
<dd><p>Removes stored numerical zeros from <code class="docutils literal"><span class="pre">A</span></code>, optionally trimming resulting excess space from <code class="docutils literal"><span class="pre">A.rowval</span></code> and <code class="docutils literal"><span class="pre">A.nzval</span></code> when <code class="docutils literal"><span class="pre">trim</span></code> is <code class="docutils literal"><span class="pre">true</span></code>.</p>
<p>For an out-of-place version, see <a class="reference internal" href="#Base.dropzeros" title="Base.dropzeros"><code class="xref jl jl-func docutils literal"><span class="pre">dropzeros()</span></code></a>. For algorithmic information, see <code class="xref jl jl-func docutils literal"><span class="pre">Base.SparseArrays.fkeep!()</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.dropzeros">
<code class="descname">dropzeros</code><span class="sig-paren">(</span><em>A::SparseMatrixCSC</em>, <em>trim::Bool = true</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.dropzeros" title="Permalink to this definition"></a></dt>
<dd><p>Generates a copy of <code class="docutils literal"><span class="pre">A</span></code> and removes stored numerical zeros from that copy, optionally trimming excess space from the result&#8217;s <code class="docutils literal"><span class="pre">rowval</span></code> and <code class="docutils literal"><span class="pre">nzval</span></code> arrays when <code class="docutils literal"><span class="pre">trim</span></code> is <code class="docutils literal"><span class="pre">true</span></code>.</p>
<p>For an in-place version and algorithmic information, see <a class="reference internal" href="#Base.dropzeros!" title="Base.dropzeros!"><code class="xref jl jl-func docutils literal"><span class="pre">dropzeros!()</span></code></a>.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">dropzeros!</code><span class="sig-paren">(</span><em>x::SparseVector</em>, <em>trim::Bool = true</em><span class="sig-paren">)</span></dt>
<dd><p>Removes stored numerical zeros from <code class="docutils literal"><span class="pre">x</span></code>, optionally trimming resulting excess space from <code class="docutils literal"><span class="pre">x.nzind</span></code> and <code class="docutils literal"><span class="pre">x.nzval</span></code> when <code class="docutils literal"><span class="pre">trim</span></code> is <code class="docutils literal"><span class="pre">true</span></code>.</p>
<p>For an out-of-place version, see <code class="xref jl jl-func docutils literal"><span class="pre">Base.SparseArrays.dropzeros()</span></code>. For algorithmic information, see <code class="xref jl jl-func docutils literal"><span class="pre">Base.SparseArrays.fkeep!()</span></code>.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">dropzeros</code><span class="sig-paren">(</span><em>x::SparseVector</em>, <em>trim::Bool = true</em><span class="sig-paren">)</span></dt>
<dd><p>Generates a copy of <code class="docutils literal"><span class="pre">x</span></code> and removes numerical zeros from that copy, optionally trimming excess space from the result&#8217;s <code class="docutils literal"><span class="pre">nzind</span></code> and <code class="docutils literal"><span class="pre">nzval</span></code> arrays when <code class="docutils literal"><span class="pre">trim</span></code> is <code class="docutils literal"><span class="pre">true</span></code>.</p>
<p>For an in-place version and algorithmic information, see <code class="xref jl jl-func docutils literal"><span class="pre">Base.SparseArrays.dropzeros!()</span></code>.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">permute{Tv,Ti,Tp&lt;:Integer,Tq&lt;:Integer}(A::SparseMatrixCSC{Tv,Ti}, p::AbstractVector{Tp},</code></dt>
<dt id="Base.q::AbstractVector{Tq})">
<code class="descname">q::AbstractVector{Tq})</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Base.q::AbstractVector{Tq})" title="Permalink to this definition"></a></dt>
<dd><p>Bilaterally permute <code class="docutils literal"><span class="pre">A</span></code>, returning <code class="docutils literal"><span class="pre">PAQ</span></code> (<code class="docutils literal"><span class="pre">A[p,q]</span></code>). Column-permutation <code class="docutils literal"><span class="pre">q</span></code>&#8216;s length must match <code class="docutils literal"><span class="pre">A</span></code>&#8216;s column count (<code class="docutils literal"><span class="pre">length(q)</span> <span class="pre">==</span> <span class="pre">A.n</span></code>). Row-permutation <code class="docutils literal"><span class="pre">p</span></code>&#8216;s length must match <code class="docutils literal"><span class="pre">A</span></code>&#8216;s row count (<code class="docutils literal"><span class="pre">length(p)</span> <span class="pre">==</span> <span class="pre">A.m</span></code>).</p>
<p>For expert drivers and additional information, see <code class="xref jl jl-func docutils literal"><span class="pre">Base.SparseArrays.permute!()</span></code>.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">permute!{Tv,Ti,Tp&lt;:Integer,Tq&lt;:Integer}(X::SparseMatrixCSC{Tv,Ti}, A::SparseMatrixCSC{Tv,Ti},</code></dt>
<dt>
<code class="descname">p::AbstractVector{Tp}, q::AbstractVector{Tq}[, C::SparseMatrixCSC{Tv,Ti}])</code></dt>
<dd><p>Bilaterally permute <code class="docutils literal"><span class="pre">A</span></code>, storing result <code class="docutils literal"><span class="pre">PAQ</span></code> (<code class="docutils literal"><span class="pre">A[p,q]</span></code>) in <code class="docutils literal"><span class="pre">X</span></code>. Stores intermediate result <code class="docutils literal"><span class="pre">(AQ)^T</span></code> (<code class="docutils literal"><span class="pre">transpose(A[:,q])</span></code>) in optional argument <code class="docutils literal"><span class="pre">C</span></code> if present. Requires that none of <code class="docutils literal"><span class="pre">X</span></code>, <code class="docutils literal"><span class="pre">A</span></code>, and, if present, <code class="docutils literal"><span class="pre">C</span></code> alias each other; to store result <code class="docutils literal"><span class="pre">PAQ</span></code> back into <code class="docutils literal"><span class="pre">A</span></code>, use the following method lacking <code class="docutils literal"><span class="pre">X</span></code>:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">permute!</span><span class="p">{</span><span class="n">Tv</span><span class="p">,</span><span class="n">Ti</span><span class="p">,</span><span class="n">Tp</span><span class="o">&lt;:</span><span class="n">Integer</span><span class="p">,</span><span class="n">Tq</span><span class="o">&lt;:</span><span class="n">Integer</span><span class="p">}(</span><span class="n">A</span><span class="p">::</span><span class="n">SparseMatrixCSC</span><span class="p">{</span><span class="n">Tv</span><span class="p">,</span><span class="n">Ti</span><span class="p">},</span> <span class="n">p</span><span class="p">::</span><span class="n">AbstractVector</span><span class="p">{</span><span class="n">Tp</span><span class="p">},</span>
    <span class="n">q</span><span class="p">::</span><span class="n">AbstractVector</span><span class="p">{</span><span class="n">Tq</span><span class="p">}[,</span> <span class="n">C</span><span class="p">::</span><span class="n">SparseMatrixCSC</span><span class="p">{</span><span class="n">Tv</span><span class="p">,</span><span class="n">Ti</span><span class="p">}[,</span> <span class="n">workcolptr</span><span class="p">::</span><span class="n">Vector</span><span class="p">{</span><span class="n">Ti</span><span class="p">}]])</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">X</span></code>&#8216;s dimensions must match those of <code class="docutils literal"><span class="pre">A</span></code> (<code class="docutils literal"><span class="pre">X.m</span> <span class="pre">==</span> <span class="pre">A.m</span></code> and <code class="docutils literal"><span class="pre">X.n</span> <span class="pre">==</span> <span class="pre">A.n</span></code>), and <code class="docutils literal"><span class="pre">X</span></code> must have enough storage to accommodate all allocated entries in <code class="docutils literal"><span class="pre">A</span></code> (<code class="docutils literal"><span class="pre">length(X.rowval)</span> <span class="pre">&gt;=</span> <span class="pre">nnz(A)</span></code> and <code class="docutils literal"><span class="pre">length(X.nzval)</span> <span class="pre">&gt;=</span> <span class="pre">nnz(A)</span></code>). Column-permutation <code class="docutils literal"><span class="pre">q</span></code>&#8216;s length must match <code class="docutils literal"><span class="pre">A</span></code>&#8216;s column count (<code class="docutils literal"><span class="pre">length(q)</span> <span class="pre">==</span> <span class="pre">A.n</span></code>). Row-permutation <code class="docutils literal"><span class="pre">p</span></code>&#8216;s length must match <code class="docutils literal"><span class="pre">A</span></code>&#8216;s row count (<code class="docutils literal"><span class="pre">length(p)</span> <span class="pre">==</span> <span class="pre">A.m</span></code>).</p>
<p><code class="docutils literal"><span class="pre">C</span></code>&#8216;s dimensions must match those of <code class="docutils literal"><span class="pre">transpose(A)</span></code> (<code class="docutils literal"><span class="pre">C.m</span> <span class="pre">==</span> <span class="pre">A.n</span></code> and <code class="docutils literal"><span class="pre">C.n</span> <span class="pre">==</span> <span class="pre">A.m</span></code>), and <code class="docutils literal"><span class="pre">C</span></code> must have enough storage to accommodate all allocated entries in <code class="docutils literal"><span class="pre">A</span></code> (<code class="docutils literal"><span class="pre">length(C.rowval)</span></code> &gt;= nnz(A)``and``length(C.nzval) &gt;= nnz(A)`).</p>
<p>For additional (algorithmic) information, and for versions of these methods that forgo argument checking, see (unexported) parent methods <code class="xref jl jl-func docutils literal"><span class="pre">Base.SparseArrays.unchecked_noalias_permute!()</span></code> and <code class="xref jl jl-func docutils literal"><span class="pre">Base.SparseArrays.unchecked_aliasing_permute!()</span></code>.</p>
<p>See also: <code class="xref jl jl-func docutils literal"><span class="pre">Base.SparseArrays.permute()</span></code></p>
</dd></dl>

</div>
</div>


          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../parallel/" class="btn btn-neutral float-right" title="Tasks and Parallel Computing">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../strings/" class="btn btn-neutral" title="Strings"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
    </p>
  </div>

  <a href="https://github.com/snide/sphinx_rtd_theme">Sphinx theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>
</footer>
        </div>
      </div>

    </section>

  </div>
  

  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'0.5.1-pre',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>