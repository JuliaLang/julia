<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Static analyzer annotations for GC correctness in C code · The Julia Language</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-28835595-6', 'auto');
ga('send', 'pageview');
</script><link rel="canonical" href="https://docs.julialang.org/en/v1/devdocs/gc-sa/index.html"/><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../../assets/julia-manual.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../../index.html"><img class="logo" src="../../assets/logo.png" alt="The Julia Language logo"/></a><h1>The Julia Language</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../../manual/getting-started/">Getting Started</a></li><li><a class="toctext" href="../../manual/variables/">Variables</a></li><li><a class="toctext" href="../../manual/integers-and-floating-point-numbers/">Integers and Floating-Point Numbers</a></li><li><a class="toctext" href="../../manual/mathematical-operations/">Mathematical Operations and Elementary Functions</a></li><li><a class="toctext" href="../../manual/complex-and-rational-numbers/">Complex and Rational Numbers</a></li><li><a class="toctext" href="../../manual/strings/">Strings</a></li><li><a class="toctext" href="../../manual/functions/">Functions</a></li><li><a class="toctext" href="../../manual/control-flow/">Control Flow</a></li><li><a class="toctext" href="../../manual/variables-and-scoping/">Scope of Variables</a></li><li><a class="toctext" href="../../manual/types/">Types</a></li><li><a class="toctext" href="../../manual/methods/">Methods</a></li><li><a class="toctext" href="../../manual/constructors/">Constructors</a></li><li><a class="toctext" href="../../manual/conversion-and-promotion/">Conversion and Promotion</a></li><li><a class="toctext" href="../../manual/interfaces/">Interfaces</a></li><li><a class="toctext" href="../../manual/modules/">Modules</a></li><li><a class="toctext" href="../../manual/documentation/">Documentation</a></li><li><a class="toctext" href="../../manual/metaprogramming/">Metaprogramming</a></li><li><a class="toctext" href="../../manual/arrays/">Multi-dimensional Arrays</a></li><li><a class="toctext" href="../../manual/missing/">Missing Values</a></li><li><a class="toctext" href="../../manual/networking-and-streams/">Networking and Streams</a></li><li><a class="toctext" href="../../manual/parallel-computing/">Parallel Computing</a></li><li><a class="toctext" href="../../manual/running-external-programs/">Running External Programs</a></li><li><a class="toctext" href="../../manual/calling-c-and-fortran-code/">Calling C and Fortran Code</a></li><li><a class="toctext" href="../../manual/handling-operating-system-variation/">Handling Operating System Variation</a></li><li><a class="toctext" href="../../manual/environment-variables/">Environment Variables</a></li><li><a class="toctext" href="../../manual/embedding/">Embedding Julia</a></li><li><a class="toctext" href="../../manual/code-loading/">Code Loading</a></li><li><a class="toctext" href="../../manual/profile/">Profiling</a></li><li><a class="toctext" href="../../manual/stacktraces/">Stack Traces</a></li><li><a class="toctext" href="../../manual/performance-tips/">Performance Tips</a></li><li><a class="toctext" href="../../manual/workflow-tips/">Workflow Tips</a></li><li><a class="toctext" href="../../manual/style-guide/">Style Guide</a></li><li><a class="toctext" href="../../manual/faq/">Frequently Asked Questions</a></li><li><a class="toctext" href="../../manual/noteworthy-differences/">Noteworthy Differences from other Languages</a></li><li><a class="toctext" href="../../manual/unicode-input/">Unicode Input</a></li></ul></li><li><span class="toctext">Base</span><ul><li><a class="toctext" href="../../base/base/">Essentials</a></li><li><a class="toctext" href="../../base/collections/">Collections and Data Structures</a></li><li><a class="toctext" href="../../base/math/">Mathematics</a></li><li><a class="toctext" href="../../base/numbers/">Numbers</a></li><li><a class="toctext" href="../../base/strings/">Strings</a></li><li><a class="toctext" href="../../base/arrays/">Arrays</a></li><li><a class="toctext" href="../../base/parallel/">Tasks</a></li><li><a class="toctext" href="../../base/multi-threading/">Multi-Threading</a></li><li><a class="toctext" href="../../base/constants/">Constants</a></li><li><a class="toctext" href="../../base/file/">Filesystem</a></li><li><a class="toctext" href="../../base/io-network/">I/O and Network</a></li><li><a class="toctext" href="../../base/punctuation/">Punctuation</a></li><li><a class="toctext" href="../../base/sort/">Sorting and Related Functions</a></li><li><a class="toctext" href="../../base/iterators/">Iteration utilities</a></li><li><a class="toctext" href="../../base/c/">C Interface</a></li><li><a class="toctext" href="../../base/libc/">C Standard Library</a></li><li><a class="toctext" href="../../base/stacktraces/">StackTraces</a></li><li><a class="toctext" href="../../base/simd-types/">SIMD Support</a></li></ul></li><li><span class="toctext">Standard Library</span><ul><li><a class="toctext" href="../../stdlib/Base64/">Base64</a></li><li><a class="toctext" href="../../stdlib/CRC32c/">CRC32c</a></li><li><a class="toctext" href="../../stdlib/Dates/">Dates</a></li><li><a class="toctext" href="../../stdlib/DelimitedFiles/">Delimited Files</a></li><li><a class="toctext" href="../../stdlib/Distributed/">Distributed Computing</a></li><li><a class="toctext" href="../../stdlib/FileWatching/">File Events</a></li><li><a class="toctext" href="../../stdlib/InteractiveUtils/">Interactive Utilities</a></li><li><a class="toctext" href="../../stdlib/LibGit2/">LibGit2</a></li><li><a class="toctext" href="../../stdlib/Libdl/">Dynamic Linker</a></li><li><a class="toctext" href="../../stdlib/LinearAlgebra/">Linear Algebra</a></li><li><a class="toctext" href="../../stdlib/Logging/">Logging</a></li><li><a class="toctext" href="../../stdlib/Markdown/">Markdown</a></li><li><a class="toctext" href="../../stdlib/Mmap/">Memory-mapped I/O</a></li><li><a class="toctext" href="../../stdlib/Pkg/">Pkg</a></li><li><a class="toctext" href="../../stdlib/Printf/">Printf</a></li><li><a class="toctext" href="../../stdlib/Profile/">Profiling</a></li><li><a class="toctext" href="../../stdlib/REPL/">The Julia REPL</a></li><li><a class="toctext" href="../../stdlib/Random/">Random Numbers</a></li><li><a class="toctext" href="../../stdlib/SHA/">SHA</a></li><li><a class="toctext" href="../../stdlib/Serialization/">Serialization</a></li><li><a class="toctext" href="../../stdlib/SharedArrays/">Shared Arrays</a></li><li><a class="toctext" href="../../stdlib/Sockets/">Sockets</a></li><li><a class="toctext" href="../../stdlib/SparseArrays/">Sparse Arrays</a></li><li><a class="toctext" href="../../stdlib/Statistics/">Statistics</a></li><li><a class="toctext" href="../../stdlib/Test/">Unit Testing</a></li><li><a class="toctext" href="../../stdlib/UUIDs/">UUIDs</a></li><li><a class="toctext" href="../../stdlib/Unicode/">Unicode</a></li></ul></li><li><span class="toctext">Developer Documentation</span><ul><li><a class="toctext" href="../reflection/">Reflection and introspection</a></li><li><span class="toctext">Documentation of Julia&#39;s Internals</span><ul><li><a class="toctext" href="../init/">Initialization of the Julia runtime</a></li><li><a class="toctext" href="../ast/">Julia ASTs</a></li><li><a class="toctext" href="../types/">More about types</a></li><li><a class="toctext" href="../object/">Memory layout of Julia Objects</a></li><li><a class="toctext" href="../eval/">Eval of Julia code</a></li><li><a class="toctext" href="../callconv/">Calling Conventions</a></li><li><a class="toctext" href="../compiler/">High-level Overview of the Native-Code Generation Process</a></li><li><a class="toctext" href="../functions/">Julia Functions</a></li><li><a class="toctext" href="../cartesian/">Base.Cartesian</a></li><li><a class="toctext" href="../meta/">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="../subarrays/">SubArrays</a></li><li><a class="toctext" href="../isbitsunionarrays/">isbits Union Optimizations</a></li><li><a class="toctext" href="../sysimg/">System Image Building</a></li><li><a class="toctext" href="../llvm/">Working with LLVM</a></li><li><a class="toctext" href="../stdio/">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="../boundscheck/">Bounds checking</a></li><li><a class="toctext" href="../locks/">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="../offset-arrays/">Arrays with custom indices</a></li><li><a class="toctext" href="../require/">Module loading</a></li><li><a class="toctext" href="../inference/">Inference</a></li><li><a class="toctext" href="../ssair/">Julia SSA-form IR</a></li><li class="current"><a class="toctext" href>Static analyzer annotations for GC correctness in C code</a><ul class="internal"><li><a class="toctext" href="#General-Overview-1">General Overview</a></li><li><a class="toctext" href="#GC-Invariants-1">GC Invariants</a></li><li><a class="toctext" href="#Static-Analysis-Algorithm-1">Static Analysis Algorithm</a></li><li><a class="toctext" href="#The-analyzer-annotations-1">The analyzer annotations</a></li><li><a class="toctext" href="#Completeness-of-analysis-1">Completeness of analysis</a></li></ul></li></ul></li><li><span class="toctext">Developing/debugging Julia&#39;s C code</span><ul><li><a class="toctext" href="../backtraces/">Reporting and analyzing crashes (segfaults)</a></li><li><a class="toctext" href="../debuggingtips/">gdb debugging tips</a></li><li><a class="toctext" href="../valgrind/">Using Valgrind with Julia</a></li><li><a class="toctext" href="../sanitizers/">Sanitizer support</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Developer Documentation</li><li>Documentation of Julia&#39;s Internals</li><li><a href>Static analyzer annotations for GC correctness in C code</a></li></ul><a class="edit-page" href="https://github.com/JuliaLang/julia/blob/master/doc/src/devdocs/gc-sa.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Static analyzer annotations for GC correctness in C code</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Static-analyzer-annotations-for-GC-correctness-in-C-code-1" href="#Static-analyzer-annotations-for-GC-correctness-in-C-code-1">Static analyzer annotations for GC correctness in C code</a></h1><h2><a class="nav-anchor" id="General-Overview-1" href="#General-Overview-1">General Overview</a></h2><p>Since Julia&#39;s GC is precise, it needs to maintain correct rooting information for any value that may be referenced at any time GC may occur. These places are known as <code>safepoints</code> and in the function local context, we extend this designation to any function call that may recursively end up at a safepoint.</p><p>In generated code, this is taken care of automatically by the GC root placement pass (see the chapter on GC rooting in the LLVM codegen devdocs). However, in C code, we need to inform the runtime of any GC roots manually. This is done using the following macros:</p><pre><code class="language-none">// The value assigned to any slot passed as an argument to these
// is rooted for the duration of this GC frame.
JL_GC_PUSH{1,...,6}(args...)
// The values assigned into the size `n` array `rts` are rooted
// for the duration of this GC frame.
JL_GC_PUSHARGS(rts, n)
// Pop a GC frame
JL_GC_POP</code></pre><p>If these macros are not used where they need to be, or they are used incorrectly, the result is silent memory corruption. As such it is very important that they are placed correctly in all applicable code.</p><p>As such, we employ static analysis (and in particular the clang static analyzer) to help ensure that these macros are used correctly. The remainder of this document gives an overview of this static analysis and describes the support needed in the julia code base to make things work.</p><h2><a class="nav-anchor" id="GC-Invariants-1" href="#GC-Invariants-1">GC Invariants</a></h2><p>There is two simple invariants correctness:</p><ul><li>All GC<em>PUSH calls need to be followed by an appropriate GC</em>POP (in practice we enforce this at the function level)</li><li>If a value was previously not rooted at any safepoint, it may no longer be referenced afterwards</li></ul><p>Of course the devil is in the details here. In particular to satisfy the second of the above conditions, we need to know:</p><ul><li>Which calls are safepoints and which are not</li><li>Which values are rooted at any given safepoint and which are not</li><li>When is a value referenced</li></ul><p>For the second point in particular, we need to know which memory locations will be considered rooting at runtime (i.e. values assigned to such locations are rooted). This includes locations explicitly designated as such by passing them to one of the <code>GC_PUSH</code> macros, globally rooted locations and values, as well as any location recursively reachable from one of those locations.</p><h2><a class="nav-anchor" id="Static-Analysis-Algorithm-1" href="#Static-Analysis-Algorithm-1">Static Analysis Algorithm</a></h2><p>The idea itself is very simple, although the implementation is quite a bit more complicated (mainly due to a large number of special cases and intricacies of C and C++). In essence, we keep track of all locations that are rooting, all values that are rootable and any expression (assignments, allocations, etc) affect the rootedness of any rootable values. Then, at any safepoint, we perform a &quot;symbolic GC&quot; and poison any values that are not rooted at said location. If these values are later referenced, we emit an error.</p><p>The clang static analyzer works by constructing a graph of states and exploring this graph for sources of errors. Several nodes in this graph are generated by the analyzer itself (e.g. for control flow), but the definitions above augment this graph with our own state.</p><p>The static analyzer is interprocedural and can analyze control flow across function boundaries. However, the static analyzer is not fully recursive and makes heuristic decisions about which calls to explore (additionally some calls are cross-translation unit and invisible to the analyzer). In our case, our definition of correctness requires total information. As such, we need to annotate the prototypes of all function calls with whatever information the analysis required, even if that information would otherwise be available by interprocedural static analysis.</p><p>Luckily however, we can still use this interprocedural analysis to ensure that the annotations we place on a given function are indeed correct given the implementation of said function.</p><h2><a class="nav-anchor" id="The-analyzer-annotations-1" href="#The-analyzer-annotations-1">The analyzer annotations</a></h2><p>These annotations are found in src/support/analyzer_annotations.h. The are only active when the analyzer is being used and expand either to nothing (for prototype annotations) or to no-ops (for function like annotations).</p><h3><a class="nav-anchor" id="JL_NOTSAFEPOINT-1" href="#JL_NOTSAFEPOINT-1"><code>JL_NOTSAFEPOINT</code></a></h3><p>This is perhaps the most common annotation, and should be placed on any function that is known not to possibly lead to reaching a GC safepoint. In general, it is only safe for such a function to perform arithmetic, memory accesses and calls to functions either annotated <code>JL_NOTSAFEPOINT</code> or otherwise known not to be safepoints (e.g. function in the C standard library, which are hardcoded as such in the analyzer)</p><p>It is valid to keep values unrooted across calls to any function annotated with this attribute:</p><p>Usage Example:</p><pre><code class="language-c">void jl_get_one() JL_NOTSAFEPOINT {
  return 1;
}

jl_value_t *example() {
  jl_value_t *val = jl_alloc_whatever();
  // This is valid, even though `val` is unrooted, because
  // jl_get_one is not a safepoint
  jl_get_one();
  return val;
}</code></pre><h3><a class="nav-anchor" id="JL_MAYBE_UNROOTED/JL_ROOTS_TEMPORARILY-1" href="#JL_MAYBE_UNROOTED/JL_ROOTS_TEMPORARILY-1"><code>JL_MAYBE_UNROOTED</code>/<code>JL_ROOTS_TEMPORARILY</code></a></h3><p>When <code>JL_MAYBE_UNROOTED</code> is annotated as an argument on a function, indicates that said argument may be passed, even if it is not rooted. In the ordinary course of events, the julia ABI guarantees that callers root values before passing them to callees. However, some functions do not follow this ABI and allow values to be passed to them even though they are not rooted. Note however, that this does not automatically imply that said argument will be preserved. The <code>ROOTS_TEMPORARILY</code> annotation provides the stronger guarantee that, not only may the value be unrooted when passed, it will also be preserved across any internal safepoints by the callee.</p><p>Note that <code>JL_NOTSAFEPOINT</code> essentially implies <code>JL_MAYBE_UNROOTED</code>/<code>JL_ROOTS_TEMPORARILY</code>, because the rootedness of an argument is irrelevant if the function contains no safepoints.</p><p>One additional point to note is that these annotations apply on both the caller and the callee side. On the caller side, they lift rootedness restrictions that are normally required for julia ABI functions. On the callee side, they have the reverse effect of preventing these arguments from being considered implicitly rooted.</p><p>If either of these annotations is applied to the function as a whole, it applies to all arguments of the function. This should generally only be necessary for varargs functions.</p><p>Usage example:</p><pre><code class="language-c">JL_DLLEXPORT void JL_NORETURN jl_throw(jl_value_t *e JL_MAYBE_UNROOTED);
jl_value_t *jl_alloc_error();

void example() {
  // The return value of the allocation is unrooted. This would normally
  // be an error, but is allowed because of the above annotation.
  jl_throw(jl_alloc_error());
}</code></pre><h3><a class="nav-anchor" id="JL_PROPAGATES_ROOT-1" href="#JL_PROPAGATES_ROOT-1"><code>JL_PROPAGATES_ROOT</code></a></h3><p>This annotation is commonly found on accessor functions that return one rootable object stored within another. When annotated on a function argument, it tells the analyzer that the root for that argument also applies to the value returned by the function.</p><p>Usage Example:</p><pre><code class="language-c">jl_value_t *jl_svecref(jl_svec_t *t JL_PROPAGATES_ROOT, size_t i) JL_NOTSAFEPOINT;

size_t example(jl_svec_t *svec) {
  jl_value_t *val = jl_svecref(svec, 1)
  // This is valid, because, as annotated by the PROPAGATES_ROOT annotation,
  // jl_svecref propagates the rooted-ness from `svec` to `val`
  jl_gc_safepoint();
  return jl_unbox_long(val);
}</code></pre><h3><a class="nav-anchor" id="JL_ROOTING_ARGUMENT/JL_ROOTED_ARGUMENT-1" href="#JL_ROOTING_ARGUMENT/JL_ROOTED_ARGUMENT-1"><code>JL_ROOTING_ARGUMENT</code>/<code>JL_ROOTED_ARGUMENT</code></a></h3><p>This is essentially the assignment counterpart to <code>JL_PROPAGATES_ROOT</code>. When assigning a value to a field of another value that is already rooted, the assigned value will inherit the root of the value it is assigned into.</p><p>Usage Example:</p><pre><code class="language-c">void jl_svecset(void *t JL_ROOTING_ARGUMENT, size_t i, void *x JL_ROOTED_ARGUMENT) JL_NOTSAFEPOINT


size_t example(jl_svec_t *svec) {
  jl_value_t *val = jl_box_long(10000);
  jl_svecset(svec, val);
  // This is valid, because the annotations imply that the
  // jl_svecset propagates the rooted-ness from `svec` to `val`
  jl_gc_safepoint();
  return jl_unbox_long(val);
}</code></pre><h3><a class="nav-anchor" id="JL_GC_DISABLED-1" href="#JL_GC_DISABLED-1"><code>JL_GC_DISABLED</code></a></h3><p>This annotation implies that this function is only called with the GC runtime-disabled. Functions of this kind are most often encountered during startup and in the GC code itself. Note that this annotation is checked against the runtime enable/disable calls, so clang will know if you lie. This is not a good way to disable processing of a given function if the GC is not actually disabled (use <code>ifdef __clang_analyzer__</code> for that if you must).</p><p>Usage example:</p><pre><code class="language-c">void jl_do_magic() JL_GC_DISABLED {
  // Wildly allocate here with no regard for roots
}

void example() {
  int en = jl_gc_enable(0);
  jl_do_magic();
  jl_gc_enable(en);
}</code></pre><h3><a class="nav-anchor" id="JL_REQUIRE_ROOTED_SLOT-1" href="#JL_REQUIRE_ROOTED_SLOT-1"><code>JL_REQUIRE_ROOTED_SLOT</code></a></h3><p>This annotation requires the caller to pass in a slot that is rooted (i.e. values assigned to this slot will be rooted).</p><p>Usage example:</p><pre><code class="language-c">void jl_do_processing(jl_value_t **slot JL_REQUIRE_ROOTED_SLOT) {
  *slot = jl_box_long(1);
  // Ok, only, because the slot was annotated as rooting
  jl_gc_safepoint();
}

void example() {
  jl_value_t *slot = NULL;
  JL_GC_PUSH1(&amp;slot);
  jl_do_processing(&amp;slot);
  JL_GC_POP();
}</code></pre><h3><a class="nav-anchor" id="JL_GLOBALLY_ROOTED-1" href="#JL_GLOBALLY_ROOTED-1"><code>JL_GLOBALLY_ROOTED</code></a></h3><p>This annotation implies that a given value is always globally rooted. It can be applied to global variable declarations, in which case it will apply to the value of those variables (or values if the declaration if for an array), or to functions, in which case it will apply to the return value of such functions (e.g. for functions that always return some private, globally rooted value).</p><p>Usage example:</p><pre><code class="language-none">extern JL_DLLEXPORT jl_datatype_t *jl_any_type JL_GLOBALLY_ROOTED;
jl_ast_context_t *jl_ast_ctx(fl_context_t *fl) JL_GLOBALLY_ROOTED;</code></pre><h3><a class="nav-anchor" id="JL_ALWAYS_LEAFTYPE-1" href="#JL_ALWAYS_LEAFTYPE-1"><code>JL_ALWAYS_LEAFTYPE</code></a></h3><p>This annotations is essentially equivalent to <code>JL_GLOBALLY_ROOTED</code>, except that is should only be used if those values are globally rooted by virtue of being a leaftype. The rooting of leaftypes is a bit complicated. They are generally rooted through <code>cache</code> field of the corresponding <code>TypeName</code>, which itself is rooted by the containing module (so they&#39;re rooted as long as the containing module is ok) and we can generally assume that leaftypes are rooted where they are used, but we may refine this property in the future, so the separate annotation helps split out the reason for being globally rooted.</p><p>The analyzer also automatically detects checks for leaftype-ness and will not complain about missing GC roots on these paths.</p><pre><code class="language-none">JL_DLLEXPORT jl_value_t *jl_apply_array_type(jl_value_t *type, size_t dim) JL_ALWAYS_LEAFTYPE;</code></pre><h3><a class="nav-anchor" id="JL_GC_PROMISE_ROOTED-1" href="#JL_GC_PROMISE_ROOTED-1"><code>JL_GC_PROMISE_ROOTED</code></a></h3><p>This is a function-like annotation. Any value passed to this annotation will be considered rooted for the scope of the current function. It is designed as an escape hatch for analyzer inadequacy or complicated situations. However, it should be used sparingly, in favor of improving the analyzer itself.</p><pre><code class="language-none">void example() {
  jl_value_t *val = jl_alloc_something();
  if (some_condition) {
    // We happen to know for complicated external reasons
    // that val is rooted under these conditions
    JL_GC_PROMISE_ROOTED(val);
  }
}</code></pre><h2><a class="nav-anchor" id="Completeness-of-analysis-1" href="#Completeness-of-analysis-1">Completeness of analysis</a></h2><p>The analyzer only looks at local information. In particular, e.g. in the <code>PROPAGATES_ROOT</code> case above, it assumes that such memory is only modified in ways it can see, not in any called functions (unless it happens to decide to consider them in its analysis) and not in any concurrently running threads. As such, it may miss a few problematic cases, though in practice such concurrent modification is fairly rare. Improving the analyzer to handle more such cases may be an interesting topic for future work.</p><footer><hr/><a class="previous" href="../ssair/"><span class="direction">Previous</span><span class="title">Julia SSA-form IR</span></a><a class="next" href="../backtraces/"><span class="direction">Next</span><span class="title">Reporting and analyzing crashes (segfaults)</span></a></footer></article></body></html>
