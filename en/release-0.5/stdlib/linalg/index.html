

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Linear Algebra &mdash; Julia Language 0.5.1-pre documentation</title>
  

  
  

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/julia.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../../_static/julia.css" type="text/css" />
  
    <link rel="top" title="Julia Language 0.5.1-pre documentation" href="../../"/>
        <link rel="next" title="Constants" href="../constants/"/>
        <link rel="prev" title="Tasks and Parallel Computing" href="../parallel/"/> 

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        <a href="http://julialang.org/"><img src="../../_static/julia-logo.svg" class="logo"></a>
        <!--
        <a href="../../" class="fa fa-home"> Julia Language</a>
        -->
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search/" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
        
            <ul>
<li class="toctree-l1"><a class="reference internal" href="../../manual/introduction/">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/getting-started/">Getting Started</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/getting-started/#resources">Resources</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/variables/">Variables</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/variables/#allowed-variable-names">Allowed Variable Names</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/variables/#stylistic-conventions">Stylistic Conventions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/integers-and-floating-point-numbers/">Integers and Floating-Point Numbers</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/integers-and-floating-point-numbers/#integers">Integers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/integers-and-floating-point-numbers/#floating-point-numbers">Floating-Point Numbers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/integers-and-floating-point-numbers/#arbitrary-precision-arithmetic">Arbitrary Precision Arithmetic</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/integers-and-floating-point-numbers/#numeric-literal-coefficients">Numeric Literal Coefficients</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/integers-and-floating-point-numbers/#literal-zero-and-one">Literal zero and one</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/mathematical-operations/">Mathematical Operations and Elementary Functions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/mathematical-operations/#arithmetic-operators">Arithmetic Operators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/mathematical-operations/#bitwise-operators">Bitwise Operators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/mathematical-operations/#updating-operators">Updating operators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/mathematical-operations/#numeric-comparisons">Numeric Comparisons</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/mathematical-operations/#numerical-conversions">Numerical Conversions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/complex-and-rational-numbers/">Complex and Rational Numbers</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/complex-and-rational-numbers/#complex-numbers">Complex Numbers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/complex-and-rational-numbers/#rational-numbers">Rational Numbers</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/strings/">Strings</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/strings/#characters">Characters</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/strings/#string-basics">String Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/strings/#unicode-and-utf-8">Unicode and UTF-8</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/strings/#interpolation">Interpolation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/strings/#triple-quoted-string-literals">Triple-Quoted String Literals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/strings/#common-operations">Common Operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/strings/#non-standard-string-literals">Non-Standard String Literals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/strings/#regular-expressions">Regular Expressions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/strings/#id2">Byte Array Literals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/strings/#version-number-literals">Version Number Literals</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/functions/">Functions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/functions/#argument-passing-behavior">Argument Passing Behavior</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/functions/#the-return-keyword">The <code class="docutils literal"><span class="pre">return</span></code> Keyword</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/functions/#operators-are-functions">Operators Are Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/functions/#operators-with-special-names">Operators With Special Names</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/functions/#anonymous-functions">Anonymous Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/functions/#multiple-return-values">Multiple Return Values</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/functions/#varargs-functions">Varargs Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/functions/#optional-arguments">Optional Arguments</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/functions/#keyword-arguments">Keyword Arguments</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/functions/#evaluation-scope-of-default-values">Evaluation Scope of Default Values</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/functions/#do-block-syntax-for-function-arguments">Do-Block Syntax for Function Arguments</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/functions/#dot-syntax-for-vectorizing-functions">Dot Syntax for Vectorizing Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/functions/#further-reading">Further Reading</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/control-flow/">Control Flow</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/control-flow/#compound-expressions">Compound Expressions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/control-flow/#conditional-evaluation">Conditional Evaluation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/control-flow/#short-circuit-evaluation">Short-Circuit Evaluation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/control-flow/#repeated-evaluation-loops">Repeated Evaluation: Loops</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/control-flow/#exception-handling">Exception Handling</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/control-flow/#tasks-aka-coroutines">Tasks (aka Coroutines)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/variables-and-scoping/">Scope of Variables</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/variables-and-scoping/#global-scope">Global Scope</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/variables-and-scoping/#local-scope">Local Scope</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/variables-and-scoping/#constants">Constants</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/types/">Types</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/types/#type-declarations">Type Declarations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/types/#abstract-types">Abstract Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/types/#bits-types">Bits Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/types/#composite-types">Composite Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/types/#immutable-composite-types">Immutable Composite Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/types/#declared-types">Declared Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/types/#type-unions">Type Unions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/types/#man-parametric-types">Parametric Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/types/#type-aliases">Type Aliases</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/types/#operations-on-types">Operations on Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/types/#value-types">&#8220;Value types&#8221;</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/types/#nullable-types-representing-missing-values">Nullable Types: Representing Missing Values</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/methods/">Methods</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/methods/#defining-methods">Defining Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/methods/#method-ambiguities">Method Ambiguities</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/methods/#parametric-methods">Parametric Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/methods/#parametrically-constrained-varargs-methods">Parametrically-constrained Varargs methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/methods/#note-on-optional-and-keyword-arguments">Note on Optional and keyword Arguments</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/methods/#function-like-objects">Function-like objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/methods/#empty-generic-functions">Empty generic functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/constructors/">Constructors</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/constructors/#outer-constructor-methods">Outer Constructor Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/constructors/#inner-constructor-methods">Inner Constructor Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/constructors/#incomplete-initialization">Incomplete Initialization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/constructors/#parametric-constructors">Parametric Constructors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/constructors/#case-study-rational">Case Study: Rational</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/constructors/#constructors-and-conversion">Constructors and Conversion</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/constructors/#outer-only-constructors">Outer-only constructors</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/conversion-and-promotion/">Conversion and Promotion</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/conversion-and-promotion/#conversion">Conversion</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/conversion-and-promotion/#promotion">Promotion</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/interfaces/">Interfaces</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/interfaces/#iteration">Iteration</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/interfaces/#indexing">Indexing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/interfaces/#abstract-arrays">Abstract Arrays</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/modules/">Modules</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/modules/#summary-of-module-usage">Summary of module usage</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/documentation/">Documentation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/documentation/#accessing-documentation">Accessing Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/documentation/#functions-methods">Functions &amp; Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/documentation/#advanced-usage">Advanced Usage</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/documentation/#syntax-guide">Syntax Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/documentation/#markdown-syntax">Markdown syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/documentation/#markdown-syntax-extensions">Markdown Syntax Extensions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/metaprogramming/">Metaprogramming</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/metaprogramming/#program-representation">Program representation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/metaprogramming/#expressions-and-evaluation">Expressions and evaluation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/metaprogramming/#macros">Macros</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/metaprogramming/#code-generation">Code Generation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/metaprogramming/#non-standard-string-literals">Non-Standard String Literals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/metaprogramming/#generated-functions">Generated functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/arrays/">Multi-dimensional Arrays</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/arrays/#arrays">Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/arrays/#sparse-matrices">Sparse Matrices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/linear-algebra/">Linear algebra</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/linear-algebra/#matrix-factorizations">Matrix factorizations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/linear-algebra/#special-matrices">Special matrices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/networking-and-streams/">Networking and Streams</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/networking-and-streams/#basic-stream-i-o">Basic Stream I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/networking-and-streams/#text-i-o">Text I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/networking-and-streams/#io-output-contextual-properties">IO Output Contextual Properties</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/networking-and-streams/#working-with-files">Working with Files</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/networking-and-streams/#a-simple-tcp-example">A simple TCP example</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/networking-and-streams/#resolving-ip-addresses">Resolving IP Addresses</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/parallel-computing/">Parallel Computing</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/parallel-computing/#code-availability-and-loading-packages">Code Availability and Loading Packages</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/parallel-computing/#data-movement">Data Movement</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/parallel-computing/#parallel-map-and-loops">Parallel Map and Loops</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/parallel-computing/#synchronization-with-remote-references">Synchronization With Remote References</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/parallel-computing/#scheduling">Scheduling</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/parallel-computing/#channels">Channels</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/parallel-computing/#remote-references-and-abstractchannels">Remote references and AbstractChannels</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/parallel-computing/#remote-references-and-distributed-garbage-collection">Remote References and Distributed Garbage Collection</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/parallel-computing/#id2">Shared Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/parallel-computing/#shared-arrays-and-distributed-garbage-collection">Shared Arrays and Distributed Garbage Collection</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/parallel-computing/#clustermanagers">ClusterManagers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/parallel-computing/#cluster-managers-with-custom-transports">Cluster Managers with custom transports</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/parallel-computing/#network-requirements-for-localmanager-and-sshmanager">Network requirements for LocalManager and SSHManager</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/parallel-computing/#cluster-cookie">Cluster cookie</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/parallel-computing/#specifying-network-topology-experimental">Specifying network topology (Experimental)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/parallel-computing/#multi-threading-experimental">Multi-threading (Experimental)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/parallel-computing/#threadcall-experimental">&#64;threadcall (Experimental)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/dates/">Date and DateTime</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/dates/#constructors">Constructors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/dates/#durations-comparisons">Durations/Comparisons</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/dates/#accessor-functions">Accessor Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/dates/#query-functions">Query Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/dates/#timetype-period-arithmetic">TimeType-Period Arithmetic</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/dates/#adjuster-functions">Adjuster Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/dates/#period-types">Period Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/dates/#rounding">Rounding</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/running-external-programs/">Running External Programs</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/running-external-programs/#interpolation">Interpolation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/running-external-programs/#quoting">Quoting</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/running-external-programs/#pipelines">Pipelines</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/calling-c-and-fortran-code/">Calling C and Fortran Code</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/calling-c-and-fortran-code/#creating-c-compatible-julia-function-pointers">Creating C-Compatible Julia Function Pointers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/calling-c-and-fortran-code/#mapping-c-types-to-julia">Mapping C Types to Julia</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/calling-c-and-fortran-code/#mapping-c-functions-to-julia">Mapping C Functions to Julia</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/calling-c-and-fortran-code/#some-examples-of-c-wrappers">Some Examples of C Wrappers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/calling-c-and-fortran-code/#garbage-collection-safety">Garbage Collection Safety</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/calling-c-and-fortran-code/#non-constant-function-specifications">Non-constant Function Specifications</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/calling-c-and-fortran-code/#indirect-calls">Indirect Calls</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/calling-c-and-fortran-code/#calling-convention">Calling Convention</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/calling-c-and-fortran-code/#accessing-global-variables">Accessing Global Variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/calling-c-and-fortran-code/#accessing-data-through-a-pointer">Accessing Data through a Pointer</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/calling-c-and-fortran-code/#thread-safety">Thread-safety</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/calling-c-and-fortran-code/#more-about-callbacks">More About Callbacks</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/calling-c-and-fortran-code/#c">C++</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/handling-operating-system-variation/">Handling Operating System Variation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/interacting-with-julia/">Interacting With Julia</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/interacting-with-julia/#the-different-prompt-modes">The different prompt modes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/interacting-with-julia/#key-bindings">Key bindings</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/interacting-with-julia/#tab-completion">Tab completion</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/interacting-with-julia/#customizing-colors">Customizing Colors</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/embedding/">Embedding Julia</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/embedding/#high-level-embedding">High-Level Embedding</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/embedding/#converting-types">Converting Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/embedding/#calling-julia-functions">Calling Julia Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/embedding/#memory-management">Memory Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/embedding/#working-with-arrays">Working with Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/embedding/#exceptions">Exceptions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/packages/">Packages</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/packages/#package-status">Package Status</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/packages/#adding-and-removing-packages">Adding and Removing Packages</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/packages/#offline-installation-of-packages">Offline Installation of Packages</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/packages/#installing-unregistered-packages">Installing Unregistered Packages</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/packages/#updating-packages">Updating Packages</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/packages/#checkout-pin-and-free">Checkout, Pin and Free</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/packages/#custom-metadata-repository">Custom METADATA Repository</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/packages/#package-development">Package Development</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/packages/#initial-setup">Initial Setup</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/packages/#making-changes-to-an-existing-package">Making changes to an existing package</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/packages/#creating-a-new-package">Creating a new Package</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/packages/#fixing-package-requirements">Fixing Package Requirements</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/packages/#man-package-requirements">Requirements Specification</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/profile/">Profiling</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/profile/#basic-usage">Basic usage</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/profile/#accumulation-and-clearing">Accumulation and clearing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/profile/#options-for-controlling-the-display-of-profile-results">Options for controlling the display of profile results</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/profile/#configuration">Configuration</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/profile/#memory-allocation-analysis">Memory allocation analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/stacktraces/">Stack Traces</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/stacktraces/#viewing-a-stack-trace">Viewing a stack trace</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/stacktraces/#extracting-useful-information">Extracting useful information</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/stacktraces/#error-handling">Error handling</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/stacktraces/#comparison-with-backtrace">Comparison with <code class="docutils literal"><span class="pre">backtrace()</span></code></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/performance-tips/">Performance Tips</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#avoid-global-variables">Avoid global variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#measure-performance-with-time-and-pay-attention-to-memory-allocation">Measure performance with <code class="docutils literal"><span class="pre">&#64;time</span></code> and pay attention to memory allocation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#tools">Tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#avoid-containers-with-abstract-type-parameters">Avoid containers with abstract type parameters</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#type-declarations">Type declarations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#break-functions-into-multiple-definitions">Break functions into multiple definitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#write-type-stable-functions">Write &#8220;type-stable&#8221; functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#avoid-changing-the-type-of-a-variable">Avoid changing the type of a variable</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#separate-kernel-functions-aka-function-barriers">Separate kernel functions (aka, function barriers)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#types-with-values-as-parameters">Types with values-as-parameters</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#the-dangers-of-abusing-multiple-dispatch-aka-more-on-types-with-values-as-parameters">The dangers of abusing multiple dispatch (aka, more on types with values-as-parameters)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#access-arrays-in-memory-order-along-columns">Access arrays in memory order, along columns</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#pre-allocating-outputs">Pre-allocating outputs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#avoid-string-interpolation-for-i-o">Avoid string interpolation for I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#optimize-network-i-o-during-parallel-execution">Optimize network I/O during parallel execution</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#fix-deprecation-warnings">Fix deprecation warnings</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#tweaks">Tweaks</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#performance-annotations">Performance Annotations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#treat-subnormal-numbers-as-zeros">Treat Subnormal Numbers as Zeros</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#code-warntype"><code class="docutils literal"><span class="pre">&#64;code_warntype</span></code></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/workflow-tips/">Workflow Tips</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/workflow-tips/#repl-based-workflow">REPL-based workflow</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/workflow-tips/#browser-based-workflow">Browser-based workflow</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/style-guide/">Style Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#write-functions-not-just-scripts">Write functions, not just scripts</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#avoid-writing-overly-specific-types">Avoid writing overly-specific types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#handle-excess-argument-diversity-in-the-caller">Handle excess argument diversity in the caller</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#append-to-names-of-functions-that-modify-their-arguments">Append <code class="docutils literal"><span class="pre">!</span></code> to names of functions that modify their arguments</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#avoid-strange-type-unions">Avoid strange type Unions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#avoid-type-unions-in-fields">Avoid type Unions in fields</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#avoid-elaborate-container-types">Avoid elaborate container types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#use-naming-conventions-consistent-with-julia-s-base">Use naming conventions consistent with Julia&#8217;s <code class="docutils literal"><span class="pre">base/</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#don-t-overuse-try-catch">Don&#8217;t overuse try-catch</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#don-t-parenthesize-conditions">Don&#8217;t parenthesize conditions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#don-t-overuse">Don&#8217;t overuse ...</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#don-t-use-unnecessary-static-parameters">Don&#8217;t use unnecessary static parameters</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#avoid-confusion-about-whether-something-is-an-instance-or-a-type">Avoid confusion about whether something is an instance or a type</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#don-t-overuse-macros">Don&#8217;t overuse macros</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#don-t-expose-unsafe-operations-at-the-interface-level">Don&#8217;t expose unsafe operations at the interface level</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#don-t-overload-methods-of-base-container-types">Don&#8217;t overload methods of base container types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#be-careful-with-type-equality">Be careful with type equality</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#do-not-write-x-f-x">Do not write <code class="docutils literal"><span class="pre">x-&gt;f(x)</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#avoid-using-floats-for-numeric-literals-in-generic-code-when-possible">Avoid using floats for numeric literals in generic code when possible</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/faq/">Frequently Asked Questions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/faq/#sessions-and-the-repl">Sessions and the REPL</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/faq/#functions">Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/faq/#types-type-declarations-and-constructors">Types, type declarations, and constructors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/faq/#packages-and-modules">Packages and Modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/faq/#nothingness-and-missing-values">Nothingness and missing values</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/faq/#memory">Memory</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/faq/#asynchronous-io-and-concurrent-synchronous-writes">Asynchronous IO and concurrent synchronous writes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/faq/#julia-releases">Julia Releases</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/noteworthy-differences/">Noteworthy Differences from other Languages</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/noteworthy-differences/#noteworthy-differences-from-matlab">Noteworthy differences from MATLAB</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/noteworthy-differences/#noteworthy-differences-from-r">Noteworthy differences from R</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/noteworthy-differences/#noteworthy-differences-from-python">Noteworthy differences from Python</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/noteworthy-differences/#noteworthy-differences-from-c-c">Noteworthy differences from C/C++</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/unicode-input/">Unicode Input</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../base/">Essentials</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../base/#introduction">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../base/#getting-around">Getting Around</a></li>
<li class="toctree-l2"><a class="reference internal" href="../base/#all-objects">All Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="../base/#types">Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../base/#generic-functions">Generic Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../base/#syntax">Syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="../base/#nullables">Nullables</a></li>
<li class="toctree-l2"><a class="reference internal" href="../base/#system">System</a></li>
<li class="toctree-l2"><a class="reference internal" href="../base/#errors">Errors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../base/#events">Events</a></li>
<li class="toctree-l2"><a class="reference internal" href="../base/#reflection">Reflection</a></li>
<li class="toctree-l2"><a class="reference internal" href="../base/#internals">Internals</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../collections/">Collections and Data Structures</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../collections/#iteration">Iteration</a></li>
<li class="toctree-l2"><a class="reference internal" href="../collections/#general-collections">General Collections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../collections/#iterable-collections">Iterable Collections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../collections/#indexable-collections">Indexable Collections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../collections/#associative-collections">Associative Collections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../collections/#set-like-collections">Set-Like Collections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../collections/#dequeues">Dequeues</a></li>
<li class="toctree-l2"><a class="reference internal" href="../collections/#priorityqueue">PriorityQueue</a></li>
<li class="toctree-l2"><a class="reference internal" href="../collections/#heap-functions">Heap Functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../math/">Mathematics</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../math/#mathematical-operators">Mathematical Operators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../math/#mathematical-functions">Mathematical Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../math/#statistics">Statistics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../math/#signal-processing">Signal Processing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../math/#numerical-integration">Numerical Integration</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../numbers/">Numbers</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../numbers/#standard-numeric-types">Standard Numeric Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../numbers/#data-formats">Data Formats</a></li>
<li class="toctree-l2"><a class="reference internal" href="../numbers/#general-number-functions-and-constants">General Number Functions and Constants</a></li>
<li class="toctree-l2"><a class="reference internal" href="../numbers/#bigfloats">BigFloats</a></li>
<li class="toctree-l2"><a class="reference internal" href="../numbers/#random-numbers">Random Numbers</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../strings/">Strings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../arrays/">Arrays</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../arrays/#basic-functions">Basic functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../arrays/#constructors">Constructors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../arrays/#mathematical-operators-and-functions">Mathematical operators and functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../arrays/#indexing-assignment-and-concatenation">Indexing, Assignment, and Concatenation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../arrays/#array-functions">Array functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../arrays/#combinatorics">Combinatorics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../arrays/#bitarrays">BitArrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="../arrays/#sparse-vectors-and-matrices">Sparse Vectors and Matrices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../parallel/">Tasks and Parallel Computing</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../parallel/#tasks">Tasks</a></li>
<li class="toctree-l2"><a class="reference internal" href="../parallel/#general-parallel-computing-support">General Parallel Computing Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../parallel/#shared-arrays">Shared Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="../parallel/#multi-threading">Multi-Threading</a></li>
<li class="toctree-l2"><a class="reference internal" href="../parallel/#ccall-using-a-threadpool-experimental">ccall using a threadpool (Experimental)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../parallel/#synchronization-primitives">Synchronization Primitives</a></li>
<li class="toctree-l2"><a class="reference internal" href="../parallel/#cluster-manager-interface">Cluster Manager Interface</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="current reference internal" href="">Linear Algebra</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#module-Base.LinAlg">Standard Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#low-level-matrix-operations">Low-level matrix operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-Base.LinAlg.BLAS">BLAS Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-Base.LinAlg.LAPACK">LAPACK Functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../constants/">Constants</a></li>
<li class="toctree-l1"><a class="reference internal" href="../file/">Filesystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../io-network/">I/O and Network</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../io-network/#general-i-o">General I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../io-network/#text-i-o">Text I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../io-network/#multimedia-i-o">Multimedia I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../io-network/#memory-mapped-i-o">Memory-mapped I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../io-network/#network-i-o">Network I/O</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../punctuation/">Punctuation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sort/">Sorting and Related Functions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../sort/#sorting-functions">Sorting Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sort/#order-related-functions">Order-Related Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sort/#sorting-algorithms">Sorting Algorithms</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../pkg/">Package Manager Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dates/">Dates and Time</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../dates/#dates-and-time-types">Dates and Time Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dates/#dates-functions">Dates Functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../test/">Unit Testing</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../test/#testing-base-julia">Testing Base Julia</a></li>
<li class="toctree-l2"><a class="reference internal" href="../test/#basic-unit-tests">Basic Unit Tests</a></li>
<li class="toctree-l2"><a class="reference internal" href="../test/#working-with-test-sets">Working with Test Sets</a></li>
<li class="toctree-l2"><a class="reference internal" href="../test/#other-test-macros">Other Test Macros</a></li>
<li class="toctree-l2"><a class="reference internal" href="../test/#broken-tests">Broken Tests</a></li>
<li class="toctree-l2"><a class="reference internal" href="../test/#creating-custom-abstracttestset-types">Creating Custom <code class="docutils literal"><span class="pre">AbstractTestSet</span></code> Types</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../c/">C Interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../c/#llvm-interface">LLVM Interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../libc/">C Standard Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="../libdl/">Dynamic Linker</a></li>
<li class="toctree-l1"><a class="reference internal" href="../profile/">Profiling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../stacktraces/">StackTraces</a></li>
<li class="toctree-l1"><a class="reference internal" href="../simd-types/">SIMD Support</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../devdocs/reflection/">Reflection and introspection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../devdocs/julia/">Documentation of Julia&#8217;s Internals</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/init/">Initialization of the Julia runtime</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/eval/">Eval of Julia code</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/ast/">Julia ASTs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/types/">More about types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/object/">Memory layout of Julia Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/functions/">Julia Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/callconv/">Calling Conventions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/cartesian/">Base.Cartesian</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/meta/">Talking to the compiler (the <code class="docutils literal"><span class="pre">:meta</span></code> mechanism)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/subarrays/">SubArrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/sysimg/">System Image Building</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/llvm/">Working with LLVM</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/stdio/">printf() and stdio in the Julia runtime</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/boundscheck/">Bounds checking</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/locks/">Proper maintenance and care of multi-threading locks</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/offset-arrays/">Arrays with custom indices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../devdocs/C/">Developing/debugging Julia&#8217;s C code</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/backtraces/">Reporting and analyzing crashes (segfaults)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/debuggingtips/">gdb debugging tips</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/valgrind/">Using Valgrind with Julia</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/sanitizers/">Sanitizer support</a></li>
</ul>
</li>
</ul>

        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../">Julia Language</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../">Docs</a> &raquo;</li>
      
    <li>Linear Algebra</li>
      <li class="wy-breadcrumbs-aside">
        
          <a href="../../_sources/stdlib/linalg.txt" rel="nofollow"> View page source</a>
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document">
            
  <div class="section" id="linear-algebra">
<span id="stdlib-linalg"></span><h1>Linear Algebra<a class="headerlink" href="#linear-algebra" title="Permalink to this headline"></a></h1>
<div class="section" id="module-Base.LinAlg">
<span id="standard-functions"></span><h2>Standard Functions<a class="headerlink" href="#module-Base.LinAlg" title="Permalink to this headline"></a></h2>
<p>Linear algebra functions in Julia are largely implemented by calling functions from <a class="reference external" href="http://www.netlib.org/lapack/">LAPACK</a>.  Sparse factorizations call functions from <a class="reference external" href="http://faculty.cse.tamu.edu/davis/suitesparse.html">SuiteSparse</a>.</p>
<dl class="function">
<dt id="Base.*">
<code class="descname">*</code><span class="sig-paren">(</span><em>A</em>, <em>B</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.*" title="Permalink to this definition"></a></dt>
<dd><p>Matrix multiplication.</p>
</dd></dl>

<dl class="function">
<dt id="Base.\">
<code class="descname">\</code><span class="sig-paren">(</span><em>A</em>, <em>B</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.\" title="Permalink to this definition"></a></dt>
<dd><p>Matrix division using a polyalgorithm. For input matrices <code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">B</span></code>, the result <code class="docutils literal"><span class="pre">X</span></code> is such that <code class="docutils literal"><span class="pre">A*X</span> <span class="pre">==</span> <span class="pre">B</span></code> when <code class="docutils literal"><span class="pre">A</span></code> is square. The solver that is used depends upon the structure of <code class="docutils literal"><span class="pre">A</span></code>.  If <code class="docutils literal"><span class="pre">A</span></code> is upper or lower triangular (or diagonal), no factorization of <code class="docutils literal"><span class="pre">A</span></code> is required and the system is solved with either forward or backward substitution. For non-triangular square matrices, an LU factorization is used.</p>
<p>For rectangular <code class="docutils literal"><span class="pre">A</span></code> the result is the minimum-norm least squares solution computed by a pivoted QR factorization of <code class="docutils literal"><span class="pre">A</span></code> and a rank estimate of <code class="docutils literal"><span class="pre">A</span></code> based on the R factor.</p>
<p>When <code class="docutils literal"><span class="pre">A</span></code> is sparse, a similar polyalgorithm is used. For indefinite matrices, the <code class="docutils literal"><span class="pre">LDLt</span></code> factorization does not use pivoting during the numerical factorization and therefore the procedure can fail even for invertible matrices.</p>
</dd></dl>

<dl class="function">
<dt id="Base.dot">
<code class="descname">dot</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.dot" title="Permalink to this definition"></a></dt>
<dt id="Base.">
<code class="descname"></code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#Base." title="Permalink to this definition"></a></dt>
<dd><p>Compute the dot product. For complex vectors, the first vector is conjugated.</p>
</dd></dl>

<dl class="function">
<dt id="Base.vecdot">
<code class="descname">vecdot</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.vecdot" title="Permalink to this definition"></a></dt>
<dd><p>For any iterable containers <code class="docutils literal"><span class="pre">x</span></code> and <code class="docutils literal"><span class="pre">y</span></code> (including arrays of any dimension) of numbers (or any element type for which <code class="docutils literal"><span class="pre">dot</span></code> is defined), compute the Euclidean dot product (the sum of <code class="docutils literal"><span class="pre">dot(x[i],y[i])</span></code>) as if they were vectors.</p>
</dd></dl>

<dl class="function">
<dt id="Base.cross">
<code class="descname">cross</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.cross" title="Permalink to this definition"></a></dt>
<dt id="Base.">
<code class="descname"></code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#Base." title="Permalink to this definition"></a></dt>
<dd><p>Compute the cross product of two 3-vectors.</p>
</dd></dl>

<dl class="function">
<dt id="Base.factorize">
<code class="descname">factorize</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.factorize" title="Permalink to this definition"></a></dt>
<dd><p>Compute a convenient factorization of <code class="docutils literal"><span class="pre">A</span></code>, based upon the type of the input matrix. <code class="docutils literal"><span class="pre">factorize</span></code> checks <code class="docutils literal"><span class="pre">A</span></code> to see if it is symmetric/triangular/etc. if <code class="docutils literal"><span class="pre">A</span></code> is passed as a generic matrix. <code class="docutils literal"><span class="pre">factorize</span></code> checks every element of <code class="docutils literal"><span class="pre">A</span></code> to verify/rule out each property. It will short-circuit as soon as it can rule out symmetry/triangular structure. The return value can be reused for efficient solving of multiple systems. For example: <code class="docutils literal"><span class="pre">A=factorize(A);</span> <span class="pre">x=A\b;</span> <span class="pre">y=A\C</span></code>.</p>
<table border="1" class="docutils">
<colgroup>
<col width="42%" />
<col width="58%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Properties of <code class="docutils literal"><span class="pre">A</span></code></th>
<th class="head">type of factorization</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Positive-definite</td>
<td>Cholesky (see <a class="reference internal" href="#Base.cholfact" title="Base.cholfact"><code class="xref jl jl-func docutils literal"><span class="pre">cholfact()</span></code></a>)</td>
</tr>
<tr class="row-odd"><td>Dense Symmetric/Hermitian</td>
<td>Bunch-Kaufman (see <a class="reference internal" href="#Base.bkfact" title="Base.bkfact"><code class="xref jl jl-func docutils literal"><span class="pre">bkfact()</span></code></a>)</td>
</tr>
<tr class="row-even"><td>Sparse Symmetric/Hermitian</td>
<td>LDLt (see <a class="reference internal" href="#Base.ldltfact" title="Base.ldltfact"><code class="xref jl jl-func docutils literal"><span class="pre">ldltfact()</span></code></a>)</td>
</tr>
<tr class="row-odd"><td>Triangular</td>
<td>Triangular</td>
</tr>
<tr class="row-even"><td>Diagonal</td>
<td>Diagonal</td>
</tr>
<tr class="row-odd"><td>Bidiagonal</td>
<td>Bidiagonal</td>
</tr>
<tr class="row-even"><td>Tridiagonal</td>
<td>LU (see <a class="reference internal" href="#Base.lufact" title="Base.lufact"><code class="xref jl jl-func docutils literal"><span class="pre">lufact()</span></code></a>)</td>
</tr>
<tr class="row-odd"><td>Symmetric real tridiagonal</td>
<td>LDLt (see <a class="reference internal" href="#Base.ldltfact" title="Base.ldltfact"><code class="xref jl jl-func docutils literal"><span class="pre">ldltfact()</span></code></a>)</td>
</tr>
<tr class="row-even"><td>General square</td>
<td>LU (see <a class="reference internal" href="#Base.lufact" title="Base.lufact"><code class="xref jl jl-func docutils literal"><span class="pre">lufact()</span></code></a>)</td>
</tr>
<tr class="row-odd"><td>General non-square</td>
<td>QR (see <a class="reference internal" href="#Base.qrfact" title="Base.qrfact"><code class="xref jl jl-func docutils literal"><span class="pre">qrfact()</span></code></a>)</td>
</tr>
</tbody>
</table>
<p>If <code class="docutils literal"><span class="pre">factorize</span></code> is called on a Hermitian positive-definite matrix, for instance, then <code class="docutils literal"><span class="pre">factorize</span></code> will return a Cholesky factorization.</p>
<p>Example:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">=</span> <span class="n">diagm</span><span class="p">(</span><span class="n">rand</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span> <span class="o">+</span> <span class="n">diagm</span><span class="p">(</span><span class="n">rand</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span><span class="mi">1</span><span class="p">);</span> <span class="c">#A is really bidiagonal</span>
<span class="n">factorize</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="c">#factorize will check to see that A is already factorized</span>
</pre></div>
</div>
<p>This returns a <code class="docutils literal"><span class="pre">55</span> <span class="pre">Bidiagonal{Float64}</span></code>, which can now be passed to other linear algebra functions (e.g. eigensolvers) which will use specialized methods for <code class="docutils literal"><span class="pre">Bidiagonal</span></code> types.</p>
</dd></dl>

<dl class="function">
<dt id="Base.full">
<code class="descname">full</code><span class="sig-paren">(</span><em>F</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.full" title="Permalink to this definition"></a></dt>
<dd><p>Reconstruct the matrix <code class="docutils literal"><span class="pre">A</span></code> from the factorization <code class="docutils literal"><span class="pre">F=factorize(A)</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.Diagonal">
<code class="descname">Diagonal</code><span class="sig-paren">(</span><em>A::AbstractMatrix</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.Diagonal" title="Permalink to this definition"></a></dt>
<dd><p>Constructs a matrix from the diagonal of <code class="docutils literal"><span class="pre">A</span></code>.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">Diagonal</code><span class="sig-paren">(</span><em>V::AbstractVector</em><span class="sig-paren">)</span></dt>
<dd><p>Constructs a matrix with <code class="docutils literal"><span class="pre">V</span></code> as its diagonal.</p>
</dd></dl>

<dl class="function">
<dt id="Base.Bidiagonal">
<code class="descname">Bidiagonal</code><span class="sig-paren">(</span><em>dv</em>, <em>ev</em>, <em>isupper::Bool</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.Bidiagonal" title="Permalink to this definition"></a></dt>
<dd><p>Constructs an upper (<code class="docutils literal"><span class="pre">isupper=true</span></code>) or lower (<code class="docutils literal"><span class="pre">isupper=false</span></code>) bidiagonal matrix using the given diagonal (<code class="docutils literal"><span class="pre">dv</span></code>) and off-diagonal (<code class="docutils literal"><span class="pre">ev</span></code>) vectors.  The result is of type <code class="docutils literal"><span class="pre">Bidiagonal</span></code> and provides efficient specialized linear solvers, but may be converted into a regular matrix with <a class="reference internal" href="#Base.full" title="Base.full"><code class="xref jl jl-func docutils literal"><span class="pre">full()</span></code></a>. <code class="docutils literal"><span class="pre">ev</span></code>&#8216;s length must be one less than the length of <code class="docutils literal"><span class="pre">dv</span></code>.</p>
<p><strong>Example</strong></p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">dv</span> <span class="o">=</span> <span class="n">rand</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="n">ev</span> <span class="o">=</span> <span class="n">rand</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="n">Bu</span> <span class="o">=</span> <span class="n">Bidiagonal</span><span class="p">(</span><span class="n">dv</span><span class="p">,</span> <span class="n">ev</span><span class="p">,</span> <span class="n">true</span><span class="p">)</span> <span class="c">#e is on the first superdiagonal</span>
<span class="n">Bl</span> <span class="o">=</span> <span class="n">Bidiagonal</span><span class="p">(</span><span class="n">dv</span><span class="p">,</span> <span class="n">ev</span><span class="p">,</span> <span class="n">false</span><span class="p">)</span> <span class="c">#e is on the first subdiagonal</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">Bidiagonal</code><span class="sig-paren">(</span><em>dv</em>, <em>ev</em>, <em>uplo::Char</em><span class="sig-paren">)</span></dt>
<dd><p>Constructs an upper (<code class="docutils literal"><span class="pre">uplo='U'</span></code>) or lower (<code class="docutils literal"><span class="pre">uplo='L'</span></code>) bidiagonal matrix using the given diagonal (<code class="docutils literal"><span class="pre">dv</span></code>) and off-diagonal (<code class="docutils literal"><span class="pre">ev</span></code>) vectors.  The result is of type <code class="docutils literal"><span class="pre">Bidiagonal</span></code> and provides efficient specialized linear solvers, but may be converted into a regular matrix with <a class="reference internal" href="#Base.full" title="Base.full"><code class="xref jl jl-func docutils literal"><span class="pre">full()</span></code></a>. <code class="docutils literal"><span class="pre">ev</span></code>&#8216;s length must be one less than the length of <code class="docutils literal"><span class="pre">dv</span></code>.</p>
<p><strong>Example</strong></p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">dv</span> <span class="o">=</span> <span class="n">rand</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="n">ev</span> <span class="o">=</span> <span class="n">rand</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="n">Bu</span> <span class="o">=</span> <span class="n">Bidiagonal</span><span class="p">(</span><span class="n">dv</span><span class="p">,</span> <span class="n">ev</span><span class="p">,</span> <span class="sc">&#39;U&#39;</span><span class="p">)</span> <span class="c">#e is on the first superdiagonal</span>
<span class="n">Bl</span> <span class="o">=</span> <span class="n">Bidiagonal</span><span class="p">(</span><span class="n">dv</span><span class="p">,</span> <span class="n">ev</span><span class="p">,</span> <span class="sc">&#39;L&#39;</span><span class="p">)</span> <span class="c">#e is on the first subdiagonal</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">Bidiagonal</code><span class="sig-paren">(</span><em>A</em>, <em>isupper::Bool</em><span class="sig-paren">)</span></dt>
<dd><p>Construct a <code class="docutils literal"><span class="pre">Bidiagonal</span></code> matrix from the main diagonal of <code class="docutils literal"><span class="pre">A</span></code> and its first super- (if <code class="docutils literal"><span class="pre">isupper=true</span></code>) or sub-diagonal (if <code class="docutils literal"><span class="pre">isupper=false</span></code>).</p>
<p><strong>Example</strong></p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">=</span> <span class="n">rand</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
<span class="n">Bu</span> <span class="o">=</span> <span class="n">Bidiagonal</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">true</span><span class="p">)</span> <span class="c">#contains the main diagonal and first superdiagonal of A</span>
<span class="n">Bl</span> <span class="o">=</span> <span class="n">Bidiagonal</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">false</span><span class="p">)</span> <span class="c">#contains the main diagonal and first subdiagonal of A</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="Base.SymTridiagonal">
<code class="descname">SymTridiagonal</code><span class="sig-paren">(</span><em>dv</em>, <em>ev</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.SymTridiagonal" title="Permalink to this definition"></a></dt>
<dd><p>Construct a symmetric tridiagonal matrix from the diagonal and first sub/super-diagonal, respectively. The result is of type <code class="docutils literal"><span class="pre">SymTridiagonal</span></code> and provides efficient specialized eigensolvers, but may be converted into a regular matrix with <a class="reference internal" href="#Base.full" title="Base.full"><code class="xref jl jl-func docutils literal"><span class="pre">full()</span></code></a>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.Tridiagonal">
<code class="descname">Tridiagonal</code><span class="sig-paren">(</span><em>dl</em>, <em>d</em>, <em>du</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.Tridiagonal" title="Permalink to this definition"></a></dt>
<dd><p>Construct a tridiagonal matrix from the first subdiagonal, diagonal, and first superdiagonal, respectively.  The result is of type <code class="docutils literal"><span class="pre">Tridiagonal</span></code> and provides efficient specialized linear solvers, but may be converted into a regular matrix with <a class="reference internal" href="#Base.full" title="Base.full"><code class="xref jl jl-func docutils literal"><span class="pre">full()</span></code></a>. The lengths of <code class="docutils literal"><span class="pre">dl</span></code> and <code class="docutils literal"><span class="pre">du</span></code> must be one less than the length of <code class="docutils literal"><span class="pre">d</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.Symmetric">
<code class="descname">Symmetric</code><span class="sig-paren">(</span><em>A</em>, <em>uplo=:U</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.Symmetric" title="Permalink to this definition"></a></dt>
<dd><p>Construct a <code class="docutils literal"><span class="pre">Symmetric</span></code> matrix from the upper (if <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">:U</span></code>) or lower (if <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">:L</span></code>) triangle of <code class="docutils literal"><span class="pre">A</span></code>.</p>
<p><strong>Example</strong></p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">=</span> <span class="n">randn</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span>
<span class="n">Supper</span> <span class="o">=</span> <span class="n">Symmetric</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="n">Slower</span> <span class="o">=</span> <span class="n">Symmetric</span><span class="p">(</span><span class="n">A</span><span class="p">,:</span><span class="n">L</span><span class="p">)</span>
<span class="n">eigfact</span><span class="p">(</span><span class="n">Supper</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">eigfact</span></code> will use a method specialized for matrices known to be symmetric. Note that <code class="docutils literal"><span class="pre">Supper</span></code> will not be equal to <code class="docutils literal"><span class="pre">Slower</span></code> unless <code class="docutils literal"><span class="pre">A</span></code> is itself symmetric (e.g. if <code class="docutils literal"><span class="pre">A</span> <span class="pre">==</span> <span class="pre">A.'</span></code>).</p>
</dd></dl>

<dl class="function">
<dt id="Base.Hermitian">
<code class="descname">Hermitian</code><span class="sig-paren">(</span><em>A</em>, <em>uplo=:U</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.Hermitian" title="Permalink to this definition"></a></dt>
<dd><p>Construct a <code class="docutils literal"><span class="pre">Hermitian</span></code> matrix from the upper (if <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">:U</span></code>) or lower (if <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">:L</span></code>) triangle of <code class="docutils literal"><span class="pre">A</span></code>.</p>
<p><strong>Example</strong></p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">=</span> <span class="n">randn</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span>
<span class="n">Hupper</span> <span class="o">=</span> <span class="n">Hermitian</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="n">Hlower</span> <span class="o">=</span> <span class="n">Hermitian</span><span class="p">(</span><span class="n">A</span><span class="p">,:</span><span class="n">L</span><span class="p">)</span>
<span class="n">eigfact</span><span class="p">(</span><span class="n">Hupper</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">eigfact</span></code> will use a method specialized for matrices known to be Hermitian. Note that <code class="docutils literal"><span class="pre">Hupper</span></code> will not be equal to <code class="docutils literal"><span class="pre">Hlower</span></code> unless <code class="docutils literal"><span class="pre">A</span></code> is itself Hermitian (e.g. if <code class="docutils literal"><span class="pre">A</span> <span class="pre">==</span> <span class="pre">A'</span></code>).</p>
</dd></dl>

<dl class="function">
<dt id="Base.lu">
<code class="descname">lu</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span> &rarr; L, U, p<a class="headerlink" href="#Base.lu" title="Permalink to this definition"></a></dt>
<dd><p>Compute the LU factorization of <code class="docutils literal"><span class="pre">A</span></code>, such that <code class="docutils literal"><span class="pre">A[p,:]</span> <span class="pre">=</span> <span class="pre">L*U</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.lufact">
<code class="descname">lufact</code><span class="sig-paren">(</span><em>A</em><span class="optional">[</span>, <em>pivot=Val{true}</em><span class="optional">]</span><span class="sig-paren">)</span> &rarr; F::LU<a class="headerlink" href="#Base.lufact" title="Permalink to this definition"></a></dt>
<dd><p>Compute the LU factorization of <code class="docutils literal"><span class="pre">A</span></code>.</p>
<p>In most cases, if <code class="docutils literal"><span class="pre">A</span></code> is a subtype <code class="docutils literal"><span class="pre">S</span></code> of <code class="docutils literal"><span class="pre">AbstractMatrix{T}</span></code> with an element type <code class="docutils literal"><span class="pre">T</span></code> supporting <code class="docutils literal"><span class="pre">+</span></code>, <code class="docutils literal"><span class="pre">-</span></code>, <code class="docutils literal"><span class="pre">*</span></code> and <code class="docutils literal"><span class="pre">/</span></code>, the return type is <code class="docutils literal"><span class="pre">LU{T,S{T}}</span></code>. If pivoting is chosen (default) the element type should also support <code class="docutils literal"><span class="pre">abs</span></code> and <code class="docutils literal"><span class="pre">&lt;</span></code>.</p>
<p>The individual components of the factorization <code class="docutils literal"><span class="pre">F</span></code> can be accessed by indexing:</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Component</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">F[:L]</span></code></td>
<td><code class="docutils literal"><span class="pre">L</span></code> (lower triangular) part of <code class="docutils literal"><span class="pre">LU</span></code></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">F[:U]</span></code></td>
<td><code class="docutils literal"><span class="pre">U</span></code> (upper triangular) part of <code class="docutils literal"><span class="pre">LU</span></code></td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">F[:p]</span></code></td>
<td>(right) permutation <code class="docutils literal"><span class="pre">Vector</span></code></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">F[:P]</span></code></td>
<td>(right) permutation <code class="docutils literal"><span class="pre">Matrix</span></code></td>
</tr>
</tbody>
</table>
<p>The relationship between <code class="docutils literal"><span class="pre">F</span></code> and <code class="docutils literal"><span class="pre">A</span></code> is</p>
<p><code class="docutils literal"><span class="pre">F[:L]*F[:U]</span> <span class="pre">==</span> <span class="pre">A[F[:p],</span> <span class="pre">:]</span></code></p>
<p><code class="docutils literal"><span class="pre">F</span></code> further supports the following functions:</p>
<table border="1" class="docutils">
<colgroup>
<col width="37%" />
<col width="15%" />
<col width="48%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Supported function</th>
<th class="head"><code class="docutils literal"><span class="pre">LU</span></code></th>
<th class="head"><code class="docutils literal"><span class="pre">LU{T,Tridiagonal{T}}</span></code></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><a class="reference internal" href="../math/#Base./" title="Base./"><code class="xref jl jl-func docutils literal"><span class="pre">/()</span></code></a></td>
<td></td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="../math/#Base.\" title="Base.\"><code class="xref jl jl-func docutils literal"><span class="pre">\()</span></code></a></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Base.cond" title="Base.cond"><code class="xref jl jl-func docutils literal"><span class="pre">cond()</span></code></a></td>
<td></td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Base.det" title="Base.det"><code class="xref jl jl-func docutils literal"><span class="pre">det()</span></code></a></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Base.logdet" title="Base.logdet"><code class="xref jl jl-func docutils literal"><span class="pre">logdet()</span></code></a></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Base.logabsdet" title="Base.logabsdet"><code class="xref jl jl-func docutils literal"><span class="pre">logabsdet()</span></code></a></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="../arrays/#Base.size" title="Base.size"><code class="xref jl jl-func docutils literal"><span class="pre">size()</span></code></a></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">lufact</code><span class="sig-paren">(</span><em>A::SparseMatrixCSC</em><span class="sig-paren">)</span> &rarr; F::UmfpackLU</dt>
<dd><p>Compute the LU factorization of a sparse matrix <code class="docutils literal"><span class="pre">A</span></code>.</p>
<p>For sparse <code class="docutils literal"><span class="pre">A</span></code> with real or complex element type, the return type of <code class="docutils literal"><span class="pre">F</span></code> is <code class="docutils literal"><span class="pre">UmfpackLU{Tv,</span> <span class="pre">Ti}</span></code>, with <code class="docutils literal"><span class="pre">Tv</span></code> = <code class="docutils literal"><span class="pre">Float64</span></code> or <code class="docutils literal"><span class="pre">Complex128</span></code> respectively and <code class="docutils literal"><span class="pre">Ti</span></code> is an integer type (<code class="docutils literal"><span class="pre">Int32</span></code> or <code class="docutils literal"><span class="pre">Int64</span></code>).</p>
<p>The individual components of the factorization <code class="docutils literal"><span class="pre">F</span></code> can be accessed by indexing:</p>
<table border="1" class="docutils">
<colgroup>
<col width="24%" />
<col width="76%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Component</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">F[:L]</span></code></td>
<td><code class="docutils literal"><span class="pre">L</span></code> (lower triangular) part of <code class="docutils literal"><span class="pre">LU</span></code></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">F[:U]</span></code></td>
<td><code class="docutils literal"><span class="pre">U</span></code> (upper triangular) part of <code class="docutils literal"><span class="pre">LU</span></code></td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">F[:p]</span></code></td>
<td>right permutation <code class="docutils literal"><span class="pre">Vector</span></code></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">F[:q]</span></code></td>
<td>left permutation <code class="docutils literal"><span class="pre">Vector</span></code></td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">F[:Rs]</span></code></td>
<td><code class="docutils literal"><span class="pre">Vector</span></code> of scaling factors</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">F[:(:)]</span></code></td>
<td><code class="docutils literal"><span class="pre">(L,U,p,q,Rs)</span></code> components</td>
</tr>
</tbody>
</table>
<p>The relation between <code class="docutils literal"><span class="pre">F</span></code> and <code class="docutils literal"><span class="pre">A</span></code> is</p>
<p><code class="docutils literal"><span class="pre">F[:L]*F[:U]</span> <span class="pre">==</span> <span class="pre">(F[:Rs]</span> <span class="pre">.*</span> <span class="pre">A)[F[:p],</span> <span class="pre">F[:q]]</span></code></p>
<p><code class="docutils literal"><span class="pre">F</span></code> further supports the following functions:</p>
<ul class="simple">
<li><a class="reference internal" href="../math/#Base.\" title="Base.\"><code class="xref jl jl-func docutils literal"><span class="pre">\()</span></code></a></li>
<li><a class="reference internal" href="#Base.cond" title="Base.cond"><code class="xref jl jl-func docutils literal"><span class="pre">cond()</span></code></a></li>
<li><a class="reference internal" href="#Base.det" title="Base.det"><code class="xref jl jl-func docutils literal"><span class="pre">det()</span></code></a></li>
</ul>
<p>** Implementation note **</p>
<p><code class="docutils literal"><span class="pre">lufact(A::SparseMatrixCSC)</span></code> uses the UMFPACK library that is part of SuiteSparse. As this library only supports sparse matrices with <code class="docutils literal"><span class="pre">Float64</span></code> or <code class="docutils literal"><span class="pre">Complex128</span></code> elements, <code class="docutils literal"><span class="pre">lufact</span></code> converts <code class="docutils literal"><span class="pre">A</span></code> into a copy that is of type <code class="docutils literal"><span class="pre">SparseMatrixCSC{Float64}</span></code> or <code class="docutils literal"><span class="pre">SparseMatrixCSC{Complex128}</span></code> as appropriate.</p>
</dd></dl>

<dl class="function">
<dt id="Base.lufact!">
<code class="descname">lufact!</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span> &rarr; LU<a class="headerlink" href="#Base.lufact!" title="Permalink to this definition"></a></dt>
<dd><p><code class="docutils literal"><span class="pre">lufact!</span></code> is the same as <a class="reference internal" href="#Base.lufact" title="Base.lufact"><code class="xref jl jl-func docutils literal"><span class="pre">lufact()</span></code></a>, but saves space by overwriting the input <code class="docutils literal"><span class="pre">A</span></code>, instead of creating a copy. An <code class="docutils literal"><span class="pre">InexactError</span></code> exception is thrown if the factorisation produces a number not representable by the element type of <code class="docutils literal"><span class="pre">A</span></code>, e.g. for integer types.</p>
</dd></dl>

<dl class="function">
<dt id="Base.chol">
<code class="descname">chol</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span> &rarr; U<a class="headerlink" href="#Base.chol" title="Permalink to this definition"></a></dt>
<dd><p>Compute the Cholesky factorization of a positive definite matrix <code class="docutils literal"><span class="pre">A</span></code> and return the UpperTriangular matrix <code class="docutils literal"><span class="pre">U</span></code> such that <code class="docutils literal"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">U'U</span></code>.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">chol</code><span class="sig-paren">(</span><em>x::Number</em><span class="sig-paren">)</span> &rarr; y</dt>
<dd><p>Compute the square root of a non-negative number <code class="docutils literal"><span class="pre">x</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.cholfact">
<code class="descname">cholfact</code><span class="sig-paren">(</span><em>A</em>, <span class="optional">[</span><em>uplo::Symbol</em>, <span class="optional">]</span><em>Val{false}</em><span class="sig-paren">)</span> &rarr; Cholesky<a class="headerlink" href="#Base.cholfact" title="Permalink to this definition"></a></dt>
<dd><p>Compute the Cholesky factorization of a dense symmetric positive definite matrix <code class="docutils literal"><span class="pre">A</span></code> and return a <code class="docutils literal"><span class="pre">Cholesky</span></code> factorization. The matrix <code class="docutils literal"><span class="pre">A</span></code> can either be a <code class="docutils literal"><span class="pre">Symmetric</span></code> or <code class="docutils literal"><span class="pre">Hermitian</span></code> <code class="docutils literal"><span class="pre">StridedMatrix</span></code> or a <em>perfectly</em> symmetric or Hermitian <code class="docutils literal"><span class="pre">StridedMatrix</span></code>. In the latter case, the optional argument <code class="docutils literal"><span class="pre">uplo</span></code> may be <code class="docutils literal"><span class="pre">:L</span></code> for using the lower part or <code class="docutils literal"><span class="pre">:U</span></code> for the upper part of <code class="docutils literal"><span class="pre">A</span></code>. The default is to use <code class="docutils literal"><span class="pre">:U</span></code>. The triangular Cholesky factor can be obtained from the factorization <code class="docutils literal"><span class="pre">F</span></code> with: <code class="docutils literal"><span class="pre">F[:L]</span></code> and <code class="docutils literal"><span class="pre">F[:U]</span></code>. The following functions are available for <code class="docutils literal"><span class="pre">Cholesky</span></code> objects: <code class="docutils literal"><span class="pre">size</span></code>, <code class="docutils literal"><span class="pre">\</span></code>, <code class="docutils literal"><span class="pre">inv</span></code>, <code class="docutils literal"><span class="pre">det</span></code>. A <code class="docutils literal"><span class="pre">PosDefException</span></code> exception is thrown in case the matrix is not positive definite.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">cholfact</code><span class="sig-paren">(</span><em>A</em>, <span class="optional">[</span><em>uplo::Symbol</em>, <span class="optional">]</span><em>Val{true}; tol = 0.0</em><span class="sig-paren">)</span> &rarr; CholeskyPivoted</dt>
<dd><p>Compute the pivoted Cholesky factorization of a dense symmetric positive semi-definite matrix <code class="docutils literal"><span class="pre">A</span></code> and return a <code class="docutils literal"><span class="pre">CholeskyPivoted</span></code> factorization. The matrix <code class="docutils literal"><span class="pre">A</span></code> can either be a <code class="docutils literal"><span class="pre">Symmetric</span></code> or <code class="docutils literal"><span class="pre">Hermitian</span></code> <code class="docutils literal"><span class="pre">StridedMatrix</span></code> or a <em>perfectly</em> symmetric or Hermitian <code class="docutils literal"><span class="pre">StridedMatrix</span></code>. In the latter case, the optional argument <code class="docutils literal"><span class="pre">uplo</span></code> may be <code class="docutils literal"><span class="pre">:L</span></code> for using the lower part or <code class="docutils literal"><span class="pre">:U</span></code> for the upper part of <code class="docutils literal"><span class="pre">A</span></code>. The default is to use <code class="docutils literal"><span class="pre">:U</span></code>. The triangular Cholesky factor can be obtained from the factorization <code class="docutils literal"><span class="pre">F</span></code> with: <code class="docutils literal"><span class="pre">F[:L]</span></code> and <code class="docutils literal"><span class="pre">F[:U]</span></code>. The following functions are available for <code class="docutils literal"><span class="pre">PivotedCholesky</span></code> objects: <code class="docutils literal"><span class="pre">size</span></code>, <code class="docutils literal"><span class="pre">\</span></code>, <code class="docutils literal"><span class="pre">inv</span></code>, <code class="docutils literal"><span class="pre">det</span></code>, and <code class="docutils literal"><span class="pre">rank</span></code>. The argument <code class="docutils literal"><span class="pre">tol</span></code> determines the tolerance for determining the rank. For negative values, the tolerance is the machine precision.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">cholfact</code><span class="sig-paren">(</span><em>A; shift = 0.0</em>, <em>perm = Int[]</em><span class="sig-paren">)</span> &rarr; CHOLMOD.Factor</dt>
<dd><p>Compute the Cholesky factorization of a sparse positive definite matrix <code class="docutils literal"><span class="pre">A</span></code>. <code class="docutils literal"><span class="pre">A</span></code> must be a <code class="docutils literal"><span class="pre">SparseMatrixCSC</span></code>, <code class="docutils literal"><span class="pre">Symmetric{SparseMatrixCSC}</span></code>, or <code class="docutils literal"><span class="pre">Hermitian{SparseMatrixCSC}</span></code>. Note that even if <code class="docutils literal"><span class="pre">A</span></code> doesn&#8217;t have the type tag, it must still be symmetric or Hermitian. A fill-reducing permutation is used. <code class="docutils literal"><span class="pre">F</span> <span class="pre">=</span> <span class="pre">cholfact(A)</span></code> is most frequently used to solve systems of equations with <code class="docutils literal"><span class="pre">F\b</span></code>, but also the methods <code class="docutils literal"><span class="pre">diag</span></code>, <code class="docutils literal"><span class="pre">det</span></code>, <code class="docutils literal"><span class="pre">logdet</span></code> are defined for <code class="docutils literal"><span class="pre">F</span></code>. You can also extract individual factors from <code class="docutils literal"><span class="pre">F</span></code>, using <code class="docutils literal"><span class="pre">F[:L]</span></code>. However, since pivoting is on by default, the factorization is internally represented as <code class="docutils literal"><span class="pre">A</span> <span class="pre">==</span> <span class="pre">P'*L*L'*P</span></code> with a permutation matrix <code class="docutils literal"><span class="pre">P</span></code>; using just <code class="docutils literal"><span class="pre">L</span></code> without accounting for <code class="docutils literal"><span class="pre">P</span></code> will give incorrect answers. To include the effects of permutation, it&#8217;s typically preferable to extact &#8220;combined&#8221; factors like <code class="docutils literal"><span class="pre">PtL</span> <span class="pre">=</span> <span class="pre">F[:PtL]</span></code> (the equivalent of <code class="docutils literal"><span class="pre">P'*L</span></code>) and <code class="docutils literal"><span class="pre">LtP</span> <span class="pre">=</span> <span class="pre">F[:UP]</span></code> (the equivalent of <code class="docutils literal"><span class="pre">L'*P</span></code>).</p>
<p>Setting optional <code class="docutils literal"><span class="pre">shift</span></code> keyword argument computes the factorization of <code class="docutils literal"><span class="pre">A+shift*I</span></code> instead of <code class="docutils literal"><span class="pre">A</span></code>. If the <code class="docutils literal"><span class="pre">perm</span></code> argument is nonempty, it should be a permutation of <code class="docutils literal"><span class="pre">1:size(A,1)</span></code> giving the ordering to use (instead of CHOLMOD&#8217;s default AMD ordering).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>This method uses the CHOLMOD library from SuiteSparse, which only supports doubles or complex doubles. Input matrices not of those element types will be converted to <code class="docutils literal"><span class="pre">SparseMatrixCSC{Float64}</span></code> or <code class="docutils literal"><span class="pre">SparseMatrixCSC{Complex128}</span></code> as appropriate.</p>
<p class="last">Many other functions from CHOLMOD are wrapped but not exported from the <code class="docutils literal"><span class="pre">Base.SparseArrays.CHOLMOD</span></code> module.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="Base.cholfact!">
<code class="descname">cholfact!</code><span class="sig-paren">(</span><em>F::Factor</em>, <em>A; shift = 0.0</em><span class="sig-paren">)</span> &rarr; CHOLMOD.Factor<a class="headerlink" href="#Base.cholfact!" title="Permalink to this definition"></a></dt>
<dd><p>Compute the Cholesky (<span class="math">\(LL'\)</span>) factorization of <code class="docutils literal"><span class="pre">A</span></code>, reusing the symbolic factorization <code class="docutils literal"><span class="pre">F</span></code>. <code class="docutils literal"><span class="pre">A</span></code> must be a <code class="docutils literal"><span class="pre">SparseMatrixCSC</span></code>, <code class="docutils literal"><span class="pre">Symmetric{SparseMatrixCSC}</span></code>, or <code class="docutils literal"><span class="pre">Hermitian{SparseMatrixCSC}</span></code>. Note that even if <code class="docutils literal"><span class="pre">A</span></code> doesn&#8217;t have the type tag, it must still be symmetric or Hermitian.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This method uses the CHOLMOD library from SuiteSparse, which only supports doubles or complex doubles. Input matrices not of those element types will be converted to <code class="docutils literal"><span class="pre">SparseMatrixCSC{Float64}</span></code> or <code class="docutils literal"><span class="pre">SparseMatrixCSC{Complex128}</span></code> as appropriate.</p>
</div>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">cholfact!</code><span class="sig-paren">(</span><em>A</em>, <span class="optional">[</span><em>uplo::Symbol</em>, <span class="optional">]</span><em>Val{false}</em><span class="sig-paren">)</span> &rarr; Cholesky</dt>
<dd><p>The same as <code class="docutils literal"><span class="pre">cholfact</span></code>, but saves space by overwriting the input <code class="docutils literal"><span class="pre">A</span></code>, instead of creating a copy. An <code class="docutils literal"><span class="pre">InexactError</span></code> exception is thrown if the factorisation produces a number not representable by the element type of <code class="docutils literal"><span class="pre">A</span></code>, e.g. for integer types.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">cholfact!</code><span class="sig-paren">(</span><em>A</em>, <span class="optional">[</span><em>uplo::Symbol</em>, <span class="optional">]</span><em>Val{true}; tol = 0.0</em><span class="sig-paren">)</span> &rarr; CholeskyPivoted</dt>
<dd><p>The same as <code class="docutils literal"><span class="pre">cholfact</span></code>, but saves space by overwriting the input <code class="docutils literal"><span class="pre">A</span></code>, instead of creating a copy. An <code class="docutils literal"><span class="pre">InexactError</span></code> exception is thrown if the factorisation produces a number not representable by the element type of <code class="docutils literal"><span class="pre">A</span></code>, e.g. for integer types.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.lowrankupdate">
<code class="descname">lowrankupdate</code><span class="sig-paren">(</span><em>C::Cholesky</em>, <em>v::StridedVector</em><span class="sig-paren">)</span> &rarr; CC::Cholesky<a class="headerlink" href="#Base.LinAlg.lowrankupdate" title="Permalink to this definition"></a></dt>
<dd><p>Update a Cholesky factorization <code class="docutils literal"><span class="pre">C</span></code> with the vector <code class="docutils literal"><span class="pre">v</span></code>. If <code class="docutils literal"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">C[:U]'C[:U]</span></code> then <code class="docutils literal"><span class="pre">CC</span> <span class="pre">=</span> <span class="pre">cholfact(C[:U]'C[:U]</span> <span class="pre">+</span> <span class="pre">v*v')</span></code> but the computation of <code class="docutils literal"><span class="pre">CC</span></code> only uses <code class="docutils literal"><span class="pre">O(n^2)</span></code> operations.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.lowrankdowndate">
<code class="descname">lowrankdowndate</code><span class="sig-paren">(</span><em>C::Cholesky</em>, <em>v::StridedVector</em><span class="sig-paren">)</span> &rarr; CC::Cholesky<a class="headerlink" href="#Base.LinAlg.lowrankdowndate" title="Permalink to this definition"></a></dt>
<dd><p>Downdate a Cholesky factorization <code class="docutils literal"><span class="pre">C</span></code> with the vector <code class="docutils literal"><span class="pre">v</span></code>. If <code class="docutils literal"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">C[:U]'C[:U]</span></code> then <code class="docutils literal"><span class="pre">CC</span> <span class="pre">=</span> <span class="pre">cholfact(C[:U]'C[:U]</span> <span class="pre">-</span> <span class="pre">v*v')</span></code> but the computation of <code class="docutils literal"><span class="pre">CC</span></code> only uses <code class="docutils literal"><span class="pre">O(n^2)</span></code> operations.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.lowrankupdate!">
<code class="descname">lowrankupdate!</code><span class="sig-paren">(</span><em>C::Cholesky</em>, <em>v::StridedVector</em><span class="sig-paren">)</span> &rarr; CC::Cholesky<a class="headerlink" href="#Base.LinAlg.lowrankupdate!" title="Permalink to this definition"></a></dt>
<dd><p>Update a Cholesky factorization <code class="docutils literal"><span class="pre">C</span></code> with the vector <code class="docutils literal"><span class="pre">v</span></code>. If <code class="docutils literal"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">C[:U]'C[:U]</span></code> then <code class="docutils literal"><span class="pre">CC</span> <span class="pre">=</span> <span class="pre">cholfact(C[:U]'C[:U]</span> <span class="pre">+</span> <span class="pre">v*v')</span></code> but the computation of <code class="docutils literal"><span class="pre">CC</span></code> only uses <code class="docutils literal"><span class="pre">O(n^2)</span></code> operations. The input factorization <code class="docutils literal"><span class="pre">C</span></code> is updated in place such that on exit <code class="docutils literal"><span class="pre">C</span> <span class="pre">==</span> <span class="pre">CC</span></code>. The vector <code class="docutils literal"><span class="pre">v</span></code> is destroyed during the computation.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.lowrankdowndate!">
<code class="descname">lowrankdowndate!</code><span class="sig-paren">(</span><em>C::Cholesky</em>, <em>v::StridedVector</em><span class="sig-paren">)</span> &rarr; CC::Cholesky<a class="headerlink" href="#Base.LinAlg.lowrankdowndate!" title="Permalink to this definition"></a></dt>
<dd><p>Downdate a Cholesky factorization <code class="docutils literal"><span class="pre">C</span></code> with the vector <code class="docutils literal"><span class="pre">v</span></code>. If <code class="docutils literal"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">C[:U]'C[:U]</span></code> then <code class="docutils literal"><span class="pre">CC</span> <span class="pre">=</span> <span class="pre">cholfact(C[:U]'C[:U]</span> <span class="pre">-</span> <span class="pre">v*v')</span></code> but the computation of <code class="docutils literal"><span class="pre">CC</span></code> only uses <code class="docutils literal"><span class="pre">O(n^2)</span></code> operations. The input factorization <code class="docutils literal"><span class="pre">C</span></code> is updated in place such that on exit <code class="docutils literal"><span class="pre">C</span> <span class="pre">==</span> <span class="pre">CC</span></code>. The vector <code class="docutils literal"><span class="pre">v</span></code> is destroyed during the computation.</p>
</dd></dl>

<dl class="function">
<dt id="Base.ldltfact">
<code class="descname">ldltfact</code><span class="sig-paren">(</span><em>::SymTridiagonal</em><span class="sig-paren">)</span> &rarr; LDLt<a class="headerlink" href="#Base.ldltfact" title="Permalink to this definition"></a></dt>
<dd><p>Compute an <code class="docutils literal"><span class="pre">LDLt</span></code> factorization of a real symmetric tridiagonal matrix such that <code class="docutils literal"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">L*Diagonal(d)*L'</span></code> where <code class="docutils literal"><span class="pre">L</span></code> is a unit lower triangular matrix and <code class="docutils literal"><span class="pre">d</span></code> is a vector. The main use of an <code class="docutils literal"><span class="pre">LDLt</span></code> factorization <code class="docutils literal"><span class="pre">F</span> <span class="pre">=</span> <span class="pre">ldltfact(A)</span></code> is to solve the linear system of equations <code class="docutils literal"><span class="pre">Ax</span> <span class="pre">=</span> <span class="pre">b</span></code> with <code class="docutils literal"><span class="pre">F\b</span></code>.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">ldltfact</code><span class="sig-paren">(</span><em>A; shift = 0.0</em>, <em>perm=Int[]</em><span class="sig-paren">)</span> &rarr; CHOLMOD.Factor</dt>
<dd><p>Compute the <span class="math">\(LDL'\)</span> factorization of a sparse matrix <code class="docutils literal"><span class="pre">A</span></code>. <code class="docutils literal"><span class="pre">A</span></code> must be a <code class="docutils literal"><span class="pre">SparseMatrixCSC</span></code>, <code class="docutils literal"><span class="pre">Symmetric{SparseMatrixCSC}</span></code>, or <code class="docutils literal"><span class="pre">Hermitian{SparseMatrixCSC}</span></code>. Note that even if <code class="docutils literal"><span class="pre">A</span></code> doesn&#8217;t have the type tag, it must still be symmetric or Hermitian. A fill-reducing permutation is used. <code class="docutils literal"><span class="pre">F</span> <span class="pre">=</span> <span class="pre">ldltfact(A)</span></code> is most frequently used to solve systems of equations <code class="docutils literal"><span class="pre">A*x</span> <span class="pre">=</span> <span class="pre">b</span></code> with <code class="docutils literal"><span class="pre">F\b</span></code>. The returned factorization object <code class="docutils literal"><span class="pre">F</span></code> also supports the methods <code class="docutils literal"><span class="pre">diag</span></code>, <code class="docutils literal"><span class="pre">det</span></code>, and <code class="docutils literal"><span class="pre">logdet</span></code>. You can extract individual factors from <code class="docutils literal"><span class="pre">F</span></code> using <code class="docutils literal"><span class="pre">F[:L]</span></code>. However, since pivoting is on by default, the factorization is internally represented as <code class="docutils literal"><span class="pre">A</span> <span class="pre">==</span> <span class="pre">P'*L*D*L'*P</span></code> with a permutation matrix <code class="docutils literal"><span class="pre">P</span></code>; using just <code class="docutils literal"><span class="pre">L</span></code> without accounting for <code class="docutils literal"><span class="pre">P</span></code> will give incorrect answers. To include the effects of permutation, it is typically preferable to extact &#8220;combined&#8221; factors like <code class="docutils literal"><span class="pre">PtL</span> <span class="pre">=</span> <span class="pre">F[:PtL]</span></code> (the equivalent of <code class="docutils literal"><span class="pre">P'*L</span></code>) and <code class="docutils literal"><span class="pre">LtP</span> <span class="pre">=</span> <span class="pre">F[:UP]</span></code> (the equivalent of <code class="docutils literal"><span class="pre">L'*P</span></code>). The complete list of supported factors is <code class="docutils literal"><span class="pre">:L,</span> <span class="pre">:PtL,</span> <span class="pre">:D,</span> <span class="pre">:UP,</span> <span class="pre">:U,</span> <span class="pre">:LD,</span> <span class="pre">:DU,</span> <span class="pre">:PtLD,</span> <span class="pre">:DUP</span></code>.</p>
<p>Setting optional <code class="docutils literal"><span class="pre">shift</span></code> keyword argument computes the factorization of <code class="docutils literal"><span class="pre">A+shift*I</span></code> instead of <code class="docutils literal"><span class="pre">A</span></code>. If the <code class="docutils literal"><span class="pre">perm</span></code> argument is nonempty, it should be a permutation of <code class="docutils literal"><span class="pre">1:size(A,1)</span></code> giving the ordering to use (instead of CHOLMOD&#8217;s default AMD ordering).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>This method uses the CHOLMOD library from SuiteSparse, which only supports doubles or complex doubles. Input matrices not of those element types will be converted to <code class="docutils literal"><span class="pre">SparseMatrixCSC{Float64}</span></code> or <code class="docutils literal"><span class="pre">SparseMatrixCSC{Complex128}</span></code> as appropriate.</p>
<p class="last">Many other functions from CHOLMOD are wrapped but not exported from the <code class="docutils literal"><span class="pre">Base.SparseArrays.CHOLMOD</span></code> module.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="Base.ldltfact!">
<code class="descname">ldltfact!</code><span class="sig-paren">(</span><em>F::Factor</em>, <em>A; shift = 0.0</em><span class="sig-paren">)</span> &rarr; CHOLMOD.Factor<a class="headerlink" href="#Base.ldltfact!" title="Permalink to this definition"></a></dt>
<dd><p>Compute the <span class="math">\(LDL'\)</span> factorization of <code class="docutils literal"><span class="pre">A</span></code>, reusing the symbolic factorization <code class="docutils literal"><span class="pre">F</span></code>. <code class="docutils literal"><span class="pre">A</span></code> must be a <code class="docutils literal"><span class="pre">SparseMatrixCSC</span></code>, <code class="docutils literal"><span class="pre">Symmetric{SparseMatrixCSC}</span></code>, or <code class="docutils literal"><span class="pre">Hermitian{SparseMatrixCSC}</span></code>. Note that even if <code class="docutils literal"><span class="pre">A</span></code> doesn&#8217;t have the type tag, it must still be symmetric or Hermitian.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This method uses the CHOLMOD library from SuiteSparse, which only supports doubles or complex doubles. Input matrices not of those element types will be converted to <code class="docutils literal"><span class="pre">SparseMatrixCSC{Float64}</span></code> or <code class="docutils literal"><span class="pre">SparseMatrixCSC{Complex128}</span></code> as appropriate.</p>
</div>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">ldltfact!</code><span class="sig-paren">(</span><em>::SymTridiagonal</em><span class="sig-paren">)</span> &rarr; LDLt</dt>
<dd><p>Same as <code class="docutils literal"><span class="pre">ldltfact</span></code>, but saves space by overwriting the input <code class="docutils literal"><span class="pre">A</span></code>, instead of creating a copy.</p>
</dd></dl>

<dl class="function">
<dt id="Base.qr">
<code class="descname">qr</code><span class="sig-paren">(</span><em>v::AbstractVector</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.qr" title="Permalink to this definition"></a></dt>
<dd><p>Computes the polar decomposition of a vector.</p>
<p>Input:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">v::AbstractVector</span></code> - vector to normalize</li>
</ul>
<p>Outputs:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">w</span></code> - A unit vector in the direction of <code class="docutils literal"><span class="pre">v</span></code></li>
<li><code class="docutils literal"><span class="pre">r</span></code> - The norm of <code class="docutils literal"><span class="pre">v</span></code></li>
</ul>
<p>See also:</p>
<p><code class="docutils literal"><span class="pre">normalize</span></code>, <code class="docutils literal"><span class="pre">normalize!</span></code>, <code class="docutils literal"><span class="pre">LinAlg.qr!</span></code></p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.qr!">
<code class="descclassname">LinAlg.</code><code class="descname">qr!</code><span class="sig-paren">(</span><em>v::AbstractVector</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.qr!" title="Permalink to this definition"></a></dt>
<dd><p>Computes the polar decomposition of a vector. Instead of returning a new vector as <code class="docutils literal"><span class="pre">qr(v::AbstractVector)</span></code>, this function mutates the input vector <code class="docutils literal"><span class="pre">v</span></code> in place.</p>
<p>Input:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">v::AbstractVector</span></code> - vector to normalize</li>
</ul>
<p>Outputs:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">w</span></code> - A unit vector in the direction of <code class="docutils literal"><span class="pre">v</span></code> (This is a mutation of <code class="docutils literal"><span class="pre">v</span></code>).</li>
<li><code class="docutils literal"><span class="pre">r</span></code> - The norm of <code class="docutils literal"><span class="pre">v</span></code></li>
</ul>
<p>See also:</p>
<p><code class="docutils literal"><span class="pre">normalize</span></code>, <code class="docutils literal"><span class="pre">normalize!</span></code>, <code class="docutils literal"><span class="pre">qr</span></code></p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">qr</code><span class="sig-paren">(</span><em>A</em><span class="optional">[</span>, <em>pivot=Val{false}][;thin=true</em><span class="optional">]</span><span class="sig-paren">)</span> &rarr; Q, R, [p]</dt>
<dd><p>Compute the (pivoted) QR factorization of <code class="docutils literal"><span class="pre">A</span></code> such that either <code class="docutils literal"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">Q*R</span></code> or <code class="docutils literal"><span class="pre">A[:,p]</span> <span class="pre">=</span> <span class="pre">Q*R</span></code>. Also see <code class="docutils literal"><span class="pre">qrfact</span></code>. The default is to compute a thin factorization. Note that <code class="docutils literal"><span class="pre">R</span></code> is not extended with zeros when the full <code class="docutils literal"><span class="pre">Q</span></code> is requested.</p>
</dd></dl>

<dl class="function">
<dt id="Base.qrfact">
<code class="descname">qrfact</code><span class="sig-paren">(</span><em>A</em><span class="optional">[</span>, <em>pivot=Val{false}</em><span class="optional">]</span><span class="sig-paren">)</span> &rarr; F<a class="headerlink" href="#Base.qrfact" title="Permalink to this definition"></a></dt>
<dd><p>Computes the QR factorization of <code class="docutils literal"><span class="pre">A</span></code>. The return type of <code class="docutils literal"><span class="pre">F</span></code> depends on the element type of <code class="docutils literal"><span class="pre">A</span></code> and whether pivoting is specified (with <code class="docutils literal"><span class="pre">pivot==Val{true}</span></code>).</p>
<table border="1" class="docutils">
<colgroup>
<col width="19%" />
<col width="21%" />
<col width="18%" />
<col width="42%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Return type</th>
<th class="head"><code class="docutils literal"><span class="pre">eltype(A)</span></code></th>
<th class="head"><code class="docutils literal"><span class="pre">pivot</span></code></th>
<th class="head">Relationship between <code class="docutils literal"><span class="pre">F</span></code> and <code class="docutils literal"><span class="pre">A</span></code></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">QR</span></code></td>
<td>not <code class="docutils literal"><span class="pre">BlasFloat</span></code></td>
<td>either</td>
<td><code class="docutils literal"><span class="pre">A==F[:Q]*F[:R]</span></code></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">QRCompactWY</span></code></td>
<td><code class="docutils literal"><span class="pre">BlasFloat</span></code></td>
<td><code class="docutils literal"><span class="pre">Val{false}</span></code></td>
<td><code class="docutils literal"><span class="pre">A==F[:Q]*F[:R]</span></code></td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">QRPivoted</span></code></td>
<td><code class="docutils literal"><span class="pre">BlasFloat</span></code></td>
<td><code class="docutils literal"><span class="pre">Val{true}</span></code></td>
<td><code class="docutils literal"><span class="pre">A[:,F[:p]]==F[:Q]*F[:R]</span></code></td>
</tr>
</tbody>
</table>
<p><code class="docutils literal"><span class="pre">BlasFloat</span></code> refers to any of: <code class="docutils literal"><span class="pre">Float32</span></code>, <code class="docutils literal"><span class="pre">Float64</span></code>, <code class="docutils literal"><span class="pre">Complex64</span></code> or <code class="docutils literal"><span class="pre">Complex128</span></code>.</p>
<p>The individual components of the factorization <code class="docutils literal"><span class="pre">F</span></code> can be accessed by indexing:</p>
<table border="1" class="docutils">
<colgroup>
<col width="9%" />
<col width="38%" />
<col width="17%" />
<col width="19%" />
<col width="17%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Component</th>
<th class="head">Description</th>
<th class="head"><code class="docutils literal"><span class="pre">QR</span></code></th>
<th class="head"><code class="docutils literal"><span class="pre">QRCompactWY</span></code></th>
<th class="head"><code class="docutils literal"><span class="pre">QRPivoted</span></code></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">F[:Q]</span></code></td>
<td><code class="docutils literal"><span class="pre">Q</span></code> (orthogonal/unitary) part of <code class="docutils literal"><span class="pre">QR</span></code></td>
<td> (<code class="docutils literal"><span class="pre">QRPackedQ</span></code>)</td>
<td> (<code class="docutils literal"><span class="pre">QRCompactWYQ</span></code>)</td>
<td> (<code class="docutils literal"><span class="pre">QRPackedQ</span></code>)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">F[:R]</span></code></td>
<td><code class="docutils literal"><span class="pre">R</span></code> (upper right triangular) part of <code class="docutils literal"><span class="pre">QR</span></code></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">F[:p]</span></code></td>
<td>pivot <code class="docutils literal"><span class="pre">Vector</span></code></td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">F[:P]</span></code></td>
<td>(pivot) permutation <code class="docutils literal"><span class="pre">Matrix</span></code></td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td></td>
</tr>
</tbody>
</table>
<p>The following functions are available for the <code class="docutils literal"><span class="pre">QR</span></code> objects: <code class="docutils literal"><span class="pre">size</span></code>, <code class="docutils literal"><span class="pre">\</span></code>. When <code class="docutils literal"><span class="pre">A</span></code> is rectangular, <code class="docutils literal"><span class="pre">\</span></code> will return a least squares solution and if the solution is not unique, the one with smallest norm is returned.</p>
<p>Multiplication with respect to either thin or full <code class="docutils literal"><span class="pre">Q</span></code> is allowed, i.e. both <code class="docutils literal"><span class="pre">F[:Q]*F[:R]</span></code> and <code class="docutils literal"><span class="pre">F[:Q]*A</span></code> are supported. A <code class="docutils literal"><span class="pre">Q</span></code> matrix can be converted into a regular matrix with <a class="reference internal" href="#Base.full" title="Base.full"><code class="xref jl jl-func docutils literal"><span class="pre">full()</span></code></a> which has a named argument <code class="docutils literal"><span class="pre">thin</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p><code class="docutils literal"><span class="pre">qrfact</span></code> returns multiple types because LAPACK uses several representations that minimize the memory storage requirements of products of Householder elementary reflectors, so that the <code class="docutils literal"><span class="pre">Q</span></code> and <code class="docutils literal"><span class="pre">R</span></code> matrices can be stored compactly rather as two separate dense matrices.</p>
<p>The data contained in <code class="docutils literal"><span class="pre">QR</span></code> or <code class="docutils literal"><span class="pre">QRPivoted</span></code> can be used to construct the <code class="docutils literal"><span class="pre">QRPackedQ</span></code> type, which is a compact representation of the rotation matrix:</p>
<div class="math">
\[Q = \prod_{i=1}^{\min(m,n)} (I - \tau_i v_i v_i^T)\]</div>
<p>where <span class="math">\(\tau_i\)</span> is the scale factor and <span class="math">\(v_i\)</span> is the projection vector associated with the <span class="math">\(i^{th}\)</span> Householder elementary reflector.</p>
<p>The data contained in <code class="docutils literal"><span class="pre">QRCompactWY</span></code> can be used to construct the <code class="docutils literal"><span class="pre">QRCompactWYQ</span></code> type, which is a compact representation of the rotation matrix</p>
<div class="math">
\[Q = I + Y T Y^T\]</div>
<p>where <code class="docutils literal"><span class="pre">Y</span></code> is <span class="math">\(m \times r\)</span> lower trapezoidal and <code class="docutils literal"><span class="pre">T</span></code> is <span class="math">\(r \times r\)</span> upper triangular. The <em>compact WY</em> representation <a class="reference internal" href="#schreiber1989" id="id1">[Schreiber1989]</a> is not to be confused with the older, <em>WY</em> representation <a class="reference internal" href="#bischof1987" id="id2">[Bischof1987]</a>. (The LAPACK documentation uses <code class="docutils literal"><span class="pre">V</span></code> in lieu of <code class="docutils literal"><span class="pre">Y</span></code>.)</p>
<table class="docutils citation" frame="void" id="bischof1987" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Bischof1987]</td><td><em>(<a class="fn-backref" href="#id2">1</a>, <a class="fn-backref" href="#id3">2</a>)</em> C Bischof and C Van Loan, &#8220;The WY representation for products of Householder matrices&#8221;, SIAM J Sci Stat Comput 8 (1987), s2-s13. <a class="reference external" href="http://dx.doi.org/10.1137/0908009">doi:10.1137/0908009</a></td></tr>
</tbody>
</table>
<table class="last docutils citation" frame="void" id="schreiber1989" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[Schreiber1989]</a></td><td>R Schreiber and C Van Loan, &#8220;A storage-efficient WY representation for products of Householder transformations&#8221;, SIAM J Sci Stat Comput 10 (1989), 53-57. <a class="reference external" href="http://dx.doi.org/10.1137/0910005">doi:10.1137/0910005</a></td></tr>
</tbody>
</table>
</div>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">qrfact</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span> &rarr; SPQR.Factorization</dt>
<dd><p>Compute the QR factorization of a sparse matrix <code class="docutils literal"><span class="pre">A</span></code>. A fill-reducing permutation is used. The main application of this type is to solve least squares problems with <code class="docutils literal"><span class="pre">\</span></code>. The function calls the C library SPQR and a few additional functions from the library are wrapped but not exported.</p>
</dd></dl>

<dl class="function">
<dt id="Base.qrfact!">
<code class="descname">qrfact!</code><span class="sig-paren">(</span><em>A</em><span class="optional">[</span>, <em>pivot=Val{false}</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#Base.qrfact!" title="Permalink to this definition"></a></dt>
<dd><p><code class="docutils literal"><span class="pre">qrfact!</span></code> is the same as <a class="reference internal" href="#Base.qrfact" title="Base.qrfact"><code class="xref jl jl-func docutils literal"><span class="pre">qrfact()</span></code></a> when <code class="docutils literal"><span class="pre">A</span></code> is a subtype of <code class="docutils literal"><span class="pre">StridedMatrix</span></code>, but saves space by overwriting the input <code class="docutils literal"><span class="pre">A</span></code>, instead of creating a copy. An <code class="docutils literal"><span class="pre">InexactError</span></code> exception is thrown if the factorisation produces a number not representable by the element type of <code class="docutils literal"><span class="pre">A</span></code>, e.g. for integer types.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">full</code><span class="sig-paren">(</span><em>QRCompactWYQ</em><span class="optional">[</span>, <em>thin=true</em><span class="optional">]</span><span class="sig-paren">)</span> &rarr; Matrix</dt>
<dd><p>Converts an orthogonal or unitary matrix stored as a <code class="docutils literal"><span class="pre">QRCompactWYQ</span></code> object, i.e. in the compact WY format <a class="reference internal" href="#bischof1987" id="id3">[Bischof1987]</a>, to a dense matrix.</p>
<p>Optionally takes a <code class="docutils literal"><span class="pre">thin</span></code> Boolean argument, which if <code class="docutils literal"><span class="pre">true</span></code> omits the columns that span the rows of <code class="docutils literal"><span class="pre">R</span></code> in the QR factorization that are zero. The resulting matrix is the <code class="docutils literal"><span class="pre">Q</span></code> in a thin QR factorization (sometimes called the reduced QR factorization). If <code class="docutils literal"><span class="pre">false</span></code>, returns a <code class="docutils literal"><span class="pre">Q</span></code> that spans all rows of <code class="docutils literal"><span class="pre">R</span></code> in its corresponding QR factorization.</p>
</dd></dl>

<dl class="function">
<dt id="Base.lqfact!">
<code class="descname">lqfact!</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span> &rarr; LQ<a class="headerlink" href="#Base.lqfact!" title="Permalink to this definition"></a></dt>
<dd><p>Compute the LQ factorization of <code class="docutils literal"><span class="pre">A</span></code>, using the input matrix as a workspace. See also <a class="reference internal" href="#Base.lq" title="Base.lq"><code class="xref jl jl-func docutils literal"><span class="pre">lq()</span></code></a>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.lqfact">
<code class="descname">lqfact</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span> &rarr; LQ<a class="headerlink" href="#Base.lqfact" title="Permalink to this definition"></a></dt>
<dd><p>Compute the LQ factorization of <code class="docutils literal"><span class="pre">A</span></code>. See also <a class="reference internal" href="#Base.lq" title="Base.lq"><code class="xref jl jl-func docutils literal"><span class="pre">lq()</span></code></a>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.lq">
<code class="descname">lq</code><span class="sig-paren">(</span><em>A; [thin=true]</em><span class="sig-paren">)</span> &rarr; L, Q<a class="headerlink" href="#Base.lq" title="Permalink to this definition"></a></dt>
<dd><p>Perform an LQ factorization of <code class="docutils literal"><span class="pre">A</span></code> such that <code class="docutils literal"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">L*Q</span></code>. The default is to compute a thin factorization. The LQ factorization is the QR factorization of <code class="docutils literal"><span class="pre">A.'</span></code>. <code class="docutils literal"><span class="pre">L</span></code> is not extended with zeros if the full <code class="docutils literal"><span class="pre">Q</span></code> is requested.</p>
</dd></dl>

<dl class="function">
<dt id="Base.bkfact">
<code class="descname">bkfact</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span> &rarr; BunchKaufman<a class="headerlink" href="#Base.bkfact" title="Permalink to this definition"></a></dt>
<dd><p>Compute the Bunch-Kaufman <a class="reference internal" href="#bunch1977" id="id4">[Bunch1977]</a> factorization of a real symmetric or complex Hermitian matrix <code class="docutils literal"><span class="pre">A</span></code> and return a <code class="docutils literal"><span class="pre">BunchKaufman</span></code> object. The following functions are available for <code class="docutils literal"><span class="pre">BunchKaufman</span></code> objects: <code class="docutils literal"><span class="pre">size</span></code>, <code class="docutils literal"><span class="pre">\</span></code>, <code class="docutils literal"><span class="pre">inv</span></code>, <code class="docutils literal"><span class="pre">issymmetric</span></code>, <code class="docutils literal"><span class="pre">ishermitian</span></code>.</p>
<table class="docutils citation" frame="void" id="bunch1977" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[Bunch1977]</a></td><td>J R Bunch and L Kaufman, Some stable methods for calculating inertia and solving symmetric linear systems, Mathematics of Computation 31:137 (1977), 163-179. <a class="reference external" href="http://www.ams.org/journals/mcom/1977-31-137/S0025-5718-1977-0428694-0">url</a>.</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Base.bkfact!">
<code class="descname">bkfact!</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span> &rarr; BunchKaufman<a class="headerlink" href="#Base.bkfact!" title="Permalink to this definition"></a></dt>
<dd><p><code class="docutils literal"><span class="pre">bkfact!</span></code> is the same as <a class="reference internal" href="#Base.bkfact" title="Base.bkfact"><code class="xref jl jl-func docutils literal"><span class="pre">bkfact()</span></code></a>, but saves space by overwriting the input <code class="docutils literal"><span class="pre">A</span></code>, instead of creating a copy.</p>
</dd></dl>

<dl class="function">
<dt id="Base.eig">
<code class="descname">eig</code><span class="sig-paren">(</span><em>A,[irange,][vl,][vu,][permute=true,][scale=true]</em><span class="sig-paren">)</span> &rarr; D, V<a class="headerlink" href="#Base.eig" title="Permalink to this definition"></a></dt>
<dd><p>Computes eigenvalues (<code class="docutils literal"><span class="pre">D</span></code>) and eigenvectors (<code class="docutils literal"><span class="pre">V</span></code>) of <code class="docutils literal"><span class="pre">A</span></code>. See <a class="reference internal" href="#Base.eigfact" title="Base.eigfact"><code class="xref jl jl-func docutils literal"><span class="pre">eigfact()</span></code></a> for details on the <code class="docutils literal"><span class="pre">irange</span></code>, <code class="docutils literal"><span class="pre">vl</span></code>, and <code class="docutils literal"><span class="pre">vu</span></code> arguments and the <code class="docutils literal"><span class="pre">permute</span></code> and <code class="docutils literal"><span class="pre">scale</span></code> keyword arguments. The eigenvectors are returned columnwise.</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">eig</span><span class="p">([</span><span class="mf">1.0</span> <span class="mf">0.0</span> <span class="mf">0.0</span><span class="p">;</span> <span class="mf">0.0</span> <span class="mf">3.0</span> <span class="mf">0.0</span><span class="p">;</span> <span class="mf">0.0</span> <span class="mf">0.0</span> <span class="mf">18.0</span><span class="p">])</span>
<span class="p">([</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">3.0</span><span class="p">,</span><span class="mf">18.0</span><span class="p">],</span>
<span class="p">[</span><span class="mf">1.0</span> <span class="mf">0.0</span> <span class="mf">0.0</span><span class="p">;</span> <span class="mf">0.0</span> <span class="mf">1.0</span> <span class="mf">0.0</span><span class="p">;</span> <span class="mf">0.0</span> <span class="mf">0.0</span> <span class="mf">1.0</span><span class="p">])</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">eig</span></code> is a wrapper around <a class="reference internal" href="#Base.eigfact" title="Base.eigfact"><code class="xref jl jl-func docutils literal"><span class="pre">eigfact()</span></code></a>, extracting all parts of the factorization to a tuple; where possible, using <a class="reference internal" href="#Base.eigfact" title="Base.eigfact"><code class="xref jl jl-func docutils literal"><span class="pre">eigfact()</span></code></a> is recommended.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">eig</code><span class="sig-paren">(</span><em>A</em>, <em>B</em><span class="sig-paren">)</span> &rarr; D, V</dt>
<dd><p>Computes generalized eigenvalues (<code class="docutils literal"><span class="pre">D</span></code>) and vectors (<code class="docutils literal"><span class="pre">V</span></code>) of <code class="docutils literal"><span class="pre">A</span></code> with respect to <code class="docutils literal"><span class="pre">B</span></code>.</p>
<p><code class="docutils literal"><span class="pre">eig</span></code> is a wrapper around <a class="reference internal" href="#Base.eigfact" title="Base.eigfact"><code class="xref jl jl-func docutils literal"><span class="pre">eigfact()</span></code></a>, extracting all parts of the factorization to a tuple; where possible, using <a class="reference internal" href="#Base.eigfact" title="Base.eigfact"><code class="xref jl jl-func docutils literal"><span class="pre">eigfact()</span></code></a> is recommended.</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">0</span><span class="p">;</span> <span class="mi">0</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="mi">2</span><span class="n">2</span> <span class="n">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">2</span><span class="p">}:</span>
 <span class="mi">1</span>   <span class="mi">0</span>
 <span class="mi">0</span>  <span class="o">-</span><span class="mi">1</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">B</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span> <span class="mi">0</span><span class="p">]</span>
<span class="mi">2</span><span class="n">2</span> <span class="n">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">2</span><span class="p">}:</span>
 <span class="mi">0</span>  <span class="mi">1</span>
 <span class="mi">1</span>  <span class="mi">0</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">eig</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="p">(</span><span class="n">Complex</span><span class="p">{</span><span class="kt">Float64</span><span class="p">}[</span><span class="mf">0.0</span><span class="o">+</span><span class="mf">1.0</span><span class="nb">im</span><span class="p">,</span><span class="mf">0.0</span><span class="o">-</span><span class="mf">1.0</span><span class="nb">im</span><span class="p">],</span>
<span class="n">Complex</span><span class="p">{</span><span class="kt">Float64</span><span class="p">}[</span><span class="mf">0.0</span><span class="o">-</span><span class="mf">1.0</span><span class="nb">im</span> <span class="mf">0.0</span><span class="o">+</span><span class="mf">1.0</span><span class="nb">im</span><span class="p">;</span> <span class="o">-</span><span class="mf">1.0</span><span class="o">-</span><span class="mf">0.0</span><span class="nb">im</span> <span class="o">-</span><span class="mf">1.0</span><span class="o">+</span><span class="mf">0.0</span><span class="nb">im</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="Base.eigvals">
<code class="descname">eigvals</code><span class="sig-paren">(</span><em>A,[irange,][vl,][vu]</em><span class="sig-paren">)</span> &rarr; values<a class="headerlink" href="#Base.eigvals" title="Permalink to this definition"></a></dt>
<dd><p>Returns the eigenvalues of <code class="docutils literal"><span class="pre">A</span></code>. If <code class="docutils literal"><span class="pre">A</span></code> is <code class="docutils literal"><span class="pre">Symmetric</span></code>, <code class="docutils literal"><span class="pre">Hermitian</span></code> or <code class="docutils literal"><span class="pre">SymTridiagonal</span></code>, it is possible to calculate only a subset of the eigenvalues by specifying either a <code class="docutils literal"><span class="pre">UnitRange</span></code> <code class="docutils literal"><span class="pre">irange</span></code> covering indices of the sorted eigenvalues, or a pair <code class="docutils literal"><span class="pre">vl</span></code> and <code class="docutils literal"><span class="pre">vu</span></code> for the lower and upper boundaries of the eigenvalues.</p>
<p>For general non-symmetric matrices it is possible to specify how the matrix is balanced before the eigenvector calculation. The option <code class="docutils literal"><span class="pre">permute=true</span></code> permutes the matrix to become closer to upper triangular, and <code class="docutils literal"><span class="pre">scale=true</span></code> scales the matrix by its diagonal elements to make rows and columns moreequal in norm. The default is <code class="docutils literal"><span class="pre">true</span></code> for both options.</p>
</dd></dl>

<dl class="function">
<dt id="Base.eigvals!">
<code class="descname">eigvals!</code><span class="sig-paren">(</span><em>A,[irange,][vl,][vu]</em><span class="sig-paren">)</span> &rarr; values<a class="headerlink" href="#Base.eigvals!" title="Permalink to this definition"></a></dt>
<dd><p>Same as <a class="reference internal" href="#Base.eigvals" title="Base.eigvals"><code class="xref jl jl-func docutils literal"><span class="pre">eigvals()</span></code></a>, but saves space by overwriting the input <code class="docutils literal"><span class="pre">A</span></code>, instead of creating a copy.</p>
</dd></dl>

<dl class="function">
<dt id="Base.eigmax">
<code class="descname">eigmax</code><span class="sig-paren">(</span><em>A; permute::Bool=true</em>, <em>scale::Bool=true</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.eigmax" title="Permalink to this definition"></a></dt>
<dd><p>Returns the largest eigenvalue of <code class="docutils literal"><span class="pre">A</span></code>. The option <code class="docutils literal"><span class="pre">permute=true</span></code> permutes the matrix to become closer to upper triangular, and <code class="docutils literal"><span class="pre">scale=true</span></code> scales the matrix by its diagonal elements to make rows and columns more equal in norm. Note that if the eigenvalues of <code class="docutils literal"><span class="pre">A</span></code> are complex, this method will fail, since complex numbers cannot be sorted.</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="nb">im</span><span class="p">;</span> <span class="o">-</span><span class="nb">im</span> <span class="mi">0</span><span class="p">]</span>
<span class="mi">2</span><span class="n">2</span> <span class="n">Array</span><span class="p">{</span><span class="n">Complex</span><span class="p">{</span><span class="kt">Int64</span><span class="p">},</span><span class="mi">2</span><span class="p">}:</span>
 <span class="mi">0</span><span class="o">+</span><span class="mi">0</span><span class="nb">im</span>  <span class="mi">0</span><span class="o">+</span><span class="mi">1</span><span class="nb">im</span>
 <span class="mi">0</span><span class="o">-</span><span class="mi">1</span><span class="nb">im</span>  <span class="mi">0</span><span class="o">+</span><span class="mi">0</span><span class="nb">im</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">eigmax</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="mf">1.0</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="nb">im</span><span class="p">;</span> <span class="o">-</span><span class="mi">1</span> <span class="mi">0</span><span class="p">]</span>
<span class="mi">2</span><span class="n">2</span> <span class="n">Array</span><span class="p">{</span><span class="n">Complex</span><span class="p">{</span><span class="kt">Int64</span><span class="p">},</span><span class="mi">2</span><span class="p">}:</span>
  <span class="mi">0</span><span class="o">+</span><span class="mi">0</span><span class="nb">im</span>  <span class="mi">0</span><span class="o">+</span><span class="mi">1</span><span class="nb">im</span>
 <span class="o">-</span><span class="mi">1</span><span class="o">+</span><span class="mi">0</span><span class="nb">im</span>  <span class="mi">0</span><span class="o">+</span><span class="mi">0</span><span class="nb">im</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">eigmax</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="n">ERROR</span><span class="p">:</span> <span class="n">DomainError</span><span class="p">:</span>
 <span class="k">in</span> <span class="c">#eigmax#30(::Bool, ::Bool, ::Function, ::Array{Complex{Int64},2}) at ./linalg/eigen.jl:186</span>
 <span class="k">in</span> <span class="n">eigmax</span><span class="p">(::</span><span class="n">Array</span><span class="p">{</span><span class="n">Complex</span><span class="p">{</span><span class="kt">Int64</span><span class="p">},</span><span class="mi">2</span><span class="p">})</span> <span class="n">at</span> <span class="o">./</span><span class="n">linalg</span><span class="o">/</span><span class="n">eigen</span><span class="o">.</span><span class="n">jl</span><span class="p">:</span><span class="mi">184</span>
 <span class="o">...</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="Base.eigmin">
<code class="descname">eigmin</code><span class="sig-paren">(</span><em>A; permute::Bool=true</em>, <em>scale::Bool=true</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.eigmin" title="Permalink to this definition"></a></dt>
<dd><p>Returns the smallest eigenvalue of <code class="docutils literal"><span class="pre">A</span></code>. The option <code class="docutils literal"><span class="pre">permute=true</span></code> permutes the matrix to become closer to upper triangular, and <code class="docutils literal"><span class="pre">scale=true</span></code> scales the matrix by its diagonal elements to make rows and columns more equal in norm. Note that if the eigenvalues of <code class="docutils literal"><span class="pre">A</span></code> are complex, this method will fail, since complex numbers cannot be sorted.</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="nb">im</span><span class="p">;</span> <span class="o">-</span><span class="nb">im</span> <span class="mi">0</span><span class="p">]</span>
<span class="mi">2</span><span class="n">2</span> <span class="n">Array</span><span class="p">{</span><span class="n">Complex</span><span class="p">{</span><span class="kt">Int64</span><span class="p">},</span><span class="mi">2</span><span class="p">}:</span>
 <span class="mi">0</span><span class="o">+</span><span class="mi">0</span><span class="nb">im</span>  <span class="mi">0</span><span class="o">+</span><span class="mi">1</span><span class="nb">im</span>
 <span class="mi">0</span><span class="o">-</span><span class="mi">1</span><span class="nb">im</span>  <span class="mi">0</span><span class="o">+</span><span class="mi">0</span><span class="nb">im</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">eigmin</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="o">-</span><span class="mf">1.0</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="nb">im</span><span class="p">;</span> <span class="o">-</span><span class="mi">1</span> <span class="mi">0</span><span class="p">]</span>
<span class="mi">2</span><span class="n">2</span> <span class="n">Array</span><span class="p">{</span><span class="n">Complex</span><span class="p">{</span><span class="kt">Int64</span><span class="p">},</span><span class="mi">2</span><span class="p">}:</span>
  <span class="mi">0</span><span class="o">+</span><span class="mi">0</span><span class="nb">im</span>  <span class="mi">0</span><span class="o">+</span><span class="mi">1</span><span class="nb">im</span>
 <span class="o">-</span><span class="mi">1</span><span class="o">+</span><span class="mi">0</span><span class="nb">im</span>  <span class="mi">0</span><span class="o">+</span><span class="mi">0</span><span class="nb">im</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">eigmin</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="n">ERROR</span><span class="p">:</span> <span class="n">DomainError</span><span class="p">:</span>
 <span class="k">in</span> <span class="c">#eigmin#31(::Bool, ::Bool, ::Function, ::Array{Complex{Int64},2}) at ./linalg/eigen.jl:226</span>
 <span class="k">in</span> <span class="n">eigmin</span><span class="p">(::</span><span class="n">Array</span><span class="p">{</span><span class="n">Complex</span><span class="p">{</span><span class="kt">Int64</span><span class="p">},</span><span class="mi">2</span><span class="p">})</span> <span class="n">at</span> <span class="o">./</span><span class="n">linalg</span><span class="o">/</span><span class="n">eigen</span><span class="o">.</span><span class="n">jl</span><span class="p">:</span><span class="mi">224</span>
 <span class="o">...</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="Base.eigvecs">
<code class="descname">eigvecs</code><span class="sig-paren">(</span><em>A, [eigvals,][permute=true,][scale=true]</em><span class="sig-paren">)</span> &rarr; Matrix<a class="headerlink" href="#Base.eigvecs" title="Permalink to this definition"></a></dt>
<dd><p>Returns a matrix <code class="docutils literal"><span class="pre">M</span></code> whose columns are the eigenvectors of <code class="docutils literal"><span class="pre">A</span></code>. (The <code class="docutils literal"><span class="pre">k</span></code>th eigenvector can be obtained from the slice <code class="docutils literal"><span class="pre">M[:,</span> <span class="pre">k]</span></code>.) The <code class="docutils literal"><span class="pre">permute</span></code> and <code class="docutils literal"><span class="pre">scale</span></code> keywords are the same as for <a class="reference internal" href="#Base.eigfact" title="Base.eigfact"><code class="xref jl jl-func docutils literal"><span class="pre">eigfact()</span></code></a>.</p>
<p>For <a class="reference internal" href="#Base.SymTridiagonal" title="Base.SymTridiagonal"><code class="xref jl jl-class docutils literal"><span class="pre">SymTridiagonal</span></code></a> matrices, if the optional vector of eigenvalues <code class="docutils literal"><span class="pre">eigvals</span></code> is specified, returns the specific corresponding eigenvectors.</p>
</dd></dl>

<dl class="function">
<dt id="Base.eigfact">
<code class="descname">eigfact</code><span class="sig-paren">(</span><em>A,[irange,][vl,][vu,][permute=true,][scale=true]</em><span class="sig-paren">)</span> &rarr; Eigen<a class="headerlink" href="#Base.eigfact" title="Permalink to this definition"></a></dt>
<dd><p>Computes the eigenvalue decomposition of <code class="docutils literal"><span class="pre">A</span></code>, returning an <code class="xref jl jl-obj docutils literal"><span class="pre">Eigen</span></code> factorization object <code class="docutils literal"><span class="pre">F</span></code> which contains the eigenvalues in <code class="docutils literal"><span class="pre">F[:values]</span></code> and the eigenvectors in the columns of the matrix <code class="docutils literal"><span class="pre">F[:vectors]</span></code>. (The <code class="docutils literal"><span class="pre">k</span></code>th eigenvector can be obtained from the slice <code class="docutils literal"><span class="pre">F[:vectors][:,</span> <span class="pre">k]</span></code>.)</p>
<p>The following functions are available for <code class="docutils literal"><span class="pre">Eigen</span></code> objects: <a class="reference internal" href="#Base.inv" title="Base.inv"><code class="xref jl jl-func docutils literal"><span class="pre">inv()</span></code></a>, <a class="reference internal" href="#Base.det" title="Base.det"><code class="xref jl jl-func docutils literal"><span class="pre">det()</span></code></a>, and <a class="reference internal" href="#Base.isposdef" title="Base.isposdef"><code class="xref jl jl-func docutils literal"><span class="pre">isposdef()</span></code></a>.</p>
<p>If <code class="docutils literal"><span class="pre">A</span></code> is <a class="reference internal" href="#Base.Symmetric" title="Base.Symmetric"><code class="xref jl jl-class docutils literal"><span class="pre">Symmetric</span></code></a>, <a class="reference internal" href="#Base.Hermitian" title="Base.Hermitian"><code class="xref jl jl-class docutils literal"><span class="pre">Hermitian</span></code></a> or <a class="reference internal" href="#Base.SymTridiagonal" title="Base.SymTridiagonal"><code class="xref jl jl-class docutils literal"><span class="pre">SymTridiagonal</span></code></a>, it is possible to calculate only a subset of the eigenvalues by specifying either a <code class="xref jl jl-class docutils literal"><span class="pre">UnitRange</span></code> <code class="docutils literal"><span class="pre">irange</span></code> covering indices of the sorted eigenvalues or a pair <code class="docutils literal"><span class="pre">vl</span></code> and <code class="docutils literal"><span class="pre">vu</span></code> for the lower and upper boundaries of the eigenvalues.</p>
<p>For general nonsymmetric matrices it is possible to specify how the matrix is balanced before the eigenvector calculation. The option <code class="docutils literal"><span class="pre">permute=true</span></code> permutes the matrix to become closer to upper triangular, and <code class="docutils literal"><span class="pre">scale=true</span></code> scales the matrix by its diagonal elements to make rows and columns more equal in norm. The default is <code class="docutils literal"><span class="pre">true</span></code> for both options.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">eigfact</code><span class="sig-paren">(</span><em>A</em>, <em>B</em><span class="sig-paren">)</span> &rarr; GeneralizedEigen</dt>
<dd><p>Computes the generalized eigenvalue decomposition of <code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">B</span></code>, returning a <code class="docutils literal"><span class="pre">GeneralizedEigen</span></code> factorization object <code class="docutils literal"><span class="pre">F</span></code> which contains the generalized eigenvalues in <code class="docutils literal"><span class="pre">F[:values]</span></code> and the generalized eigenvectors in the columns of the matrix <code class="docutils literal"><span class="pre">F[:vectors]</span></code>. (The <code class="docutils literal"><span class="pre">k</span></code>th generalized eigenvector can be obtained from the slice <code class="docutils literal"><span class="pre">F[:vectors][:,</span> <span class="pre">k]</span></code>.)</p>
</dd></dl>

<dl class="function">
<dt id="Base.eigfact!">
<code class="descname">eigfact!</code><span class="sig-paren">(</span><em>A</em><span class="optional">[</span>, <em>B</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#Base.eigfact!" title="Permalink to this definition"></a></dt>
<dd><p>Same as <a class="reference internal" href="#Base.eigfact" title="Base.eigfact"><code class="xref jl jl-func docutils literal"><span class="pre">eigfact()</span></code></a>, but saves space by overwriting the input <code class="docutils literal"><span class="pre">A</span></code> (and <code class="docutils literal"><span class="pre">B</span></code>), instead of creating a copy.</p>
</dd></dl>

<dl class="function">
<dt id="Base.hessfact">
<code class="descname">hessfact</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.hessfact" title="Permalink to this definition"></a></dt>
<dd><p>Compute the Hessenberg decomposition of <code class="docutils literal"><span class="pre">A</span></code> and return a <code class="docutils literal"><span class="pre">Hessenberg</span></code> object. If <code class="docutils literal"><span class="pre">F</span></code> is the factorization object, the unitary matrix can be accessed with <code class="docutils literal"><span class="pre">F[:Q]</span></code> and the Hessenberg matrix with <code class="docutils literal"><span class="pre">F[:H]</span></code>. When <code class="docutils literal"><span class="pre">Q</span></code> is extracted, the resulting type is the <code class="docutils literal"><span class="pre">HessenbergQ</span></code> object, and may be converted to a regular matrix with <a class="reference internal" href="#Base.full" title="Base.full"><code class="xref jl jl-func docutils literal"><span class="pre">full()</span></code></a>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.hessfact!">
<code class="descname">hessfact!</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.hessfact!" title="Permalink to this definition"></a></dt>
<dd><p><code class="docutils literal"><span class="pre">hessfact!</span></code> is the same as <a class="reference internal" href="#Base.hessfact" title="Base.hessfact"><code class="xref jl jl-func docutils literal"><span class="pre">hessfact()</span></code></a>, but saves space by overwriting the input <code class="docutils literal"><span class="pre">A</span></code>, instead of creating a copy.</p>
</dd></dl>

<dl class="function">
<dt id="Base.schurfact">
<code class="descname">schurfact</code><span class="sig-paren">(</span><em>A::StridedMatrix</em><span class="sig-paren">)</span> &rarr; F::Schur<a class="headerlink" href="#Base.schurfact" title="Permalink to this definition"></a></dt>
<dd><p>Computes the Schur factorization of the matrix <code class="docutils literal"><span class="pre">A</span></code>. The (quasi) triangular Schur factor can be obtained from the <code class="docutils literal"><span class="pre">Schur</span></code> object <code class="docutils literal"><span class="pre">F</span></code> with either <code class="docutils literal"><span class="pre">F[:Schur]</span></code> or <code class="docutils literal"><span class="pre">F[:T]</span></code> and the orthogonal/unitary Schur vectors can be obtained with <code class="docutils literal"><span class="pre">F[:vectors]</span></code> or <code class="docutils literal"><span class="pre">F[:Z]</span></code> such that <code class="docutils literal"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">F[:vectors]*F[:Schur]*F[:vectors]'</span></code>. The eigenvalues of <code class="docutils literal"><span class="pre">A</span></code> can be obtained with <code class="docutils literal"><span class="pre">F[:values]</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.schurfact!">
<code class="descname">schurfact!</code><span class="sig-paren">(</span><em>A::StridedMatrix</em><span class="sig-paren">)</span> &rarr; F::Schur<a class="headerlink" href="#Base.schurfact!" title="Permalink to this definition"></a></dt>
<dd><p>Same as <code class="docutils literal"><span class="pre">schurfact</span></code> but uses the input argument as workspace.</p>
</dd></dl>

<dl class="function">
<dt id="Base.schur">
<code class="descname">schur</code><span class="sig-paren">(</span><em>A::StridedMatrix</em><span class="sig-paren">)</span> &rarr; T::Matrix, Z::Matrix, ::Vector<a class="headerlink" href="#Base.schur" title="Permalink to this definition"></a></dt>
<dd><p>Computes the Schur factorization of the matrix <code class="docutils literal"><span class="pre">A</span></code>. The methods return the (quasi) triangular Schur factor <code class="docutils literal"><span class="pre">T</span></code> and the orthogonal/unitary Schur vectors <code class="docutils literal"><span class="pre">Z</span></code> such that <code class="docutils literal"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">Z*T*Z'</span></code>. The eigenvalues of <code class="docutils literal"><span class="pre">A</span></code> are returned in the vector <code class="docutils literal"><span class="pre"></span></code>.</p>
<p>See <code class="docutils literal"><span class="pre">schurfact</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.ordschur">
<code class="descname">ordschur</code><span class="sig-paren">(</span><em>F::Schur</em>, <em>select::Union{Vector{Bool}</em>, <em>BitVector}</em><span class="sig-paren">)</span> &rarr; F::Schur<a class="headerlink" href="#Base.ordschur" title="Permalink to this definition"></a></dt>
<dd><p>Reorders the Schur factorization <code class="docutils literal"><span class="pre">F</span></code> of a matrix <code class="docutils literal"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">Z*T*Z'</span></code> according to the logical array <code class="docutils literal"><span class="pre">select</span></code> returning the reordered factorization <code class="docutils literal"><span class="pre">F</span></code> object. The selected eigenvalues appear in the leading diagonal of <code class="docutils literal"><span class="pre">F[:Schur]</span></code> and the corresponding leading columns of <code class="docutils literal"><span class="pre">F[:vectors]</span></code> form an orthogonal/unitary basis of the corresponding right invariant subspace. In the real case, a complex conjugate pair of eigenvalues must be either both included or both excluded via <code class="docutils literal"><span class="pre">select</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.ordschur!">
<code class="descname">ordschur!</code><span class="sig-paren">(</span><em>F::Schur</em>, <em>select::Union{Vector{Bool}</em>, <em>BitVector}</em><span class="sig-paren">)</span> &rarr; F::Schur<a class="headerlink" href="#Base.ordschur!" title="Permalink to this definition"></a></dt>
<dd><p>Same as <code class="docutils literal"><span class="pre">ordschur</span></code> but overwrites the factorization <code class="docutils literal"><span class="pre">F</span></code>.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">ordschur</code><span class="sig-paren">(</span><em>T::StridedMatrix</em>, <em>Z::StridedMatrix</em>, <em>select::Union{Vector{Bool}</em>, <em>BitVector}</em><span class="sig-paren">)</span> &rarr; T::StridedMatrix, Z::StridedMatrix, ::Vector</dt>
<dd><p>Reorders the Schur factorization of a real matrix <code class="docutils literal"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">Z*T*Z'</span></code> according to the logical array <code class="docutils literal"><span class="pre">select</span></code> returning the reordered matrices <code class="docutils literal"><span class="pre">T</span></code> and <code class="docutils literal"><span class="pre">Z</span></code> as well as the vector of eigenvalues <code class="docutils literal"><span class="pre"></span></code>. The selected eigenvalues appear in the leading diagonal of <code class="docutils literal"><span class="pre">T</span></code> and the corresponding leading columns of <code class="docutils literal"><span class="pre">Z</span></code> form an orthogonal/unitary basis of the corresponding right invariant subspace. In the real case, a complex conjugate pair of eigenvalues must be either both included or both excluded via <code class="docutils literal"><span class="pre">select</span></code>.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">ordschur!</code><span class="sig-paren">(</span><em>T::StridedMatrix</em>, <em>Z::StridedMatrix</em>, <em>select::Union{Vector{Bool}</em>, <em>BitVector}</em><span class="sig-paren">)</span> &rarr; T::StridedMatrix, Z::StridedMatrix, ::Vector</dt>
<dd><p>Same as <code class="docutils literal"><span class="pre">ordschur</span></code> but overwrites the input arguments.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">schurfact</code><span class="sig-paren">(</span><em>A::StridedMatrix</em>, <em>B::StridedMatrix</em><span class="sig-paren">)</span> &rarr; F::GeneralizedSchur</dt>
<dd><p>Computes the Generalized Schur (or QZ) factorization of the matrices <code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">B</span></code>. The (quasi) triangular Schur factors can be obtained from the <code class="docutils literal"><span class="pre">Schur</span></code> object <code class="docutils literal"><span class="pre">F</span></code> with <code class="docutils literal"><span class="pre">F[:S]</span></code> and <code class="docutils literal"><span class="pre">F[:T]</span></code>, the left unitary/orthogonal Schur vectors can be obtained with <code class="docutils literal"><span class="pre">F[:left]</span></code> or <code class="docutils literal"><span class="pre">F[:Q]</span></code> and the right unitary/orthogonal Schur vectors can be obtained with <code class="docutils literal"><span class="pre">F[:right]</span></code> or <code class="docutils literal"><span class="pre">F[:Z]</span></code> such that <code class="docutils literal"><span class="pre">A=F[:left]*F[:S]*F[:right]'</span></code> and <code class="docutils literal"><span class="pre">B=F[:left]*F[:T]*F[:right]'</span></code>. The generalized eigenvalues of <code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">B</span></code> can be obtained with <code class="docutils literal"><span class="pre">F[:alpha]./F[:beta]</span></code>.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">schurfact!</code><span class="sig-paren">(</span><em>A::StridedMatrix</em>, <em>B::StridedMatrix</em><span class="sig-paren">)</span> &rarr; F::GeneralizedSchur</dt>
<dd><p>Same as <code class="docutils literal"><span class="pre">schurfact</span></code> but uses the input matrices <code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">B</span></code> as workspace.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">ordschur</code><span class="sig-paren">(</span><em>F::GeneralizedSchur</em>, <em>select::Union{Vector{Bool}</em>, <em>BitVector}</em><span class="sig-paren">)</span> &rarr; F::GeneralizedSchur</dt>
<dd><p>Reorders the Generalized Schur factorization <code class="docutils literal"><span class="pre">F</span></code> of a matrix pair <code class="docutils literal"><span class="pre">(A,</span> <span class="pre">B)</span> <span class="pre">=</span> <span class="pre">(Q*S*Z',</span> <span class="pre">Q*T*Z')</span></code> according to the logical array <code class="docutils literal"><span class="pre">select</span></code> and returns a GeneralizedSchur object <code class="docutils literal"><span class="pre">F</span></code>. The selected eigenvalues appear in the leading diagonal of both <code class="docutils literal"><span class="pre">F[:S]</span></code> and <code class="docutils literal"><span class="pre">F[:T]</span></code>, and the left and right orthogonal/unitary Schur vectors are also reordered such that <code class="docutils literal"><span class="pre">(A,</span> <span class="pre">B)</span> <span class="pre">=</span> <span class="pre">F[:Q]*(F[:S],</span> <span class="pre">F[:T])*F[:Z]'</span></code> still holds and the generalized eigenvalues of <code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">B</span></code> can still be obtained with <code class="docutils literal"><span class="pre">F[:alpha]./F[:beta]</span></code>.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">ordschur!</code><span class="sig-paren">(</span><em>F::GeneralizedSchur</em>, <em>select::Union{Vector{Bool}</em>, <em>BitVector}</em><span class="sig-paren">)</span> &rarr; F::GeneralizedSchur</dt>
<dd><p>Same as <code class="docutils literal"><span class="pre">ordschur</span></code> but overwrites the factorization <code class="docutils literal"><span class="pre">F</span></code>.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">ordschur</code><span class="sig-paren">(</span><em>S::StridedMatrix</em>, <em>T::StridedMatrix</em>, <em>Q::StridedMatrix</em>, <em>Z::StridedMatrix</em>, <em>select</em><span class="sig-paren">)</span> &rarr; S::StridedMatrix, T::StridedMatrix, Q::StridedMatrix, Z::StridedMatrix, ::Vector, ::Vector</dt>
<dd><p>Reorders the Generalized Schur factorization of a matrix pair <code class="docutils literal"><span class="pre">(A,</span> <span class="pre">B)</span> <span class="pre">=</span> <span class="pre">(Q*S*Z',</span> <span class="pre">Q*T*Z')</span></code> according to the logical array <code class="docutils literal"><span class="pre">select</span></code> and returns the matrices <code class="docutils literal"><span class="pre">S</span></code>, <code class="docutils literal"><span class="pre">T</span></code>, <code class="docutils literal"><span class="pre">Q</span></code>, <code class="docutils literal"><span class="pre">Z</span></code> and vectors <code class="docutils literal"><span class="pre"></span></code> and <code class="docutils literal"><span class="pre"></span></code>.  The selected eigenvalues appear in the leading diagonal of both <code class="docutils literal"><span class="pre">S</span></code> and <code class="docutils literal"><span class="pre">T</span></code>, and the left and right unitary/orthogonal Schur vectors are also reordered such that <code class="docutils literal"><span class="pre">(A,</span> <span class="pre">B)</span> <span class="pre">=</span> <span class="pre">Q*(S,</span> <span class="pre">T)*Z'</span></code> still holds and the generalized eigenvalues of <code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">B</span></code> can still be obtained with <code class="docutils literal"><span class="pre">./</span></code>.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">ordschur!</code><span class="sig-paren">(</span><em>S::StridedMatrix</em>, <em>T::StridedMatrix</em>, <em>Q::StridedMatrix</em>, <em>Z::StridedMatrix</em>, <em>select</em><span class="sig-paren">)</span> &rarr; S::StridedMatrix, T::StridedMatrix, Q::StridedMatrix, Z::StridedMatrix, ::Vector, ::Vector</dt>
<dd><p>Same as <code class="docutils literal"><span class="pre">ordschur</span></code> but overwrites the factorization the input arguments.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">schur</code><span class="sig-paren">(</span><em>A::StridedMatrix</em>, <em>B::StridedMatrix</em><span class="sig-paren">)</span> &rarr; S::StridedMatrix, T::StridedMatrix, Q::StridedMatrix, Z::StridedMatrix, ::Vector, ::Vector</dt>
<dd><p>See <code class="docutils literal"><span class="pre">schurfact</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.svdfact">
<code class="descname">svdfact</code><span class="sig-paren">(</span><em>A</em><span class="optional">[</span>, <em>thin=true</em><span class="optional">]</span><span class="sig-paren">)</span> &rarr; SVD<a class="headerlink" href="#Base.svdfact" title="Permalink to this definition"></a></dt>
<dd><p>Compute the singular value decomposition (SVD) of <code class="docutils literal"><span class="pre">A</span></code> and return an <code class="docutils literal"><span class="pre">SVD</span></code> object.</p>
<p><code class="docutils literal"><span class="pre">U</span></code>, <code class="docutils literal"><span class="pre">S</span></code>, <code class="docutils literal"><span class="pre">V</span></code> and <code class="docutils literal"><span class="pre">Vt</span></code> can be obtained from the factorization <code class="docutils literal"><span class="pre">F</span></code> with <code class="docutils literal"><span class="pre">F[:U]</span></code>, <code class="docutils literal"><span class="pre">F[:S]</span></code>, <code class="docutils literal"><span class="pre">F[:V]</span></code> and <code class="docutils literal"><span class="pre">F[:Vt]</span></code>, such that <code class="docutils literal"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">U*diagm(S)*Vt</span></code>. The algorithm produces <code class="docutils literal"><span class="pre">Vt</span></code> and hence <code class="docutils literal"><span class="pre">Vt</span></code> is more efficient to extract than <code class="docutils literal"><span class="pre">V</span></code>.</p>
<p>If <code class="docutils literal"><span class="pre">thin=true</span></code> (default), a thin SVD is returned. For a <span class="math">\(M \times N\)</span> matrix <code class="docutils literal"><span class="pre">A</span></code>, <code class="docutils literal"><span class="pre">U</span></code> is <span class="math">\(M \times M\)</span> for a full SVD (<code class="docutils literal"><span class="pre">thin=false</span></code>) and <span class="math">\(M \times \min(M, N)\)</span> for a thin SVD.</p>
</dd></dl>

<dl class="function">
<dt id="Base.svdfact!">
<code class="descname">svdfact!</code><span class="sig-paren">(</span><em>A</em><span class="optional">[</span>, <em>thin=true</em><span class="optional">]</span><span class="sig-paren">)</span> &rarr; SVD<a class="headerlink" href="#Base.svdfact!" title="Permalink to this definition"></a></dt>
<dd><p><code class="docutils literal"><span class="pre">svdfact!</span></code> is the same as <a class="reference internal" href="#Base.svdfact" title="Base.svdfact"><code class="xref jl jl-func docutils literal"><span class="pre">svdfact()</span></code></a>, but saves space by overwriting the input <code class="docutils literal"><span class="pre">A</span></code>, instead of creating a copy.</p>
<p>If <code class="docutils literal"><span class="pre">thin=true</span></code> (default), a thin SVD is returned. For a <span class="math">\(M \times N\)</span> matrix <code class="docutils literal"><span class="pre">A</span></code>, <code class="docutils literal"><span class="pre">U</span></code> is <span class="math">\(M \times M\)</span> for a full SVD (<code class="docutils literal"><span class="pre">thin=false</span></code>) and <span class="math">\(M \times \min(M, N)\)</span> for a thin SVD.</p>
</dd></dl>

<dl class="function">
<dt id="Base.svd">
<code class="descname">svd</code><span class="sig-paren">(</span><em>A</em><span class="optional">[</span>, <em>thin=true</em><span class="optional">]</span><span class="sig-paren">)</span> &rarr; U, S, V<a class="headerlink" href="#Base.svd" title="Permalink to this definition"></a></dt>
<dd><p>Computes the SVD of <code class="docutils literal"><span class="pre">A</span></code>, returning <code class="docutils literal"><span class="pre">U</span></code>, vector <code class="docutils literal"><span class="pre">S</span></code>, and <code class="docutils literal"><span class="pre">V</span></code> such that <code class="docutils literal"><span class="pre">A</span> <span class="pre">==</span> <span class="pre">U*diagm(S)*V'</span></code>.</p>
<p>If <code class="docutils literal"><span class="pre">thin=true</span></code> (default), a thin SVD is returned. For a <span class="math">\(M \times N\)</span> matrix <code class="docutils literal"><span class="pre">A</span></code>, <code class="docutils literal"><span class="pre">U</span></code> is <span class="math">\(M \times M\)</span> for a full SVD (<code class="docutils literal"><span class="pre">thin=false</span></code>) and <span class="math">\(M \times \min(M, N)\)</span> for a thin SVD.</p>
<p><code class="docutils literal"><span class="pre">svd</span></code> is a wrapper around <code class="xref jl jl-func docutils literal"><span class="pre">svdfact(A)()</span></code>, extracting all parts of the <code class="docutils literal"><span class="pre">SVD</span></code> factorization to a tuple. Direct use of <code class="docutils literal"><span class="pre">svdfact</span></code> is therefore more efficient.</p>
</dd></dl>

<dl class="function">
<dt id="Base.svdvals">
<code class="descname">svdvals</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.svdvals" title="Permalink to this definition"></a></dt>
<dd><p>Returns the singular values of <code class="docutils literal"><span class="pre">A</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.svdvals!">
<code class="descname">svdvals!</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.svdvals!" title="Permalink to this definition"></a></dt>
<dd><p>Returns the singular values of <code class="docutils literal"><span class="pre">A</span></code>, saving space by overwriting the input.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">svdfact</code><span class="sig-paren">(</span><em>A</em>, <em>B</em><span class="sig-paren">)</span> &rarr; GeneralizedSVD</dt>
<dd><p>Compute the generalized SVD of <code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">B</span></code>, returning a <code class="docutils literal"><span class="pre">GeneralizedSVD</span></code> factorization object <code class="docutils literal"><span class="pre">F</span></code>, such that <code class="docutils literal"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">F[:U]*F[:D1]*F[:R0]*F[:Q]'</span></code> and <code class="docutils literal"><span class="pre">B</span> <span class="pre">=</span> <span class="pre">F[:V]*F[:D2]*F[:R0]*F[:Q]'</span></code>.</p>
<p>For an M-by-N matrix <code class="docutils literal"><span class="pre">A</span></code> and P-by-N matrix <code class="docutils literal"><span class="pre">B</span></code>,</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">F[:U]</span></code> is a M-by-M orthogonal matrix,</li>
<li><code class="docutils literal"><span class="pre">F[:V]</span></code> is a P-by-P orthogonal matrix,</li>
<li><code class="docutils literal"><span class="pre">F[:Q]</span></code> is a N-by-N orthogonal matrix,</li>
<li><code class="docutils literal"><span class="pre">F[:R0]</span></code> is a (K+L)-by-N matrix whose rightmost (K+L)-by-(K+L) block is          nonsingular upper block triangular,</li>
<li><code class="docutils literal"><span class="pre">F[:D1]</span></code> is a M-by-(K+L) diagonal matrix with 1s in the first K entries,</li>
<li><code class="docutils literal"><span class="pre">F[:D2]</span></code> is a P-by-(K+L) matrix whose top right L-by-L block is diagonal,</li>
</ul>
<p><code class="docutils literal"><span class="pre">K+L</span></code> is the effective numerical rank of the matrix <code class="docutils literal"><span class="pre">[A;</span> <span class="pre">B]</span></code>.</p>
<p>The entries of <code class="docutils literal"><span class="pre">F[:D1]</span></code> and <code class="docutils literal"><span class="pre">F[:D2]</span></code> are related, as explained in the LAPACK documentation for the <a class="reference external" href="http://www.netlib.org/lapack/lug/node36.html">generalized SVD</a> and the <a class="reference external" href="http://www.netlib.org/lapack/explore-html/d6/db3/dggsvd3_8f.html">xGGSVD3</a> routine which is called underneath (in LAPACK 3.6.0 and newer).</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">svd</code><span class="sig-paren">(</span><em>A</em>, <em>B</em><span class="sig-paren">)</span> &rarr; U, V, Q, D1, D2, R0</dt>
<dd><p>Wrapper around <code class="xref jl jl-func docutils literal"><span class="pre">svdfact(A,</span> <span class="pre">B)()</span></code> extracting all parts of the factorization to a tuple. Direct use of <code class="docutils literal"><span class="pre">svdfact</span></code> is therefore generally more efficient. The function returns the generalized SVD of <code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">B</span></code>, returning <code class="docutils literal"><span class="pre">U</span></code>, <code class="docutils literal"><span class="pre">V</span></code>, <code class="docutils literal"><span class="pre">Q</span></code>, <code class="docutils literal"><span class="pre">D1</span></code>, <code class="docutils literal"><span class="pre">D2</span></code>, and <code class="docutils literal"><span class="pre">R0</span></code> such that <code class="docutils literal"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">U*D1*R0*Q'</span></code> and <code class="docutils literal"><span class="pre">B</span> <span class="pre">=</span> <span class="pre">V*D2*R0*Q'</span></code>.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">svdvals</code><span class="sig-paren">(</span><em>A</em>, <em>B</em><span class="sig-paren">)</span></dt>
<dd><p>Return the generalized singular values from the generalized singular value decomposition of <code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">B</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.Givens">
<code class="descclassname">LinAlg.</code><code class="descname">Givens</code><span class="sig-paren">(</span><em>i1</em>, <em>i2</em>, <em>c</em>, <em>s</em><span class="sig-paren">)</span> &rarr; G<a class="headerlink" href="#Base.LinAlg.Givens" title="Permalink to this definition"></a></dt>
<dd><p>A Givens rotation linear operator. The fields <code class="docutils literal"><span class="pre">c</span></code> and <code class="docutils literal"><span class="pre">s</span></code> represent the cosine and sine of the rotation angle, respectively. The <code class="docutils literal"><span class="pre">Givens</span></code> type supports left multiplication <code class="docutils literal"><span class="pre">G*A</span></code> and conjugated transpose right multiplication <code class="docutils literal"><span class="pre">A*G'</span></code>. The type doesn&#8217;t have a <code class="docutils literal"><span class="pre">size</span></code> and can therefore be multiplied with matrices of arbitrary size as long as <code class="docutils literal"><span class="pre">i2&lt;=size(A,2)</span></code> for <code class="docutils literal"><span class="pre">G*A</span></code> or <code class="docutils literal"><span class="pre">i2&lt;=size(A,1)</span></code> for <code class="docutils literal"><span class="pre">A*G'</span></code>.</p>
<p>See also: <a class="reference internal" href="#Base.givens" title="Base.givens"><code class="xref jl jl-func docutils literal"><span class="pre">givens()</span></code></a></p>
</dd></dl>

<dl class="function">
<dt id="Base.givens{T}">
<code class="descname">givens{T}</code><span class="sig-paren">(</span><em>f::T</em>, <em>g::T</em>, <em>i1::Integer</em>, <em>i2::Integer</em><span class="sig-paren">)</span> &rarr; (G::Givens, r::T)<a class="headerlink" href="#Base.givens{T}" title="Permalink to this definition"></a></dt>
<dd><p>Computes the Givens rotation <code class="docutils literal"><span class="pre">G</span></code> and scalar <code class="docutils literal"><span class="pre">r</span></code> such that for any vector <code class="docutils literal"><span class="pre">x</span></code> where</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">x</span><span class="p">[</span><span class="n">i1</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span>
<span class="n">x</span><span class="p">[</span><span class="n">i2</span><span class="p">]</span> <span class="o">=</span> <span class="n">g</span>
</pre></div>
</div>
<p>the result of the multiplication</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">y</span> <span class="o">=</span> <span class="n">G</span><span class="o">*</span><span class="n">x</span>
</pre></div>
</div>
<p>has the property that</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">y</span><span class="p">[</span><span class="n">i1</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>
<span class="n">y</span><span class="p">[</span><span class="n">i2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
</pre></div>
</div>
<p>See also: <a class="reference internal" href="#Base.LinAlg.Givens" title="Base.LinAlg.Givens"><code class="xref jl jl-class docutils literal"><span class="pre">LinAlg.Givens</span></code></a></p>
</dd></dl>

<dl class="function">
<dt id="Base.givens">
<code class="descname">givens</code><span class="sig-paren">(</span><em>x::AbstractVector</em>, <em>i1::Integer</em>, <em>i2::Integer</em><span class="sig-paren">)</span> &rarr; (G::Givens, r)<a class="headerlink" href="#Base.givens" title="Permalink to this definition"></a></dt>
<dd><p>Computes the Givens rotation <code class="docutils literal"><span class="pre">G</span></code> and scalar <code class="docutils literal"><span class="pre">r</span></code> such that the result of the multiplication</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">B</span> <span class="o">=</span> <span class="n">G</span><span class="o">*</span><span class="n">x</span>
</pre></div>
</div>
<p>has the property that</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">B</span><span class="p">[</span><span class="n">i1</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>
<span class="n">B</span><span class="p">[</span><span class="n">i2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
</pre></div>
</div>
<p>See also: <a class="reference internal" href="#Base.LinAlg.Givens" title="Base.LinAlg.Givens"><code class="xref jl jl-class docutils literal"><span class="pre">LinAlg.Givens</span></code></a></p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">givens</code><span class="sig-paren">(</span><em>A::AbstractArray</em>, <em>i1::Integer</em>, <em>i2::Integer</em>, <em>j::Integer</em><span class="sig-paren">)</span> &rarr; (G::Givens, r)</dt>
<dd><p>Computes the Givens rotation <code class="docutils literal"><span class="pre">G</span></code> and scalar <code class="docutils literal"><span class="pre">r</span></code> such that the result of the multiplication</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">B</span> <span class="o">=</span> <span class="n">G</span><span class="o">*</span><span class="n">A</span>
</pre></div>
</div>
<p>has the property that</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">B</span><span class="p">[</span><span class="n">i1</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>
<span class="n">B</span><span class="p">[</span><span class="n">i2</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
</pre></div>
</div>
<p>See also: <a class="reference internal" href="#Base.LinAlg.Givens" title="Base.LinAlg.Givens"><code class="xref jl jl-class docutils literal"><span class="pre">LinAlg.Givens</span></code></a></p>
</dd></dl>

<dl class="function">
<dt id="Base.triu">
<code class="descname">triu</code><span class="sig-paren">(</span><em>M</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.triu" title="Permalink to this definition"></a></dt>
<dd><p>Upper triangle of a matrix.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">triu</code><span class="sig-paren">(</span><em>M</em>, <em>k</em><span class="sig-paren">)</span></dt>
<dd><p>Returns the upper triangle of <code class="docutils literal"><span class="pre">M</span></code> starting from the <code class="docutils literal"><span class="pre">k</span></code>th superdiagonal.</p>
</dd></dl>

<dl class="function">
<dt id="Base.triu!">
<code class="descname">triu!</code><span class="sig-paren">(</span><em>M</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.triu!" title="Permalink to this definition"></a></dt>
<dd><p>Upper triangle of a matrix, overwriting <code class="docutils literal"><span class="pre">M</span></code> in the process.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">triu!</code><span class="sig-paren">(</span><em>M</em>, <em>k</em><span class="sig-paren">)</span></dt>
<dd><p>Returns the upper triangle of <code class="docutils literal"><span class="pre">M</span></code> starting from the <code class="docutils literal"><span class="pre">k</span></code>th superdiagonal, overwriting <code class="docutils literal"><span class="pre">M</span></code> in the process.</p>
</dd></dl>

<dl class="function">
<dt id="Base.tril">
<code class="descname">tril</code><span class="sig-paren">(</span><em>M</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.tril" title="Permalink to this definition"></a></dt>
<dd><p>Lower triangle of a matrix.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">tril</code><span class="sig-paren">(</span><em>M</em>, <em>k</em><span class="sig-paren">)</span></dt>
<dd><p>Returns the lower triangle of <code class="docutils literal"><span class="pre">M</span></code> starting from the <code class="docutils literal"><span class="pre">k</span></code>th superdiagonal.</p>
</dd></dl>

<dl class="function">
<dt id="Base.tril!">
<code class="descname">tril!</code><span class="sig-paren">(</span><em>M</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.tril!" title="Permalink to this definition"></a></dt>
<dd><p>Lower triangle of a matrix, overwriting <code class="docutils literal"><span class="pre">M</span></code> in the process.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">tril!</code><span class="sig-paren">(</span><em>M</em>, <em>k</em><span class="sig-paren">)</span></dt>
<dd><p>Returns the lower triangle of <code class="docutils literal"><span class="pre">M</span></code> starting from the <code class="docutils literal"><span class="pre">k</span></code>th superdiagonal, overwriting <code class="docutils literal"><span class="pre">M</span></code> in the process.</p>
</dd></dl>

<dl class="function">
<dt id="Base.diagind">
<code class="descname">diagind</code><span class="sig-paren">(</span><em>M</em><span class="optional">[</span>, <em>k</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#Base.diagind" title="Permalink to this definition"></a></dt>
<dd><p>A <code class="docutils literal"><span class="pre">Range</span></code> giving the indices of the <code class="docutils literal"><span class="pre">k</span></code>th diagonal of the matrix <code class="docutils literal"><span class="pre">M</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.diag">
<code class="descname">diag</code><span class="sig-paren">(</span><em>M</em><span class="optional">[</span>, <em>k</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#Base.diag" title="Permalink to this definition"></a></dt>
<dd><p>The <code class="docutils literal"><span class="pre">k</span></code>th diagonal of a matrix, as a vector. Use <code class="docutils literal"><span class="pre">diagm</span></code> to construct a diagonal matrix.</p>
</dd></dl>

<dl class="function">
<dt id="Base.diagm">
<code class="descname">diagm</code><span class="sig-paren">(</span><em>v</em><span class="optional">[</span>, <em>k</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#Base.diagm" title="Permalink to this definition"></a></dt>
<dd><p>Construct a diagonal matrix and place <code class="docutils literal"><span class="pre">v</span></code> on the <code class="docutils literal"><span class="pre">k</span></code>th diagonal.</p>
</dd></dl>

<dl class="function">
<dt id="Base.scale!">
<code class="descname">scale!</code><span class="sig-paren">(</span><em>A</em>, <em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.scale!" title="Permalink to this definition"></a></dt>
<dt>
<code class="descname">scale!</code><span class="sig-paren">(</span><em>b</em>, <em>A</em><span class="sig-paren">)</span></dt>
<dd><p>Scale an array <code class="docutils literal"><span class="pre">A</span></code> by a scalar <code class="docutils literal"><span class="pre">b</span></code> overwriting <code class="docutils literal"><span class="pre">A</span></code> in-place.</p>
<p>If <code class="docutils literal"><span class="pre">A</span></code> is a matrix and <code class="docutils literal"><span class="pre">b</span></code> is a vector, then <code class="docutils literal"><span class="pre">scale!(A,b)</span></code> scales each column <code class="docutils literal"><span class="pre">i</span></code> of <code class="docutils literal"><span class="pre">A</span></code> by <code class="docutils literal"><span class="pre">b[i]</span></code> (similar to <code class="docutils literal"><span class="pre">A*Diagonal(b)</span></code>), while <code class="docutils literal"><span class="pre">scale!(b,A)</span></code> scales each row <code class="docutils literal"><span class="pre">i</span></code> of <code class="docutils literal"><span class="pre">A</span></code> by <code class="docutils literal"><span class="pre">b[i]</span></code> (similar to <code class="docutils literal"><span class="pre">Diagonal(b)*A</span></code>), again operating in-place on <code class="docutils literal"><span class="pre">A</span></code>. An <code class="docutils literal"><span class="pre">InexactError</span></code> exception is thrown if the scaling produces a number not representable by the element type of <code class="docutils literal"><span class="pre">A</span></code>, e.g. for integer types.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">Tridiagonal</code><span class="sig-paren">(</span><em>dl</em>, <em>d</em>, <em>du</em><span class="sig-paren">)</span></dt>
<dd><p>Construct a tridiagonal matrix from the first subdiagonal, diagonal, and first superdiagonal, respectively.  The result is of type <code class="docutils literal"><span class="pre">Tridiagonal</span></code> and provides efficient specialized linear solvers, but may be converted into a regular matrix with <a class="reference internal" href="#Base.full" title="Base.full"><code class="xref jl jl-func docutils literal"><span class="pre">full()</span></code></a>. The lengths of <code class="docutils literal"><span class="pre">dl</span></code> and <code class="docutils literal"><span class="pre">du</span></code> must be one less than the length of <code class="docutils literal"><span class="pre">d</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.rank">
<code class="descname">rank</code><span class="sig-paren">(</span><em>M</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.rank" title="Permalink to this definition"></a></dt>
<dd><p>Compute the rank of a matrix.</p>
</dd></dl>

<dl class="function">
<dt id="Base.norm">
<code class="descname">norm</code><span class="sig-paren">(</span><em>A</em><span class="optional">[</span>, <em>p</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#Base.norm" title="Permalink to this definition"></a></dt>
<dd><p>Compute the <code class="docutils literal"><span class="pre">p</span></code>-norm of a vector or the operator norm of a matrix <code class="docutils literal"><span class="pre">A</span></code>, defaulting to the <code class="docutils literal"><span class="pre">p=2</span></code>-norm.</p>
<p>For vectors, <code class="docutils literal"><span class="pre">p</span></code> can assume any numeric value (even though not all values produce a mathematically valid vector norm). In particular, <code class="docutils literal"><span class="pre">norm(A,</span> <span class="pre">Inf)</span></code> returns the largest value in <code class="docutils literal"><span class="pre">abs(A)</span></code>, whereas <code class="docutils literal"><span class="pre">norm(A,</span> <span class="pre">-Inf)</span></code> returns the smallest.</p>
<p>For matrices, the matrix norm induced by the vector <code class="docutils literal"><span class="pre">p</span></code>-norm is used, where valid values of <code class="docutils literal"><span class="pre">p</span></code> are <code class="docutils literal"><span class="pre">1</span></code>, <code class="docutils literal"><span class="pre">2</span></code>, or <code class="docutils literal"><span class="pre">Inf</span></code>. (Note that for sparse matrices, <code class="docutils literal"><span class="pre">p=2</span></code> is currently not implemented.) Use <a class="reference internal" href="#Base.vecnorm" title="Base.vecnorm"><code class="xref jl jl-func docutils literal"><span class="pre">vecnorm()</span></code></a> to compute the Frobenius norm.</p>
</dd></dl>

<dl class="function">
<dt id="Base.vecnorm">
<code class="descname">vecnorm</code><span class="sig-paren">(</span><em>A</em><span class="optional">[</span>, <em>p</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#Base.vecnorm" title="Permalink to this definition"></a></dt>
<dd><p>For any iterable container <code class="docutils literal"><span class="pre">A</span></code> (including arrays of any dimension) of numbers (or any element type for which <code class="docutils literal"><span class="pre">norm</span></code> is defined), compute the <code class="docutils literal"><span class="pre">p</span></code>-norm (defaulting to <code class="docutils literal"><span class="pre">p=2</span></code>) as if <code class="docutils literal"><span class="pre">A</span></code> were a vector of the corresponding length.</p>
<p>For example, if <code class="docutils literal"><span class="pre">A</span></code> is a matrix and <code class="docutils literal"><span class="pre">p=2</span></code>, then this is equivalent to the Frobenius norm.</p>
</dd></dl>

<dl class="function">
<dt id="Base.normalize!">
<code class="descname">normalize!</code><span class="sig-paren">(</span><em>v</em><span class="optional">[</span>, <em>p=2</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#Base.normalize!" title="Permalink to this definition"></a></dt>
<dd><p>Normalize the vector <code class="docutils literal"><span class="pre">v</span></code> in-place with respect to the <code class="docutils literal"><span class="pre">p</span></code>-norm.</p>
<p>Inputs:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">v::AbstractVector</span></code> - vector to be normalized</li>
<li><code class="docutils literal"><span class="pre">p::Real</span></code> - The <code class="docutils literal"><span class="pre">p</span></code>-norm to normalize with respect to. Default: 2</li>
</ul>
<p>Output:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">v</span></code> - A unit vector being the input vector, rescaled to have norm 1.       The input vector is modified in-place.</li>
</ul>
<p>See also:</p>
<p><code class="docutils literal"><span class="pre">normalize</span></code>, <code class="docutils literal"><span class="pre">qr</span></code></p>
</dd></dl>

<dl class="function">
<dt id="Base.normalize">
<code class="descname">normalize</code><span class="sig-paren">(</span><em>v</em><span class="optional">[</span>, <em>p=2</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#Base.normalize" title="Permalink to this definition"></a></dt>
<dd><p>Normalize the vector <code class="docutils literal"><span class="pre">v</span></code> with respect to the <code class="docutils literal"><span class="pre">p</span></code>-norm.</p>
<p>Inputs:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">v::AbstractVector</span></code> - vector to be normalized</li>
<li><code class="docutils literal"><span class="pre">p::Real</span></code> - The <code class="docutils literal"><span class="pre">p</span></code>-norm to normalize with respect to. Default: 2</li>
</ul>
<p>Output:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">v</span></code> - A unit vector being a copy of the input vector, scaled to have norm 1</li>
</ul>
<p>See also:</p>
<p><code class="docutils literal"><span class="pre">normalize!</span></code>, <code class="docutils literal"><span class="pre">qr</span></code></p>
</dd></dl>

<dl class="function">
<dt id="Base.cond">
<code class="descname">cond</code><span class="sig-paren">(</span><em>M</em><span class="optional">[</span>, <em>p</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#Base.cond" title="Permalink to this definition"></a></dt>
<dd><p>Condition number of the matrix <code class="docutils literal"><span class="pre">M</span></code>, computed using the operator <code class="docutils literal"><span class="pre">p</span></code>-norm. Valid values for <code class="docutils literal"><span class="pre">p</span></code> are <code class="docutils literal"><span class="pre">1</span></code>, <code class="docutils literal"><span class="pre">2</span></code> (default), or <code class="docutils literal"><span class="pre">Inf</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.condskeel">
<code class="descname">condskeel</code><span class="sig-paren">(</span><em>M</em><span class="optional">[</span>, <em>x</em>, <em>p</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#Base.condskeel" title="Permalink to this definition"></a></dt>
<dd><div class="math">
\[\begin{split}\kappa_S(M, p) &amp; = \left\Vert \left\vert M \right\vert \left\vert M^{-1} \right\vert  \right\Vert_p \\
\kappa_S(M, x, p) &amp; = \left\Vert \left\vert M \right\vert \left\vert M^{-1} \right\vert \left\vert x \right\vert \right\Vert_p\end{split}\]</div>
<p>Skeel condition number <span class="math">\(\kappa_S\)</span> of the matrix <code class="docutils literal"><span class="pre">M</span></code>, optionally with respect to the vector <code class="docutils literal"><span class="pre">x</span></code>, as computed using the operator <code class="docutils literal"><span class="pre">p</span></code>-norm. <code class="docutils literal"><span class="pre">p</span></code> is <code class="docutils literal"><span class="pre">Inf</span></code> by default, if not provided. Valid values for <code class="docutils literal"><span class="pre">p</span></code> are <code class="docutils literal"><span class="pre">1</span></code>, <code class="docutils literal"><span class="pre">2</span></code>, or <code class="docutils literal"><span class="pre">Inf</span></code>.</p>
<p>This quantity is also known in the literature as the Bauer condition number, relative condition number, or componentwise relative condition number.</p>
</dd></dl>

<dl class="function">
<dt id="Base.trace">
<code class="descname">trace</code><span class="sig-paren">(</span><em>M</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.trace" title="Permalink to this definition"></a></dt>
<dd><p>Matrix trace.</p>
</dd></dl>

<dl class="function">
<dt id="Base.det">
<code class="descname">det</code><span class="sig-paren">(</span><em>M</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.det" title="Permalink to this definition"></a></dt>
<dd><p>Matrix determinant.</p>
</dd></dl>

<dl class="function">
<dt id="Base.logdet">
<code class="descname">logdet</code><span class="sig-paren">(</span><em>M</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.logdet" title="Permalink to this definition"></a></dt>
<dd><p>Log of matrix determinant. Equivalent to <code class="docutils literal"><span class="pre">log(det(M))</span></code>, but may provide increased accuracy and/or speed.</p>
</dd></dl>

<dl class="function">
<dt id="Base.logabsdet">
<code class="descname">logabsdet</code><span class="sig-paren">(</span><em>M</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.logabsdet" title="Permalink to this definition"></a></dt>
<dd><p>Log of absolute value of determinant of real matrix. Equivalent to <code class="docutils literal"><span class="pre">(log(abs(det(M))),</span> <span class="pre">sign(det(M)))</span></code>, but may provide increased accuracy and/or speed.</p>
</dd></dl>

<dl class="function">
<dt id="Base.inv">
<code class="descname">inv</code><span class="sig-paren">(</span><em>M</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.inv" title="Permalink to this definition"></a></dt>
<dd><p>Matrix inverse.</p>
</dd></dl>

<dl class="function">
<dt id="Base.pinv">
<code class="descname">pinv</code><span class="sig-paren">(</span><em>M</em><span class="optional">[</span>, <em>tol</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#Base.pinv" title="Permalink to this definition"></a></dt>
<dd><p>Computes the Moore-Penrose pseudoinverse.</p>
<p>For matrices <code class="docutils literal"><span class="pre">M</span></code> with floating point elements, it is convenient to compute the pseudoinverse by inverting only singular values above a given threshold, <code class="docutils literal"><span class="pre">tol</span></code>.</p>
<p>The optimal choice of <code class="docutils literal"><span class="pre">tol</span></code> varies both with the value of <code class="docutils literal"><span class="pre">M</span></code> and the intended application of the pseudoinverse. The default value of <code class="docutils literal"><span class="pre">tol</span></code> is <code class="docutils literal"><span class="pre">eps(real(float(one(eltype(M)))))*maximum(size(A))</span></code>, which is essentially machine epsilon for the real part of a matrix element multiplied by the larger matrix dimension. For inverting dense ill-conditioned matrices in a least-squares sense, <code class="docutils literal"><span class="pre">tol</span> <span class="pre">=</span> <span class="pre">sqrt(eps(real(float(one(eltype(M))))))</span></code> is recommended.</p>
<p>For more information, see <a class="reference internal" href="#issue8859" id="id5">[issue8859]</a>, <a class="reference internal" href="#b96" id="id6">[B96]</a>, <a class="reference internal" href="#s84" id="id7">[S84]</a>, <a class="reference internal" href="#ky88" id="id8">[KY88]</a>.</p>
<table class="docutils citation" frame="void" id="issue8859" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[issue8859]</a></td><td>Issue 8859, &#8220;Fix least squares&#8221;, <a class="reference external" href="https://github.com/JuliaLang/julia/pull/8859">https://github.com/JuliaLang/julia/pull/8859</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="b96" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[B96]</a></td><td>ke Bjrck, &#8220;Numerical Methods for Least Squares Problems&#8221;,  SIAM Press, Philadelphia, 1996, &#8220;Other Titles in Applied Mathematics&#8221;, Vol. 51. <a class="reference external" href="http://epubs.siam.org/doi/book/10.1137/1.9781611971484">doi:10.1137/1.9781611971484</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="s84" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7">[S84]</a></td><td><ol class="first last upperalpha simple" start="7">
<li><ol class="first upperalpha" start="23">
<li>Stewart, &#8220;Rank Degeneracy&#8221;, SIAM Journal on Scientific and Statistical Computing, 5(2), 1984, 403-413. <a class="reference external" href="http://epubs.siam.org/doi/abs/10.1137/0905030">doi:10.1137/0905030</a></li>
</ol>
</li>
</ol>
</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="ky88" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8">[KY88]</a></td><td>Konstantinos Konstantinides and Kung Yao, &#8220;Statistical analysis of effective singular values in matrix rank determination&#8221;, IEEE Transactions on Acoustics, Speech and Signal Processing, 36(5), 1988, 757-763. <a class="reference external" href="http://dx.doi.org/10.1109/29.1585">doi:10.1109/29.1585</a></td></tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Base.nullspace">
<code class="descname">nullspace</code><span class="sig-paren">(</span><em>M</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.nullspace" title="Permalink to this definition"></a></dt>
<dd><p>Basis for nullspace of <code class="docutils literal"><span class="pre">M</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.repmat">
<code class="descname">repmat</code><span class="sig-paren">(</span><em>A</em>, <em>n</em>, <em>m</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.repmat" title="Permalink to this definition"></a></dt>
<dd><p>Construct a matrix by repeating the given matrix <code class="docutils literal"><span class="pre">n</span></code> times in dimension 1 and <code class="docutils literal"><span class="pre">m</span></code> times in dimension 2.</p>
</dd></dl>

<dl class="function">
<dt id="Base.repeat">
<code class="descname">repeat</code><span class="sig-paren">(</span><em>A::AbstractArray; inner=ntuple(x-&gt;1</em>, <em>ndims(A))</em>, <em>outer=ntuple(x-&gt;1</em>, <em>ndims(A))</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.repeat" title="Permalink to this definition"></a></dt>
<dd><p>Construct an array by repeating the entries of <code class="docutils literal"><span class="pre">A</span></code>. The i-th element of <code class="docutils literal"><span class="pre">inner</span></code> specifies the number of times that the individual entries of the i-th dimension of <code class="docutils literal"><span class="pre">A</span></code> should be repeated. The i-th element of <code class="docutils literal"><span class="pre">outer</span></code> specifies the number of times that a slice along the i-th dimension of <code class="docutils literal"><span class="pre">A</span></code> should be repeated. If <code class="docutils literal"><span class="pre">inner</span></code> or <code class="docutils literal"><span class="pre">outer</span></code> are omitted, no repetition is performed.</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">repeat</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="n">inner</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="mi">4</span><span class="o">-</span><span class="n">element</span> <span class="n">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">1</span><span class="p">}:</span>
 <span class="mi">1</span>
 <span class="mi">1</span>
 <span class="mi">2</span>
 <span class="mi">2</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">repeat</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="n">outer</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="mi">4</span><span class="o">-</span><span class="n">element</span> <span class="n">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">1</span><span class="p">}:</span>
 <span class="mi">1</span>
 <span class="mi">2</span>
 <span class="mi">1</span>
 <span class="mi">2</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">repeat</span><span class="p">([</span><span class="mi">1</span> <span class="mi">2</span><span class="p">;</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">],</span> <span class="n">inner</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">outer</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="mi">4</span><span class="n">6</span> <span class="n">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">2</span><span class="p">}:</span>
 <span class="mi">1</span>  <span class="mi">2</span>  <span class="mi">1</span>  <span class="mi">2</span>  <span class="mi">1</span>  <span class="mi">2</span>
 <span class="mi">1</span>  <span class="mi">2</span>  <span class="mi">1</span>  <span class="mi">2</span>  <span class="mi">1</span>  <span class="mi">2</span>
 <span class="mi">3</span>  <span class="mi">4</span>  <span class="mi">3</span>  <span class="mi">4</span>  <span class="mi">3</span>  <span class="mi">4</span>
 <span class="mi">3</span>  <span class="mi">4</span>  <span class="mi">3</span>  <span class="mi">4</span>  <span class="mi">3</span>  <span class="mi">4</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="Base.kron">
<code class="descname">kron</code><span class="sig-paren">(</span><em>A</em>, <em>B</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.kron" title="Permalink to this definition"></a></dt>
<dd><p>Kronecker tensor product of two vectors or two matrices.</p>
</dd></dl>

<dl class="function">
<dt id="Base.blkdiag">
<code class="descname">blkdiag</code><span class="sig-paren">(</span><em>A...</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.blkdiag" title="Permalink to this definition"></a></dt>
<dd><p>Concatenate matrices block-diagonally. Currently only implemented for sparse matrices.</p>
</dd></dl>

<dl class="function">
<dt id="Base.linreg">
<code class="descname">linreg</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.linreg" title="Permalink to this definition"></a></dt>
<dd><p>Perform simple linear regression using Ordinary Least Squares. Returns <code class="docutils literal"><span class="pre">a</span></code> and <code class="docutils literal"><span class="pre">b</span></code> such that <code class="docutils literal"><span class="pre">a</span> <span class="pre">+</span> <span class="pre">b*x</span></code> is the closest straight line to the given points <code class="docutils literal"><span class="pre">(x,</span> <span class="pre">y)</span></code>, i.e., such that the squared error between <code class="docutils literal"><span class="pre">y</span></code> and <code class="docutils literal"><span class="pre">a</span> <span class="pre">+</span> <span class="pre">b*x</span></code> is minimized.</p>
<p>Examples:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="n">PyPlot</span>
<span class="n">x</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">:</span><span class="mf">12.0</span>
<span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="mf">5.5</span><span class="p">,</span> <span class="mf">6.3</span><span class="p">,</span> <span class="mf">7.6</span><span class="p">,</span> <span class="mf">8.8</span><span class="p">,</span> <span class="mf">10.9</span><span class="p">,</span> <span class="mf">11.79</span><span class="p">,</span> <span class="mf">13.48</span><span class="p">,</span> <span class="mf">15.02</span><span class="p">,</span> <span class="mf">17.77</span><span class="p">,</span> <span class="mf">20.81</span><span class="p">,</span> <span class="mf">22.0</span><span class="p">,</span> <span class="mf">22.99</span><span class="p">]</span>
<span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">linreg</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>          <span class="c"># Linear regression</span>
<span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s">&quot;o&quot;</span><span class="p">)</span>              <span class="c"># Plot (x, y) points</span>
<span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>             <span class="c"># Plot line determined by linear regression</span>
</pre></div>
</div>
<p>See also:</p>
<p><code class="docutils literal"><span class="pre">\</span></code>, <code class="docutils literal"><span class="pre">cov</span></code>, <code class="docutils literal"><span class="pre">std</span></code>, <code class="docutils literal"><span class="pre">mean</span></code></p>
</dd></dl>

<dl class="function">
<dt id="Base.expm">
<code class="descname">expm</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.expm" title="Permalink to this definition"></a></dt>
<dd><p>Compute the matrix exponential of <code class="docutils literal"><span class="pre">A</span></code>, defined by</p>
<div class="math">
\[e^A = \sum_{n=0}^{\infty} \frac{A^n}{n!}.\]</div>
<p>For symmetric or Hermitian <code class="docutils literal"><span class="pre">A</span></code>, an eigendecomposition (<a class="reference internal" href="#Base.eigfact" title="Base.eigfact"><code class="xref jl jl-func docutils literal"><span class="pre">eigfact()</span></code></a>) is used, otherwise the scaling and squaring algorithm (see <a class="reference internal" href="#h05" id="id9">[H05]</a>) is chosen.</p>
<table class="docutils citation" frame="void" id="h05" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id9">[H05]</a></td><td>Nicholas J. Higham, &#8220;The squaring and scaling method for the matrix exponential revisited&#8221;, SIAM Journal on Matrix Analysis and Applications, 26(4), 2005, 1179-1193. <a class="reference external" href="http://dx.doi.org/10.1137/090768539">doi:10.1137/090768539</a></td></tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Base.logm">
<code class="descname">logm</code><span class="sig-paren">(</span><em>A::StridedMatrix</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.logm" title="Permalink to this definition"></a></dt>
<dd><p>If <code class="docutils literal"><span class="pre">A</span></code> has no negative real eigenvalue, compute the principal matrix logarithm of <code class="docutils literal"><span class="pre">A</span></code>, i.e. the unique matrix <span class="math">\(X\)</span> such that <span class="math">\(e^X = A\)</span> and <span class="math">\(-\pi &lt; Im(\lambda) &lt; \pi\)</span> for all the eigenvalues <span class="math">\(\lambda\)</span> of <span class="math">\(X\)</span>. If <code class="docutils literal"><span class="pre">A</span></code> has nonpositive eigenvalues, a nonprincipal matrix function is returned whenever possible.</p>
<p>If <code class="docutils literal"><span class="pre">A</span></code> is symmetric or Hermitian, its eigendecomposition (<a class="reference internal" href="#Base.eigfact" title="Base.eigfact"><code class="xref jl jl-func docutils literal"><span class="pre">eigfact()</span></code></a>) is used, if <code class="docutils literal"><span class="pre">A</span></code> is triangular an improved version of the inverse scaling and squaring method is employed (see <a class="reference internal" href="#ah12" id="id10">[AH12]</a> and <a class="reference internal" href="#ahr13" id="id11">[AHR13]</a>). For general matrices, the complex Schur form (<a class="reference internal" href="#Base.schur" title="Base.schur"><code class="xref jl jl-func docutils literal"><span class="pre">schur()</span></code></a>) is computed and the triangular algorithm is used on the triangular factor.</p>
<table class="docutils citation" frame="void" id="ah12" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id10">[AH12]</a></td><td>Awad H. Al-Mohy and Nicholas J. Higham, &#8220;Improved inverse  scaling and squaring algorithms for the matrix logarithm&#8221;, SIAM Journal on Scientific Computing, 34(4), 2012, C153-C169. <a class="reference external" href="http://dx.doi.org/10.1137/110852553">doi:10.1137/110852553</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="ahr13" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id11">[AHR13]</a></td><td>Awad H. Al-Mohy, Nicholas J. Higham and Samuel D. Relton, &#8220;Computing the Frchet derivative of the matrix logarithm and estimating the condition number&#8221;, SIAM Journal on Scientific Computing, 35(4), 2013, C394-C410. <a class="reference external" href="http://dx.doi.org/10.1137/120885991">doi:10.1137/120885991</a></td></tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Base.sqrtm">
<code class="descname">sqrtm</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.sqrtm" title="Permalink to this definition"></a></dt>
<dd><p>If <code class="docutils literal"><span class="pre">A</span></code> has no negative real eigenvalues, compute the principal matrix square root of <code class="docutils literal"><span class="pre">A</span></code>, that is the unique matrix <span class="math">\(X\)</span> with eigenvalues having positive real part such that <span class="math">\(X^2 = A\)</span>. Otherwise, a nonprincipal square root is returned.</p>
<p>If <code class="docutils literal"><span class="pre">A</span></code> is symmetric or Hermitian, its eigendecomposition (<a class="reference internal" href="#Base.eigfact" title="Base.eigfact"><code class="xref jl jl-func docutils literal"><span class="pre">eigfact()</span></code></a>) is used to compute the square root. Otherwise, the square root is determined by means of the Bjrck-Hammarling method, which computes the complex Schur form (<a class="reference internal" href="#Base.schur" title="Base.schur"><code class="xref jl jl-func docutils literal"><span class="pre">schur()</span></code></a>) and then the complex square root of the triangular factor.</p>
<table class="docutils citation" frame="void" id="bh83" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[BH83]</td><td>ke Bjrck and Sven Hammarling, &#8220;A Schur method for the square root of a matrix&#8221;, Linear Algebra and its Applications, 52-53, 1983, 127-140. <a class="reference external" href="http://dx.doi.org/10.1016/0024-3795(83)80010-X">doi:10.1016/0024-3795(83)80010-X</a></td></tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Base.lyap">
<code class="descname">lyap</code><span class="sig-paren">(</span><em>A</em>, <em>C</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.lyap" title="Permalink to this definition"></a></dt>
<dd><p>Computes the solution <code class="docutils literal"><span class="pre">X</span></code> to the continuous Lyapunov equation <code class="docutils literal"><span class="pre">AX</span> <span class="pre">+</span> <span class="pre">XA'</span> <span class="pre">+</span> <span class="pre">C</span> <span class="pre">=</span> <span class="pre">0</span></code>, where no eigenvalue of <code class="docutils literal"><span class="pre">A</span></code> has a zero real part and no two eigenvalues are negative complex conjugates of each other.</p>
</dd></dl>

<dl class="function">
<dt id="Base.sylvester">
<code class="descname">sylvester</code><span class="sig-paren">(</span><em>A</em>, <em>B</em>, <em>C</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.sylvester" title="Permalink to this definition"></a></dt>
<dd><p>Computes the solution <code class="docutils literal"><span class="pre">X</span></code> to the Sylvester equation <code class="docutils literal"><span class="pre">AX</span> <span class="pre">+</span> <span class="pre">XB</span> <span class="pre">+</span> <span class="pre">C</span> <span class="pre">=</span> <span class="pre">0</span></code>, where <code class="docutils literal"><span class="pre">A</span></code>, <code class="docutils literal"><span class="pre">B</span></code> and <code class="docutils literal"><span class="pre">C</span></code> have compatible dimensions and <code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">-B</span></code> have no eigenvalues with equal real part.</p>
</dd></dl>

<dl class="function">
<dt id="Base.issymmetric">
<code class="descname">issymmetric</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span> &rarr; Bool<a class="headerlink" href="#Base.issymmetric" title="Permalink to this definition"></a></dt>
<dd><p>Test whether a matrix is symmetric.</p>
</dd></dl>

<dl class="function">
<dt id="Base.isposdef">
<code class="descname">isposdef</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span> &rarr; Bool<a class="headerlink" href="#Base.isposdef" title="Permalink to this definition"></a></dt>
<dd><p>Test whether a matrix is positive definite.</p>
</dd></dl>

<dl class="function">
<dt id="Base.isposdef!">
<code class="descname">isposdef!</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span> &rarr; Bool<a class="headerlink" href="#Base.isposdef!" title="Permalink to this definition"></a></dt>
<dd><p>Test whether a matrix is positive definite, overwriting <code class="docutils literal"><span class="pre">A</span></code> in the processes.</p>
</dd></dl>

<dl class="function">
<dt id="Base.istril">
<code class="descname">istril</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span> &rarr; Bool<a class="headerlink" href="#Base.istril" title="Permalink to this definition"></a></dt>
<dd><p>Test whether a matrix is lower triangular.</p>
</dd></dl>

<dl class="function">
<dt id="Base.istriu">
<code class="descname">istriu</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span> &rarr; Bool<a class="headerlink" href="#Base.istriu" title="Permalink to this definition"></a></dt>
<dd><p>Test whether a matrix is upper triangular.</p>
</dd></dl>

<dl class="function">
<dt id="Base.isdiag">
<code class="descname">isdiag</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span> &rarr; Bool<a class="headerlink" href="#Base.isdiag" title="Permalink to this definition"></a></dt>
<dd><p>Test whether a matrix is diagonal.</p>
</dd></dl>

<dl class="function">
<dt id="Base.ishermitian">
<code class="descname">ishermitian</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span> &rarr; Bool<a class="headerlink" href="#Base.ishermitian" title="Permalink to this definition"></a></dt>
<dd><p>Test whether a matrix is Hermitian.</p>
</dd></dl>

<dl class="function">
<dt id="Base.transpose">
<code class="descname">transpose</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.transpose" title="Permalink to this definition"></a></dt>
<dd><p>The transposition operator (<code class="docutils literal"><span class="pre">.'</span></code>).</p>
</dd></dl>

<dl class="function">
<dt id="Base.transpose!">
<code class="descname">transpose!</code><span class="sig-paren">(</span><em>dest</em>, <em>src</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.transpose!" title="Permalink to this definition"></a></dt>
<dd><p>Transpose array <code class="docutils literal"><span class="pre">src</span></code> and store the result in the preallocated array <code class="docutils literal"><span class="pre">dest</span></code>, which should have a size corresponding to <code class="docutils literal"><span class="pre">(size(src,2),size(src,1))</span></code>. No in-place transposition is supported and unexpected results will happen if <code class="docutils literal"><span class="pre">src</span></code> and <code class="docutils literal"><span class="pre">dest</span></code> have overlapping memory regions.</p>
</dd></dl>

<dl class="function">
<dt id="Base.ctranspose">
<code class="descname">ctranspose</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.ctranspose" title="Permalink to this definition"></a></dt>
<dd><p>The conjugate transposition operator (<code class="docutils literal"><span class="pre">'</span></code>).</p>
</dd></dl>

<dl class="function">
<dt id="Base.ctranspose!">
<code class="descname">ctranspose!</code><span class="sig-paren">(</span><em>dest</em>, <em>src</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.ctranspose!" title="Permalink to this definition"></a></dt>
<dd><p>Conjugate transpose array <code class="docutils literal"><span class="pre">src</span></code> and store the result in the preallocated array <code class="docutils literal"><span class="pre">dest</span></code>, which should have a size corresponding to <code class="docutils literal"><span class="pre">(size(src,2),size(src,1))</span></code>. No in-place transposition is supported and unexpected results will happen if <code class="docutils literal"><span class="pre">src</span></code> and <code class="docutils literal"><span class="pre">dest</span></code> have overlapping memory regions.</p>
</dd></dl>

<dl class="function">
<dt id="Base.eigs">
<code class="descname">eigs</code><span class="sig-paren">(</span><em>A; nev=6</em>, <em>ncv=max(20</em>, <em>2*nev+1)</em>, <em>which=&quot;LM&quot;</em>, <em>tol=0.0</em>, <em>maxiter=300</em>, <em>sigma=nothing</em>, <em>ritzvec=true</em>, <em>v0=zeros((0</em>, <em>))</em><span class="sig-paren">)</span> &rarr; (d,[v,],nconv,niter,nmult,resid)<a class="headerlink" href="#Base.eigs" title="Permalink to this definition"></a></dt>
<dd><p>Computes eigenvalues <code class="docutils literal"><span class="pre">d</span></code> of <code class="docutils literal"><span class="pre">A</span></code> using implicitly restarted Lanczos or Arnoldi iterations for real symmetric or general nonsymmetric matrices respectively.</p>
<p>The following keyword arguments are supported:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">nev</span></code>: Number of eigenvalues</li>
<li><code class="docutils literal"><span class="pre">ncv</span></code>: Number of Krylov vectors used in the computation; should satisfy <code class="docutils literal"><span class="pre">nev+1</span> <span class="pre">&lt;=</span> <span class="pre">ncv</span> <span class="pre">&lt;=</span> <span class="pre">n</span></code> for real symmetric problems and <code class="docutils literal"><span class="pre">nev+2</span> <span class="pre">&lt;=</span> <span class="pre">ncv</span> <span class="pre">&lt;=</span> <span class="pre">n</span></code> for other problems, where <code class="docutils literal"><span class="pre">n</span></code> is the size of the input matrix <code class="docutils literal"><span class="pre">A</span></code>. The default is <code class="docutils literal"><span class="pre">ncv</span> <span class="pre">=</span> <span class="pre">max(20,2*nev+1)</span></code>. Note that these restrictions limit the input matrix <code class="docutils literal"><span class="pre">A</span></code> to be of dimension at least 2.</li>
<li><code class="docutils literal"><span class="pre">which</span></code>: type of eigenvalues to compute. See the note below.</li>
</ul>
<table border="1" class="docutils">
<colgroup>
<col width="8%" />
<col width="92%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><code class="docutils literal"><span class="pre">which</span></code></th>
<th class="head">type of eigenvalues</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">:LM</span></code></td>
<td>eigenvalues of largest magnitude (default)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">:SM</span></code></td>
<td>eigenvalues of smallest magnitude</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">:LR</span></code></td>
<td>eigenvalues of largest real part</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">:SR</span></code></td>
<td>eigenvalues of smallest real part</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">:LI</span></code></td>
<td>eigenvalues of largest imaginary part (nonsymmetric or complex <code class="docutils literal"><span class="pre">A</span></code> only)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">:SI</span></code></td>
<td>eigenvalues of smallest imaginary part (nonsymmetric or complex <code class="docutils literal"><span class="pre">A</span></code> only)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">:BE</span></code></td>
<td>compute half of the eigenvalues from each end of the spectrum, biased in favor of the high end. (real symmetric <code class="docutils literal"><span class="pre">A</span></code> only)</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">tol</span></code>: parameter defining the relative tolerance for convergence of Ritz values (eigenvalue estimates).    A Ritz value <span class="math">\(\)</span> is considered converged when its associated residual    is less than or equal to the product of <code class="docutils literal"><span class="pre">tol</span></code> and <span class="math">\(max(^{2/3}, ||)\)</span>,    where <code class="docutils literal"><span class="pre"></span> <span class="pre">=</span> <span class="pre">eps(real(eltype(A)))/2</span></code> is LAPACK&#8217;s machine epsilon.    The residual associated with <span class="math">\(\)</span> and its corresponding Ritz vector <span class="math">\(v\)</span>    is defined as the norm <span class="math">\(||Av - v||\)</span>.    The specified value of <code class="docutils literal"><span class="pre">tol</span></code> should be positive; otherwise, it is ignored    and <span class="math">\(\)</span> is used instead.    Default: <span class="math">\(\)</span>.</li>
<li><code class="docutils literal"><span class="pre">maxiter</span></code>: Maximum number of iterations (default = 300)</li>
<li><code class="docutils literal"><span class="pre">sigma</span></code>: Specifies the level shift used in inverse iteration. If <code class="docutils literal"><span class="pre">nothing</span></code> (default), defaults to ordinary (forward) iterations. Otherwise, find eigenvalues close to <code class="docutils literal"><span class="pre">sigma</span></code> using shift and invert iterations.</li>
<li><code class="docutils literal"><span class="pre">ritzvec</span></code>: Returns the Ritz vectors <code class="docutils literal"><span class="pre">v</span></code> (eigenvectors) if <code class="docutils literal"><span class="pre">true</span></code></li>
<li><code class="docutils literal"><span class="pre">v0</span></code>: starting vector from which to start the iterations</li>
</ul>
<p><code class="docutils literal"><span class="pre">eigs</span></code> returns the <code class="docutils literal"><span class="pre">nev</span></code> requested eigenvalues in <code class="docutils literal"><span class="pre">d</span></code>, the corresponding Ritz vectors <code class="docutils literal"><span class="pre">v</span></code> (only if <code class="docutils literal"><span class="pre">ritzvec=true</span></code>), the number of converged eigenvalues <code class="docutils literal"><span class="pre">nconv</span></code>, the number of iterations <code class="docutils literal"><span class="pre">niter</span></code> and the number of matrix vector multiplications <code class="docutils literal"><span class="pre">nmult</span></code>, as well as the final residual vector <code class="docutils literal"><span class="pre">resid</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>The <code class="docutils literal"><span class="pre">sigma</span></code> and <code class="docutils literal"><span class="pre">which</span></code> keywords interact: the description of eigenvalues searched for by <code class="docutils literal"><span class="pre">which</span></code> do <em>not</em> necessarily refer to the eigenvalues of <code class="docutils literal"><span class="pre">A</span></code>, but rather the linear operator constructed by the specification of the iteration mode implied by <code class="docutils literal"><span class="pre">sigma</span></code>.</p>
<table border="1" class="last docutils">
<colgroup>
<col width="19%" />
<col width="40%" />
<col width="40%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><code class="docutils literal"><span class="pre">sigma</span></code></th>
<th class="head">iteration mode</th>
<th class="head"><code class="docutils literal"><span class="pre">which</span></code> refers to eigenvalues of</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">nothing</span></code></td>
<td>ordinary (forward)</td>
<td><span class="math">\(A\)</span></td>
</tr>
<tr class="row-odd"><td>real or complex</td>
<td>inverse with level shift <code class="docutils literal"><span class="pre">sigma</span></code></td>
<td><span class="math">\((A - \sigma I )^{-1}\)</span></td>
</tr>
</tbody>
</table>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Although <code class="docutils literal"><span class="pre">tol</span></code> has a default value, the best choice depends strongly on the matrix <code class="docutils literal"><span class="pre">A</span></code>. We recommend that users _always_ specify a value for <code class="docutils literal"><span class="pre">tol</span></code> which suits their specific needs.</p>
<p>For details of how the errors in the computed eigenvalues are estimated, see:</p>
<ul class="last simple">
<li><ol class="first upperalpha" start="2">
<li><ol class="first upperalpha" start="14">
<li>Parlett, &#8220;The Symmetric Eigenvalue Problem&#8221;, SIAM: Philadelphia, 2/e (1998), Ch. 13.2, &#8220;Accessing Accuracy in Lanczos Problems&#8221;, pp. 290-292 ff.</li>
</ol>
</li>
</ol>
</li>
<li><ol class="first upperalpha" start="18">
<li><ol class="first upperalpha" start="2">
<li>Lehoucq and D. C. Sorensen, &#8220;Deflation Techniques for an Implicitly Restarted Arnoldi Iteration&#8221;, SIAM Journal on Matrix Analysis and Applications (1996), 17(4), 789821.  doi:10.1137/S0895479895281484</li>
</ol>
</li>
</ol>
</li>
</ul>
</div>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">eigs</code><span class="sig-paren">(</span><em>A</em>, <em>B; nev=6</em>, <em>ncv=max(20</em>, <em>2*nev+1)</em>, <em>which=&quot;LM&quot;</em>, <em>tol=0.0</em>, <em>maxiter=300</em>, <em>sigma=nothing</em>, <em>ritzvec=true</em>, <em>v0=zeros((0</em>, <em>))</em><span class="sig-paren">)</span> &rarr; (d,[v,],nconv,niter,nmult,resid)</dt>
<dd><p>Computes generalized eigenvalues <code class="docutils literal"><span class="pre">d</span></code> of <code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">B</span></code> using implicitly restarted Lanczos or Arnoldi iterations for real symmetric or general nonsymmetric matrices respectively.</p>
<p>The following keyword arguments are supported:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">nev</span></code>: Number of eigenvalues</li>
<li><code class="docutils literal"><span class="pre">ncv</span></code>: Number of Krylov vectors used in the computation; should satisfy <code class="docutils literal"><span class="pre">nev+1</span> <span class="pre">&lt;=</span> <span class="pre">ncv</span> <span class="pre">&lt;=</span> <span class="pre">n</span></code> for real symmetric problems and <code class="docutils literal"><span class="pre">nev+2</span> <span class="pre">&lt;=</span> <span class="pre">ncv</span> <span class="pre">&lt;=</span> <span class="pre">n</span></code> for other problems, where <code class="docutils literal"><span class="pre">n</span></code> is the size of the input matrices <code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">B</span></code>. The default is <code class="docutils literal"><span class="pre">ncv</span> <span class="pre">=</span> <span class="pre">max(20,2*nev+1)</span></code>. Note that these restrictions limit the input matrix <code class="docutils literal"><span class="pre">A</span></code> to be of dimension at least 2.</li>
<li><code class="docutils literal"><span class="pre">which</span></code>: type of eigenvalues to compute. See the note below.</li>
</ul>
<table border="1" class="docutils">
<colgroup>
<col width="8%" />
<col width="92%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><code class="docutils literal"><span class="pre">which</span></code></th>
<th class="head">type of eigenvalues</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">:LM</span></code></td>
<td>eigenvalues of largest magnitude (default)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">:SM</span></code></td>
<td>eigenvalues of smallest magnitude</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">:LR</span></code></td>
<td>eigenvalues of largest real part</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">:SR</span></code></td>
<td>eigenvalues of smallest real part</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">:LI</span></code></td>
<td>eigenvalues of largest imaginary part (nonsymmetric or complex <code class="docutils literal"><span class="pre">A</span></code> only)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">:SI</span></code></td>
<td>eigenvalues of smallest imaginary part (nonsymmetric or complex <code class="docutils literal"><span class="pre">A</span></code> only)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">:BE</span></code></td>
<td>compute half of the eigenvalues from each end of the spectrum, biased in favor of the high end. (real symmetric <code class="docutils literal"><span class="pre">A</span></code> only)</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">tol</span></code>: relative tolerance used in the convergence criterion for eigenvalues, similar to    <code class="docutils literal"><span class="pre">tol</span></code> in the <a class="reference internal" href="#Base.eigs" title="Base.eigs"><code class="xref jl jl-func docutils literal"><span class="pre">eigs()</span></code></a> method for the ordinary eigenvalue    problem, but effectively for the eigenvalues of <span class="math">\(B^{-1} A\)</span> instead of <span class="math">\(A\)</span>.    See the documentation for the ordinary eigenvalue problem in    <a class="reference internal" href="#Base.eigs" title="Base.eigs"><code class="xref jl jl-func docutils literal"><span class="pre">eigs()</span></code></a> and the accompanying note about <code class="docutils literal"><span class="pre">tol</span></code>.</li>
<li><code class="docutils literal"><span class="pre">maxiter</span></code>: Maximum number of iterations (default = 300)</li>
<li><code class="docutils literal"><span class="pre">sigma</span></code>: Specifies the level shift used in inverse iteration. If <code class="docutils literal"><span class="pre">nothing</span></code> (default), defaults to ordinary (forward) iterations. Otherwise, find eigenvalues close to <code class="docutils literal"><span class="pre">sigma</span></code> using shift and invert iterations.</li>
<li><code class="docutils literal"><span class="pre">ritzvec</span></code>: Returns the Ritz vectors <code class="docutils literal"><span class="pre">v</span></code> (eigenvectors) if <code class="docutils literal"><span class="pre">true</span></code></li>
<li><code class="docutils literal"><span class="pre">v0</span></code>: starting vector from which to start the iterations</li>
</ul>
<p><code class="docutils literal"><span class="pre">eigs</span></code> returns the <code class="docutils literal"><span class="pre">nev</span></code> requested eigenvalues in <code class="docutils literal"><span class="pre">d</span></code>, the corresponding Ritz vectors <code class="docutils literal"><span class="pre">v</span></code> (only if <code class="docutils literal"><span class="pre">ritzvec=true</span></code>), the number of converged eigenvalues <code class="docutils literal"><span class="pre">nconv</span></code>, the number of iterations <code class="docutils literal"><span class="pre">niter</span></code> and the number of matrix vector multiplications <code class="docutils literal"><span class="pre">nmult</span></code>, as well as the final residual vector <code class="docutils literal"><span class="pre">resid</span></code>.</p>
<p><strong>Example</strong></p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">X</span> <span class="o">=</span> <span class="n">sprand</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">)</span>
<span class="n">eigs</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">nsv</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">tol</span> <span class="o">=</span> <span class="mf">1e-3</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>The <code class="docutils literal"><span class="pre">sigma</span></code> and <code class="docutils literal"><span class="pre">which</span></code> keywords interact: the description of eigenvalues searched for by <code class="docutils literal"><span class="pre">which</span></code> do <em>not</em> necessarily refer to the eigenvalue problem <span class="math">\(Av = Bv\lambda\)</span>, but rather the linear operator constructed by the specification of the iteration mode implied by <code class="docutils literal"><span class="pre">sigma</span></code>.</p>
<table border="1" class="last docutils">
<colgroup>
<col width="19%" />
<col width="40%" />
<col width="42%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><code class="docutils literal"><span class="pre">sigma</span></code></th>
<th class="head">iteration mode</th>
<th class="head"><code class="docutils literal"><span class="pre">which</span></code> refers to the problem</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">nothing</span></code></td>
<td>ordinary (forward)</td>
<td><span class="math">\(Av = Bv\lambda\)</span></td>
</tr>
<tr class="row-odd"><td>real or complex</td>
<td>inverse with level shift <code class="docutils literal"><span class="pre">sigma</span></code></td>
<td><span class="math">\((A - \sigma B )^{-1}B = v\nu\)</span></td>
</tr>
</tbody>
</table>
</div>
</dd></dl>

<dl class="function">
<dt id="Base.svds">
<code class="descname">svds</code><span class="sig-paren">(</span><em>A; nsv=6</em>, <em>ritzvec=true</em>, <em>tol=0.0</em>, <em>maxiter=1000</em>, <em>ncv=2*nsv</em>, <em>u0=zeros((0</em>, <em>))</em>, <em>v0=zeros((0</em>, <em>))</em><span class="sig-paren">)</span> &rarr; (SVD([left_sv,] s, [right_sv,]), nconv, niter, nmult, resid)<a class="headerlink" href="#Base.svds" title="Permalink to this definition"></a></dt>
<dd><p>Computes the largest singular values <code class="docutils literal"><span class="pre">s</span></code> of <code class="docutils literal"><span class="pre">A</span></code> using implicitly restarted Lanczos iterations derived from <a class="reference internal" href="#Base.eigs" title="Base.eigs"><code class="xref jl jl-func docutils literal"><span class="pre">eigs()</span></code></a>.</p>
<p><strong>Inputs</strong></p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">A</span></code>: Linear operator whose singular values are desired. <code class="docutils literal"><span class="pre">A</span></code> may be represented as a subtype of <code class="docutils literal"><span class="pre">AbstractArray</span></code>, e.g., a sparse matrix, or any other type supporting the four methods <code class="docutils literal"><span class="pre">size(A)</span></code>, <code class="docutils literal"><span class="pre">eltype(A)</span></code>, <code class="docutils literal"><span class="pre">A</span> <span class="pre">*</span> <span class="pre">vector</span></code>, and <code class="docutils literal"><span class="pre">A'</span> <span class="pre">*</span> <span class="pre">vector</span></code>.</li>
<li><code class="docutils literal"><span class="pre">nsv</span></code>: Number of singular values. Default: 6.</li>
<li><code class="docutils literal"><span class="pre">ritzvec</span></code>: If <code class="docutils literal"><span class="pre">true</span></code>, return the left and right singular vectors <code class="docutils literal"><span class="pre">left_sv</span></code> and <code class="docutils literal"><span class="pre">right_sv</span></code>.  If <code class="docutils literal"><span class="pre">false</span></code>, omit the singular vectors. Default: <code class="docutils literal"><span class="pre">true</span></code>.</li>
<li><code class="docutils literal"><span class="pre">tol</span></code>: tolerance, see <a class="reference internal" href="#Base.eigs" title="Base.eigs"><code class="xref jl jl-func docutils literal"><span class="pre">eigs()</span></code></a>.</li>
<li><code class="docutils literal"><span class="pre">maxiter</span></code>: Maximum number of iterations, see <a class="reference internal" href="#Base.eigs" title="Base.eigs"><code class="xref jl jl-func docutils literal"><span class="pre">eigs()</span></code></a>. Default: 1000.</li>
<li><code class="docutils literal"><span class="pre">ncv</span></code>: Maximum size of the Krylov subspace, see <a class="reference internal" href="#Base.eigs" title="Base.eigs"><code class="xref jl jl-func docutils literal"><span class="pre">eigs()</span></code></a> (there called <code class="docutils literal"><span class="pre">nev</span></code>). Default: <code class="docutils literal"><span class="pre">2*nsv</span></code>.</li>
<li><code class="docutils literal"><span class="pre">u0</span></code>: Initial guess for the first left Krylov vector. It may have length <code class="docutils literal"><span class="pre">m</span></code> (the first dimension of <code class="docutils literal"><span class="pre">A</span></code>), or 0.</li>
<li><code class="docutils literal"><span class="pre">v0</span></code>: Initial guess for the first right Krylov vector. It may have length <code class="docutils literal"><span class="pre">n</span></code> (the second dimension of <code class="docutils literal"><span class="pre">A</span></code>), or 0.</li>
</ul>
<p><strong>Outputs</strong></p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">svd</span></code>: An <code class="docutils literal"><span class="pre">SVD</span></code> object containing the left singular vectors, the requested values, and the right singular vectors. If <code class="docutils literal"><span class="pre">ritzvec</span> <span class="pre">=</span> <span class="pre">false</span></code>, the left and right singular vectors will be empty.</li>
<li><code class="docutils literal"><span class="pre">nconv</span></code>: Number of converged singular values.</li>
<li><code class="docutils literal"><span class="pre">niter</span></code>: Number of iterations.</li>
<li><code class="docutils literal"><span class="pre">nmult</span></code>: Number of matrixvector products used.</li>
<li><code class="docutils literal"><span class="pre">resid</span></code>: Final residual vector.</li>
</ul>
<p><strong>Example</strong></p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">X</span> <span class="o">=</span> <span class="n">sprand</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">)</span>
<span class="n">svds</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">nsv</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Implementation note</strong></p>
<p><code class="docutils literal"><span class="pre">svds(A)</span></code> is formally equivalent to calling <code class="docutils literal"><span class="pre">eigs</span></code> to perform implicitly restarted Lanczos tridiagonalization on the Hermitian matrix <span class="math">\(\begin{pmatrix} 0 &amp; A^\prime \\ A &amp; 0 \end{pmatrix}\)</span>, whose eigenvalues are plus and minus the singular values of <span class="math">\(A\)</span>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.peakflops">
<code class="descname">peakflops</code><span class="sig-paren">(</span><em>n; parallel=false</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.peakflops" title="Permalink to this definition"></a></dt>
<dd><p><code class="docutils literal"><span class="pre">peakflops</span></code> computes the peak flop rate of the computer by using double precision <a class="reference internal" href="#Base.LinAlg.BLAS.gemm!" title="Base.LinAlg.BLAS.gemm!"><code class="xref jl jl-func docutils literal"><span class="pre">Base.LinAlg.BLAS.gemm!()</span></code></a>. By default, if no arguments are specified, it multiplies a matrix of size <code class="docutils literal"><span class="pre">n</span> <span class="pre">x</span> <span class="pre">n</span></code>, where <code class="docutils literal"><span class="pre">n</span> <span class="pre">=</span> <span class="pre">2000</span></code>. If the underlying BLAS is using multiple threads, higher flop rates are realized. The number of BLAS threads can be set with <code class="docutils literal"><span class="pre">BLAS.set_num_threads(n)</span></code>.</p>
<p>If the keyword argument <code class="docutils literal"><span class="pre">parallel</span></code> is set to <code class="docutils literal"><span class="pre">true</span></code>, <code class="docutils literal"><span class="pre">peakflops</span></code> is run in parallel on all the worker processors. The flop rate of the entire parallel computer is returned. When running in parallel, only 1 BLAS thread is used. The argument <code class="docutils literal"><span class="pre">n</span></code> still refers to the size of the problem that is solved on each processor.</p>
</dd></dl>

</div>
<div class="section" id="low-level-matrix-operations">
<h2>Low-level matrix operations<a class="headerlink" href="#low-level-matrix-operations" title="Permalink to this headline"></a></h2>
<p>Matrix operations involving transpositions operations like <code class="docutils literal"><span class="pre">A'</span> <span class="pre">\</span> <span class="pre">B</span></code> are converted
by the Julia parser into calls to specially named functions like <code class="docutils literal"><span class="pre">Ac_ldiv_B</span></code>.
If you want to overload these operations for your own types, then it is useful
to know the names of these functions.</p>
<p>Also, in many cases there are in-place versions of matrix operations that
allow you to supply a pre-allocated output vector or matrix.  This is useful
when optimizing critical code in order to avoid the overhead of repeated allocations.
These in-place operations are suffixed with <code class="docutils literal"><span class="pre">!</span></code> below (e.g. <code class="docutils literal"><span class="pre">A_mul_B!</span></code>)
according to the usual Julia convention.</p>
<dl class="function">
<dt id="Base.A_ldiv_B!">
<code class="descname">A_ldiv_B!</code><span class="sig-paren">(</span><span class="optional">[</span><em>Y</em>, <span class="optional">]</span><em>A</em>, <em>B</em><span class="sig-paren">)</span> &rarr; Y<a class="headerlink" href="#Base.A_ldiv_B!" title="Permalink to this definition"></a></dt>
<dd><p>Compute <code class="docutils literal"><span class="pre">A</span> <span class="pre">\</span> <span class="pre">B</span></code> in-place and store the result in <code class="docutils literal"><span class="pre">Y</span></code>, returning the result. If only two arguments are passed, then <code class="docutils literal"><span class="pre">A_ldiv_B!(A,</span> <span class="pre">B)</span></code> overwrites <code class="docutils literal"><span class="pre">B</span></code> with the result.</p>
<p>The argument <code class="docutils literal"><span class="pre">A</span></code> should <em>not</em> be a matrix.  Rather, instead of matrices it should be a factorization object (e.g. produced by <a class="reference internal" href="#Base.factorize" title="Base.factorize"><code class="xref jl jl-func docutils literal"><span class="pre">factorize()</span></code></a> or <a class="reference internal" href="#Base.cholfact" title="Base.cholfact"><code class="xref jl jl-func docutils literal"><span class="pre">cholfact()</span></code></a>). The reason for this is that factorization itself is both expensive and typically allocates memory (although it can also be done in-place via, e.g., <a class="reference internal" href="#Base.lufact!" title="Base.lufact!"><code class="xref jl jl-func docutils literal"><span class="pre">lufact!()</span></code></a>), and performance-critical situations requiring <code class="docutils literal"><span class="pre">A_ldiv_B!</span></code> usually also require fine-grained control over the factorization of <code class="docutils literal"><span class="pre">A</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.A_ldiv_Bc">
<code class="descname">A_ldiv_Bc</code><span class="sig-paren">(</span><em>A</em>, <em>B</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.A_ldiv_Bc" title="Permalink to this definition"></a></dt>
<dd><p>For matrices or vectors <span class="math">\(A\)</span> and <span class="math">\(B\)</span>, calculates <span class="math">\(A\)</span> \ <span class="math">\(B\)</span>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.A_ldiv_Bt">
<code class="descname">A_ldiv_Bt</code><span class="sig-paren">(</span><em>A</em>, <em>B</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.A_ldiv_Bt" title="Permalink to this definition"></a></dt>
<dd><p>For matrices or vectors <span class="math">\(A\)</span> and <span class="math">\(B\)</span>, calculates <span class="math">\(A\)</span> \ <span class="math">\(B\)</span>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.A_mul_B!">
<code class="descname">A_mul_B!</code><span class="sig-paren">(</span><em>Y</em>, <em>A</em>, <em>B</em><span class="sig-paren">)</span> &rarr; Y<a class="headerlink" href="#Base.A_mul_B!" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the matrix-matrix or matrix-vector product <span class="math">\(AB\)</span> and stores the result in <code class="docutils literal"><span class="pre">Y</span></code>, overwriting the existing value of <code class="docutils literal"><span class="pre">Y</span></code>. Note that <code class="docutils literal"><span class="pre">Y</span></code> must not be aliased with either <code class="docutils literal"><span class="pre">A</span></code> or <code class="docutils literal"><span class="pre">B</span></code>.</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">A</span><span class="o">=</span><span class="p">[</span><span class="mf">1.0</span> <span class="mf">2.0</span><span class="p">;</span> <span class="mf">3.0</span> <span class="mf">4.0</span><span class="p">];</span> <span class="n">B</span><span class="o">=</span><span class="p">[</span><span class="mf">1.0</span> <span class="mf">1.0</span><span class="p">;</span> <span class="mf">1.0</span> <span class="mf">1.0</span><span class="p">];</span> <span class="n">Y</span> <span class="o">=</span> <span class="n">similar</span><span class="p">(</span><span class="n">B</span><span class="p">);</span> <span class="n">A_mul_B!</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">);</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">Y</span>
<span class="mi">2</span><span class="n">2</span> <span class="n">Array</span><span class="p">{</span><span class="kt">Float64</span><span class="p">,</span><span class="mi">2</span><span class="p">}:</span>
 <span class="mf">3.0</span>  <span class="mf">3.0</span>
 <span class="mf">7.0</span>  <span class="mf">7.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="Base.A_mul_Bc">
<code class="descname">A_mul_Bc</code><span class="sig-paren">(</span><em>A</em>, <em>B</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.A_mul_Bc" title="Permalink to this definition"></a></dt>
<dd><p>For matrices or vectors <span class="math">\(A\)</span> and <span class="math">\(B\)</span>, calculates <span class="math">\(AB\)</span>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.A_mul_Bt">
<code class="descname">A_mul_Bt</code><span class="sig-paren">(</span><em>A</em>, <em>B</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.A_mul_Bt" title="Permalink to this definition"></a></dt>
<dd><p>For matrices or vectors <span class="math">\(A\)</span> and <span class="math">\(B\)</span>, calculates <span class="math">\(AB\)</span>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.A_rdiv_Bc">
<code class="descname">A_rdiv_Bc</code><span class="sig-paren">(</span><em>A</em>, <em>B</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.A_rdiv_Bc" title="Permalink to this definition"></a></dt>
<dd><p>For matrices or vectors <span class="math">\(A\)</span> and <span class="math">\(B\)</span>, calculates <span class="math">\(A / B\)</span>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.A_rdiv_Bt">
<code class="descname">A_rdiv_Bt</code><span class="sig-paren">(</span><em>A</em>, <em>B</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.A_rdiv_Bt" title="Permalink to this definition"></a></dt>
<dd><p>For matrices or vectors <span class="math">\(A\)</span> and <span class="math">\(B\)</span>, calculates <span class="math">\(A / B\)</span>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.Ac_ldiv_B">
<code class="descname">Ac_ldiv_B</code><span class="sig-paren">(</span><em>A</em>, <em>B</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.Ac_ldiv_B" title="Permalink to this definition"></a></dt>
<dd><p>For matrices or vectors <span class="math">\(A\)</span> and <span class="math">\(B\)</span>, calculates <span class="math">\(A\)</span> \ <span class="math">\(B\)</span>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.Ac_ldiv_B!">
<code class="descname">Ac_ldiv_B!</code><span class="sig-paren">(</span><span class="optional">[</span><em>Y</em>, <span class="optional">]</span><em>A</em>, <em>B</em><span class="sig-paren">)</span> &rarr; Y<a class="headerlink" href="#Base.Ac_ldiv_B!" title="Permalink to this definition"></a></dt>
<dd><p>Similar to <a class="reference internal" href="#Base.A_ldiv_B!" title="Base.A_ldiv_B!"><code class="xref jl jl-func docutils literal"><span class="pre">A_ldiv_B!()</span></code></a>, but return <span class="math">\(A\)</span> \ <span class="math">\(B\)</span>, computing the result in-place in <code class="docutils literal"><span class="pre">Y</span></code> (or overwriting <code class="docutils literal"><span class="pre">B</span></code> if <code class="docutils literal"><span class="pre">Y</span></code> is not supplied).</p>
</dd></dl>

<dl class="function">
<dt id="Base.Ac_ldiv_Bc">
<code class="descname">Ac_ldiv_Bc</code><span class="sig-paren">(</span><em>A</em>, <em>B</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.Ac_ldiv_Bc" title="Permalink to this definition"></a></dt>
<dd><p>For matrices or vectors <span class="math">\(A\)</span> and <span class="math">\(B\)</span>, calculates <span class="math">\(A\)</span> \ <span class="math">\(B\)</span>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.Ac_mul_B">
<code class="descname">Ac_mul_B</code><span class="sig-paren">(</span><em>A</em>, <em>B</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.Ac_mul_B" title="Permalink to this definition"></a></dt>
<dd><p>For matrices or vectors <span class="math">\(A\)</span> and <span class="math">\(B\)</span>, calculates <span class="math">\(AB\)</span>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.Ac_mul_Bc">
<code class="descname">Ac_mul_Bc</code><span class="sig-paren">(</span><em>A</em>, <em>B</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.Ac_mul_Bc" title="Permalink to this definition"></a></dt>
<dd><p>For matrices or vectors <span class="math">\(A\)</span> and <span class="math">\(B\)</span>, calculates <span class="math">\(A B\)</span>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.Ac_rdiv_B">
<code class="descname">Ac_rdiv_B</code><span class="sig-paren">(</span><em>A</em>, <em>B</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.Ac_rdiv_B" title="Permalink to this definition"></a></dt>
<dd><p>For matrices or vectors <span class="math">\(A\)</span> and <span class="math">\(B\)</span>, calculates <span class="math">\(A / B\)</span>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.Ac_rdiv_Bc">
<code class="descname">Ac_rdiv_Bc</code><span class="sig-paren">(</span><em>A</em>, <em>B</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.Ac_rdiv_Bc" title="Permalink to this definition"></a></dt>
<dd><p>For matrices or vectors <span class="math">\(A\)</span> and <span class="math">\(B\)</span>, calculates <span class="math">\(A / B\)</span>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.At_ldiv_B">
<code class="descname">At_ldiv_B</code><span class="sig-paren">(</span><em>A</em>, <em>B</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.At_ldiv_B" title="Permalink to this definition"></a></dt>
<dd><p>For matrices or vectors <span class="math">\(A\)</span> and <span class="math">\(B\)</span>, calculates <span class="math">\(A\)</span> \ <span class="math">\(B\)</span>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.At_ldiv_B!">
<code class="descname">At_ldiv_B!</code><span class="sig-paren">(</span><span class="optional">[</span><em>Y</em>, <span class="optional">]</span><em>A</em>, <em>B</em><span class="sig-paren">)</span> &rarr; Y<a class="headerlink" href="#Base.At_ldiv_B!" title="Permalink to this definition"></a></dt>
<dd><p>Similar to <a class="reference internal" href="#Base.A_ldiv_B!" title="Base.A_ldiv_B!"><code class="xref jl jl-func docutils literal"><span class="pre">A_ldiv_B!()</span></code></a>, but return <span class="math">\(A\)</span> \ <span class="math">\(B\)</span>, computing the result in-place in <code class="docutils literal"><span class="pre">Y</span></code> (or overwriting <code class="docutils literal"><span class="pre">B</span></code> if <code class="docutils literal"><span class="pre">Y</span></code> is not supplied).</p>
</dd></dl>

<dl class="function">
<dt id="Base.At_ldiv_Bt">
<code class="descname">At_ldiv_Bt</code><span class="sig-paren">(</span><em>A</em>, <em>B</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.At_ldiv_Bt" title="Permalink to this definition"></a></dt>
<dd><p>For matrices or vectors <span class="math">\(A\)</span> and <span class="math">\(B\)</span>, calculates <span class="math">\(A\)</span> \ <span class="math">\(B\)</span>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.At_mul_B">
<code class="descname">At_mul_B</code><span class="sig-paren">(</span><em>A</em>, <em>B</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.At_mul_B" title="Permalink to this definition"></a></dt>
<dd><p>For matrices or vectors <span class="math">\(A\)</span> and <span class="math">\(B\)</span>, calculates <span class="math">\(AB\)</span>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.At_mul_Bt">
<code class="descname">At_mul_Bt</code><span class="sig-paren">(</span><em>A</em>, <em>B</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.At_mul_Bt" title="Permalink to this definition"></a></dt>
<dd><p>For matrices or vectors <span class="math">\(A\)</span> and <span class="math">\(B\)</span>, calculates <span class="math">\(AB\)</span>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.At_rdiv_B">
<code class="descname">At_rdiv_B</code><span class="sig-paren">(</span><em>A</em>, <em>B</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.At_rdiv_B" title="Permalink to this definition"></a></dt>
<dd><p>For matrices or vectors <span class="math">\(A\)</span> and <span class="math">\(B\)</span>, calculates <span class="math">\(A / B\)</span>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.At_rdiv_Bt">
<code class="descname">At_rdiv_Bt</code><span class="sig-paren">(</span><em>A</em>, <em>B</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.At_rdiv_Bt" title="Permalink to this definition"></a></dt>
<dd><p>For matrices or vectors <span class="math">\(A\)</span> and <span class="math">\(B\)</span>, calculates <span class="math">\(A / B\)</span>.</p>
</dd></dl>

</div>
<div class="section" id="module-Base.LinAlg.BLAS">
<span id="blas-functions"></span><h2>BLAS Functions<a class="headerlink" href="#module-Base.LinAlg.BLAS" title="Permalink to this headline"></a></h2>
<p>In Julia (as in much of scientific computation), dense linear-algebra operations are
based on the <a class="reference external" href="http://www.netlib.org/lapack/">LAPACK library</a>, which in turn
is built on top of basic linear-algebra building-blocks known as the
<a class="reference external" href="http://www.netlib.org/blas/">BLAS</a>.  There are highly optimized implementations
of BLAS available for every computer architecture, and sometimes in
high-performance linear algebra routines it is useful to call the BLAS
functions directly.</p>
<p><a class="reference internal" href="#module-Base.LinAlg.BLAS" title="Base.LinAlg.BLAS"><code class="xref jl jl-mod docutils literal"><span class="pre">Base.LinAlg.BLAS</span></code></a> provides wrappers for some of the BLAS functions.
Those BLAS functions that overwrite one of the input
arrays have names ending in <code class="docutils literal"><span class="pre">'!'</span></code>.  Usually, a BLAS function has four methods defined,
for <code class="docutils literal"><span class="pre">Float64</span></code>, <code class="docutils literal"><span class="pre">Float32</span></code>, <code class="docutils literal"><span class="pre">Complex128</span></code>, and <code class="docutils literal"><span class="pre">Complex64</span></code> arrays.</p>
<dl class="function">
<dt id="Base.LinAlg.BLAS.dot">
<code class="descname">dot</code><span class="sig-paren">(</span><em>n</em>, <em>X</em>, <em>incx</em>, <em>Y</em>, <em>incy</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.BLAS.dot" title="Permalink to this definition"></a></dt>
<dd><p>Dot product of two vectors consisting of <code class="docutils literal"><span class="pre">n</span></code> elements of array <code class="docutils literal"><span class="pre">X</span></code> with stride <code class="docutils literal"><span class="pre">incx</span></code> and <code class="docutils literal"><span class="pre">n</span></code> elements of array <code class="docutils literal"><span class="pre">Y</span></code> with stride <code class="docutils literal"><span class="pre">incy</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.dotu">
<code class="descname">dotu</code><span class="sig-paren">(</span><em>n</em>, <em>X</em>, <em>incx</em>, <em>Y</em>, <em>incy</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.BLAS.dotu" title="Permalink to this definition"></a></dt>
<dd><p>Dot function for two complex vectors.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.dotc">
<code class="descname">dotc</code><span class="sig-paren">(</span><em>n</em>, <em>X</em>, <em>incx</em>, <em>U</em>, <em>incy</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.BLAS.dotc" title="Permalink to this definition"></a></dt>
<dd><p>Dot function for two complex vectors conjugating the first vector.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.blascopy!">
<code class="descname">blascopy!</code><span class="sig-paren">(</span><em>n</em>, <em>X</em>, <em>incx</em>, <em>Y</em>, <em>incy</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.BLAS.blascopy!" title="Permalink to this definition"></a></dt>
<dd><p>Copy <code class="docutils literal"><span class="pre">n</span></code> elements of array <code class="docutils literal"><span class="pre">X</span></code> with stride <code class="docutils literal"><span class="pre">incx</span></code> to array <code class="docutils literal"><span class="pre">Y</span></code> with stride <code class="docutils literal"><span class="pre">incy</span></code>. Returns <code class="docutils literal"><span class="pre">Y</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.nrm2">
<code class="descname">nrm2</code><span class="sig-paren">(</span><em>n</em>, <em>X</em>, <em>incx</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.BLAS.nrm2" title="Permalink to this definition"></a></dt>
<dd><p>2-norm of a vector consisting of <code class="docutils literal"><span class="pre">n</span></code> elements of array <code class="docutils literal"><span class="pre">X</span></code> with stride <code class="docutils literal"><span class="pre">incx</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.asum">
<code class="descname">asum</code><span class="sig-paren">(</span><em>n</em>, <em>X</em>, <em>incx</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.BLAS.asum" title="Permalink to this definition"></a></dt>
<dd><p>Sum of the absolute values of the first <code class="docutils literal"><span class="pre">n</span></code> elements of array <code class="docutils literal"><span class="pre">X</span></code> with stride <code class="docutils literal"><span class="pre">incx</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.axpy!">
<code class="descname">axpy!</code><span class="sig-paren">(</span><em>a</em>, <em>X</em>, <em>Y</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.BLAS.axpy!" title="Permalink to this definition"></a></dt>
<dd><p>Overwrite <code class="docutils literal"><span class="pre">Y</span></code> with <code class="docutils literal"><span class="pre">a*X</span> <span class="pre">+</span> <span class="pre">Y</span></code>. Returns <code class="docutils literal"><span class="pre">Y</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.scal!">
<code class="descname">scal!</code><span class="sig-paren">(</span><em>n</em>, <em>a</em>, <em>X</em>, <em>incx</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.BLAS.scal!" title="Permalink to this definition"></a></dt>
<dd><p>Overwrite <code class="docutils literal"><span class="pre">X</span></code> with <code class="docutils literal"><span class="pre">a*X</span></code> for the first <code class="docutils literal"><span class="pre">n</span></code> elements of array <code class="docutils literal"><span class="pre">X</span></code> with stride <code class="docutils literal"><span class="pre">incx</span></code>. Returns <code class="docutils literal"><span class="pre">X</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.scal">
<code class="descname">scal</code><span class="sig-paren">(</span><em>n</em>, <em>a</em>, <em>X</em>, <em>incx</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.BLAS.scal" title="Permalink to this definition"></a></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">X</span></code> scaled by <code class="docutils literal"><span class="pre">a</span></code> for the first <code class="docutils literal"><span class="pre">n</span></code> elements of array <code class="docutils literal"><span class="pre">X</span></code> with stride <code class="docutils literal"><span class="pre">incx</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.ger!">
<code class="descname">ger!</code><span class="sig-paren">(</span><em>alpha</em>, <em>x</em>, <em>y</em>, <em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.BLAS.ger!" title="Permalink to this definition"></a></dt>
<dd><p>Rank-1 update of the matrix <code class="docutils literal"><span class="pre">A</span></code> with vectors <code class="docutils literal"><span class="pre">x</span></code> and <code class="docutils literal"><span class="pre">y</span></code> as <code class="docutils literal"><span class="pre">alpha*x*y'</span> <span class="pre">+</span> <span class="pre">A</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.syr!">
<code class="descname">syr!</code><span class="sig-paren">(</span><em>uplo</em>, <em>alpha</em>, <em>x</em>, <em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.BLAS.syr!" title="Permalink to this definition"></a></dt>
<dd><p>Rank-1 update of the symmetric matrix <code class="docutils literal"><span class="pre">A</span></code> with vector <code class="docutils literal"><span class="pre">x</span></code> as <code class="docutils literal"><span class="pre">alpha*x*x.'</span> <span class="pre">+</span> <span class="pre">A</span></code>. When <code class="docutils literal"><span class="pre">uplo</span></code> is &#8216;U&#8217; the upper triangle of <code class="docutils literal"><span class="pre">A</span></code> is updated (&#8216;L&#8217; for lower triangle). Returns <code class="docutils literal"><span class="pre">A</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.syrk!">
<code class="descname">syrk!</code><span class="sig-paren">(</span><em>uplo</em>, <em>trans</em>, <em>alpha</em>, <em>A</em>, <em>beta</em>, <em>C</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.BLAS.syrk!" title="Permalink to this definition"></a></dt>
<dd><p>Rank-k update of the symmetric matrix <code class="docutils literal"><span class="pre">C</span></code> as <code class="docutils literal"><span class="pre">alpha*A*A.'</span> <span class="pre">+</span> <span class="pre">beta*C</span></code> or <code class="docutils literal"><span class="pre">alpha*A.'*A</span> <span class="pre">+</span> <span class="pre">beta*C</span></code> according to whether <code class="docutils literal"><span class="pre">trans</span></code> is &#8216;N&#8217; or &#8216;T&#8217;. When <code class="docutils literal"><span class="pre">uplo</span></code> is &#8216;U&#8217; the upper triangle of <code class="docutils literal"><span class="pre">C</span></code> is updated (&#8216;L&#8217; for lower triangle). Returns <code class="docutils literal"><span class="pre">C</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.syrk">
<code class="descname">syrk</code><span class="sig-paren">(</span><em>uplo</em>, <em>trans</em>, <em>alpha</em>, <em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.BLAS.syrk" title="Permalink to this definition"></a></dt>
<dd><p>Returns either the upper triangle or the lower triangle, according to <code class="docutils literal"><span class="pre">uplo</span></code> (&#8216;U&#8217; or &#8216;L&#8217;), of <code class="docutils literal"><span class="pre">alpha*A*A.'</span></code> or <code class="docutils literal"><span class="pre">alpha*A.'*A</span></code>, according to <code class="docutils literal"><span class="pre">trans</span></code> (&#8216;N&#8217; or &#8216;T&#8217;).</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.her!">
<code class="descname">her!</code><span class="sig-paren">(</span><em>uplo</em>, <em>alpha</em>, <em>x</em>, <em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.BLAS.her!" title="Permalink to this definition"></a></dt>
<dd><p>Methods for complex arrays only. Rank-1 update of the Hermitian matrix <code class="docutils literal"><span class="pre">A</span></code> with vector <code class="docutils literal"><span class="pre">x</span></code> as <code class="docutils literal"><span class="pre">alpha*x*x'</span> <span class="pre">+</span> <span class="pre">A</span></code>. When <code class="docutils literal"><span class="pre">uplo</span></code> is &#8216;U&#8217; the upper triangle of <code class="docutils literal"><span class="pre">A</span></code> is updated (&#8216;L&#8217; for lower triangle). Returns <code class="docutils literal"><span class="pre">A</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.herk!">
<code class="descname">herk!</code><span class="sig-paren">(</span><em>uplo</em>, <em>trans</em>, <em>alpha</em>, <em>A</em>, <em>beta</em>, <em>C</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.BLAS.herk!" title="Permalink to this definition"></a></dt>
<dd><p>Methods for complex arrays only. Rank-k update of the Hermitian matrix <code class="docutils literal"><span class="pre">C</span></code> as <code class="docutils literal"><span class="pre">alpha*A*A'</span> <span class="pre">+</span> <span class="pre">beta*C</span></code> or <code class="docutils literal"><span class="pre">alpha*A'*A</span> <span class="pre">+</span> <span class="pre">beta*C</span></code> according to whether <code class="docutils literal"><span class="pre">trans</span></code> is &#8216;N&#8217; or &#8216;T&#8217;. When <code class="docutils literal"><span class="pre">uplo</span></code> is &#8216;U&#8217; the upper triangle of <code class="docutils literal"><span class="pre">C</span></code> is updated (&#8216;L&#8217; for lower triangle). Returns <code class="docutils literal"><span class="pre">C</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.herk">
<code class="descname">herk</code><span class="sig-paren">(</span><em>uplo</em>, <em>trans</em>, <em>alpha</em>, <em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.BLAS.herk" title="Permalink to this definition"></a></dt>
<dd><p>Methods for complex arrays only. Returns either the upper triangle or the lower triangle, according to <code class="docutils literal"><span class="pre">uplo</span></code> (&#8216;U&#8217; or &#8216;L&#8217;), of <code class="docutils literal"><span class="pre">alpha*A*A'</span></code> or <code class="docutils literal"><span class="pre">alpha*A'*A</span></code>, according to <code class="docutils literal"><span class="pre">trans</span></code> (&#8216;N&#8217; or &#8216;T&#8217;).</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.gbmv!">
<code class="descname">gbmv!</code><span class="sig-paren">(</span><em>trans</em>, <em>m</em>, <em>kl</em>, <em>ku</em>, <em>alpha</em>, <em>A</em>, <em>x</em>, <em>beta</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.BLAS.gbmv!" title="Permalink to this definition"></a></dt>
<dd><p>Update vector <code class="docutils literal"><span class="pre">y</span></code> as <code class="docutils literal"><span class="pre">alpha*A*x</span> <span class="pre">+</span> <span class="pre">beta*y</span></code> or <code class="docutils literal"><span class="pre">alpha*A'*x</span> <span class="pre">+</span> <span class="pre">beta*y</span></code> according to <code class="docutils literal"><span class="pre">trans</span></code> (&#8216;N&#8217; or &#8216;T&#8217;). The matrix <code class="docutils literal"><span class="pre">A</span></code> is a general band matrix of dimension <code class="docutils literal"><span class="pre">m</span></code> by <code class="docutils literal"><span class="pre">size(A,2)</span></code> with <code class="docutils literal"><span class="pre">kl</span></code> sub-diagonals and <code class="docutils literal"><span class="pre">ku</span></code> super-diagonals. Returns the updated <code class="docutils literal"><span class="pre">y</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.gbmv">
<code class="descname">gbmv</code><span class="sig-paren">(</span><em>trans</em>, <em>m</em>, <em>kl</em>, <em>ku</em>, <em>alpha</em>, <em>A</em>, <em>x</em>, <em>beta</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.BLAS.gbmv" title="Permalink to this definition"></a></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">alpha*A*x</span></code> or <code class="docutils literal"><span class="pre">alpha*A'*x</span></code> according to <code class="docutils literal"><span class="pre">trans</span></code> (&#8216;N&#8217; or &#8216;T&#8217;). The matrix <code class="docutils literal"><span class="pre">A</span></code> is a general band matrix of dimension <code class="docutils literal"><span class="pre">m</span></code> by <code class="docutils literal"><span class="pre">size(A,2)</span></code> with <code class="docutils literal"><span class="pre">kl</span></code> sub-diagonals and <code class="docutils literal"><span class="pre">ku</span></code> super-diagonals.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.sbmv!">
<code class="descname">sbmv!</code><span class="sig-paren">(</span><em>uplo</em>, <em>k</em>, <em>alpha</em>, <em>A</em>, <em>x</em>, <em>beta</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.BLAS.sbmv!" title="Permalink to this definition"></a></dt>
<dd><p>Update vector <code class="docutils literal"><span class="pre">y</span></code> as <code class="docutils literal"><span class="pre">alpha*A*x</span> <span class="pre">+</span> <span class="pre">beta*y</span></code> where <code class="docutils literal"><span class="pre">A</span></code> is a a symmetric band matrix of order <code class="docutils literal"><span class="pre">size(A,2)</span></code> with <code class="docutils literal"><span class="pre">k</span></code> super-diagonals stored in the argument <code class="docutils literal"><span class="pre">A</span></code>. The storage layout for <code class="docutils literal"><span class="pre">A</span></code> is described the reference BLAS module, level-2 BLAS at &lt;<a class="reference external" href="http://www.netlib.org/lapack/explore-html/">http://www.netlib.org/lapack/explore-html/</a>&gt;.</p>
<p>Returns the updated <code class="docutils literal"><span class="pre">y</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.sbmv">
<code class="descname">sbmv</code><span class="sig-paren">(</span><em>uplo</em>, <em>k</em>, <em>alpha</em>, <em>A</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.BLAS.sbmv" title="Permalink to this definition"></a></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">alpha*A*x</span></code> where <code class="docutils literal"><span class="pre">A</span></code> is a symmetric band matrix of order <code class="docutils literal"><span class="pre">size(A,2)</span></code> with <code class="docutils literal"><span class="pre">k</span></code> super-diagonals stored in the argument <code class="docutils literal"><span class="pre">A</span></code>.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">sbmv</code><span class="sig-paren">(</span><em>uplo</em>, <em>k</em>, <em>A</em>, <em>x</em><span class="sig-paren">)</span></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">A*x</span></code> where <code class="docutils literal"><span class="pre">A</span></code> is a symmetric band matrix of order <code class="docutils literal"><span class="pre">size(A,2)</span></code> with <code class="docutils literal"><span class="pre">k</span></code> super-diagonals stored in the argument <code class="docutils literal"><span class="pre">A</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.gemm!">
<code class="descname">gemm!</code><span class="sig-paren">(</span><em>tA</em>, <em>tB</em>, <em>alpha</em>, <em>A</em>, <em>B</em>, <em>beta</em>, <em>C</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.BLAS.gemm!" title="Permalink to this definition"></a></dt>
<dd><p>Update <code class="docutils literal"><span class="pre">C</span></code> as <code class="docutils literal"><span class="pre">alpha*A*B</span> <span class="pre">+</span> <span class="pre">beta*C</span></code> or the other three variants according to <code class="docutils literal"><span class="pre">tA</span></code> (transpose <code class="docutils literal"><span class="pre">A</span></code>) and <code class="docutils literal"><span class="pre">tB</span></code>. Returns the updated <code class="docutils literal"><span class="pre">C</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.gemm">
<code class="descname">gemm</code><span class="sig-paren">(</span><em>tA</em>, <em>tB</em>, <em>alpha</em>, <em>A</em>, <em>B</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.BLAS.gemm" title="Permalink to this definition"></a></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">alpha*A*B</span></code> or the other three variants according to <code class="docutils literal"><span class="pre">tA</span></code> (transpose <code class="docutils literal"><span class="pre">A</span></code>) and <code class="docutils literal"><span class="pre">tB</span></code>.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">gemm</code><span class="sig-paren">(</span><em>tA</em>, <em>tB</em>, <em>A</em>, <em>B</em><span class="sig-paren">)</span></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">A*B</span></code> or the other three variants according to <code class="docutils literal"><span class="pre">tA</span></code> (transpose <code class="docutils literal"><span class="pre">A</span></code>) and <code class="docutils literal"><span class="pre">tB</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.gemv!">
<code class="descname">gemv!</code><span class="sig-paren">(</span><em>tA</em>, <em>alpha</em>, <em>A</em>, <em>x</em>, <em>beta</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.BLAS.gemv!" title="Permalink to this definition"></a></dt>
<dd><p>Update the vector <code class="docutils literal"><span class="pre">y</span></code> as <code class="docutils literal"><span class="pre">alpha*A*x</span> <span class="pre">+</span> <span class="pre">beta*y</span></code> or <code class="docutils literal"><span class="pre">alpha*A'x</span> <span class="pre">+</span> <span class="pre">beta*y</span></code> according to <code class="docutils literal"><span class="pre">tA</span></code> (transpose <code class="docutils literal"><span class="pre">A</span></code>). Returns the updated <code class="docutils literal"><span class="pre">y</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.gemv">
<code class="descname">gemv</code><span class="sig-paren">(</span><em>tA</em>, <em>alpha</em>, <em>A</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.BLAS.gemv" title="Permalink to this definition"></a></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">alpha*A*x</span></code> or <code class="docutils literal"><span class="pre">alpha*A'x</span></code> according to <code class="docutils literal"><span class="pre">tA</span></code> (transpose <code class="docutils literal"><span class="pre">A</span></code>).</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">gemv</code><span class="sig-paren">(</span><em>tA</em>, <em>A</em>, <em>x</em><span class="sig-paren">)</span></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">A*x</span></code> or <code class="docutils literal"><span class="pre">A'x</span></code> according to <code class="docutils literal"><span class="pre">tA</span></code> (transpose <code class="docutils literal"><span class="pre">A</span></code>).</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.symm!">
<code class="descname">symm!</code><span class="sig-paren">(</span><em>side</em>, <em>ul</em>, <em>alpha</em>, <em>A</em>, <em>B</em>, <em>beta</em>, <em>C</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.BLAS.symm!" title="Permalink to this definition"></a></dt>
<dd><p>Update <code class="docutils literal"><span class="pre">C</span></code> as <code class="docutils literal"><span class="pre">alpha*A*B</span> <span class="pre">+</span> <span class="pre">beta*C</span></code> or <code class="docutils literal"><span class="pre">alpha*B*A</span> <span class="pre">+</span> <span class="pre">beta*C</span></code> according to <code class="docutils literal"><span class="pre">side</span></code>. <code class="docutils literal"><span class="pre">A</span></code> is assumed to be symmetric. Only the <code class="docutils literal"><span class="pre">ul</span></code> triangle of <code class="docutils literal"><span class="pre">A</span></code> is used. Returns the updated <code class="docutils literal"><span class="pre">C</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.symm">
<code class="descname">symm</code><span class="sig-paren">(</span><em>side</em>, <em>ul</em>, <em>alpha</em>, <em>A</em>, <em>B</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.BLAS.symm" title="Permalink to this definition"></a></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">alpha*A*B</span></code> or <code class="docutils literal"><span class="pre">alpha*B*A</span></code> according to <code class="docutils literal"><span class="pre">side</span></code>. <code class="docutils literal"><span class="pre">A</span></code> is assumed to be symmetric. Only the <code class="docutils literal"><span class="pre">ul</span></code> triangle of <code class="docutils literal"><span class="pre">A</span></code> is used.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">symm</code><span class="sig-paren">(</span><em>side</em>, <em>ul</em>, <em>A</em>, <em>B</em><span class="sig-paren">)</span></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">A*B</span></code> or <code class="docutils literal"><span class="pre">B*A</span></code> according to <code class="docutils literal"><span class="pre">side</span></code>. <code class="docutils literal"><span class="pre">A</span></code> is assumed to be symmetric. Only the <code class="docutils literal"><span class="pre">ul</span></code> triangle of <code class="docutils literal"><span class="pre">A</span></code> is used.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">symm</code><span class="sig-paren">(</span><em>tA</em>, <em>tB</em>, <em>alpha</em>, <em>A</em>, <em>B</em><span class="sig-paren">)</span></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">alpha*A*B</span></code> or the other three variants according to <code class="docutils literal"><span class="pre">tA</span></code> (transpose <code class="docutils literal"><span class="pre">A</span></code>) and <code class="docutils literal"><span class="pre">tB</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.symv!">
<code class="descname">symv!</code><span class="sig-paren">(</span><em>ul</em>, <em>alpha</em>, <em>A</em>, <em>x</em>, <em>beta</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.BLAS.symv!" title="Permalink to this definition"></a></dt>
<dd><p>Update the vector <code class="docutils literal"><span class="pre">y</span></code> as <code class="docutils literal"><span class="pre">alpha*A*x</span> <span class="pre">+</span> <span class="pre">beta*y</span></code>. <code class="docutils literal"><span class="pre">A</span></code> is assumed to be symmetric. Only the <code class="docutils literal"><span class="pre">ul</span></code> triangle of <code class="docutils literal"><span class="pre">A</span></code> is used. Returns the updated <code class="docutils literal"><span class="pre">y</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.symv">
<code class="descname">symv</code><span class="sig-paren">(</span><em>ul</em>, <em>alpha</em>, <em>A</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.BLAS.symv" title="Permalink to this definition"></a></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">alpha*A*x</span></code>. <code class="docutils literal"><span class="pre">A</span></code> is assumed to be symmetric. Only the <code class="docutils literal"><span class="pre">ul</span></code> triangle of <code class="docutils literal"><span class="pre">A</span></code> is used.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">symv</code><span class="sig-paren">(</span><em>ul</em>, <em>A</em>, <em>x</em><span class="sig-paren">)</span></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">A*x</span></code>. <code class="docutils literal"><span class="pre">A</span></code> is assumed to be symmetric. Only the <code class="docutils literal"><span class="pre">ul</span></code> triangle of <code class="docutils literal"><span class="pre">A</span></code> is used.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.trmm!">
<code class="descname">trmm!</code><span class="sig-paren">(</span><em>side</em>, <em>ul</em>, <em>tA</em>, <em>dA</em>, <em>alpha</em>, <em>A</em>, <em>B</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.BLAS.trmm!" title="Permalink to this definition"></a></dt>
<dd><p>Update <code class="docutils literal"><span class="pre">B</span></code> as <code class="docutils literal"><span class="pre">alpha*A*B</span></code> or one of the other three variants determined by <code class="docutils literal"><span class="pre">side</span></code> (<code class="docutils literal"><span class="pre">A</span></code> on left or right) and <code class="docutils literal"><span class="pre">tA</span></code> (transpose <code class="docutils literal"><span class="pre">A</span></code>). Only the <code class="docutils literal"><span class="pre">ul</span></code> triangle of <code class="docutils literal"><span class="pre">A</span></code> is used. <code class="docutils literal"><span class="pre">dA</span></code> indicates if <code class="docutils literal"><span class="pre">A</span></code> is unit-triangular (the diagonal is assumed to be all ones). Returns the updated <code class="docutils literal"><span class="pre">B</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.trmm">
<code class="descname">trmm</code><span class="sig-paren">(</span><em>side</em>, <em>ul</em>, <em>tA</em>, <em>dA</em>, <em>alpha</em>, <em>A</em>, <em>B</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.BLAS.trmm" title="Permalink to this definition"></a></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">alpha*A*B</span></code> or one of the other three variants determined by <code class="docutils literal"><span class="pre">side</span></code> (<code class="docutils literal"><span class="pre">A</span></code> on left or right) and <code class="docutils literal"><span class="pre">tA</span></code> (transpose <code class="docutils literal"><span class="pre">A</span></code>). Only the <code class="docutils literal"><span class="pre">ul</span></code> triangle of <code class="docutils literal"><span class="pre">A</span></code> is used. <code class="docutils literal"><span class="pre">dA</span></code> indicates if <code class="docutils literal"><span class="pre">A</span></code> is unit-triangular (the diagonal is assumed to be all ones).</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.trsm!">
<code class="descname">trsm!</code><span class="sig-paren">(</span><em>side</em>, <em>ul</em>, <em>tA</em>, <em>dA</em>, <em>alpha</em>, <em>A</em>, <em>B</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.BLAS.trsm!" title="Permalink to this definition"></a></dt>
<dd><p>Overwrite <code class="docutils literal"><span class="pre">B</span></code> with the solution to <code class="docutils literal"><span class="pre">A*X</span> <span class="pre">=</span> <span class="pre">alpha*B</span></code> or one of the other three variants determined by <code class="docutils literal"><span class="pre">side</span></code> (<code class="docutils literal"><span class="pre">A</span></code> on left or right of <code class="docutils literal"><span class="pre">X</span></code>) and <code class="docutils literal"><span class="pre">tA</span></code> (transpose <code class="docutils literal"><span class="pre">A</span></code>). Only the <code class="docutils literal"><span class="pre">ul</span></code> triangle of <code class="docutils literal"><span class="pre">A</span></code> is used. <code class="docutils literal"><span class="pre">dA</span></code> indicates if <code class="docutils literal"><span class="pre">A</span></code> is unit-triangular (the diagonal is assumed to be all ones). Returns the updated <code class="docutils literal"><span class="pre">B</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.trsm">
<code class="descname">trsm</code><span class="sig-paren">(</span><em>side</em>, <em>ul</em>, <em>tA</em>, <em>dA</em>, <em>alpha</em>, <em>A</em>, <em>B</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.BLAS.trsm" title="Permalink to this definition"></a></dt>
<dd><p>Returns the solution to <code class="docutils literal"><span class="pre">A*X</span> <span class="pre">=</span> <span class="pre">alpha*B</span></code> or one of the other three variants determined by <code class="docutils literal"><span class="pre">side</span></code> (<code class="docutils literal"><span class="pre">A</span></code> on left or right of <code class="docutils literal"><span class="pre">X</span></code>) and <code class="docutils literal"><span class="pre">tA</span></code> (transpose <code class="docutils literal"><span class="pre">A</span></code>). Only the <code class="docutils literal"><span class="pre">ul</span></code> triangle of <code class="docutils literal"><span class="pre">A</span></code> is used. <code class="docutils literal"><span class="pre">dA</span></code> indicates if <code class="docutils literal"><span class="pre">A</span></code> is unit-triangular (the diagonal is assumed to be all ones).</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.trmv!">
<code class="descname">trmv!</code><span class="sig-paren">(</span><em>ul</em>, <em>tA</em>, <em>dA</em>, <em>A</em>, <em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.BLAS.trmv!" title="Permalink to this definition"></a></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">op(A)*b</span></code>, where <code class="docutils literal"><span class="pre">op</span></code> is determined by <code class="docutils literal"><span class="pre">tA</span></code> (<code class="docutils literal"><span class="pre">N</span></code> for identity, <code class="docutils literal"><span class="pre">T</span></code> for transpose <code class="docutils literal"><span class="pre">A</span></code>, and <code class="docutils literal"><span class="pre">C</span></code> for conjugate transpose <code class="docutils literal"><span class="pre">A</span></code>). Only the <code class="docutils literal"><span class="pre">ul</span></code> triangle (<code class="docutils literal"><span class="pre">U</span></code> for upper, <code class="docutils literal"><span class="pre">L</span></code> for lower) of <code class="docutils literal"><span class="pre">A</span></code> is used. <code class="docutils literal"><span class="pre">dA</span></code> indicates if <code class="docutils literal"><span class="pre">A</span></code> is unit-triangular (the diagonal is assumed to be all ones if <code class="docutils literal"><span class="pre">U</span></code>, or non-unit if <code class="docutils literal"><span class="pre">N</span></code>). The multiplication occurs in-place on <code class="docutils literal"><span class="pre">b</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.trmv">
<code class="descname">trmv</code><span class="sig-paren">(</span><em>ul</em>, <em>tA</em>, <em>dA</em>, <em>A</em>, <em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.BLAS.trmv" title="Permalink to this definition"></a></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">op(A)*b</span></code>, where <code class="docutils literal"><span class="pre">op</span></code> is determined by <code class="docutils literal"><span class="pre">tA</span></code> (<code class="docutils literal"><span class="pre">N</span></code> for identity, <code class="docutils literal"><span class="pre">T</span></code> for transpose <code class="docutils literal"><span class="pre">A</span></code>, and <code class="docutils literal"><span class="pre">C</span></code> for conjugate transpose <code class="docutils literal"><span class="pre">A</span></code>). Only the <code class="docutils literal"><span class="pre">ul</span></code> triangle (<code class="docutils literal"><span class="pre">U</span></code> for upper, <code class="docutils literal"><span class="pre">L</span></code> for lower) of <code class="docutils literal"><span class="pre">A</span></code> is used. <code class="docutils literal"><span class="pre">dA</span></code> indicates if <code class="docutils literal"><span class="pre">A</span></code> is unit-triangular (the diagonal is assumed to be all ones if <code class="docutils literal"><span class="pre">U</span></code>, or non-unit if <code class="docutils literal"><span class="pre">N</span></code>).</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.trsv!">
<code class="descname">trsv!</code><span class="sig-paren">(</span><em>ul</em>, <em>tA</em>, <em>dA</em>, <em>A</em>, <em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.BLAS.trsv!" title="Permalink to this definition"></a></dt>
<dd><p>Overwrite <code class="docutils literal"><span class="pre">b</span></code> with the solution to <code class="docutils literal"><span class="pre">A*x</span> <span class="pre">=</span> <span class="pre">b</span></code> or one of the other two variants determined by <code class="docutils literal"><span class="pre">tA</span></code> (transpose <code class="docutils literal"><span class="pre">A</span></code>) and <code class="docutils literal"><span class="pre">ul</span></code> (triangle of <code class="docutils literal"><span class="pre">A</span></code> used). <code class="docutils literal"><span class="pre">dA</span></code> indicates if <code class="docutils literal"><span class="pre">A</span></code> is unit-triangular (the diagonal is assumed to be all ones). Returns the updated <code class="docutils literal"><span class="pre">b</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.trsv">
<code class="descname">trsv</code><span class="sig-paren">(</span><em>ul</em>, <em>tA</em>, <em>dA</em>, <em>A</em>, <em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.BLAS.trsv" title="Permalink to this definition"></a></dt>
<dd><p>Returns the solution to <code class="docutils literal"><span class="pre">A*x</span> <span class="pre">=</span> <span class="pre">b</span></code> or one of the other two variants determined by <code class="docutils literal"><span class="pre">tA</span></code> (transpose <code class="docutils literal"><span class="pre">A</span></code>) and <code class="docutils literal"><span class="pre">ul</span></code> (triangle of <code class="docutils literal"><span class="pre">A</span></code> is used.) <code class="docutils literal"><span class="pre">dA</span></code> indicates if <code class="docutils literal"><span class="pre">A</span></code> is unit-triangular (the diagonal is assumed to be all ones).</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.set_num_threads">
<code class="descname">set_num_threads</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.BLAS.set_num_threads" title="Permalink to this definition"></a></dt>
<dd><p>Set the number of threads the BLAS library should use.</p>
</dd></dl>

<dl class="data">
<dt id="Base.LinAlg.BLAS.I">
<code class="descname">I</code><a class="headerlink" href="#Base.LinAlg.BLAS.I" title="Permalink to this definition"></a></dt>
<dd><p>An object of type <code class="docutils literal"><span class="pre">UniformScaling</span></code>, representing an identity matrix of any size.</p>
</dd></dl>

</div>
<div class="section" id="module-Base.LinAlg.LAPACK">
<span id="lapack-functions"></span><h2>LAPACK Functions<a class="headerlink" href="#module-Base.LinAlg.LAPACK" title="Permalink to this headline"></a></h2>
<p><a class="reference internal" href="#module-Base.LinAlg.LAPACK" title="Base.LinAlg.LAPACK"><code class="xref jl jl-mod docutils literal"><span class="pre">Base.LinAlg.LAPACK</span></code></a> provides wrappers for some of the LAPACK functions for
linear algebra.  Those functions that overwrite one of the input
arrays have names ending in <code class="docutils literal"><span class="pre">'!'</span></code>.</p>
<p>Usually a function has 4 methods defined, one each for <code class="docutils literal"><span class="pre">Float64</span></code>,
<code class="docutils literal"><span class="pre">Float32</span></code>, <code class="docutils literal"><span class="pre">Complex128</span></code> and <code class="docutils literal"><span class="pre">Complex64</span></code> arrays.</p>
<p>Note that the LAPACK API provided by Julia can and will change in the future. Since
this API is not user-facing, there is no commitment to support/deprecate this specific
set of functions in future releases.</p>
<dl class="function">
<dt id="Base.LinAlg.LAPACK.gbtrf!">
<code class="descname">gbtrf!</code><span class="sig-paren">(</span><em>kl</em>, <em>ku</em>, <em>m</em>, <em>AB</em><span class="sig-paren">)</span> &rarr; (AB, ipiv)<a class="headerlink" href="#Base.LinAlg.LAPACK.gbtrf!" title="Permalink to this definition"></a></dt>
<dd><p>Compute the LU factorization of a banded matrix <code class="docutils literal"><span class="pre">AB</span></code>. <code class="docutils literal"><span class="pre">kl</span></code> is the first subdiagonal containing a nonzero band, <code class="docutils literal"><span class="pre">ku</span></code> is the last superdiagonal containing one, and <code class="docutils literal"><span class="pre">m</span></code> is the first dimension of the matrix <code class="docutils literal"><span class="pre">AB</span></code>. Returns the LU factorization in-place and <code class="docutils literal"><span class="pre">ipiv</span></code>, the vector of pivots used.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.gbtrs!">
<code class="descname">gbtrs!</code><span class="sig-paren">(</span><em>trans</em>, <em>kl</em>, <em>ku</em>, <em>m</em>, <em>AB</em>, <em>ipiv</em>, <em>B</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.LAPACK.gbtrs!" title="Permalink to this definition"></a></dt>
<dd><p>Solve the equation <code class="docutils literal"><span class="pre">AB</span> <span class="pre">*</span> <span class="pre">X</span> <span class="pre">=</span> <span class="pre">B</span></code>. <code class="docutils literal"><span class="pre">trans</span></code> determines the orientation of <code class="docutils literal"><span class="pre">AB</span></code>. It may be <code class="docutils literal"><span class="pre">N</span></code> (no transpose), <code class="docutils literal"><span class="pre">T</span></code> (transpose), or <code class="docutils literal"><span class="pre">C</span></code> (conjugate transpose). <code class="docutils literal"><span class="pre">kl</span></code> is the first subdiagonal containing a nonzero band, <code class="docutils literal"><span class="pre">ku</span></code> is the last superdiagonal containing one, and <code class="docutils literal"><span class="pre">m</span></code> is the first dimension of the matrix <code class="docutils literal"><span class="pre">AB</span></code>. <code class="docutils literal"><span class="pre">ipiv</span></code> is the vector of pivots returned from <code class="docutils literal"><span class="pre">gbtrf!</span></code>. Returns the vector or matrix <code class="docutils literal"><span class="pre">X</span></code>, overwriting <code class="docutils literal"><span class="pre">B</span></code> in-place.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.gebal!">
<code class="descname">gebal!</code><span class="sig-paren">(</span><em>job</em>, <em>A</em><span class="sig-paren">)</span> &rarr; (ilo, ihi, scale)<a class="headerlink" href="#Base.LinAlg.LAPACK.gebal!" title="Permalink to this definition"></a></dt>
<dd><p>Balance the matrix <code class="docutils literal"><span class="pre">A</span></code> before computing its eigensystem or Schur factorization. <code class="docutils literal"><span class="pre">job</span></code> can be one of <code class="docutils literal"><span class="pre">N</span></code> (<code class="docutils literal"><span class="pre">A</span></code> will not be permuted or scaled), <code class="docutils literal"><span class="pre">P</span></code> (<code class="docutils literal"><span class="pre">A</span></code> will only be permuted), <code class="docutils literal"><span class="pre">S</span></code> (<code class="docutils literal"><span class="pre">A</span></code> will only be scaled), or <code class="docutils literal"><span class="pre">B</span></code> (<code class="docutils literal"><span class="pre">A</span></code> will be both permuted and scaled). Modifies <code class="docutils literal"><span class="pre">A</span></code> in-place and returns <code class="docutils literal"><span class="pre">ilo</span></code>, <code class="docutils literal"><span class="pre">ihi</span></code>, and <code class="docutils literal"><span class="pre">scale</span></code>. If permuting was turned on, <code class="docutils literal"><span class="pre">A[i,j]</span> <span class="pre">=</span> <span class="pre">0</span></code> if <code class="docutils literal"><span class="pre">j</span> <span class="pre">&gt;</span> <span class="pre">i</span></code> and <code class="docutils literal"><span class="pre">1</span> <span class="pre">&lt;</span> <span class="pre">j</span> <span class="pre">&lt;</span> <span class="pre">ilo</span></code> or <code class="docutils literal"><span class="pre">j</span> <span class="pre">&gt;</span> <span class="pre">ihi</span></code>. <code class="docutils literal"><span class="pre">scale</span></code> contains information about the scaling/permutations performed.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.gebak!">
<code class="descname">gebak!</code><span class="sig-paren">(</span><em>job</em>, <em>side</em>, <em>ilo</em>, <em>ihi</em>, <em>scale</em>, <em>V</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.LAPACK.gebak!" title="Permalink to this definition"></a></dt>
<dd><p>Transform the eigenvectors <code class="docutils literal"><span class="pre">V</span></code> of a matrix balanced using <code class="docutils literal"><span class="pre">gebal!</span></code> to the unscaled/unpermuted eigenvectors of the original matrix. Modifies <code class="docutils literal"><span class="pre">V</span></code> in-place. <code class="docutils literal"><span class="pre">side</span></code> can be <code class="docutils literal"><span class="pre">L</span></code> (left eigenvectors are transformed) or <code class="docutils literal"><span class="pre">R</span></code> (right eigenvectors are transformed).</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.gebrd!">
<code class="descname">gebrd!</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span> &rarr; (A, d, e, tauq, taup)<a class="headerlink" href="#Base.LinAlg.LAPACK.gebrd!" title="Permalink to this definition"></a></dt>
<dd><p>Reduce <code class="docutils literal"><span class="pre">A</span></code> in-place to bidiagonal form <code class="docutils literal"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">QBP'</span></code>. Returns <code class="docutils literal"><span class="pre">A</span></code>, containing the bidiagonal matrix <code class="docutils literal"><span class="pre">B</span></code>; <code class="docutils literal"><span class="pre">d</span></code>, containing the diagonal elements of <code class="docutils literal"><span class="pre">B</span></code>; <code class="docutils literal"><span class="pre">e</span></code>, containing the off-diagonal elements of <code class="docutils literal"><span class="pre">B</span></code>; <code class="docutils literal"><span class="pre">tauq</span></code>, containing the elementary reflectors representing <code class="docutils literal"><span class="pre">Q</span></code>; and <code class="docutils literal"><span class="pre">taup</span></code>, containing the elementary reflectors representing <code class="docutils literal"><span class="pre">P</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.gelqf!">
<code class="descname">gelqf!</code><span class="sig-paren">(</span><em>A</em>, <em>tau</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.LAPACK.gelqf!" title="Permalink to this definition"></a></dt>
<dd><p>Compute the <code class="docutils literal"><span class="pre">LQ</span></code> factorization of <code class="docutils literal"><span class="pre">A</span></code>, <code class="docutils literal"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">LQ</span></code>. <code class="docutils literal"><span class="pre">tau</span></code> contains scalars which parameterize the elementary reflectors of the factorization. <code class="docutils literal"><span class="pre">tau</span></code> must have length greater than or equal to the smallest dimension of <code class="docutils literal"><span class="pre">A</span></code>.</p>
<p>Returns <code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">tau</span></code> modified in-place.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">gelqf!</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span> &rarr; (A, tau)</dt>
<dd><p>Compute the <code class="docutils literal"><span class="pre">LQ</span></code> factorization of <code class="docutils literal"><span class="pre">A</span></code>, <code class="docutils literal"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">LQ</span></code>.</p>
<p>Returns <code class="docutils literal"><span class="pre">A</span></code>, modified in-place, and <code class="docutils literal"><span class="pre">tau</span></code>, which contains scalars which parameterize the elementary reflectors of the factorization.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.geqlf!">
<code class="descname">geqlf!</code><span class="sig-paren">(</span><em>A</em>, <em>tau</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.LAPACK.geqlf!" title="Permalink to this definition"></a></dt>
<dd><p>Compute the <code class="docutils literal"><span class="pre">QL</span></code> factorization of <code class="docutils literal"><span class="pre">A</span></code>, <code class="docutils literal"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">QL</span></code>. <code class="docutils literal"><span class="pre">tau</span></code> contains scalars which parameterize the elementary reflectors of the factorization. <code class="docutils literal"><span class="pre">tau</span></code> must have length greater than or equal to the smallest dimension of <code class="docutils literal"><span class="pre">A</span></code>.</p>
<p>Returns <code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">tau</span></code> modified in-place.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">geqlf!</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span> &rarr; (A, tau)</dt>
<dd><p>Compute the <code class="docutils literal"><span class="pre">QL</span></code> factorization of <code class="docutils literal"><span class="pre">A</span></code>, <code class="docutils literal"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">QL</span></code>.</p>
<p>Returns <code class="docutils literal"><span class="pre">A</span></code>, modified in-place, and <code class="docutils literal"><span class="pre">tau</span></code>, which contains scalars which parameterize the elementary reflectors of the factorization.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.geqrf!">
<code class="descname">geqrf!</code><span class="sig-paren">(</span><em>A</em>, <em>tau</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.LAPACK.geqrf!" title="Permalink to this definition"></a></dt>
<dd><p>Compute the <code class="docutils literal"><span class="pre">QR</span></code> factorization of <code class="docutils literal"><span class="pre">A</span></code>, <code class="docutils literal"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">QR</span></code>. <code class="docutils literal"><span class="pre">tau</span></code> contains scalars which parameterize the elementary reflectors of the factorization. <code class="docutils literal"><span class="pre">tau</span></code> must have length greater than or equal to the smallest dimension of <code class="docutils literal"><span class="pre">A</span></code>.</p>
<p>Returns <code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">tau</span></code> modified in-place.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">geqrf!</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span> &rarr; (A, tau)</dt>
<dd><p>Compute the <code class="docutils literal"><span class="pre">QR</span></code> factorization of <code class="docutils literal"><span class="pre">A</span></code>, <code class="docutils literal"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">QR</span></code>.</p>
<p>Returns <code class="docutils literal"><span class="pre">A</span></code>, modified in-place, and <code class="docutils literal"><span class="pre">tau</span></code>, which contains scalars which parameterize the elementary reflectors of the factorization.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.geqp3!">
<code class="descname">geqp3!</code><span class="sig-paren">(</span><em>A</em>, <em>jpvt</em>, <em>tau</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.LAPACK.geqp3!" title="Permalink to this definition"></a></dt>
<dd><p>Compute the pivoted <code class="docutils literal"><span class="pre">QR</span></code> factorization of <code class="docutils literal"><span class="pre">A</span></code>, <code class="docutils literal"><span class="pre">AP</span> <span class="pre">=</span> <span class="pre">QR</span></code> using BLAS level 3. <code class="docutils literal"><span class="pre">P</span></code> is a pivoting matrix, represented by <code class="docutils literal"><span class="pre">jpvt</span></code>. <code class="docutils literal"><span class="pre">tau</span></code> stores the elementary reflectors. <code class="docutils literal"><span class="pre">jpvt</span></code> must have length length greater than or equal to <code class="docutils literal"><span class="pre">n</span></code> if <code class="docutils literal"><span class="pre">A</span></code> is an <code class="docutils literal"><span class="pre">(m</span> <span class="pre">x</span> <span class="pre">n)</span></code> matrix. <code class="docutils literal"><span class="pre">tau</span></code> must have length greater than or equal to the smallest dimension of <code class="docutils literal"><span class="pre">A</span></code>.</p>
<p><code class="docutils literal"><span class="pre">A</span></code>, <code class="docutils literal"><span class="pre">jpvt</span></code>, and <code class="docutils literal"><span class="pre">tau</span></code> are modified in-place.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">geqp3!</code><span class="sig-paren">(</span><em>A</em>, <em>jpvt</em><span class="sig-paren">)</span> &rarr; (A, jpvt, tau)</dt>
<dd><p>Compute the pivoted <code class="docutils literal"><span class="pre">QR</span></code> factorization of <code class="docutils literal"><span class="pre">A</span></code>, <code class="docutils literal"><span class="pre">AP</span> <span class="pre">=</span> <span class="pre">QR</span></code> using BLAS level 3. <code class="docutils literal"><span class="pre">P</span></code> is a pivoting matrix, represented by <code class="docutils literal"><span class="pre">jpvt</span></code>. <code class="docutils literal"><span class="pre">jpvt</span></code> must have length greater than or equal to <code class="docutils literal"><span class="pre">n</span></code> if <code class="docutils literal"><span class="pre">A</span></code> is an <code class="docutils literal"><span class="pre">(m</span> <span class="pre">x</span> <span class="pre">n)</span></code> matrix.</p>
<p>Returns <code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">jpvt</span></code>, modified in-place, and <code class="docutils literal"><span class="pre">tau</span></code>, which stores the elementary reflectors.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">geqp3!</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span> &rarr; (A, jpvt, tau)</dt>
<dd><p>Compute the pivoted <code class="docutils literal"><span class="pre">QR</span></code> factorization of <code class="docutils literal"><span class="pre">A</span></code>, <code class="docutils literal"><span class="pre">AP</span> <span class="pre">=</span> <span class="pre">QR</span></code> using BLAS level 3.</p>
<p>Returns <code class="docutils literal"><span class="pre">A</span></code>, modified in-place, <code class="docutils literal"><span class="pre">jpvt</span></code>, which represents the pivoting matrix <code class="docutils literal"><span class="pre">P</span></code>, and <code class="docutils literal"><span class="pre">tau</span></code>, which stores the elementary reflectors.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.gerqf!">
<code class="descname">gerqf!</code><span class="sig-paren">(</span><em>A</em>, <em>tau</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.LAPACK.gerqf!" title="Permalink to this definition"></a></dt>
<dd><p>Compute the <code class="docutils literal"><span class="pre">RQ</span></code> factorization of <code class="docutils literal"><span class="pre">A</span></code>, <code class="docutils literal"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">RQ</span></code>. <code class="docutils literal"><span class="pre">tau</span></code> contains scalars which parameterize the elementary reflectors of the factorization. <code class="docutils literal"><span class="pre">tau</span></code> must have length greater than or equal to the smallest dimension of <code class="docutils literal"><span class="pre">A</span></code>.</p>
<p>Returns <code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">tau</span></code> modified in-place.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">gerqf!</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span> &rarr; (A, tau)</dt>
<dd><p>Compute the <code class="docutils literal"><span class="pre">RQ</span></code> factorization of <code class="docutils literal"><span class="pre">A</span></code>, <code class="docutils literal"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">RQ</span></code>.</p>
<p>Returns <code class="docutils literal"><span class="pre">A</span></code>, modified in-place, and <code class="docutils literal"><span class="pre">tau</span></code>, which contains scalars which parameterize the elementary reflectors of the factorization.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.geqrt!">
<code class="descname">geqrt!</code><span class="sig-paren">(</span><em>A</em>, <em>T</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.LAPACK.geqrt!" title="Permalink to this definition"></a></dt>
<dd><p>Compute the blocked <code class="docutils literal"><span class="pre">QR</span></code> factorization of <code class="docutils literal"><span class="pre">A</span></code>, <code class="docutils literal"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">QR</span></code>. <code class="docutils literal"><span class="pre">T</span></code> contains upper triangular block reflectors which parameterize the elementary reflectors of the factorization. The first dimension of <code class="docutils literal"><span class="pre">T</span></code> sets the block size and it must be between 1 and <code class="docutils literal"><span class="pre">n</span></code>. The second dimension of <code class="docutils literal"><span class="pre">T</span></code> must equal the smallest dimension of <code class="docutils literal"><span class="pre">A</span></code>.</p>
<p>Returns <code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">T</span></code> modified in-place.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">geqrt!</code><span class="sig-paren">(</span><em>A</em>, <em>nb</em><span class="sig-paren">)</span> &rarr; (A, T)</dt>
<dd><p>Compute the blocked <code class="docutils literal"><span class="pre">QR</span></code> factorization of <code class="docutils literal"><span class="pre">A</span></code>, <code class="docutils literal"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">QR</span></code>. <code class="docutils literal"><span class="pre">nb</span></code> sets the block size and it must be between 1 and <code class="docutils literal"><span class="pre">n</span></code>, the second dimension of <code class="docutils literal"><span class="pre">A</span></code>.</p>
<p>Returns <code class="docutils literal"><span class="pre">A</span></code>, modified in-place, and <code class="docutils literal"><span class="pre">T</span></code>, which contains upper triangular block reflectors which parameterize the elementary reflectors of the factorization.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.geqrt3!">
<code class="descname">geqrt3!</code><span class="sig-paren">(</span><em>A</em>, <em>T</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.LAPACK.geqrt3!" title="Permalink to this definition"></a></dt>
<dd><p>Recursively computes the blocked <code class="docutils literal"><span class="pre">QR</span></code> factorization of <code class="docutils literal"><span class="pre">A</span></code>, <code class="docutils literal"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">QR</span></code>. <code class="docutils literal"><span class="pre">T</span></code> contains upper triangular block reflectors which parameterize the elementary reflectors of the factorization.  The first dimension of <code class="docutils literal"><span class="pre">T</span></code> sets the block size and it must be between 1 and <code class="docutils literal"><span class="pre">n</span></code>. The second dimension of <code class="docutils literal"><span class="pre">T</span></code> must equal the smallest dimension of <code class="docutils literal"><span class="pre">A</span></code>.</p>
<p>Returns <code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">T</span></code> modified in-place.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">geqrt3!</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span> &rarr; (A, T)</dt>
<dd><p>Recursively computes the blocked <code class="docutils literal"><span class="pre">QR</span></code> factorization of <code class="docutils literal"><span class="pre">A</span></code>, <code class="docutils literal"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">QR</span></code>.</p>
<p>Returns <code class="docutils literal"><span class="pre">A</span></code>, modified in-place, and <code class="docutils literal"><span class="pre">T</span></code>, which contains upper triangular block reflectors which parameterize the elementary reflectors of the factorization.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.getrf!">
<code class="descname">getrf!</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span> &rarr; (A, ipiv, info)<a class="headerlink" href="#Base.LinAlg.LAPACK.getrf!" title="Permalink to this definition"></a></dt>
<dd><p>Compute the pivoted <code class="docutils literal"><span class="pre">LU</span></code> factorization of <code class="docutils literal"><span class="pre">A</span></code>, <code class="docutils literal"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">LU</span></code>.</p>
<p>Returns <code class="docutils literal"><span class="pre">A</span></code>, modified in-place, <code class="docutils literal"><span class="pre">ipiv</span></code>, the pivoting information, and an <code class="docutils literal"><span class="pre">info</span></code> code which indicates success (<code class="docutils literal"><span class="pre">info</span> <span class="pre">=</span> <span class="pre">0</span></code>), a singular value in <code class="docutils literal"><span class="pre">U</span></code> (<code class="docutils literal"><span class="pre">info</span> <span class="pre">=</span> <span class="pre">i</span></code>, in which case <code class="docutils literal"><span class="pre">U[i,i]</span></code> is singular), or an error code (<code class="docutils literal"><span class="pre">info</span> <span class="pre">&lt;</span> <span class="pre">0</span></code>).</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.tzrzf!">
<code class="descname">tzrzf!</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span> &rarr; (A, tau)<a class="headerlink" href="#Base.LinAlg.LAPACK.tzrzf!" title="Permalink to this definition"></a></dt>
<dd><p>Transforms the upper trapezoidal matrix <code class="docutils literal"><span class="pre">A</span></code> to upper triangular form in-place. Returns <code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">tau</span></code>, the scalar parameters for the elementary reflectors of the transformation.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.ormrz!">
<code class="descname">ormrz!</code><span class="sig-paren">(</span><em>side</em>, <em>trans</em>, <em>A</em>, <em>tau</em>, <em>C</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.LAPACK.ormrz!" title="Permalink to this definition"></a></dt>
<dd><p>Multiplies the matrix <code class="docutils literal"><span class="pre">C</span></code> by <code class="docutils literal"><span class="pre">Q</span></code> from the transformation supplied by <code class="docutils literal"><span class="pre">tzrzf!</span></code>. Depending on <code class="docutils literal"><span class="pre">side</span></code> or <code class="docutils literal"><span class="pre">trans</span></code> the multiplication can be left-sided (<code class="docutils literal"><span class="pre">side</span> <span class="pre">=</span> <span class="pre">L,</span> <span class="pre">Q*C</span></code>) or right-sided (<code class="docutils literal"><span class="pre">side</span> <span class="pre">=</span> <span class="pre">R,</span> <span class="pre">C*Q</span></code>) and <code class="docutils literal"><span class="pre">Q</span></code> can be unmodified (<code class="docutils literal"><span class="pre">trans</span> <span class="pre">=</span> <span class="pre">N</span></code>), transposed (<code class="docutils literal"><span class="pre">trans</span> <span class="pre">=</span> <span class="pre">T</span></code>), or conjugate transposed (<code class="docutils literal"><span class="pre">trans</span> <span class="pre">=</span> <span class="pre">C</span></code>). Returns matrix <code class="docutils literal"><span class="pre">C</span></code> which is modified in-place with the result of the multiplication.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.gels!">
<code class="descname">gels!</code><span class="sig-paren">(</span><em>trans</em>, <em>A</em>, <em>B</em><span class="sig-paren">)</span> &rarr; (F, B, ssr)<a class="headerlink" href="#Base.LinAlg.LAPACK.gels!" title="Permalink to this definition"></a></dt>
<dd><p>Solves the linear equation <code class="docutils literal"><span class="pre">A</span> <span class="pre">*</span> <span class="pre">X</span> <span class="pre">=</span> <span class="pre">B</span></code>, <code class="docutils literal"><span class="pre">A.'</span> <span class="pre">*</span> <span class="pre">X</span> <span class="pre">=B</span></code>, or <code class="docutils literal"><span class="pre">A'</span> <span class="pre">*</span> <span class="pre">X</span> <span class="pre">=</span> <span class="pre">B</span></code> using a QR or LQ factorization. Modifies the matrix/vector <code class="docutils literal"><span class="pre">B</span></code> in place with the solution. <code class="docutils literal"><span class="pre">A</span></code> is overwritten with its <code class="docutils literal"><span class="pre">QR</span></code> or <code class="docutils literal"><span class="pre">LQ</span></code> factorization. <code class="docutils literal"><span class="pre">trans</span></code> may be one of <code class="docutils literal"><span class="pre">N</span></code> (no modification), <code class="docutils literal"><span class="pre">T</span></code> (transpose), or <code class="docutils literal"><span class="pre">C</span></code> (conjugate transpose). <code class="docutils literal"><span class="pre">gels!</span></code> searches for the minimum norm/least squares solution. <code class="docutils literal"><span class="pre">A</span></code> may be under or over determined. The solution is returned in <code class="docutils literal"><span class="pre">B</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.gesv!">
<code class="descname">gesv!</code><span class="sig-paren">(</span><em>A</em>, <em>B</em><span class="sig-paren">)</span> &rarr; (B, A, ipiv)<a class="headerlink" href="#Base.LinAlg.LAPACK.gesv!" title="Permalink to this definition"></a></dt>
<dd><p>Solves the linear equation <code class="docutils literal"><span class="pre">A</span> <span class="pre">*</span> <span class="pre">X</span> <span class="pre">=</span> <span class="pre">B</span></code> where <code class="docutils literal"><span class="pre">A</span></code> is a square matrix using the <code class="docutils literal"><span class="pre">LU</span></code> factorization of <code class="docutils literal"><span class="pre">A</span></code>. <code class="docutils literal"><span class="pre">A</span></code> is overwritten with its <code class="docutils literal"><span class="pre">LU</span></code> factorization and <code class="docutils literal"><span class="pre">B</span></code> is overwritten with the solution <code class="docutils literal"><span class="pre">X</span></code>. <code class="docutils literal"><span class="pre">ipiv</span></code> contains the pivoting information for the <code class="docutils literal"><span class="pre">LU</span></code> factorization of <code class="docutils literal"><span class="pre">A</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.getrs!">
<code class="descname">getrs!</code><span class="sig-paren">(</span><em>trans</em>, <em>A</em>, <em>ipiv</em>, <em>B</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.LAPACK.getrs!" title="Permalink to this definition"></a></dt>
<dd><p>Solves the linear equation <code class="docutils literal"><span class="pre">A</span> <span class="pre">*</span> <span class="pre">X</span> <span class="pre">=</span> <span class="pre">B</span></code>, <code class="docutils literal"><span class="pre">A.'</span> <span class="pre">*</span> <span class="pre">X</span> <span class="pre">=B</span></code>, or <code class="docutils literal"><span class="pre">A'</span> <span class="pre">*</span> <span class="pre">X</span> <span class="pre">=</span> <span class="pre">B</span></code> for square <code class="docutils literal"><span class="pre">A</span></code>. Modifies the matrix/vector <code class="docutils literal"><span class="pre">B</span></code> in place with the solution. <code class="docutils literal"><span class="pre">A</span></code> is the <code class="docutils literal"><span class="pre">LU</span></code> factorization from <code class="docutils literal"><span class="pre">getrf!</span></code>, with <code class="docutils literal"><span class="pre">ipiv</span></code> the pivoting information. <code class="docutils literal"><span class="pre">trans</span></code> may be one of <code class="docutils literal"><span class="pre">N</span></code> (no modification), <code class="docutils literal"><span class="pre">T</span></code> (transpose), or <code class="docutils literal"><span class="pre">C</span></code> (conjugate transpose).</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.getri!">
<code class="descname">getri!</code><span class="sig-paren">(</span><em>A</em>, <em>ipiv</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.LAPACK.getri!" title="Permalink to this definition"></a></dt>
<dd><p>Computes the inverse of <code class="docutils literal"><span class="pre">A</span></code>, using its <code class="docutils literal"><span class="pre">LU</span></code> factorization found by <code class="docutils literal"><span class="pre">getrf!</span></code>. <code class="docutils literal"><span class="pre">ipiv</span></code> is the pivot information output and <code class="docutils literal"><span class="pre">A</span></code> contains the <code class="docutils literal"><span class="pre">LU</span></code> factorization of <code class="docutils literal"><span class="pre">getrf!</span></code>. <code class="docutils literal"><span class="pre">A</span></code> is overwritten with its inverse.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.gesvx!">
<code class="descname">gesvx!</code><span class="sig-paren">(</span><em>fact</em>, <em>trans</em>, <em>A</em>, <em>AF</em>, <em>ipiv</em>, <em>equed</em>, <em>R</em>, <em>C</em>, <em>B</em><span class="sig-paren">)</span> &rarr; (X, equed, R, C, B, rcond, ferr, berr, work)<a class="headerlink" href="#Base.LinAlg.LAPACK.gesvx!" title="Permalink to this definition"></a></dt>
<dd><p>Solves the linear equation <code class="docutils literal"><span class="pre">A</span> <span class="pre">*</span> <span class="pre">X</span> <span class="pre">=</span> <span class="pre">B</span></code> (<code class="docutils literal"><span class="pre">trans</span> <span class="pre">=</span> <span class="pre">N</span></code>), <code class="docutils literal"><span class="pre">A.'</span> <span class="pre">*</span> <span class="pre">X</span> <span class="pre">=B</span></code> (<code class="docutils literal"><span class="pre">trans</span> <span class="pre">=</span> <span class="pre">T</span></code>), or <code class="docutils literal"><span class="pre">A'</span> <span class="pre">*</span> <span class="pre">X</span> <span class="pre">=</span> <span class="pre">B</span></code> (<code class="docutils literal"><span class="pre">trans</span> <span class="pre">=</span> <span class="pre">C</span></code>) using the <code class="docutils literal"><span class="pre">LU</span></code> factorization of <code class="docutils literal"><span class="pre">A</span></code>. <code class="docutils literal"><span class="pre">fact</span></code> may be <code class="docutils literal"><span class="pre">E</span></code>, in which case <code class="docutils literal"><span class="pre">A</span></code> will be equilibrated and copied to <code class="docutils literal"><span class="pre">AF</span></code>; <code class="docutils literal"><span class="pre">F</span></code>, in which case <code class="docutils literal"><span class="pre">AF</span></code> and <code class="docutils literal"><span class="pre">ipiv</span></code> from a previous <code class="docutils literal"><span class="pre">LU</span></code> factorization are inputs; or <code class="docutils literal"><span class="pre">N</span></code>, in which case <code class="docutils literal"><span class="pre">A</span></code> will be copied to <code class="docutils literal"><span class="pre">AF</span></code> and then factored. If <code class="docutils literal"><span class="pre">fact</span> <span class="pre">=</span> <span class="pre">F</span></code>, <code class="docutils literal"><span class="pre">equed</span></code> may be <code class="docutils literal"><span class="pre">N</span></code>, meaning <code class="docutils literal"><span class="pre">A</span></code> has not been equilibrated; <code class="docutils literal"><span class="pre">R</span></code>, meaning <code class="docutils literal"><span class="pre">A</span></code> was multiplied by <code class="docutils literal"><span class="pre">diagm(R)</span></code> from the left; <code class="docutils literal"><span class="pre">C</span></code>, meaning <code class="docutils literal"><span class="pre">A</span></code> was multiplied by <code class="docutils literal"><span class="pre">diagm(C)</span></code> from the right; or <code class="docutils literal"><span class="pre">B</span></code>, meaning <code class="docutils literal"><span class="pre">A</span></code> was multiplied by <code class="docutils literal"><span class="pre">diagm(R)</span></code> from the left and <code class="docutils literal"><span class="pre">diagm(C)</span></code> from the right. If <code class="docutils literal"><span class="pre">fact</span> <span class="pre">=</span> <span class="pre">F</span></code> and <code class="docutils literal"><span class="pre">equed</span> <span class="pre">=</span> <span class="pre">R</span></code> or <code class="docutils literal"><span class="pre">B</span></code> the elements of <code class="docutils literal"><span class="pre">R</span></code> must all be positive. If <code class="docutils literal"><span class="pre">fact</span> <span class="pre">=</span> <span class="pre">F</span></code> and <code class="docutils literal"><span class="pre">equed</span> <span class="pre">=</span> <span class="pre">C</span></code> or <code class="docutils literal"><span class="pre">B</span></code> the elements of <code class="docutils literal"><span class="pre">C</span></code> must all be positive.</p>
<p>Returns the solution <code class="docutils literal"><span class="pre">X</span></code>; <code class="docutils literal"><span class="pre">equed</span></code>, which is an output if <code class="docutils literal"><span class="pre">fact</span></code> is not <code class="docutils literal"><span class="pre">N</span></code>, and describes the equilibration that was performed; <code class="docutils literal"><span class="pre">R</span></code>, the row equilibration diagonal; <code class="docutils literal"><span class="pre">C</span></code>, the column equilibration diagonal; <code class="docutils literal"><span class="pre">B</span></code>, which may be overwritten with its equilibrated form <code class="docutils literal"><span class="pre">diagm(R)*B</span></code> (if <code class="docutils literal"><span class="pre">trans</span> <span class="pre">=</span> <span class="pre">N</span></code> and <code class="docutils literal"><span class="pre">equed</span> <span class="pre">=</span> <span class="pre">R,B</span></code>) or <code class="docutils literal"><span class="pre">diagm(C)*B</span></code> (if <code class="docutils literal"><span class="pre">trans</span> <span class="pre">=</span> <span class="pre">T,C</span></code> and <code class="docutils literal"><span class="pre">equed</span> <span class="pre">=</span> <span class="pre">C,B</span></code>); <code class="docutils literal"><span class="pre">rcond</span></code>, the reciprocal condition number of <code class="docutils literal"><span class="pre">A</span></code> after equilbrating; <code class="docutils literal"><span class="pre">ferr</span></code>, the forward error bound for each solution vector in <code class="docutils literal"><span class="pre">X</span></code>; <code class="docutils literal"><span class="pre">berr</span></code>, the forward error bound for each solution vector in <code class="docutils literal"><span class="pre">X</span></code>; and <code class="docutils literal"><span class="pre">work</span></code>, the reciprocal pivot growth factor.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">gesvx!</code><span class="sig-paren">(</span><em>A</em>, <em>B</em><span class="sig-paren">)</span></dt>
<dd><p>The no-equilibration, no-transpose simplification of <code class="docutils literal"><span class="pre">gesvx!</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.gelsd!">
<code class="descname">gelsd!</code><span class="sig-paren">(</span><em>A</em>, <em>B</em>, <em>rcond</em><span class="sig-paren">)</span> &rarr; (B, rnk)<a class="headerlink" href="#Base.LinAlg.LAPACK.gelsd!" title="Permalink to this definition"></a></dt>
<dd><p>Computes the least norm solution of <code class="docutils literal"><span class="pre">A</span> <span class="pre">*</span> <span class="pre">X</span> <span class="pre">=</span> <span class="pre">B</span></code> by finding the <code class="docutils literal"><span class="pre">SVD</span></code> factorization of <code class="docutils literal"><span class="pre">A</span></code>, then dividing-and-conquering the problem. <code class="docutils literal"><span class="pre">B</span></code> is overwritten with the solution <code class="docutils literal"><span class="pre">X</span></code>. Singular values below <code class="docutils literal"><span class="pre">rcond</span></code> will be treated as zero. Returns the solution in <code class="docutils literal"><span class="pre">B</span></code> and the effective rank of <code class="docutils literal"><span class="pre">A</span></code> in <code class="docutils literal"><span class="pre">rnk</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.gelsy!">
<code class="descname">gelsy!</code><span class="sig-paren">(</span><em>A</em>, <em>B</em>, <em>rcond</em><span class="sig-paren">)</span> &rarr; (B, rnk)<a class="headerlink" href="#Base.LinAlg.LAPACK.gelsy!" title="Permalink to this definition"></a></dt>
<dd><p>Computes the least norm solution of <code class="docutils literal"><span class="pre">A</span> <span class="pre">*</span> <span class="pre">X</span> <span class="pre">=</span> <span class="pre">B</span></code> by finding the full <code class="docutils literal"><span class="pre">QR</span></code> factorization of <code class="docutils literal"><span class="pre">A</span></code>, then dividing-and-conquering the problem. <code class="docutils literal"><span class="pre">B</span></code> is overwritten with the solution <code class="docutils literal"><span class="pre">X</span></code>. Singular values below <code class="docutils literal"><span class="pre">rcond</span></code> will be treated as zero. Returns the solution in <code class="docutils literal"><span class="pre">B</span></code> and the effective rank of <code class="docutils literal"><span class="pre">A</span></code> in <code class="docutils literal"><span class="pre">rnk</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.gglse!">
<code class="descname">gglse!</code><span class="sig-paren">(</span><em>A</em>, <em>c</em>, <em>B</em>, <em>d</em><span class="sig-paren">)</span> &rarr; (X,res)<a class="headerlink" href="#Base.LinAlg.LAPACK.gglse!" title="Permalink to this definition"></a></dt>
<dd><p>Solves the equation <code class="docutils literal"><span class="pre">A</span> <span class="pre">*</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">c</span></code> where <code class="docutils literal"><span class="pre">x</span></code> is subject to the equality constraint <code class="docutils literal"><span class="pre">B</span> <span class="pre">*</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">d</span></code>. Uses the formula <code class="docutils literal"><span class="pre">||c</span> <span class="pre">-</span> <span class="pre">A*x||^2</span> <span class="pre">=</span> <span class="pre">0</span></code> to solve. Returns <code class="docutils literal"><span class="pre">X</span></code> and the residual sum-of-squares.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.geev!">
<code class="descname">geev!</code><span class="sig-paren">(</span><em>jobvl</em>, <em>jobvr</em>, <em>A</em><span class="sig-paren">)</span> &rarr; (W, VL, VR)<a class="headerlink" href="#Base.LinAlg.LAPACK.geev!" title="Permalink to this definition"></a></dt>
<dd><p>Finds the eigensystem of <code class="docutils literal"><span class="pre">A</span></code>. If <code class="docutils literal"><span class="pre">jobvl</span> <span class="pre">=</span> <span class="pre">N</span></code>, the left eigenvectors of <code class="docutils literal"><span class="pre">A</span></code> aren&#8217;t computed. If <code class="docutils literal"><span class="pre">jobvr</span> <span class="pre">=</span> <span class="pre">N</span></code>, the right eigenvectors of <code class="docutils literal"><span class="pre">A</span></code> aren&#8217;t computed. If <code class="docutils literal"><span class="pre">jobvl</span> <span class="pre">=</span> <span class="pre">V</span></code> or <code class="docutils literal"><span class="pre">jobvr</span> <span class="pre">=</span> <span class="pre">V</span></code>, the corresponding eigenvectors are computed. Returns the eigenvalues in <code class="docutils literal"><span class="pre">W</span></code>, the right eigenvectors in <code class="docutils literal"><span class="pre">VR</span></code>, and the left eigenvectors in <code class="docutils literal"><span class="pre">VL</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.gesdd!">
<code class="descname">gesdd!</code><span class="sig-paren">(</span><em>job</em>, <em>A</em><span class="sig-paren">)</span> &rarr; (U, S, VT)<a class="headerlink" href="#Base.LinAlg.LAPACK.gesdd!" title="Permalink to this definition"></a></dt>
<dd><p>Finds the singular value decomposition of <code class="docutils literal"><span class="pre">A</span></code>, <code class="docutils literal"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">U</span> <span class="pre">*</span> <span class="pre">S</span> <span class="pre">*</span> <span class="pre">V'</span></code>, using a divide and conquer approach. If <code class="docutils literal"><span class="pre">job</span> <span class="pre">=</span> <span class="pre">A</span></code>, all the columns of <code class="docutils literal"><span class="pre">U</span></code> and the rows of <code class="docutils literal"><span class="pre">V'</span></code> are computed. If <code class="docutils literal"><span class="pre">job</span> <span class="pre">=</span> <span class="pre">N</span></code>, no columns of <code class="docutils literal"><span class="pre">U</span></code> or rows of <code class="docutils literal"><span class="pre">V'</span></code> are computed. If <code class="docutils literal"><span class="pre">job</span> <span class="pre">=</span> <span class="pre">O</span></code>, <code class="docutils literal"><span class="pre">A</span></code> is overwritten with the columns of (thin) <code class="docutils literal"><span class="pre">U</span></code> and the rows of (thin) <code class="docutils literal"><span class="pre">V'</span></code>. If <code class="docutils literal"><span class="pre">job</span> <span class="pre">=</span> <span class="pre">S</span></code>, the columns of (thin) <code class="docutils literal"><span class="pre">U</span></code> and the rows of (thin) <code class="docutils literal"><span class="pre">V'</span></code> are computed and returned separately.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.gesvd!">
<code class="descname">gesvd!</code><span class="sig-paren">(</span><em>jobu</em>, <em>jobvt</em>, <em>A</em><span class="sig-paren">)</span> &rarr; (U, S, VT)<a class="headerlink" href="#Base.LinAlg.LAPACK.gesvd!" title="Permalink to this definition"></a></dt>
<dd><p>Finds the singular value decomposition of <code class="docutils literal"><span class="pre">A</span></code>, <code class="docutils literal"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">U</span> <span class="pre">*</span> <span class="pre">S</span> <span class="pre">*</span> <span class="pre">V'</span></code>. If <code class="docutils literal"><span class="pre">jobu</span> <span class="pre">=</span> <span class="pre">A</span></code>, all the columns of <code class="docutils literal"><span class="pre">U</span></code> are computed. If <code class="docutils literal"><span class="pre">jobvt</span> <span class="pre">=</span> <span class="pre">A</span></code> all the rows of <code class="docutils literal"><span class="pre">V'</span></code> are computed. If <code class="docutils literal"><span class="pre">jobu</span> <span class="pre">=</span> <span class="pre">N</span></code>, no columns of <code class="docutils literal"><span class="pre">U</span></code> are computed. If <code class="docutils literal"><span class="pre">jobvt</span> <span class="pre">=</span> <span class="pre">N</span></code> no rows of <code class="docutils literal"><span class="pre">V'</span></code> are computed. If <code class="docutils literal"><span class="pre">jobu</span> <span class="pre">=</span> <span class="pre">O</span></code>, <code class="docutils literal"><span class="pre">A</span></code> is overwritten with the columns of (thin) <code class="docutils literal"><span class="pre">U</span></code>. If <code class="docutils literal"><span class="pre">jobvt</span> <span class="pre">=</span> <span class="pre">O</span></code>, <code class="docutils literal"><span class="pre">A</span></code> is overwritten with the rows of (thin) <code class="docutils literal"><span class="pre">V'</span></code>. If <code class="docutils literal"><span class="pre">jobu</span> <span class="pre">=</span> <span class="pre">S</span></code>, the columns of (thin) <code class="docutils literal"><span class="pre">U</span></code> are computed and returned separately. If <code class="docutils literal"><span class="pre">jobvt</span> <span class="pre">=</span> <span class="pre">S</span></code> the rows of (thin) <code class="docutils literal"><span class="pre">V'</span></code> are computed and returned separately. <code class="docutils literal"><span class="pre">jobu</span></code> and <code class="docutils literal"><span class="pre">jobvt</span></code> can&#8217;t both be <code class="docutils literal"><span class="pre">O</span></code>.</p>
<p>Returns <code class="docutils literal"><span class="pre">U</span></code>, <code class="docutils literal"><span class="pre">S</span></code>, and <code class="docutils literal"><span class="pre">Vt</span></code>, where <code class="docutils literal"><span class="pre">S</span></code> are the singular values of <code class="docutils literal"><span class="pre">A</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.ggsvd!">
<code class="descname">ggsvd!</code><span class="sig-paren">(</span><em>jobu</em>, <em>jobv</em>, <em>jobq</em>, <em>A</em>, <em>B</em><span class="sig-paren">)</span> &rarr; (U, V, Q, alpha, beta, k, l, R)<a class="headerlink" href="#Base.LinAlg.LAPACK.ggsvd!" title="Permalink to this definition"></a></dt>
<dd><p>Finds the generalized singular value decomposition of <code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">B</span></code>, <code class="docutils literal"><span class="pre">U'*A*Q</span> <span class="pre">=</span> <span class="pre">D1*R</span></code> and <code class="docutils literal"><span class="pre">V'*B*Q</span> <span class="pre">=</span> <span class="pre">D2*R</span></code>. <code class="docutils literal"><span class="pre">D1</span></code> has <code class="docutils literal"><span class="pre">alpha</span></code> on its diagonal and <code class="docutils literal"><span class="pre">D2</span></code> has <code class="docutils literal"><span class="pre">beta</span></code> on its diagonal. If <code class="docutils literal"><span class="pre">jobu</span> <span class="pre">=</span> <span class="pre">U</span></code>, the orthogonal/unitary matrix <code class="docutils literal"><span class="pre">U</span></code> is computed. If <code class="docutils literal"><span class="pre">jobv</span> <span class="pre">=</span> <span class="pre">V</span></code> the orthogonal/unitary matrix <code class="docutils literal"><span class="pre">V</span></code> is computed. If <code class="docutils literal"><span class="pre">jobq</span> <span class="pre">=</span> <span class="pre">Q</span></code>, the orthogonal/unitary matrix <code class="docutils literal"><span class="pre">Q</span></code> is computed. If <code class="docutils literal"><span class="pre">jobu</span></code>, <code class="docutils literal"><span class="pre">jobv</span></code> or <code class="docutils literal"><span class="pre">jobq</span></code> is <code class="docutils literal"><span class="pre">N</span></code>, that matrix is not computed. This function is only available in LAPACK versions prior to 3.6.0.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.ggsvd3!">
<code class="descname">ggsvd3!</code><span class="sig-paren">(</span><em>jobu</em>, <em>jobv</em>, <em>jobq</em>, <em>A</em>, <em>B</em><span class="sig-paren">)</span> &rarr; (U, V, Q, alpha, beta, k, l, R)<a class="headerlink" href="#Base.LinAlg.LAPACK.ggsvd3!" title="Permalink to this definition"></a></dt>
<dd><p>Finds the generalized singular value decomposition of <code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">B</span></code>, <code class="docutils literal"><span class="pre">U'*A*Q</span> <span class="pre">=</span> <span class="pre">D1*R</span></code> and <code class="docutils literal"><span class="pre">V'*B*Q</span> <span class="pre">=</span> <span class="pre">D2*R</span></code>. <code class="docutils literal"><span class="pre">D1</span></code> has <code class="docutils literal"><span class="pre">alpha</span></code> on its diagonal and <code class="docutils literal"><span class="pre">D2</span></code> has <code class="docutils literal"><span class="pre">beta</span></code> on its diagonal. If <code class="docutils literal"><span class="pre">jobu</span> <span class="pre">=</span> <span class="pre">U</span></code>, the orthogonal/unitary matrix <code class="docutils literal"><span class="pre">U</span></code> is computed. If <code class="docutils literal"><span class="pre">jobv</span> <span class="pre">=</span> <span class="pre">V</span></code> the orthogonal/unitary matrix <code class="docutils literal"><span class="pre">V</span></code> is computed. If <code class="docutils literal"><span class="pre">jobq</span> <span class="pre">=</span> <span class="pre">Q</span></code>, the orthogonal/unitary matrix <code class="docutils literal"><span class="pre">Q</span></code> is computed. If <code class="docutils literal"><span class="pre">jobu</span></code>, <code class="docutils literal"><span class="pre">jobv</span></code>, or <code class="docutils literal"><span class="pre">jobq</span></code> is <code class="docutils literal"><span class="pre">N</span></code>, that matrix is not computed. This function requires LAPACK 3.6.0.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.geevx!">
<code class="descname">geevx!</code><span class="sig-paren">(</span><em>balanc</em>, <em>jobvl</em>, <em>jobvr</em>, <em>sense</em>, <em>A</em><span class="sig-paren">)</span> &rarr; (A, w, VL, VR, ilo, ihi, scale, abnrm, rconde, rcondv)<a class="headerlink" href="#Base.LinAlg.LAPACK.geevx!" title="Permalink to this definition"></a></dt>
<dd><p>Finds the eigensystem of <code class="docutils literal"><span class="pre">A</span></code> with matrix balancing. If <code class="docutils literal"><span class="pre">jobvl</span> <span class="pre">=</span> <span class="pre">N</span></code>, the left eigenvectors of <code class="docutils literal"><span class="pre">A</span></code> aren&#8217;t computed. If <code class="docutils literal"><span class="pre">jobvr</span> <span class="pre">=</span> <span class="pre">N</span></code>, the right eigenvectors of <code class="docutils literal"><span class="pre">A</span></code> aren&#8217;t computed. If <code class="docutils literal"><span class="pre">jobvl</span> <span class="pre">=</span> <span class="pre">V</span></code> or <code class="docutils literal"><span class="pre">jobvr</span> <span class="pre">=</span> <span class="pre">V</span></code>, the corresponding eigenvectors are computed. If <code class="docutils literal"><span class="pre">balanc</span> <span class="pre">=</span> <span class="pre">N</span></code>, no balancing is performed. If <code class="docutils literal"><span class="pre">balanc</span> <span class="pre">=</span> <span class="pre">P</span></code>, <code class="docutils literal"><span class="pre">A</span></code> is permuted but not scaled. If <code class="docutils literal"><span class="pre">balanc</span> <span class="pre">=</span> <span class="pre">S</span></code>, <code class="docutils literal"><span class="pre">A</span></code> is scaled but not permuted. If <code class="docutils literal"><span class="pre">balanc</span> <span class="pre">=</span> <span class="pre">B</span></code>, <code class="docutils literal"><span class="pre">A</span></code> is permuted and scaled. If <code class="docutils literal"><span class="pre">sense</span> <span class="pre">=</span> <span class="pre">N</span></code>, no reciprocal condition numbers are computed. If <code class="docutils literal"><span class="pre">sense</span> <span class="pre">=</span> <span class="pre">E</span></code>, reciprocal condition numbers are computed for the eigenvalues only. If <code class="docutils literal"><span class="pre">sense</span> <span class="pre">=</span> <span class="pre">V</span></code>, reciprocal condition numbers are computed for the right eigenvectors only. If <code class="docutils literal"><span class="pre">sense</span> <span class="pre">=</span> <span class="pre">B</span></code>, reciprocal condition numbers are computed for the right eigenvectors and the eigenvectors. If <code class="docutils literal"><span class="pre">sense</span> <span class="pre">=</span> <span class="pre">E,B</span></code>, the right and left eigenvectors must be computed.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.ggev!">
<code class="descname">ggev!</code><span class="sig-paren">(</span><em>jobvl</em>, <em>jobvr</em>, <em>A</em>, <em>B</em><span class="sig-paren">)</span> &rarr; (alpha, beta, vl, vr)<a class="headerlink" href="#Base.LinAlg.LAPACK.ggev!" title="Permalink to this definition"></a></dt>
<dd><p>Finds the generalized eigendecomposition of <code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">B</span></code>. If <code class="docutils literal"><span class="pre">jobvl</span> <span class="pre">=</span> <span class="pre">N</span></code>, the left eigenvectors aren&#8217;t computed. If <code class="docutils literal"><span class="pre">jobvr</span> <span class="pre">=</span> <span class="pre">N</span></code>, the right eigenvectors aren&#8217;t computed. If <code class="docutils literal"><span class="pre">jobvl</span> <span class="pre">=</span> <span class="pre">V</span></code> or <code class="docutils literal"><span class="pre">jobvr</span> <span class="pre">=</span> <span class="pre">V</span></code>, the corresponding eigenvectors are computed.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.gtsv!">
<code class="descname">gtsv!</code><span class="sig-paren">(</span><em>dl</em>, <em>d</em>, <em>du</em>, <em>B</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.LAPACK.gtsv!" title="Permalink to this definition"></a></dt>
<dd><p>Solves the equation <code class="docutils literal"><span class="pre">A</span> <span class="pre">*</span> <span class="pre">X</span> <span class="pre">=</span> <span class="pre">B</span></code> where <code class="docutils literal"><span class="pre">A</span></code> is a tridiagonal matrix with <code class="docutils literal"><span class="pre">dl</span></code> on the subdiagonal, <code class="docutils literal"><span class="pre">d</span></code> on the diagonal, and <code class="docutils literal"><span class="pre">du</span></code> on the superdiagonal.</p>
<p>Overwrites <code class="docutils literal"><span class="pre">B</span></code> with the solution <code class="docutils literal"><span class="pre">X</span></code> and returns it.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.gttrf!">
<code class="descname">gttrf!</code><span class="sig-paren">(</span><em>dl</em>, <em>d</em>, <em>du</em><span class="sig-paren">)</span> &rarr; (dl, d, du, du2, ipiv)<a class="headerlink" href="#Base.LinAlg.LAPACK.gttrf!" title="Permalink to this definition"></a></dt>
<dd><p>Finds the <code class="docutils literal"><span class="pre">LU</span></code> factorization of a tridiagonal matrix with <code class="docutils literal"><span class="pre">dl</span></code> on the subdiagonal, <code class="docutils literal"><span class="pre">d</span></code> on the diagonal, and <code class="docutils literal"><span class="pre">du</span></code> on the superdiagonal.</p>
<p>Modifies <code class="docutils literal"><span class="pre">dl</span></code>, <code class="docutils literal"><span class="pre">d</span></code>, and <code class="docutils literal"><span class="pre">du</span></code> in-place and returns them and the second superdiagonal <code class="docutils literal"><span class="pre">du2</span></code> and the pivoting vector <code class="docutils literal"><span class="pre">ipiv</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.gttrs!">
<code class="descname">gttrs!</code><span class="sig-paren">(</span><em>trans</em>, <em>dl</em>, <em>d</em>, <em>du</em>, <em>du2</em>, <em>ipiv</em>, <em>B</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.LAPACK.gttrs!" title="Permalink to this definition"></a></dt>
<dd><p>Solves the equation <code class="docutils literal"><span class="pre">A</span> <span class="pre">*</span> <span class="pre">X</span> <span class="pre">=</span> <span class="pre">B</span></code> (<code class="docutils literal"><span class="pre">trans</span> <span class="pre">=</span> <span class="pre">N</span></code>), <code class="docutils literal"><span class="pre">A.'</span> <span class="pre">*</span> <span class="pre">X</span> <span class="pre">=</span> <span class="pre">B</span></code> (<code class="docutils literal"><span class="pre">trans</span> <span class="pre">=</span> <span class="pre">T</span></code>), or <code class="docutils literal"><span class="pre">A'</span> <span class="pre">*</span> <span class="pre">X</span> <span class="pre">=</span> <span class="pre">B</span></code> (<code class="docutils literal"><span class="pre">trans</span> <span class="pre">=</span> <span class="pre">C</span></code>) using the <code class="docutils literal"><span class="pre">LU</span></code> factorization computed by <code class="docutils literal"><span class="pre">gttrf!</span></code>. <code class="docutils literal"><span class="pre">B</span></code> is overwritten with the solution <code class="docutils literal"><span class="pre">X</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.orglq!">
<code class="descname">orglq!</code><span class="sig-paren">(</span><em>A</em>, <em>tau</em>, <em>k = length(tau)</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.LAPACK.orglq!" title="Permalink to this definition"></a></dt>
<dd><p>Explicitly finds the matrix <code class="docutils literal"><span class="pre">Q</span></code> of a <code class="docutils literal"><span class="pre">LQ</span></code> factorization after calling <code class="docutils literal"><span class="pre">gelqf!</span></code> on <code class="docutils literal"><span class="pre">A</span></code>. Uses the output of <code class="docutils literal"><span class="pre">gelqf!</span></code>. <code class="docutils literal"><span class="pre">A</span></code> is overwritten by <code class="docutils literal"><span class="pre">Q</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.orgqr!">
<code class="descname">orgqr!</code><span class="sig-paren">(</span><em>A</em>, <em>tau</em>, <em>k = length(tau)</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.LAPACK.orgqr!" title="Permalink to this definition"></a></dt>
<dd><p>Explicitly finds the matrix <code class="docutils literal"><span class="pre">Q</span></code> of a <code class="docutils literal"><span class="pre">QR</span></code> factorization after calling <code class="docutils literal"><span class="pre">geqrf!</span></code> on <code class="docutils literal"><span class="pre">A</span></code>. Uses the output of <code class="docutils literal"><span class="pre">geqrf!</span></code>. <code class="docutils literal"><span class="pre">A</span></code> is overwritten by <code class="docutils literal"><span class="pre">Q</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.orgql!">
<code class="descname">orgql!</code><span class="sig-paren">(</span><em>A</em>, <em>tau</em>, <em>k = length(tau)</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.LAPACK.orgql!" title="Permalink to this definition"></a></dt>
<dd><p>Explicitly finds the matrix <code class="docutils literal"><span class="pre">Q</span></code> of a <code class="docutils literal"><span class="pre">QL</span></code> factorization after calling <code class="docutils literal"><span class="pre">geqlf!</span></code> on <code class="docutils literal"><span class="pre">A</span></code>. Uses the output of <code class="docutils literal"><span class="pre">geqlf!</span></code>. <code class="docutils literal"><span class="pre">A</span></code> is overwritten by <code class="docutils literal"><span class="pre">Q</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.orgrq!">
<code class="descname">orgrq!</code><span class="sig-paren">(</span><em>A</em>, <em>tau</em>, <em>k = length(tau)</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.LAPACK.orgrq!" title="Permalink to this definition"></a></dt>
<dd><p>Explicitly finds the matrix <code class="docutils literal"><span class="pre">Q</span></code> of a <code class="docutils literal"><span class="pre">RQ</span></code> factorization after calling <code class="docutils literal"><span class="pre">gerqf!</span></code> on <code class="docutils literal"><span class="pre">A</span></code>. Uses the output of <code class="docutils literal"><span class="pre">gerqf!</span></code>. <code class="docutils literal"><span class="pre">A</span></code> is overwritten by <code class="docutils literal"><span class="pre">Q</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.ormlq!">
<code class="descname">ormlq!</code><span class="sig-paren">(</span><em>side</em>, <em>trans</em>, <em>A</em>, <em>tau</em>, <em>C</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.LAPACK.ormlq!" title="Permalink to this definition"></a></dt>
<dd><p>Computes <code class="docutils literal"><span class="pre">Q</span> <span class="pre">*</span> <span class="pre">C</span></code> (<code class="docutils literal"><span class="pre">trans</span> <span class="pre">=</span> <span class="pre">N</span></code>), <code class="docutils literal"><span class="pre">Q.'</span> <span class="pre">*</span> <span class="pre">C</span></code> (<code class="docutils literal"><span class="pre">trans</span> <span class="pre">=</span> <span class="pre">T</span></code>), <code class="docutils literal"><span class="pre">Q'</span> <span class="pre">*</span> <span class="pre">C</span></code> (<code class="docutils literal"><span class="pre">trans</span> <span class="pre">=</span> <span class="pre">C</span></code>) for <code class="docutils literal"><span class="pre">side</span> <span class="pre">=</span> <span class="pre">L</span></code> or the equivalent right-sided multiplication for <code class="docutils literal"><span class="pre">side</span> <span class="pre">=</span> <span class="pre">R</span></code> using <code class="docutils literal"><span class="pre">Q</span></code> from a <code class="docutils literal"><span class="pre">LQ</span></code> factorization of <code class="docutils literal"><span class="pre">A</span></code> computed using <code class="docutils literal"><span class="pre">gelqf!</span></code>. <code class="docutils literal"><span class="pre">C</span></code> is overwritten.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.ormqr!">
<code class="descname">ormqr!</code><span class="sig-paren">(</span><em>side</em>, <em>trans</em>, <em>A</em>, <em>tau</em>, <em>C</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.LAPACK.ormqr!" title="Permalink to this definition"></a></dt>
<dd><p>Computes <code class="docutils literal"><span class="pre">Q</span> <span class="pre">*</span> <span class="pre">C</span></code> (<code class="docutils literal"><span class="pre">trans</span> <span class="pre">=</span> <span class="pre">N</span></code>), <code class="docutils literal"><span class="pre">Q.'</span> <span class="pre">*</span> <span class="pre">C</span></code> (<code class="docutils literal"><span class="pre">trans</span> <span class="pre">=</span> <span class="pre">T</span></code>), <code class="docutils literal"><span class="pre">Q'</span> <span class="pre">*</span> <span class="pre">C</span></code> (<code class="docutils literal"><span class="pre">trans</span> <span class="pre">=</span> <span class="pre">C</span></code>) for <code class="docutils literal"><span class="pre">side</span> <span class="pre">=</span> <span class="pre">L</span></code> or the equivalent right-sided multiplication for <code class="docutils literal"><span class="pre">side</span> <span class="pre">=</span> <span class="pre">R</span></code> using <code class="docutils literal"><span class="pre">Q</span></code> from a <code class="docutils literal"><span class="pre">QR</span></code> factorization of <code class="docutils literal"><span class="pre">A</span></code> computed using <code class="docutils literal"><span class="pre">geqrf!</span></code>. <code class="docutils literal"><span class="pre">C</span></code> is overwritten.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.ormql!">
<code class="descname">ormql!</code><span class="sig-paren">(</span><em>side</em>, <em>trans</em>, <em>A</em>, <em>tau</em>, <em>C</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.LAPACK.ormql!" title="Permalink to this definition"></a></dt>
<dd><p>Computes <code class="docutils literal"><span class="pre">Q</span> <span class="pre">*</span> <span class="pre">C</span></code> (<code class="docutils literal"><span class="pre">trans</span> <span class="pre">=</span> <span class="pre">N</span></code>), <code class="docutils literal"><span class="pre">Q.'</span> <span class="pre">*</span> <span class="pre">C</span></code> (<code class="docutils literal"><span class="pre">trans</span> <span class="pre">=</span> <span class="pre">T</span></code>), <code class="docutils literal"><span class="pre">Q'</span> <span class="pre">*</span> <span class="pre">C</span></code> (<code class="docutils literal"><span class="pre">trans</span> <span class="pre">=</span> <span class="pre">C</span></code>) for <code class="docutils literal"><span class="pre">side</span> <span class="pre">=</span> <span class="pre">L</span></code> or the equivalent right-sided multiplication for <code class="docutils literal"><span class="pre">side</span> <span class="pre">=</span> <span class="pre">R</span></code> using <code class="docutils literal"><span class="pre">Q</span></code> from a <code class="docutils literal"><span class="pre">QL</span></code> factorization of <code class="docutils literal"><span class="pre">A</span></code> computed using <code class="docutils literal"><span class="pre">geqlf!</span></code>. <code class="docutils literal"><span class="pre">C</span></code> is overwritten.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.ormrq!">
<code class="descname">ormrq!</code><span class="sig-paren">(</span><em>side</em>, <em>trans</em>, <em>A</em>, <em>tau</em>, <em>C</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.LAPACK.ormrq!" title="Permalink to this definition"></a></dt>
<dd><p>Computes <code class="docutils literal"><span class="pre">Q</span> <span class="pre">*</span> <span class="pre">C</span></code> (<code class="docutils literal"><span class="pre">trans</span> <span class="pre">=</span> <span class="pre">N</span></code>), <code class="docutils literal"><span class="pre">Q.'</span> <span class="pre">*</span> <span class="pre">C</span></code> (<code class="docutils literal"><span class="pre">trans</span> <span class="pre">=</span> <span class="pre">T</span></code>), <code class="docutils literal"><span class="pre">Q'</span> <span class="pre">*</span> <span class="pre">C</span></code> (<code class="docutils literal"><span class="pre">trans</span> <span class="pre">=</span> <span class="pre">C</span></code>) for <code class="docutils literal"><span class="pre">side</span> <span class="pre">=</span> <span class="pre">L</span></code> or the equivalent right-sided multiplication for <code class="docutils literal"><span class="pre">side</span> <span class="pre">=</span> <span class="pre">R</span></code> using <code class="docutils literal"><span class="pre">Q</span></code> from a <code class="docutils literal"><span class="pre">RQ</span></code> factorization of <code class="docutils literal"><span class="pre">A</span></code> computed using <code class="docutils literal"><span class="pre">gerqf!</span></code>. <code class="docutils literal"><span class="pre">C</span></code> is overwritten.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.gemqrt!">
<code class="descname">gemqrt!</code><span class="sig-paren">(</span><em>side</em>, <em>trans</em>, <em>V</em>, <em>T</em>, <em>C</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.LAPACK.gemqrt!" title="Permalink to this definition"></a></dt>
<dd><p>Computes <code class="docutils literal"><span class="pre">Q</span> <span class="pre">*</span> <span class="pre">C</span></code> (<code class="docutils literal"><span class="pre">trans</span> <span class="pre">=</span> <span class="pre">N</span></code>), <code class="docutils literal"><span class="pre">Q.'</span> <span class="pre">*</span> <span class="pre">C</span></code> (<code class="docutils literal"><span class="pre">trans</span> <span class="pre">=</span> <span class="pre">T</span></code>), <code class="docutils literal"><span class="pre">Q'</span> <span class="pre">*</span> <span class="pre">C</span></code> (<code class="docutils literal"><span class="pre">trans</span> <span class="pre">=</span> <span class="pre">C</span></code>) for <code class="docutils literal"><span class="pre">side</span> <span class="pre">=</span> <span class="pre">L</span></code> or the equivalent right-sided multiplication for <code class="docutils literal"><span class="pre">side</span> <span class="pre">=</span> <span class="pre">R</span></code> using <code class="docutils literal"><span class="pre">Q</span></code> from a <code class="docutils literal"><span class="pre">QR</span></code> factorization of <code class="docutils literal"><span class="pre">A</span></code> computed using <code class="docutils literal"><span class="pre">geqrt!</span></code>. <code class="docutils literal"><span class="pre">C</span></code> is overwritten.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.posv!">
<code class="descname">posv!</code><span class="sig-paren">(</span><em>uplo</em>, <em>A</em>, <em>B</em><span class="sig-paren">)</span> &rarr; (A, B)<a class="headerlink" href="#Base.LinAlg.LAPACK.posv!" title="Permalink to this definition"></a></dt>
<dd><p>Finds the solution to <code class="docutils literal"><span class="pre">A</span> <span class="pre">*</span> <span class="pre">X</span> <span class="pre">=</span> <span class="pre">B</span></code> where <code class="docutils literal"><span class="pre">A</span></code> is a symmetric or Hermitian positive definite matrix. If <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">U</span></code> the upper Cholesky decomposition of <code class="docutils literal"><span class="pre">A</span></code> is computed. If <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">L</span></code> the lower Cholesky decomposition of <code class="docutils literal"><span class="pre">A</span></code> is computed. <code class="docutils literal"><span class="pre">A</span></code> is overwritten by its Cholesky decomposition. <code class="docutils literal"><span class="pre">B</span></code> is overwritten with the solution <code class="docutils literal"><span class="pre">X</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.potrf!">
<code class="descname">potrf!</code><span class="sig-paren">(</span><em>uplo</em>, <em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.LAPACK.potrf!" title="Permalink to this definition"></a></dt>
<dd><p>Computes the Cholesky (upper if <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">U</span></code>, lower if <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">L</span></code>) decomposition of positive-definite matrix <code class="docutils literal"><span class="pre">A</span></code>. <code class="docutils literal"><span class="pre">A</span></code> is overwritten and returned with an info code.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.potri!">
<code class="descname">potri!</code><span class="sig-paren">(</span><em>uplo</em>, <em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.LAPACK.potri!" title="Permalink to this definition"></a></dt>
<dd><p>Computes the inverse of positive-definite matrix <code class="docutils literal"><span class="pre">A</span></code> after calling <code class="docutils literal"><span class="pre">potrf!</span></code> to find its (upper if <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">U</span></code>, lower if <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">L</span></code>) Cholesky decomposition.</p>
<p><code class="docutils literal"><span class="pre">A</span></code> is overwritten by its inverse and returned.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.potrs!">
<code class="descname">potrs!</code><span class="sig-paren">(</span><em>uplo</em>, <em>A</em>, <em>B</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.LAPACK.potrs!" title="Permalink to this definition"></a></dt>
<dd><p>Finds the solution to <code class="docutils literal"><span class="pre">A</span> <span class="pre">*</span> <span class="pre">X</span> <span class="pre">=</span> <span class="pre">B</span></code> where <code class="docutils literal"><span class="pre">A</span></code> is a symmetric or Hermitian positive definite matrix whose Cholesky decomposition was computed by <code class="docutils literal"><span class="pre">potrf!</span></code>. If <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">U</span></code> the upper Cholesky decomposition of <code class="docutils literal"><span class="pre">A</span></code> was computed. If <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">L</span></code> the lower Cholesky decomposition of <code class="docutils literal"><span class="pre">A</span></code> was computed. <code class="docutils literal"><span class="pre">B</span></code> is overwritten with the solution <code class="docutils literal"><span class="pre">X</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.pstrf!">
<code class="descname">pstrf!</code><span class="sig-paren">(</span><em>uplo</em>, <em>A</em>, <em>tol</em><span class="sig-paren">)</span> &rarr; (A, piv, rank, info)<a class="headerlink" href="#Base.LinAlg.LAPACK.pstrf!" title="Permalink to this definition"></a></dt>
<dd><p>Computes the (upper if <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">U</span></code>, lower if <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">L</span></code>) pivoted Cholesky decomposition of positive-definite matrix <code class="docutils literal"><span class="pre">A</span></code> with a user-set tolerance <code class="docutils literal"><span class="pre">tol</span></code>. <code class="docutils literal"><span class="pre">A</span></code> is overwritten by its Cholesky decomposition.</p>
<p>Returns <code class="docutils literal"><span class="pre">A</span></code>, the pivots <code class="docutils literal"><span class="pre">piv</span></code>, the rank of <code class="docutils literal"><span class="pre">A</span></code>, and an <code class="docutils literal"><span class="pre">info</span></code> code. If <code class="docutils literal"><span class="pre">info</span> <span class="pre">=</span> <span class="pre">0</span></code>, the factorization succeeded. If <code class="docutils literal"><span class="pre">info</span> <span class="pre">=</span> <span class="pre">i</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>, then <code class="docutils literal"><span class="pre">A</span></code> is indefinite or rank-deficient.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.ptsv!">
<code class="descname">ptsv!</code><span class="sig-paren">(</span><em>D</em>, <em>E</em>, <em>B</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.LAPACK.ptsv!" title="Permalink to this definition"></a></dt>
<dd><p>Solves <code class="docutils literal"><span class="pre">A</span> <span class="pre">*</span> <span class="pre">X</span> <span class="pre">=</span> <span class="pre">B</span></code> for positive-definite tridiagonal <code class="docutils literal"><span class="pre">A</span></code>. <code class="docutils literal"><span class="pre">D</span></code> is the diagonal of <code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">E</span></code> is the off-diagonal. <code class="docutils literal"><span class="pre">B</span></code> is overwritten with the solution <code class="docutils literal"><span class="pre">X</span></code> and returned.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.pttrf!">
<code class="descname">pttrf!</code><span class="sig-paren">(</span><em>D</em>, <em>E</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.LAPACK.pttrf!" title="Permalink to this definition"></a></dt>
<dd><p>Computes the LDLt factorization of a positive-definite tridiagonal matrix with <code class="docutils literal"><span class="pre">D</span></code> as diagonal and <code class="docutils literal"><span class="pre">E</span></code> as off-diagonal. <code class="docutils literal"><span class="pre">D</span></code> and <code class="docutils literal"><span class="pre">E</span></code> are overwritten and returned.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.pttrs!">
<code class="descname">pttrs!</code><span class="sig-paren">(</span><em>D</em>, <em>E</em>, <em>B</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.LAPACK.pttrs!" title="Permalink to this definition"></a></dt>
<dd><p>Solves <code class="docutils literal"><span class="pre">A</span> <span class="pre">*</span> <span class="pre">X</span> <span class="pre">=</span> <span class="pre">B</span></code> for positive-definite tridiagonal <code class="docutils literal"><span class="pre">A</span></code> with diagonal <code class="docutils literal"><span class="pre">D</span></code> and off-diagonal <code class="docutils literal"><span class="pre">E</span></code> after computing <code class="docutils literal"><span class="pre">A</span></code>&#8216;s LDLt factorization using <code class="docutils literal"><span class="pre">pttrf!</span></code>. <code class="docutils literal"><span class="pre">B</span></code> is overwritten with the solution <code class="docutils literal"><span class="pre">X</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.trtri!">
<code class="descname">trtri!</code><span class="sig-paren">(</span><em>uplo</em>, <em>diag</em>, <em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.LAPACK.trtri!" title="Permalink to this definition"></a></dt>
<dd><p>Finds the inverse of (upper if <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">U</span></code>, lower if <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">L</span></code>) triangular matrix <code class="docutils literal"><span class="pre">A</span></code>. If <code class="docutils literal"><span class="pre">diag</span> <span class="pre">=</span> <span class="pre">N</span></code>, <code class="docutils literal"><span class="pre">A</span></code> has non-unit diagonal elements. If <code class="docutils literal"><span class="pre">diag</span> <span class="pre">=</span> <span class="pre">U</span></code>, all diagonal elements of <code class="docutils literal"><span class="pre">A</span></code> are one. <code class="docutils literal"><span class="pre">A</span></code> is overwritten with its inverse.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.trtrs!">
<code class="descname">trtrs!</code><span class="sig-paren">(</span><em>uplo</em>, <em>trans</em>, <em>diag</em>, <em>A</em>, <em>B</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.LAPACK.trtrs!" title="Permalink to this definition"></a></dt>
<dd><p>Solves <code class="docutils literal"><span class="pre">A</span> <span class="pre">*</span> <span class="pre">X</span> <span class="pre">=</span> <span class="pre">B</span></code> (<code class="docutils literal"><span class="pre">trans</span> <span class="pre">=</span> <span class="pre">N</span></code>), <code class="docutils literal"><span class="pre">A.'</span> <span class="pre">*</span> <span class="pre">X</span> <span class="pre">=</span> <span class="pre">B</span></code> (<code class="docutils literal"><span class="pre">trans</span> <span class="pre">=</span> <span class="pre">T</span></code>), or <code class="docutils literal"><span class="pre">A'</span> <span class="pre">*</span> <span class="pre">X</span> <span class="pre">=</span> <span class="pre">B</span></code> (<code class="docutils literal"><span class="pre">trans</span> <span class="pre">=</span> <span class="pre">C</span></code>) for (upper if <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">U</span></code>, lower if <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">L</span></code>) triangular matrix <code class="docutils literal"><span class="pre">A</span></code>. If <code class="docutils literal"><span class="pre">diag</span> <span class="pre">=</span> <span class="pre">N</span></code>, <code class="docutils literal"><span class="pre">A</span></code> has non-unit diagonal elements. If <code class="docutils literal"><span class="pre">diag</span> <span class="pre">=</span> <span class="pre">U</span></code>, all diagonal elements of <code class="docutils literal"><span class="pre">A</span></code> are one. <code class="docutils literal"><span class="pre">B</span></code> is overwritten with the solution <code class="docutils literal"><span class="pre">X</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.trcon!">
<code class="descname">trcon!</code><span class="sig-paren">(</span><em>norm</em>, <em>uplo</em>, <em>diag</em>, <em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.LAPACK.trcon!" title="Permalink to this definition"></a></dt>
<dd><p>Finds the reciprocal condition number of (upper if <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">U</span></code>, lower if <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">L</span></code>) triangular matrix <code class="docutils literal"><span class="pre">A</span></code>. If <code class="docutils literal"><span class="pre">diag</span> <span class="pre">=</span> <span class="pre">N</span></code>, <code class="docutils literal"><span class="pre">A</span></code> has non-unit diagonal elements. If <code class="docutils literal"><span class="pre">diag</span> <span class="pre">=</span> <span class="pre">U</span></code>, all diagonal elements of <code class="docutils literal"><span class="pre">A</span></code> are one. If <code class="docutils literal"><span class="pre">norm</span> <span class="pre">=</span> <span class="pre">I</span></code>, the condition number is found in the infinity norm. If <code class="docutils literal"><span class="pre">norm</span> <span class="pre">=</span> <span class="pre">O</span></code> or <code class="docutils literal"><span class="pre">1</span></code>, the condition number is found in the one norm.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.trevc!">
<code class="descname">trevc!</code><span class="sig-paren">(</span><em>side</em>, <em>howmny</em>, <em>select</em>, <em>T</em>, <em>VL = similar(T)</em>, <em>VR = similar(T)</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.LAPACK.trevc!" title="Permalink to this definition"></a></dt>
<dd><p>Finds the eigensystem of an upper triangular matrix <code class="docutils literal"><span class="pre">T</span></code>. If <code class="docutils literal"><span class="pre">side</span> <span class="pre">=</span> <span class="pre">R</span></code>, the right eigenvectors are computed. If <code class="docutils literal"><span class="pre">side</span> <span class="pre">=</span> <span class="pre">L</span></code>, the left eigenvectors are computed. If <code class="docutils literal"><span class="pre">side</span> <span class="pre">=</span> <span class="pre">B</span></code>, both sets are computed. If <code class="docutils literal"><span class="pre">howmny</span> <span class="pre">=</span> <span class="pre">A</span></code>, all eigenvectors are found. If <code class="docutils literal"><span class="pre">howmny</span> <span class="pre">=</span> <span class="pre">B</span></code>, all eigenvectors are found and backtransformed using <code class="docutils literal"><span class="pre">VL</span></code> and <code class="docutils literal"><span class="pre">VR</span></code>. If <code class="docutils literal"><span class="pre">howmny</span> <span class="pre">=</span> <span class="pre">S</span></code>, only the eigenvectors corresponding to the values in <code class="docutils literal"><span class="pre">select</span></code> are computed.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.trrfs!">
<code class="descname">trrfs!</code><span class="sig-paren">(</span><em>uplo</em>, <em>trans</em>, <em>diag</em>, <em>A</em>, <em>B</em>, <em>X</em>, <em>Ferr</em>, <em>Berr</em><span class="sig-paren">)</span> &rarr; (Ferr, Berr)<a class="headerlink" href="#Base.LinAlg.LAPACK.trrfs!" title="Permalink to this definition"></a></dt>
<dd><p>Estimates the error in the solution to <code class="docutils literal"><span class="pre">A</span> <span class="pre">*</span> <span class="pre">X</span> <span class="pre">=</span> <span class="pre">B</span></code> (<code class="docutils literal"><span class="pre">trans</span> <span class="pre">=</span> <span class="pre">N</span></code>), <code class="docutils literal"><span class="pre">A.'</span> <span class="pre">*</span> <span class="pre">X</span> <span class="pre">=</span> <span class="pre">B</span></code> (<code class="docutils literal"><span class="pre">trans</span> <span class="pre">=</span> <span class="pre">T</span></code>), <code class="docutils literal"><span class="pre">A'</span> <span class="pre">*</span> <span class="pre">X</span> <span class="pre">=</span> <span class="pre">B</span></code> (<code class="docutils literal"><span class="pre">trans</span> <span class="pre">=</span> <span class="pre">C</span></code>) for <code class="docutils literal"><span class="pre">side</span> <span class="pre">=</span> <span class="pre">L</span></code>, or the equivalent equations a right-handed <code class="docutils literal"><span class="pre">side</span> <span class="pre">=</span> <span class="pre">R</span></code> <code class="docutils literal"><span class="pre">X</span> <span class="pre">*</span> <span class="pre">A</span></code> after computing <code class="docutils literal"><span class="pre">X</span></code> using <code class="docutils literal"><span class="pre">trtrs!</span></code>. If <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">U</span></code>, <code class="docutils literal"><span class="pre">A</span></code> is upper triangular. If <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">L</span></code>, <code class="docutils literal"><span class="pre">A</span></code> is lower triangular. If <code class="docutils literal"><span class="pre">diag</span> <span class="pre">=</span> <span class="pre">N</span></code>, <code class="docutils literal"><span class="pre">A</span></code> has non-unit diagonal elements. If <code class="docutils literal"><span class="pre">diag</span> <span class="pre">=</span> <span class="pre">U</span></code>, all diagonal elements of <code class="docutils literal"><span class="pre">A</span></code> are one. <code class="docutils literal"><span class="pre">Ferr</span></code> and <code class="docutils literal"><span class="pre">Berr</span></code> are optional inputs. <code class="docutils literal"><span class="pre">Ferr</span></code> is the forward error and <code class="docutils literal"><span class="pre">Berr</span></code> is the backward error, each component-wise.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.stev!">
<code class="descname">stev!</code><span class="sig-paren">(</span><em>job</em>, <em>dv</em>, <em>ev</em><span class="sig-paren">)</span> &rarr; (dv, Zmat)<a class="headerlink" href="#Base.LinAlg.LAPACK.stev!" title="Permalink to this definition"></a></dt>
<dd><p>Computes the eigensystem for a symmetric tridiagonal matrix with <code class="docutils literal"><span class="pre">dv</span></code> as diagonal and <code class="docutils literal"><span class="pre">ev</span></code> as off-diagonal. If <code class="docutils literal"><span class="pre">job</span> <span class="pre">=</span> <span class="pre">N</span></code> only the eigenvalues are found and returned in <code class="docutils literal"><span class="pre">dv</span></code>. If <code class="docutils literal"><span class="pre">job</span> <span class="pre">=</span> <span class="pre">V</span></code> then the eigenvectors are also found and returned in <code class="docutils literal"><span class="pre">Zmat</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.stebz!">
<code class="descname">stebz!</code><span class="sig-paren">(</span><em>range</em>, <em>order</em>, <em>vl</em>, <em>vu</em>, <em>il</em>, <em>iu</em>, <em>abstol</em>, <em>dv</em>, <em>ev</em><span class="sig-paren">)</span> &rarr; (dv, iblock, isplit)<a class="headerlink" href="#Base.LinAlg.LAPACK.stebz!" title="Permalink to this definition"></a></dt>
<dd><p>Computes the eigenvalues for a symmetric tridiagonal matrix with <code class="docutils literal"><span class="pre">dv</span></code> as diagonal and <code class="docutils literal"><span class="pre">ev</span></code> as off-diagonal. If <code class="docutils literal"><span class="pre">range</span> <span class="pre">=</span> <span class="pre">A</span></code>, all the eigenvalues are found. If <code class="docutils literal"><span class="pre">range</span> <span class="pre">=</span> <span class="pre">V</span></code>, the eigenvalues in the half-open interval <code class="docutils literal"><span class="pre">(vl,</span> <span class="pre">vu]</span></code> are found. If <code class="docutils literal"><span class="pre">range</span> <span class="pre">=</span> <span class="pre">I</span></code>, the eigenvalues with indices between <code class="docutils literal"><span class="pre">il</span></code> and <code class="docutils literal"><span class="pre">iu</span></code> are found. If <code class="docutils literal"><span class="pre">order</span> <span class="pre">=</span> <span class="pre">B</span></code>, eigvalues are ordered within a block. If <code class="docutils literal"><span class="pre">order</span> <span class="pre">=</span> <span class="pre">E</span></code>, they are ordered across all the blocks. <code class="docutils literal"><span class="pre">abstol</span></code> can be set as a tolerance for convergence.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.stegr!">
<code class="descname">stegr!</code><span class="sig-paren">(</span><em>jobz</em>, <em>range</em>, <em>dv</em>, <em>ev</em>, <em>vl</em>, <em>vu</em>, <em>il</em>, <em>iu</em><span class="sig-paren">)</span> &rarr; (w, Z)<a class="headerlink" href="#Base.LinAlg.LAPACK.stegr!" title="Permalink to this definition"></a></dt>
<dd><p>Computes the eigenvalues (<code class="docutils literal"><span class="pre">jobz</span> <span class="pre">=</span> <span class="pre">N</span></code>) or eigenvalues and eigenvectors (<code class="docutils literal"><span class="pre">jobz</span> <span class="pre">=</span> <span class="pre">V</span></code>) for a symmetric tridiagonal matrix with <code class="docutils literal"><span class="pre">dv</span></code> as diagonal and <code class="docutils literal"><span class="pre">ev</span></code> as off-diagonal. If <code class="docutils literal"><span class="pre">range</span> <span class="pre">=</span> <span class="pre">A</span></code>, all the eigenvalues are found. If <code class="docutils literal"><span class="pre">range</span> <span class="pre">=</span> <span class="pre">V</span></code>, the eigenvalues in the half-open interval <code class="docutils literal"><span class="pre">(vl,</span> <span class="pre">vu]</span></code> are found. If <code class="docutils literal"><span class="pre">range</span> <span class="pre">=</span> <span class="pre">I</span></code>, the eigenvalues with indices between <code class="docutils literal"><span class="pre">il</span></code> and <code class="docutils literal"><span class="pre">iu</span></code> are found. The eigenvalues are returned in <code class="docutils literal"><span class="pre">w</span></code> and the eigenvectors in <code class="docutils literal"><span class="pre">Z</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.stein!">
<code class="descname">stein!</code><span class="sig-paren">(</span><em>dv</em>, <em>ev_in</em>, <em>w_in</em>, <em>iblock_in</em>, <em>isplit_in</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.LAPACK.stein!" title="Permalink to this definition"></a></dt>
<dd><p>Computes the eigenvectors for a symmetric tridiagonal matrix with <code class="docutils literal"><span class="pre">dv</span></code> as diagonal and <code class="docutils literal"><span class="pre">ev_in</span></code> as off-diagonal. <code class="docutils literal"><span class="pre">w_in</span></code> specifies the input eigenvalues for which to find corresponding eigenvectors. <code class="docutils literal"><span class="pre">iblock_in</span></code> specifies the submatrices corresponding to the eigenvalues in <code class="docutils literal"><span class="pre">w_in</span></code>. <code class="docutils literal"><span class="pre">isplit_in</span></code> specifies the splitting points between the submatrix blocks.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.syconv!">
<code class="descname">syconv!</code><span class="sig-paren">(</span><em>uplo</em>, <em>A</em>, <em>ipiv</em><span class="sig-paren">)</span> &rarr; (A, work)<a class="headerlink" href="#Base.LinAlg.LAPACK.syconv!" title="Permalink to this definition"></a></dt>
<dd><p>Converts a symmetric matrix <code class="docutils literal"><span class="pre">A</span></code> (which has been factorized into a triangular matrix) into two matrices <code class="docutils literal"><span class="pre">L</span></code> and <code class="docutils literal"><span class="pre">D</span></code>. If <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">U</span></code>, <code class="docutils literal"><span class="pre">A</span></code> is upper triangular. If <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">L</span></code>, it is lower triangular. <code class="docutils literal"><span class="pre">ipiv</span></code> is the pivot vector from the triangular factorization. <code class="docutils literal"><span class="pre">A</span></code> is overwritten by <code class="docutils literal"><span class="pre">L</span></code> and <code class="docutils literal"><span class="pre">D</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.sysv!">
<code class="descname">sysv!</code><span class="sig-paren">(</span><em>uplo</em>, <em>A</em>, <em>B</em><span class="sig-paren">)</span> &rarr; (B, A, ipiv)<a class="headerlink" href="#Base.LinAlg.LAPACK.sysv!" title="Permalink to this definition"></a></dt>
<dd><p>Finds the solution to <code class="docutils literal"><span class="pre">A</span> <span class="pre">*</span> <span class="pre">X</span> <span class="pre">=</span> <span class="pre">B</span></code> for symmetric matrix <code class="docutils literal"><span class="pre">A</span></code>. If <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">U</span></code>, the upper half of <code class="docutils literal"><span class="pre">A</span></code> is stored. If <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">L</span></code>, the lower half is stored. <code class="docutils literal"><span class="pre">B</span></code> is overwritten by the solution <code class="docutils literal"><span class="pre">X</span></code>. <code class="docutils literal"><span class="pre">A</span></code> is overwritten by its Bunch-Kaufman factorization. <code class="docutils literal"><span class="pre">ipiv</span></code> contains pivoting information about the factorization.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.sytrf!">
<code class="descname">sytrf!</code><span class="sig-paren">(</span><em>uplo</em>, <em>A</em><span class="sig-paren">)</span> &rarr; (A, ipiv, info)<a class="headerlink" href="#Base.LinAlg.LAPACK.sytrf!" title="Permalink to this definition"></a></dt>
<dd><p>Computes the Bunch-Kaufman factorization of a symmetric matrix <code class="docutils literal"><span class="pre">A</span></code>. If <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">U</span></code>, the upper half of <code class="docutils literal"><span class="pre">A</span></code> is stored. If <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">L</span></code>, the lower half is stored.</p>
<p>Returns <code class="docutils literal"><span class="pre">A</span></code>, overwritten by the factorization, a pivot vector <code class="docutils literal"><span class="pre">ipiv</span></code>, and the error code <code class="docutils literal"><span class="pre">info</span></code> which is a non-negative integer. If <code class="docutils literal"><span class="pre">info</span></code> is positive the matrix is singular and the diagonal part of the factorization is exactly zero at position <code class="docutils literal"><span class="pre">info</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.sytri!">
<code class="descname">sytri!</code><span class="sig-paren">(</span><em>uplo</em>, <em>A</em>, <em>ipiv</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.LAPACK.sytri!" title="Permalink to this definition"></a></dt>
<dd><p>Computes the inverse of a symmetric matrix <code class="docutils literal"><span class="pre">A</span></code> using the results of <code class="docutils literal"><span class="pre">sytrf!</span></code>. If <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">U</span></code>, the upper half of <code class="docutils literal"><span class="pre">A</span></code> is stored. If <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">L</span></code>, the lower half is stored. <code class="docutils literal"><span class="pre">A</span></code> is overwritten by its inverse.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.sytrs!">
<code class="descname">sytrs!</code><span class="sig-paren">(</span><em>uplo</em>, <em>A</em>, <em>ipiv</em>, <em>B</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.LAPACK.sytrs!" title="Permalink to this definition"></a></dt>
<dd><p>Solves the equation <code class="docutils literal"><span class="pre">A</span> <span class="pre">*</span> <span class="pre">X</span> <span class="pre">=</span> <span class="pre">B</span></code> for a symmetric matrix <code class="docutils literal"><span class="pre">A</span></code> using the results of <code class="docutils literal"><span class="pre">sytrf!</span></code>. If <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">U</span></code>, the upper half of <code class="docutils literal"><span class="pre">A</span></code> is stored. If <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">L</span></code>, the lower half is stored. <code class="docutils literal"><span class="pre">B</span></code> is overwritten by the solution <code class="docutils literal"><span class="pre">X</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.hesv!">
<code class="descname">hesv!</code><span class="sig-paren">(</span><em>uplo</em>, <em>A</em>, <em>B</em><span class="sig-paren">)</span> &rarr; (B, A, ipiv)<a class="headerlink" href="#Base.LinAlg.LAPACK.hesv!" title="Permalink to this definition"></a></dt>
<dd><p>Finds the solution to <code class="docutils literal"><span class="pre">A</span> <span class="pre">*</span> <span class="pre">X</span> <span class="pre">=</span> <span class="pre">B</span></code> for Hermitian matrix <code class="docutils literal"><span class="pre">A</span></code>. If <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">U</span></code>, the upper half of <code class="docutils literal"><span class="pre">A</span></code> is stored. If <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">L</span></code>, the lower half is stored. <code class="docutils literal"><span class="pre">B</span></code> is overwritten by the solution <code class="docutils literal"><span class="pre">X</span></code>. <code class="docutils literal"><span class="pre">A</span></code> is overwritten by its Bunch-Kaufman factorization. <code class="docutils literal"><span class="pre">ipiv</span></code> contains pivoting information about the factorization.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.hetrf!">
<code class="descname">hetrf!</code><span class="sig-paren">(</span><em>uplo</em>, <em>A</em><span class="sig-paren">)</span> &rarr; (A, ipiv, info)<a class="headerlink" href="#Base.LinAlg.LAPACK.hetrf!" title="Permalink to this definition"></a></dt>
<dd><p>Computes the Bunch-Kaufman factorization of a Hermitian matrix <code class="docutils literal"><span class="pre">A</span></code>. If <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">U</span></code>, the upper half of <code class="docutils literal"><span class="pre">A</span></code> is stored. If <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">L</span></code>, the lower half is stored.</p>
<p>Returns <code class="docutils literal"><span class="pre">A</span></code>, overwritten by the factorization, a pivot vector <code class="docutils literal"><span class="pre">ipiv</span></code>, and the error code <code class="docutils literal"><span class="pre">info</span></code> which is a non-negative integer. If <code class="docutils literal"><span class="pre">info</span></code> is positive the matrix is singular and the diagonal part of the factorization is exactly zero at position <code class="docutils literal"><span class="pre">info</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.hetri!">
<code class="descname">hetri!</code><span class="sig-paren">(</span><em>uplo</em>, <em>A</em>, <em>ipiv</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.LAPACK.hetri!" title="Permalink to this definition"></a></dt>
<dd><p>Computes the inverse of a Hermitian matrix <code class="docutils literal"><span class="pre">A</span></code> using the results of <code class="docutils literal"><span class="pre">sytrf!</span></code>. If <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">U</span></code>, the upper half of <code class="docutils literal"><span class="pre">A</span></code> is stored. If <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">L</span></code>, the lower half is stored. <code class="docutils literal"><span class="pre">A</span></code> is overwritten by its inverse.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.hetrs!">
<code class="descname">hetrs!</code><span class="sig-paren">(</span><em>uplo</em>, <em>A</em>, <em>ipiv</em>, <em>B</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.LAPACK.hetrs!" title="Permalink to this definition"></a></dt>
<dd><p>Solves the equation <code class="docutils literal"><span class="pre">A</span> <span class="pre">*</span> <span class="pre">X</span> <span class="pre">=</span> <span class="pre">B</span></code> for a Hermitian matrix <code class="docutils literal"><span class="pre">A</span></code> using the results of <code class="docutils literal"><span class="pre">sytrf!</span></code>. If <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">U</span></code>, the upper half of <code class="docutils literal"><span class="pre">A</span></code> is stored. If <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">L</span></code>, the lower half is stored. <code class="docutils literal"><span class="pre">B</span></code> is overwritten by the solution <code class="docutils literal"><span class="pre">X</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.syev!">
<code class="descname">syev!</code><span class="sig-paren">(</span><em>jobz</em>, <em>uplo</em>, <em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.LAPACK.syev!" title="Permalink to this definition"></a></dt>
<dd><p>Finds the eigenvalues (<code class="docutils literal"><span class="pre">jobz</span> <span class="pre">=</span> <span class="pre">N</span></code>) or eigenvalues and eigenvectors (<code class="docutils literal"><span class="pre">jobz</span> <span class="pre">=</span> <span class="pre">V</span></code>) of a symmetric matrix <code class="docutils literal"><span class="pre">A</span></code>. If <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">U</span></code>, the upper triangle of <code class="docutils literal"><span class="pre">A</span></code> is used. If <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">L</span></code>, the lower triangle of <code class="docutils literal"><span class="pre">A</span></code> is used.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.syevr!">
<code class="descname">syevr!</code><span class="sig-paren">(</span><em>jobz</em>, <em>range</em>, <em>uplo</em>, <em>A</em>, <em>vl</em>, <em>vu</em>, <em>il</em>, <em>iu</em>, <em>abstol</em><span class="sig-paren">)</span> &rarr; (W, Z)<a class="headerlink" href="#Base.LinAlg.LAPACK.syevr!" title="Permalink to this definition"></a></dt>
<dd><p>Finds the eigenvalues (<code class="docutils literal"><span class="pre">jobz</span> <span class="pre">=</span> <span class="pre">N</span></code>) or eigenvalues and eigenvectors (<code class="docutils literal"><span class="pre">jobz</span> <span class="pre">=</span> <span class="pre">V</span></code>) of a symmetric matrix <code class="docutils literal"><span class="pre">A</span></code>. If <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">U</span></code>, the upper triangle of <code class="docutils literal"><span class="pre">A</span></code> is used. If <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">L</span></code>, the lower triangle of <code class="docutils literal"><span class="pre">A</span></code> is used. If <code class="docutils literal"><span class="pre">range</span> <span class="pre">=</span> <span class="pre">A</span></code>, all the eigenvalues are found. If <code class="docutils literal"><span class="pre">range</span> <span class="pre">=</span> <span class="pre">V</span></code>, the eigenvalues in the half-open interval <code class="docutils literal"><span class="pre">(vl,</span> <span class="pre">vu]</span></code> are found. If <code class="docutils literal"><span class="pre">range</span> <span class="pre">=</span> <span class="pre">I</span></code>, the eigenvalues with indices between <code class="docutils literal"><span class="pre">il</span></code> and <code class="docutils literal"><span class="pre">iu</span></code> are found. <code class="docutils literal"><span class="pre">abstol</span></code> can be set as a tolerance for convergence.</p>
<p>The eigenvalues are returned in <code class="docutils literal"><span class="pre">W</span></code> and the eigenvectors in <code class="docutils literal"><span class="pre">Z</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.sygvd!">
<code class="descname">sygvd!</code><span class="sig-paren">(</span><em>jobz</em>, <em>range</em>, <em>uplo</em>, <em>A</em>, <em>vl</em>, <em>vu</em>, <em>il</em>, <em>iu</em>, <em>abstol</em><span class="sig-paren">)</span> &rarr; (w, A, B)<a class="headerlink" href="#Base.LinAlg.LAPACK.sygvd!" title="Permalink to this definition"></a></dt>
<dd><p>Finds the generalized eigenvalues (<code class="docutils literal"><span class="pre">jobz</span> <span class="pre">=</span> <span class="pre">N</span></code>) or eigenvalues and eigenvectors (<code class="docutils literal"><span class="pre">jobz</span> <span class="pre">=</span> <span class="pre">V</span></code>) of a symmetric matrix <code class="docutils literal"><span class="pre">A</span></code> and symmetric positive-definite matrix <code class="docutils literal"><span class="pre">B</span></code>. If <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">U</span></code>, the upper triangles of <code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">B</span></code> are used. If <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">L</span></code>, the lower triangles of <code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">B</span></code> are used. If <code class="docutils literal"><span class="pre">itype</span> <span class="pre">=</span> <span class="pre">1</span></code>, the problem to solve is <code class="docutils literal"><span class="pre">A</span> <span class="pre">*</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">lambda</span> <span class="pre">*</span> <span class="pre">B</span> <span class="pre">*</span> <span class="pre">x</span></code>. If <code class="docutils literal"><span class="pre">itype</span> <span class="pre">=</span> <span class="pre">2</span></code>, the problem to solve is <code class="docutils literal"><span class="pre">A</span> <span class="pre">*</span> <span class="pre">B</span> <span class="pre">*</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">lambda</span> <span class="pre">*</span> <span class="pre">x</span></code>. If <code class="docutils literal"><span class="pre">itype</span> <span class="pre">=</span> <span class="pre">3</span></code>, the problem to solve is <code class="docutils literal"><span class="pre">B</span> <span class="pre">*</span> <span class="pre">A</span> <span class="pre">*</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">lambda</span> <span class="pre">*</span> <span class="pre">x</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.bdsqr!">
<code class="descname">bdsqr!</code><span class="sig-paren">(</span><em>uplo</em>, <em>d</em>, <em>e_</em>, <em>Vt</em>, <em>U</em>, <em>C</em><span class="sig-paren">)</span> &rarr; (d, Vt, U, C)<a class="headerlink" href="#Base.LinAlg.LAPACK.bdsqr!" title="Permalink to this definition"></a></dt>
<dd><p>Computes the singular value decomposition of a bidiagonal matrix with <code class="docutils literal"><span class="pre">d</span></code> on the diagonal and <code class="docutils literal"><span class="pre">e_</span></code> on the off-diagonal. If <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">U</span></code>, <code class="docutils literal"><span class="pre">e_</span></code> is the superdiagonal. If <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">L</span></code>, <code class="docutils literal"><span class="pre">e_</span></code> is the subdiagonal. Can optionally also compute the product <code class="docutils literal"><span class="pre">Q'</span> <span class="pre">*</span> <span class="pre">C</span></code>.</p>
<p>Returns the singular values in <code class="docutils literal"><span class="pre">d</span></code>, and the matrix <code class="docutils literal"><span class="pre">C</span></code> overwritten with <code class="docutils literal"><span class="pre">Q'</span> <span class="pre">*</span> <span class="pre">C</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.bdsdc!">
<code class="descname">bdsdc!</code><span class="sig-paren">(</span><em>uplo</em>, <em>compq</em>, <em>d</em>, <em>e_</em><span class="sig-paren">)</span> &rarr; (d, e, u, vt, q, iq)<a class="headerlink" href="#Base.LinAlg.LAPACK.bdsdc!" title="Permalink to this definition"></a></dt>
<dd><p>Computes the singular value decomposition of a bidiagonal matrix with <code class="docutils literal"><span class="pre">d</span></code> on the diagonal and <code class="docutils literal"><span class="pre">e_</span></code> on the off-diagonal using a divide and conqueq method. If <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">U</span></code>, <code class="docutils literal"><span class="pre">e_</span></code> is the superdiagonal. If <code class="docutils literal"><span class="pre">uplo</span> <span class="pre">=</span> <span class="pre">L</span></code>, <code class="docutils literal"><span class="pre">e_</span></code> is the subdiagonal. If <code class="docutils literal"><span class="pre">compq</span> <span class="pre">=</span> <span class="pre">N</span></code>, only the singular values are found. If <code class="docutils literal"><span class="pre">compq</span> <span class="pre">=</span> <span class="pre">I</span></code>, the singular values and vectors are found. If <code class="docutils literal"><span class="pre">compq</span> <span class="pre">=</span> <span class="pre">P</span></code>, the singular values and vectors are found in compact form. Only works for real types.</p>
<p>Returns the singular values in <code class="docutils literal"><span class="pre">d</span></code>, and if <code class="docutils literal"><span class="pre">compq</span> <span class="pre">=</span> <span class="pre">P</span></code>, the compact singular vectors in <code class="docutils literal"><span class="pre">iq</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.gecon!">
<code class="descname">gecon!</code><span class="sig-paren">(</span><em>normtype</em>, <em>A</em>, <em>anorm</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.LAPACK.gecon!" title="Permalink to this definition"></a></dt>
<dd><p>Finds the reciprocal condition number of matrix <code class="docutils literal"><span class="pre">A</span></code>. If <code class="docutils literal"><span class="pre">normtype</span> <span class="pre">=</span> <span class="pre">I</span></code>, the condition number is found in the infinity norm. If <code class="docutils literal"><span class="pre">normtype</span> <span class="pre">=</span> <span class="pre">O</span></code> or <code class="docutils literal"><span class="pre">1</span></code>, the condition number is found in the one norm. <code class="docutils literal"><span class="pre">A</span></code> must be the result of <code class="docutils literal"><span class="pre">getrf!</span></code> and <code class="docutils literal"><span class="pre">anorm</span></code> is the norm of <code class="docutils literal"><span class="pre">A</span></code> in the relevant norm.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.gehrd!">
<code class="descname">gehrd!</code><span class="sig-paren">(</span><em>ilo</em>, <em>ihi</em>, <em>A</em><span class="sig-paren">)</span> &rarr; (A, tau)<a class="headerlink" href="#Base.LinAlg.LAPACK.gehrd!" title="Permalink to this definition"></a></dt>
<dd><p>Converts a matrix <code class="docutils literal"><span class="pre">A</span></code> to Hessenberg form. If <code class="docutils literal"><span class="pre">A</span></code> is balanced with <code class="docutils literal"><span class="pre">gebal!</span></code> then <code class="docutils literal"><span class="pre">ilo</span></code> and <code class="docutils literal"><span class="pre">ihi</span></code> are the outputs of <code class="docutils literal"><span class="pre">gebal!</span></code>. Otherwise they should be <code class="docutils literal"><span class="pre">ilo</span> <span class="pre">=</span> <span class="pre">1</span></code> and <code class="docutils literal"><span class="pre">ihi</span> <span class="pre">=</span> <span class="pre">size(A,2)</span></code>. <code class="docutils literal"><span class="pre">tau</span></code> contains the elementary reflectors of the factorization.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.orghr!">
<code class="descname">orghr!</code><span class="sig-paren">(</span><em>ilo</em>, <em>ihi</em>, <em>A</em>, <em>tau</em><span class="sig-paren">)</span><a class="headerlink" href="#Base.LinAlg.LAPACK.orghr!" title="Permalink to this definition"></a></dt>
<dd><p>Explicitly finds <code class="docutils literal"><span class="pre">Q</span></code>, the orthogonal/unitary matrix from <code class="docutils literal"><span class="pre">gehrd!</span></code>. <code class="docutils literal"><span class="pre">ilo</span></code>, <code class="docutils literal"><span class="pre">ihi</span></code>, <code class="docutils literal"><span class="pre">A</span></code>, and <code class="docutils literal"><span class="pre">tau</span></code> must correspond to the input/output to <code class="docutils literal"><span class="pre">gehrd!</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.gees!">
<code class="descname">gees!</code><span class="sig-paren">(</span><em>jobvs</em>, <em>A</em><span class="sig-paren">)</span> &rarr; (A, vs, w)<a class="headerlink" href="#Base.LinAlg.LAPACK.gees!" title="Permalink to this definition"></a></dt>
<dd><p>Computes the eigenvalues (<code class="docutils literal"><span class="pre">jobvs</span> <span class="pre">=</span> <span class="pre">N</span></code>) or the eigenvalues and Schur vectors (<code class="docutils literal"><span class="pre">jobvs</span> <span class="pre">=</span> <span class="pre">V</span></code>) of matrix <code class="docutils literal"><span class="pre">A</span></code>. <code class="docutils literal"><span class="pre">A</span></code> is overwritten by its Schur form.</p>
<p>Returns <code class="docutils literal"><span class="pre">A</span></code>, <code class="docutils literal"><span class="pre">vs</span></code> containing the Schur vectors, and <code class="docutils literal"><span class="pre">w</span></code>, containing the eigenvalues.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.gges!">
<code class="descname">gges!</code><span class="sig-paren">(</span><em>jobvsl</em>, <em>jobvsr</em>, <em>A</em>, <em>B</em><span class="sig-paren">)</span> &rarr; (A, B, alpha, beta, vsl, vsr)<a class="headerlink" href="#Base.LinAlg.LAPACK.gges!" title="Permalink to this definition"></a></dt>
<dd><p>Computes the generalized eigenvalues, generalized Schur form, left Schur vectors (<code class="docutils literal"><span class="pre">jobsvl</span> <span class="pre">=</span> <span class="pre">V</span></code>), or right Schur vectors (<code class="docutils literal"><span class="pre">jobvsr</span> <span class="pre">=</span> <span class="pre">V</span></code>) of <code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">B</span></code>.</p>
<p>The generalized eigenvalues are returned in <code class="docutils literal"><span class="pre">alpha</span></code> and <code class="docutils literal"><span class="pre">beta</span></code>. The left Schur vectors are returned in <code class="docutils literal"><span class="pre">vsl</span></code> and the right Schur vectors are returned in <code class="docutils literal"><span class="pre">vsr</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.trexc!">
<code class="descname">trexc!</code><span class="sig-paren">(</span><em>compq</em>, <em>ifst</em>, <em>ilst</em>, <em>T</em>, <em>Q</em><span class="sig-paren">)</span> &rarr; (T, Q)<a class="headerlink" href="#Base.LinAlg.LAPACK.trexc!" title="Permalink to this definition"></a></dt>
<dd><p>Reorder the Schur factorization of a matrix. If <code class="docutils literal"><span class="pre">compq</span> <span class="pre">=</span> <span class="pre">V</span></code>, the Schur vectors <code class="docutils literal"><span class="pre">Q</span></code> are reordered. If <code class="docutils literal"><span class="pre">compq</span> <span class="pre">=</span> <span class="pre">N</span></code> they are not modified. <code class="docutils literal"><span class="pre">ifst</span></code> and <code class="docutils literal"><span class="pre">ilst</span></code> specify the reordering of the vectors.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.trsen!">
<code class="descname">trsen!</code><span class="sig-paren">(</span><em>compq</em>, <em>job</em>, <em>select</em>, <em>T</em>, <em>Q</em><span class="sig-paren">)</span> &rarr; (T, Q, w)<a class="headerlink" href="#Base.LinAlg.LAPACK.trsen!" title="Permalink to this definition"></a></dt>
<dd><p>Reorder the Schur factorization of a matrix and optionally finds reciprocal condition numbers. If <code class="docutils literal"><span class="pre">job</span> <span class="pre">=</span> <span class="pre">N</span></code>, no condition numbers are found. If <code class="docutils literal"><span class="pre">job</span> <span class="pre">=</span> <span class="pre">E</span></code>, only the condition number for this cluster of eigenvalues is found. If <code class="docutils literal"><span class="pre">job</span> <span class="pre">=</span> <span class="pre">V</span></code>, only the condition number for the invariant subspace is found. If <code class="docutils literal"><span class="pre">job</span> <span class="pre">=</span> <span class="pre">B</span></code> then the condition numbers for the cluster and subspace are found. If <code class="docutils literal"><span class="pre">compq</span> <span class="pre">=</span> <span class="pre">V</span></code> the Schur vectors <code class="docutils literal"><span class="pre">Q</span></code> are updated. If <code class="docutils literal"><span class="pre">compq</span> <span class="pre">=</span> <span class="pre">N</span></code> the Schur vectors are not modified. <code class="docutils literal"><span class="pre">select</span></code> determines which eigenvalues are in the cluster.</p>
<p>Returns <code class="docutils literal"><span class="pre">T</span></code>, <code class="docutils literal"><span class="pre">Q</span></code>, and reordered eigenvalues in <code class="docutils literal"><span class="pre">w</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.tgsen!">
<code class="descname">tgsen!</code><span class="sig-paren">(</span><em>select</em>, <em>S</em>, <em>T</em>, <em>Q</em>, <em>Z</em><span class="sig-paren">)</span> &rarr; (S, T, alpha, beta, Q, Z)<a class="headerlink" href="#Base.LinAlg.LAPACK.tgsen!" title="Permalink to this definition"></a></dt>
<dd><p>Reorders the vectors of a generalized Schur decomposition. <code class="docutils literal"><span class="pre">select</span></code> specifices the eigenvalues in each cluster.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.LAPACK.trsyl!">
<code class="descname">trsyl!</code><span class="sig-paren">(</span><em>transa</em>, <em>transb</em>, <em>A</em>, <em>B</em>, <em>C</em>, <em>isgn=1</em><span class="sig-paren">)</span> &rarr; (C, scale)<a class="headerlink" href="#Base.LinAlg.LAPACK.trsyl!" title="Permalink to this definition"></a></dt>
<dd><p>Solves the Sylvester matrix equation <code class="docutils literal"><span class="pre">A</span> <span class="pre">*</span> <span class="pre">X</span> <span class="pre">+/-</span> <span class="pre">X</span> <span class="pre">*</span> <span class="pre">B</span> <span class="pre">=</span> <span class="pre">scale*C</span></code> where <code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">B</span></code> are both quasi-upper triangular. If <code class="docutils literal"><span class="pre">transa</span> <span class="pre">=</span> <span class="pre">N</span></code>, <code class="docutils literal"><span class="pre">A</span></code> is not modified. If <code class="docutils literal"><span class="pre">transa</span> <span class="pre">=</span> <span class="pre">T</span></code>, <code class="docutils literal"><span class="pre">A</span></code> is transposed. If <code class="docutils literal"><span class="pre">transa</span> <span class="pre">=</span> <span class="pre">C</span></code>, <code class="docutils literal"><span class="pre">A</span></code> is conjugate transposed. Similarly for <code class="docutils literal"><span class="pre">transb</span></code> and <code class="docutils literal"><span class="pre">B</span></code>. If <code class="docutils literal"><span class="pre">isgn</span> <span class="pre">=</span> <span class="pre">1</span></code>, the equation <code class="docutils literal"><span class="pre">A</span> <span class="pre">*</span> <span class="pre">X</span> <span class="pre">+</span> <span class="pre">X</span> <span class="pre">*</span> <span class="pre">B</span> <span class="pre">=</span> <span class="pre">scale</span> <span class="pre">*</span> <span class="pre">C</span></code> is solved. If <code class="docutils literal"><span class="pre">isgn</span> <span class="pre">=</span> <span class="pre">-1</span></code>, the equation <code class="docutils literal"><span class="pre">A</span> <span class="pre">*</span> <span class="pre">X</span> <span class="pre">-</span> <span class="pre">X</span> <span class="pre">*</span> <span class="pre">B</span> <span class="pre">=</span> <span class="pre">scale</span> <span class="pre">*</span> <span class="pre">C</span></code> is solved.</p>
<p>Returns <code class="docutils literal"><span class="pre">X</span></code> (overwriting <code class="docutils literal"><span class="pre">C</span></code>) and <code class="docutils literal"><span class="pre">scale</span></code>.</p>
</dd></dl>

</div>
</div>


          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../constants/" class="btn btn-neutral float-right" title="Constants">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../parallel/" class="btn btn-neutral" title="Tasks and Parallel Computing"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
    </p>
  </div>

  <a href="https://github.com/snide/sphinx_rtd_theme">Sphinx theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>
</footer>
        </div>
      </div>

    </section>

  </div>
  

  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'0.5.1-pre',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>