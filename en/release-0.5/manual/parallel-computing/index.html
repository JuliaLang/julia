

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Parallel Computing &mdash; Julia Language 0.5.3-pre documentation</title>
  

  
  

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/julia.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../../_static/julia.css" type="text/css" />
  
    <link rel="top" title="Julia Language 0.5.3-pre documentation" href="../../"/>
        <link rel="next" title="Date and DateTime" href="../dates/"/>
        <link rel="prev" title="Networking and Streams" href="../networking-and-streams/"/> 

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        <a href="http://julialang.org/"><img src="../../_static/julia-logo.svg" class="logo"></a>
        <!--
        <a href="../../" class="fa fa-home"> Julia Language</a>
        -->
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search/" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
        
            <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../introduction/">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../getting-started/">Getting Started</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../getting-started/#resources">Resources</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../variables/">Variables</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../variables/#allowed-variable-names">Allowed Variable Names</a></li>
<li class="toctree-l2"><a class="reference internal" href="../variables/#stylistic-conventions">Stylistic Conventions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../integers-and-floating-point-numbers/">Integers and Floating-Point Numbers</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../integers-and-floating-point-numbers/#integers">Integers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../integers-and-floating-point-numbers/#floating-point-numbers">Floating-Point Numbers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../integers-and-floating-point-numbers/#arbitrary-precision-arithmetic">Arbitrary Precision Arithmetic</a></li>
<li class="toctree-l2"><a class="reference internal" href="../integers-and-floating-point-numbers/#numeric-literal-coefficients">Numeric Literal Coefficients</a></li>
<li class="toctree-l2"><a class="reference internal" href="../integers-and-floating-point-numbers/#literal-zero-and-one">Literal zero and one</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../mathematical-operations/">Mathematical Operations and Elementary Functions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../mathematical-operations/#arithmetic-operators">Arithmetic Operators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical-operations/#bitwise-operators">Bitwise Operators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical-operations/#updating-operators">Updating operators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical-operations/#numeric-comparisons">Numeric Comparisons</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical-operations/#numerical-conversions">Numerical Conversions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../complex-and-rational-numbers/">Complex and Rational Numbers</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../complex-and-rational-numbers/#complex-numbers">Complex Numbers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../complex-and-rational-numbers/#rational-numbers">Rational Numbers</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../strings/">Strings</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../strings/#characters">Characters</a></li>
<li class="toctree-l2"><a class="reference internal" href="../strings/#string-basics">String Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../strings/#unicode-and-utf-8">Unicode and UTF-8</a></li>
<li class="toctree-l2"><a class="reference internal" href="../strings/#interpolation">Interpolation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../strings/#triple-quoted-string-literals">Triple-Quoted String Literals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../strings/#common-operations">Common Operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../strings/#non-standard-string-literals">Non-Standard String Literals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../strings/#regular-expressions">Regular Expressions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../strings/#id2">Byte Array Literals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../strings/#version-number-literals">Version Number Literals</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../functions/">Functions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../functions/#argument-passing-behavior">Argument Passing Behavior</a></li>
<li class="toctree-l2"><a class="reference internal" href="../functions/#the-return-keyword">The <code class="docutils literal"><span class="pre">return</span></code> Keyword</a></li>
<li class="toctree-l2"><a class="reference internal" href="../functions/#operators-are-functions">Operators Are Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../functions/#operators-with-special-names">Operators With Special Names</a></li>
<li class="toctree-l2"><a class="reference internal" href="../functions/#anonymous-functions">Anonymous Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../functions/#multiple-return-values">Multiple Return Values</a></li>
<li class="toctree-l2"><a class="reference internal" href="../functions/#varargs-functions">Varargs Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../functions/#optional-arguments">Optional Arguments</a></li>
<li class="toctree-l2"><a class="reference internal" href="../functions/#keyword-arguments">Keyword Arguments</a></li>
<li class="toctree-l2"><a class="reference internal" href="../functions/#evaluation-scope-of-default-values">Evaluation Scope of Default Values</a></li>
<li class="toctree-l2"><a class="reference internal" href="../functions/#do-block-syntax-for-function-arguments">Do-Block Syntax for Function Arguments</a></li>
<li class="toctree-l2"><a class="reference internal" href="../functions/#dot-syntax-for-vectorizing-functions">Dot Syntax for Vectorizing Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../functions/#further-reading">Further Reading</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../control-flow/">Control Flow</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../control-flow/#compound-expressions">Compound Expressions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../control-flow/#conditional-evaluation">Conditional Evaluation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../control-flow/#short-circuit-evaluation">Short-Circuit Evaluation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../control-flow/#repeated-evaluation-loops">Repeated Evaluation: Loops</a></li>
<li class="toctree-l2"><a class="reference internal" href="../control-flow/#exception-handling">Exception Handling</a></li>
<li class="toctree-l2"><a class="reference internal" href="../control-flow/#tasks-aka-coroutines">Tasks (aka Coroutines)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../variables-and-scoping/">Scope of Variables</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../variables-and-scoping/#global-scope">Global Scope</a></li>
<li class="toctree-l2"><a class="reference internal" href="../variables-and-scoping/#local-scope">Local Scope</a></li>
<li class="toctree-l2"><a class="reference internal" href="../variables-and-scoping/#constants">Constants</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../types/">Types</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../types/#type-declarations">Type Declarations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../types/#abstract-types">Abstract Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../types/#bits-types">Bits Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../types/#composite-types">Composite Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../types/#immutable-composite-types">Immutable Composite Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../types/#declared-types">Declared Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../types/#type-unions">Type Unions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../types/#man-parametric-types">Parametric Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../types/#type-aliases">Type Aliases</a></li>
<li class="toctree-l2"><a class="reference internal" href="../types/#operations-on-types">Operations on Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../types/#custom-pretty-printing">Custom pretty-printing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../types/#value-types">&#8220;Value types&#8221;</a></li>
<li class="toctree-l2"><a class="reference internal" href="../types/#nullable-types-representing-missing-values">Nullable Types: Representing Missing Values</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../methods/">Methods</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../methods/#defining-methods">Defining Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="../methods/#method-ambiguities">Method Ambiguities</a></li>
<li class="toctree-l2"><a class="reference internal" href="../methods/#parametric-methods">Parametric Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="../methods/#parametrically-constrained-varargs-methods">Parametrically-constrained Varargs methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="../methods/#note-on-optional-and-keyword-arguments">Note on Optional and keyword Arguments</a></li>
<li class="toctree-l2"><a class="reference internal" href="../methods/#function-like-objects">Function-like objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="../methods/#empty-generic-functions">Empty generic functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../constructors/">Constructors</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../constructors/#outer-constructor-methods">Outer Constructor Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="../constructors/#inner-constructor-methods">Inner Constructor Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="../constructors/#incomplete-initialization">Incomplete Initialization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../constructors/#parametric-constructors">Parametric Constructors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../constructors/#case-study-rational">Case Study: Rational</a></li>
<li class="toctree-l2"><a class="reference internal" href="../constructors/#constructors-and-conversion">Constructors and Conversion</a></li>
<li class="toctree-l2"><a class="reference internal" href="../constructors/#outer-only-constructors">Outer-only constructors</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../conversion-and-promotion/">Conversion and Promotion</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../conversion-and-promotion/#conversion">Conversion</a></li>
<li class="toctree-l2"><a class="reference internal" href="../conversion-and-promotion/#promotion">Promotion</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../interfaces/">Interfaces</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../interfaces/#iteration">Iteration</a></li>
<li class="toctree-l2"><a class="reference internal" href="../interfaces/#indexing">Indexing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../interfaces/#abstract-arrays">Abstract Arrays</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../modules/">Modules</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../modules/#summary-of-module-usage">Summary of module usage</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../documentation/">Documentation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../documentation/#accessing-documentation">Accessing Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../documentation/#functions-methods">Functions &amp; Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="../documentation/#advanced-usage">Advanced Usage</a></li>
<li class="toctree-l2"><a class="reference internal" href="../documentation/#syntax-guide">Syntax Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../documentation/#markdown-syntax">Markdown syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="../documentation/#markdown-syntax-extensions">Markdown Syntax Extensions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../metaprogramming/">Metaprogramming</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../metaprogramming/#program-representation">Program representation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../metaprogramming/#expressions-and-evaluation">Expressions and evaluation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../metaprogramming/#macros">Macros</a></li>
<li class="toctree-l2"><a class="reference internal" href="../metaprogramming/#code-generation">Code Generation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../metaprogramming/#non-standard-string-literals">Non-Standard String Literals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../metaprogramming/#generated-functions">Generated functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../arrays/">Multi-dimensional Arrays</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../arrays/#arrays">Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="../arrays/#sparse-matrices">Sparse Matrices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../linear-algebra/">Linear algebra</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../linear-algebra/#matrix-factorizations">Matrix factorizations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../linear-algebra/#special-matrices">Special matrices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../networking-and-streams/">Networking and Streams</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../networking-and-streams/#basic-stream-i-o">Basic Stream I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../networking-and-streams/#text-i-o">Text I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../networking-and-streams/#io-output-contextual-properties">IO Output Contextual Properties</a></li>
<li class="toctree-l2"><a class="reference internal" href="../networking-and-streams/#working-with-files">Working with Files</a></li>
<li class="toctree-l2"><a class="reference internal" href="../networking-and-streams/#a-simple-tcp-example">A simple TCP example</a></li>
<li class="toctree-l2"><a class="reference internal" href="../networking-and-streams/#resolving-ip-addresses">Resolving IP Addresses</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Parallel Computing</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#code-availability-and-loading-packages">Code Availability and Loading Packages</a></li>
<li class="toctree-l2"><a class="reference internal" href="#data-movement">Data Movement</a></li>
<li class="toctree-l2"><a class="reference internal" href="#parallel-map-and-loops">Parallel Map and Loops</a></li>
<li class="toctree-l2"><a class="reference internal" href="#synchronization-with-remote-references">Synchronization With Remote References</a></li>
<li class="toctree-l2"><a class="reference internal" href="#scheduling">Scheduling</a></li>
<li class="toctree-l2"><a class="reference internal" href="#channels">Channels</a></li>
<li class="toctree-l2"><a class="reference internal" href="#remote-references-and-abstractchannels">Remote references and AbstractChannels</a></li>
<li class="toctree-l2"><a class="reference internal" href="#remote-references-and-distributed-garbage-collection">Remote References and Distributed Garbage Collection</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id2">Shared Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="#shared-arrays-and-distributed-garbage-collection">Shared Arrays and Distributed Garbage Collection</a></li>
<li class="toctree-l2"><a class="reference internal" href="#clustermanagers">ClusterManagers</a></li>
<li class="toctree-l2"><a class="reference internal" href="#cluster-managers-with-custom-transports">Cluster Managers with custom transports</a></li>
<li class="toctree-l2"><a class="reference internal" href="#network-requirements-for-localmanager-and-sshmanager">Network requirements for LocalManager and SSHManager</a></li>
<li class="toctree-l2"><a class="reference internal" href="#cluster-cookie">Cluster cookie</a></li>
<li class="toctree-l2"><a class="reference internal" href="#specifying-network-topology-experimental">Specifying network topology (Experimental)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#multi-threading-experimental">Multi-threading (Experimental)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#threadcall-experimental">&#64;threadcall (Experimental)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../dates/">Date and DateTime</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../dates/#constructors">Constructors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dates/#durations-comparisons">Durations/Comparisons</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dates/#accessor-functions">Accessor Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dates/#query-functions">Query Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dates/#timetype-period-arithmetic">TimeType-Period Arithmetic</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dates/#adjuster-functions">Adjuster Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dates/#period-types">Period Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dates/#rounding">Rounding</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../running-external-programs/">Running External Programs</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../running-external-programs/#interpolation">Interpolation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../running-external-programs/#quoting">Quoting</a></li>
<li class="toctree-l2"><a class="reference internal" href="../running-external-programs/#pipelines">Pipelines</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../calling-c-and-fortran-code/">Calling C and Fortran Code</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../calling-c-and-fortran-code/#creating-c-compatible-julia-function-pointers">Creating C-Compatible Julia Function Pointers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../calling-c-and-fortran-code/#mapping-c-types-to-julia">Mapping C Types to Julia</a></li>
<li class="toctree-l2"><a class="reference internal" href="../calling-c-and-fortran-code/#mapping-c-functions-to-julia">Mapping C Functions to Julia</a></li>
<li class="toctree-l2"><a class="reference internal" href="../calling-c-and-fortran-code/#some-examples-of-c-wrappers">Some Examples of C Wrappers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../calling-c-and-fortran-code/#garbage-collection-safety">Garbage Collection Safety</a></li>
<li class="toctree-l2"><a class="reference internal" href="../calling-c-and-fortran-code/#non-constant-function-specifications">Non-constant Function Specifications</a></li>
<li class="toctree-l2"><a class="reference internal" href="../calling-c-and-fortran-code/#indirect-calls">Indirect Calls</a></li>
<li class="toctree-l2"><a class="reference internal" href="../calling-c-and-fortran-code/#calling-convention">Calling Convention</a></li>
<li class="toctree-l2"><a class="reference internal" href="../calling-c-and-fortran-code/#accessing-global-variables">Accessing Global Variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="../calling-c-and-fortran-code/#accessing-data-through-a-pointer">Accessing Data through a Pointer</a></li>
<li class="toctree-l2"><a class="reference internal" href="../calling-c-and-fortran-code/#thread-safety">Thread-safety</a></li>
<li class="toctree-l2"><a class="reference internal" href="../calling-c-and-fortran-code/#more-about-callbacks">More About Callbacks</a></li>
<li class="toctree-l2"><a class="reference internal" href="../calling-c-and-fortran-code/#c">C++</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../handling-operating-system-variation/">Handling Operating System Variation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../interacting-with-julia/">Interacting With Julia</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../interacting-with-julia/#the-different-prompt-modes">The different prompt modes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../interacting-with-julia/#key-bindings">Key bindings</a></li>
<li class="toctree-l2"><a class="reference internal" href="../interacting-with-julia/#tab-completion">Tab completion</a></li>
<li class="toctree-l2"><a class="reference internal" href="../interacting-with-julia/#customizing-colors">Customizing Colors</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../embedding/">Embedding Julia</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../embedding/#high-level-embedding">High-Level Embedding</a></li>
<li class="toctree-l2"><a class="reference internal" href="../embedding/#converting-types">Converting Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../embedding/#calling-julia-functions">Calling Julia Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../embedding/#memory-management">Memory Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="../embedding/#working-with-arrays">Working with Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="../embedding/#exceptions">Exceptions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../packages/">Packages</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../packages/#package-status">Package Status</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/#adding-and-removing-packages">Adding and Removing Packages</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/#offline-installation-of-packages">Offline Installation of Packages</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/#installing-unregistered-packages">Installing Unregistered Packages</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/#updating-packages">Updating Packages</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/#checkout-pin-and-free">Checkout, Pin and Free</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/#custom-metadata-repository">Custom METADATA Repository</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../packages/#package-development">Package Development</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../packages/#initial-setup">Initial Setup</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/#making-changes-to-an-existing-package">Making changes to an existing package</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/#creating-a-new-package">Creating a new Package</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/#fixing-package-requirements">Fixing Package Requirements</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/#man-package-requirements">Requirements Specification</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../profile/">Profiling</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../profile/#basic-usage">Basic usage</a></li>
<li class="toctree-l2"><a class="reference internal" href="../profile/#accumulation-and-clearing">Accumulation and clearing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../profile/#options-for-controlling-the-display-of-profile-results">Options for controlling the display of profile results</a></li>
<li class="toctree-l2"><a class="reference internal" href="../profile/#configuration">Configuration</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../profile/#memory-allocation-analysis">Memory allocation analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../stacktraces/">Stack Traces</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../stacktraces/#viewing-a-stack-trace">Viewing a stack trace</a></li>
<li class="toctree-l2"><a class="reference internal" href="../stacktraces/#extracting-useful-information">Extracting useful information</a></li>
<li class="toctree-l2"><a class="reference internal" href="../stacktraces/#error-handling">Error handling</a></li>
<li class="toctree-l2"><a class="reference internal" href="../stacktraces/#comparison-with-backtrace">Comparison with <code class="docutils literal"><span class="pre">backtrace()</span></code></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../performance-tips/">Performance Tips</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../performance-tips/#avoid-global-variables">Avoid global variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="../performance-tips/#measure-performance-with-time-and-pay-attention-to-memory-allocation">Measure performance with <code class="docutils literal"><span class="pre">&#64;time</span></code> and pay attention to memory allocation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../performance-tips/#tools">Tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="../performance-tips/#avoid-containers-with-abstract-type-parameters">Avoid containers with abstract type parameters</a></li>
<li class="toctree-l2"><a class="reference internal" href="../performance-tips/#type-declarations">Type declarations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../performance-tips/#break-functions-into-multiple-definitions">Break functions into multiple definitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../performance-tips/#write-type-stable-functions">Write &#8220;type-stable&#8221; functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../performance-tips/#avoid-changing-the-type-of-a-variable">Avoid changing the type of a variable</a></li>
<li class="toctree-l2"><a class="reference internal" href="../performance-tips/#separate-kernel-functions-aka-function-barriers">Separate kernel functions (aka, function barriers)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../performance-tips/#types-with-values-as-parameters">Types with values-as-parameters</a></li>
<li class="toctree-l2"><a class="reference internal" href="../performance-tips/#the-dangers-of-abusing-multiple-dispatch-aka-more-on-types-with-values-as-parameters">The dangers of abusing multiple dispatch (aka, more on types with values-as-parameters)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../performance-tips/#access-arrays-in-memory-order-along-columns">Access arrays in memory order, along columns</a></li>
<li class="toctree-l2"><a class="reference internal" href="../performance-tips/#pre-allocating-outputs">Pre-allocating outputs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../performance-tips/#avoid-string-interpolation-for-i-o">Avoid string interpolation for I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../performance-tips/#optimize-network-i-o-during-parallel-execution">Optimize network I/O during parallel execution</a></li>
<li class="toctree-l2"><a class="reference internal" href="../performance-tips/#fix-deprecation-warnings">Fix deprecation warnings</a></li>
<li class="toctree-l2"><a class="reference internal" href="../performance-tips/#tweaks">Tweaks</a></li>
<li class="toctree-l2"><a class="reference internal" href="../performance-tips/#performance-annotations">Performance Annotations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../performance-tips/#treat-subnormal-numbers-as-zeros">Treat Subnormal Numbers as Zeros</a></li>
<li class="toctree-l2"><a class="reference internal" href="../performance-tips/#code-warntype"><code class="docutils literal"><span class="pre">&#64;code_warntype</span></code></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../workflow-tips/">Workflow Tips</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../workflow-tips/#repl-based-workflow">REPL-based workflow</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflow-tips/#browser-based-workflow">Browser-based workflow</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../style-guide/">Style Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#write-functions-not-just-scripts">Write functions, not just scripts</a></li>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#avoid-writing-overly-specific-types">Avoid writing overly-specific types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#handle-excess-argument-diversity-in-the-caller">Handle excess argument diversity in the caller</a></li>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#append-to-names-of-functions-that-modify-their-arguments">Append <code class="docutils literal"><span class="pre">!</span></code> to names of functions that modify their arguments</a></li>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#avoid-strange-type-unions">Avoid strange type Unions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#avoid-type-unions-in-fields">Avoid type Unions in fields</a></li>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#avoid-elaborate-container-types">Avoid elaborate container types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#use-naming-conventions-consistent-with-julia-s-base">Use naming conventions consistent with Julia&#8217;s <code class="docutils literal"><span class="pre">base/</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#don-t-overuse-try-catch">Don&#8217;t overuse try-catch</a></li>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#don-t-parenthesize-conditions">Don&#8217;t parenthesize conditions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#don-t-overuse">Don&#8217;t overuse ...</a></li>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#don-t-use-unnecessary-static-parameters">Don&#8217;t use unnecessary static parameters</a></li>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#avoid-confusion-about-whether-something-is-an-instance-or-a-type">Avoid confusion about whether something is an instance or a type</a></li>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#don-t-overuse-macros">Don&#8217;t overuse macros</a></li>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#don-t-expose-unsafe-operations-at-the-interface-level">Don&#8217;t expose unsafe operations at the interface level</a></li>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#don-t-overload-methods-of-base-container-types">Don&#8217;t overload methods of base container types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#be-careful-with-type-equality">Be careful with type equality</a></li>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#do-not-write-x-f-x">Do not write <code class="docutils literal"><span class="pre">x-&gt;f(x)</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#avoid-using-floats-for-numeric-literals-in-generic-code-when-possible">Avoid using floats for numeric literals in generic code when possible</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../faq/">Frequently Asked Questions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../faq/#sessions-and-the-repl">Sessions and the REPL</a></li>
<li class="toctree-l2"><a class="reference internal" href="../faq/#functions">Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../faq/#types-type-declarations-and-constructors">Types, type declarations, and constructors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../faq/#packages-and-modules">Packages and Modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="../faq/#nothingness-and-missing-values">Nothingness and missing values</a></li>
<li class="toctree-l2"><a class="reference internal" href="../faq/#memory">Memory</a></li>
<li class="toctree-l2"><a class="reference internal" href="../faq/#asynchronous-io-and-concurrent-synchronous-writes">Asynchronous IO and concurrent synchronous writes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../faq/#julia-releases">Julia Releases</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../noteworthy-differences/">Noteworthy Differences from other Languages</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../noteworthy-differences/#noteworthy-differences-from-matlab">Noteworthy differences from MATLAB</a></li>
<li class="toctree-l2"><a class="reference internal" href="../noteworthy-differences/#noteworthy-differences-from-r">Noteworthy differences from R</a></li>
<li class="toctree-l2"><a class="reference internal" href="../noteworthy-differences/#noteworthy-differences-from-python">Noteworthy differences from Python</a></li>
<li class="toctree-l2"><a class="reference internal" href="../noteworthy-differences/#noteworthy-differences-from-c-c">Noteworthy differences from C/C++</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../unicode-input/">Unicode Input</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/base/">Essentials</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/base/#introduction">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/base/#getting-around">Getting Around</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/base/#all-objects">All Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/base/#types">Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/base/#generic-functions">Generic Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/base/#syntax">Syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/base/#nullables">Nullables</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/base/#system">System</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/base/#errors">Errors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/base/#events">Events</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/base/#reflection">Reflection</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/base/#internals">Internals</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/collections/">Collections and Data Structures</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/collections/#iteration">Iteration</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/collections/#general-collections">General Collections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/collections/#iterable-collections">Iterable Collections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/collections/#indexable-collections">Indexable Collections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/collections/#associative-collections">Associative Collections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/collections/#set-like-collections">Set-Like Collections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/collections/#dequeues">Dequeues</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/collections/#priorityqueue">PriorityQueue</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/collections/#heap-functions">Heap Functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/math/">Mathematics</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/math/#mathematical-operators">Mathematical Operators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/math/#mathematical-functions">Mathematical Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/math/#statistics">Statistics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/math/#signal-processing">Signal Processing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/math/#numerical-integration">Numerical Integration</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/numbers/">Numbers</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/numbers/#standard-numeric-types">Standard Numeric Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/numbers/#data-formats">Data Formats</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/numbers/#general-number-functions-and-constants">General Number Functions and Constants</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/numbers/#bigfloats">BigFloats</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/numbers/#random-numbers">Random Numbers</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/strings/">Strings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/arrays/">Arrays</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/arrays/#basic-functions">Basic functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/arrays/#constructors">Constructors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/arrays/#mathematical-operators-and-functions">Mathematical operators and functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/arrays/#indexing-assignment-and-concatenation">Indexing, Assignment, and Concatenation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/arrays/#array-functions">Array functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/arrays/#combinatorics">Combinatorics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/arrays/#bitarrays">BitArrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/arrays/#sparse-vectors-and-matrices">Sparse Vectors and Matrices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/parallel/">Tasks and Parallel Computing</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/parallel/#tasks">Tasks</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/parallel/#general-parallel-computing-support">General Parallel Computing Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/parallel/#shared-arrays">Shared Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/parallel/#multi-threading">Multi-Threading</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/parallel/#ccall-using-a-threadpool-experimental">ccall using a threadpool (Experimental)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/parallel/#synchronization-primitives">Synchronization Primitives</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/parallel/#cluster-manager-interface">Cluster Manager Interface</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/linalg/">Linear Algebra</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/linalg/#module-Base.LinAlg">Standard Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/linalg/#low-level-matrix-operations">Low-level matrix operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/linalg/#module-Base.LinAlg.BLAS">BLAS Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/linalg/#module-Base.LinAlg.LAPACK">LAPACK Functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/constants/">Constants</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/file/">Filesystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/io-network/">I/O and Network</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/io-network/#general-i-o">General I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/io-network/#text-i-o">Text I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/io-network/#multimedia-i-o">Multimedia I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/io-network/#memory-mapped-i-o">Memory-mapped I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/io-network/#network-i-o">Network I/O</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/punctuation/">Punctuation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/sort/">Sorting and Related Functions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/sort/#sorting-functions">Sorting Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/sort/#order-related-functions">Order-Related Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/sort/#sorting-algorithms">Sorting Algorithms</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/pkg/">Package Manager Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/dates/">Dates and Time</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/dates/#dates-and-time-types">Dates and Time Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/dates/#dates-functions">Dates Functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/test/">Unit Testing</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/test/#testing-base-julia">Testing Base Julia</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/test/#basic-unit-tests">Basic Unit Tests</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/test/#working-with-test-sets">Working with Test Sets</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/test/#other-test-macros">Other Test Macros</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/test/#broken-tests">Broken Tests</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/test/#creating-custom-abstracttestset-types">Creating Custom <code class="docutils literal"><span class="pre">AbstractTestSet</span></code> Types</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/c/">C Interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/c/#llvm-interface">LLVM Interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/libc/">C Standard Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/libdl/">Dynamic Linker</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/profile/">Profiling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/stacktraces/">StackTraces</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/simd-types/">SIMD Support</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../devdocs/reflection/">Reflection and introspection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../devdocs/julia/">Documentation of Julia&#8217;s Internals</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/init/">Initialization of the Julia runtime</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/eval/">Eval of Julia code</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/ast/">Julia ASTs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/types/">More about types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/object/">Memory layout of Julia Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/functions/">Julia Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/callconv/">Calling Conventions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/cartesian/">Base.Cartesian</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/meta/">Talking to the compiler (the <code class="docutils literal"><span class="pre">:meta</span></code> mechanism)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/subarrays/">SubArrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/sysimg/">System Image Building</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/llvm/">Working with LLVM</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/stdio/">printf() and stdio in the Julia runtime</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/boundscheck/">Bounds checking</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/locks/">Proper maintenance and care of multi-threading locks</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/offset-arrays/">Arrays with custom indices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../devdocs/C/">Developing/debugging Julia&#8217;s C code</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/backtraces/">Reporting and analyzing crashes (segfaults)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/debuggingtips/">gdb debugging tips</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/valgrind/">Using Valgrind with Julia</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/sanitizers/">Sanitizer support</a></li>
</ul>
</li>
</ul>

        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../">Julia Language</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../">Docs</a> &raquo;</li>
      
    <li>Parallel Computing</li>
      <li class="wy-breadcrumbs-aside">
        
          <a href="../../_sources/manual/parallel-computing.txt" rel="nofollow"> View page source</a>
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document">
            
  <div class="section" id="parallel-computing">
<span id="man-parallel-computing"></span><h1>Parallel Computing<a class="headerlink" href="#parallel-computing" title="Permalink to this headline">¶</a></h1>
<p>Most modern computers possess more than one CPU, and several computers
can be combined together in a cluster. Harnessing the power of these
multiple CPUs allows many computations to be completed more quickly.
There are two major factors that influence performance: the speed of the
CPUs themselves, and the speed of their access to memory. In a cluster,
it&#8217;s fairly obvious that a given CPU will have fastest access to the RAM
within the same computer (node). Perhaps more surprisingly, similar
issues are relevant on a typical multicore laptop, due to
differences in the speed of main memory and the
<a class="reference external" href="https://www.akkadia.org/drepper/cpumemory.pdf">cache</a>. Consequently, a
good multiprocessing environment should allow control over the
&#8220;ownership&#8221; of a chunk of memory by a particular CPU. Julia provides a
multiprocessing environment based on message passing to allow programs
to run on multiple processes in separate memory domains at once.</p>
<p>Julia&#8217;s implementation of message passing is different from other
environments such as MPI <a class="footnote-reference" href="#mpi2rma" id="id1">[1]</a>. Communication in Julia is generally
&#8220;one-sided&#8221;, meaning that the programmer needs to explicitly manage only
one process in a two-process operation. Furthermore, these
operations typically do not look like &#8220;message send&#8221; and &#8220;message
receive&#8221; but rather resemble higher-level operations like calls to user
functions.</p>
<p>Parallel programming in Julia is built on two primitives: <em>remote
references</em> and <em>remote calls</em>. A remote reference is an object that can
be used from any process to refer to an object stored on a particular
process. A remote call is a request by one process to call a certain
function on certain arguments on another (possibly the same) process.</p>
<p>Remote references come in two flavors - <a class="reference internal" href="../../stdlib/parallel/#Base.Future" title="Base.Future"><code class="xref jl jl-class docutils literal"><span class="pre">Future</span></code></a> and <a class="reference internal" href="../../stdlib/parallel/#Base.RemoteChannel" title="Base.RemoteChannel"><code class="xref jl jl-class docutils literal"><span class="pre">RemoteChannel</span></code></a>.</p>
<p>A remote call returns a <a class="reference internal" href="../../stdlib/parallel/#Base.Future" title="Base.Future"><code class="xref jl jl-class docutils literal"><span class="pre">Future</span></code></a> to its result. Remote calls
return immediately; the process that made the call proceeds to its
next operation while the remote call happens somewhere else. You can
wait for a remote call to finish by calling <a class="reference internal" href="../../stdlib/parallel/#Base.wait" title="Base.wait"><code class="xref jl jl-func docutils literal"><span class="pre">wait()</span></code></a> on the returned
<a class="reference internal" href="../../stdlib/parallel/#Base.Future" title="Base.Future"><code class="xref jl jl-class docutils literal"><span class="pre">Future</span></code></a>, and you can obtain the full value of the result using
<a class="reference internal" href="../../stdlib/parallel/#Base.fetch" title="Base.fetch"><code class="xref jl jl-func docutils literal"><span class="pre">fetch()</span></code></a>.</p>
<p>On the other hand <a class="reference internal" href="../../stdlib/parallel/#Base.RemoteChannel" title="Base.RemoteChannel"><code class="xref jl jl-class docutils literal"><span class="pre">RemoteChannel</span></code></a> s are rewritable. For example, multiple processes
can co-ordinate their processing by referencing the same remote <code class="xref jl jl-class docutils literal"><span class="pre">Channel</span></code>.</p>
<p>Let&#8217;s try this out. Starting with <code class="docutils literal"><span class="pre">julia</span> <span class="pre">-p</span> <span class="pre">n</span></code> provides <code class="docutils literal"><span class="pre">n</span></code> worker
processes on the local machine. Generally it makes sense for <code class="docutils literal"><span class="pre">n</span></code> to
equal the number of CPU cores on the machine.</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="o">$</span> <span class="o">./</span><span class="n">julia</span> <span class="o">-</span><span class="n">p</span> <span class="mi">2</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">r</span> <span class="o">=</span> <span class="n">remotecall</span><span class="p">(</span><span class="n">rand</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">Future</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="kt">Nullable</span><span class="p">{</span><span class="kt">Any</span><span class="p">}())</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">s</span> <span class="o">=</span> <span class="nd">@spawnat</span> <span class="mi">2</span> <span class="mi">1</span> <span class="o">.+</span> <span class="n">fetch</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
<span class="n">Future</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="kt">Nullable</span><span class="p">{</span><span class="kt">Any</span><span class="p">}())</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">fetch</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="mi">2</span><span class="n">×2</span> <span class="kt">Array</span><span class="p">{</span><span class="kt">Float64</span><span class="p">,</span><span class="mi">2</span><span class="p">}</span><span class="o">:</span>
 <span class="mf">1.60401</span>  <span class="mf">1.50111</span>
 <span class="mf">1.17457</span>  <span class="mf">1.15741</span>
</pre></div>
</div>
<p>The first argument to <a class="reference internal" href="../../stdlib/parallel/#Base.remotecall" title="Base.remotecall"><code class="xref jl jl-func docutils literal"><span class="pre">remotecall()</span></code></a> is the function to call.
Most parallel programming in Julia does not reference specific processes
or the number of processes available, but <a class="reference internal" href="../../stdlib/parallel/#Base.remotecall" title="Base.remotecall"><code class="xref jl jl-func docutils literal"><span class="pre">remotecall()</span></code></a> is
considered a low-level interface providing finer control. The second
argument to <a class="reference internal" href="../../stdlib/parallel/#Base.remotecall" title="Base.remotecall"><code class="xref jl jl-func docutils literal"><span class="pre">remotecall()</span></code></a> is the index of the process
that will do the work, and the remaining arguments will be passed
to the function being called.</p>
<p>As you can see, in the first line we asked process 2 to
construct a 2-by-2 random matrix, and in the second line we asked it
to add 1 to it. The result of both calculations is available in the
two futures, <code class="docutils literal"><span class="pre">r</span></code> and <code class="docutils literal"><span class="pre">s</span></code>. The <a class="reference internal" href="../../stdlib/parallel/#Base.&#64;spawnat" title="Base.&#64;spawnat"><code class="xref jl jl-obj docutils literal"><span class="pre">&#64;spawnat</span></code></a> macro
evaluates the expression in the second argument on the process
specified by the first argument.</p>
<p>Occasionally you might want a remotely-computed value immediately. This
typically happens when you read from a remote object to obtain data
needed by the next local operation. The function <a class="reference internal" href="../../stdlib/parallel/#Base.remotecall_fetch" title="Base.remotecall_fetch"><code class="xref jl jl-func docutils literal"><span class="pre">remotecall_fetch()</span></code></a>
exists for this purpose. It is equivalent to <code class="docutils literal"><span class="pre">fetch(remotecall(...))</span></code>
but is more efficient.</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">remotecall_fetch</span><span class="p">(</span><span class="n">getindex</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="mf">0.10824216411304866</span>
</pre></div>
</div>
<p>Remember that <a class="reference internal" href="../../stdlib/collections/#Base.getindex" title="Base.getindex"><code class="xref jl jl-func docutils literal"><span class="pre">getindex(r,1,1)</span></code></a> is <a class="reference internal" href="../arrays/#man-array-indexing"><span class="std std-ref">equivalent</span></a> to
<code class="docutils literal"><span class="pre">r[1,1]</span></code>, so this call fetches the first element of the future <code class="docutils literal"><span class="pre">r</span></code>.</p>
<p>The syntax of <a class="reference internal" href="../../stdlib/parallel/#Base.remotecall" title="Base.remotecall"><code class="xref jl jl-func docutils literal"><span class="pre">remotecall()</span></code></a> is not especially convenient. The macro
<a class="reference internal" href="../../stdlib/parallel/#Base.&#64;spawn" title="Base.&#64;spawn"><code class="xref jl jl-obj docutils literal"><span class="pre">&#64;spawn</span></code></a> makes things easier. It operates on an expression rather than
a function, and picks where to do the operation for you:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">r</span> <span class="o">=</span> <span class="nd">@spawn</span> <span class="n">rand</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">Future</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="kt">Nullable</span><span class="p">{</span><span class="kt">Any</span><span class="p">}())</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">s</span> <span class="o">=</span> <span class="nd">@spawn</span> <span class="mi">1</span> <span class="o">.+</span> <span class="n">fetch</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
<span class="n">Future</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="kt">Nullable</span><span class="p">{</span><span class="kt">Any</span><span class="p">}())</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">fetch</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="mf">1.10824216411304866</span> <span class="mf">1.13798233877923116</span>
<span class="mf">1.12376292706355074</span> <span class="mf">1.18750497916607167</span>
</pre></div>
</div>
<p>Note that we used <code class="docutils literal"><span class="pre">1</span> <span class="pre">.+</span> <span class="pre">fetch(r)</span></code> instead of <code class="docutils literal"><span class="pre">1</span> <span class="pre">.+</span> <span class="pre">r</span></code>. This is because we
do not know where the code will run, so in general a <a class="reference internal" href="../../stdlib/parallel/#Base.fetch" title="Base.fetch"><code class="xref jl jl-func docutils literal"><span class="pre">fetch()</span></code></a> might be
required to move <code class="docutils literal"><span class="pre">r</span></code> to the process doing the addition. In this
case, <a class="reference internal" href="../../stdlib/parallel/#Base.&#64;spawn" title="Base.&#64;spawn"><code class="xref jl jl-obj docutils literal"><span class="pre">&#64;spawn</span></code></a> is smart enough to perform the computation on the
process that owns <code class="docutils literal"><span class="pre">r</span></code>, so the <a class="reference internal" href="../../stdlib/parallel/#Base.fetch" title="Base.fetch"><code class="xref jl jl-func docutils literal"><span class="pre">fetch()</span></code></a> will be a no-op (no work is done).</p>
<p>(It is worth noting that <a class="reference internal" href="../../stdlib/parallel/#Base.&#64;spawn" title="Base.&#64;spawn"><code class="xref jl jl-obj docutils literal"><span class="pre">&#64;spawn</span></code></a> is not built-in but defined in Julia
as a <a class="reference internal" href="../metaprogramming/#man-macros"><span class="std std-ref">macro</span></a>. It is possible to define your
own such constructs.)</p>
<p>An important thing to remember is that, once fetched, a <a class="reference internal" href="../../stdlib/parallel/#Base.Future" title="Base.Future"><code class="xref jl jl-class docutils literal"><span class="pre">Future</span></code></a> will cache its value
locally. Further <a class="reference internal" href="../../stdlib/parallel/#Base.fetch" title="Base.fetch"><code class="xref jl jl-func docutils literal"><span class="pre">fetch()</span></code></a> calls do not entail a network hop. Once all referencing
<a class="reference internal" href="../../stdlib/parallel/#Base.Future" title="Base.Future"><code class="xref jl jl-class docutils literal"><span class="pre">Future</span></code></a>s have fetched, the remote stored value is deleted.</p>
<div class="section" id="code-availability-and-loading-packages">
<span id="man-parallel-computing-code-availability"></span><h2>Code Availability and Loading Packages<a class="headerlink" href="#code-availability-and-loading-packages" title="Permalink to this headline">¶</a></h2>
<p>Your code must be available on any process that runs it. For example,
type the following into the Julia prompt:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="k">function</span> <span class="n">rand2</span><span class="p">(</span><span class="n">dims</span><span class="o">...</span><span class="p">)</span>
         <span class="k">return</span> <span class="mi">2</span><span class="o">*</span><span class="n">rand</span><span class="p">(</span><span class="n">dims</span><span class="o">...</span><span class="p">)</span>
       <span class="k">end</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">rand2</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="mi">2</span><span class="n">×2</span> <span class="kt">Array</span><span class="p">{</span><span class="kt">Float64</span><span class="p">,</span><span class="mi">2</span><span class="p">}</span><span class="o">:</span>
 <span class="mf">0.153756</span>  <span class="mf">0.368514</span>
 <span class="mf">1.15119</span>   <span class="mf">0.918912</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">fetch</span><span class="p">(</span><span class="nd">@spawn</span> <span class="n">rand2</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="n">ERROR</span><span class="o">:</span> <span class="n">On</span> <span class="n">worker</span> <span class="mi">2</span><span class="o">:</span>
<span class="k">function</span> <span class="n">rand2</span> <span class="n">not</span> <span class="n">defined</span> <span class="n">on</span> <span class="n">process</span> <span class="mi">2</span>
</pre></div>
</div>
<p>Process 1 knew about the function <code class="docutils literal"><span class="pre">rand2</span></code>, but process 2 did not.</p>
<p>Most commonly you&#8217;ll be loading code from files or packages, and you
have a considerable amount of flexibility in controlling which
processes load code.  Consider a file, <code class="docutils literal"><span class="pre">&quot;DummyModule.jl&quot;</span></code>, containing
the following code:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="k">module</span> <span class="n">DummyModule</span>

<span class="k">export</span> <span class="n">MyType</span><span class="p">,</span> <span class="n">f</span>

<span class="k">type</span> <span class="n">MyType</span>
    <span class="n">a</span><span class="o">::</span><span class="kt">Int</span>
<span class="k">end</span>

<span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="n">x</span><span class="o">^</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span>

<span class="n">println</span><span class="p">(</span><span class="s">&quot;loaded&quot;</span><span class="p">)</span>

<span class="k">end</span>
</pre></div>
</div>
<p>Starting Julia with <code class="docutils literal"><span class="pre">julia</span> <span class="pre">-p</span> <span class="pre">2</span></code>, you can use this to verify the following:</p>
<ul>
<li><p class="first"><a class="reference internal" href="../../stdlib/base/#Base.include" title="Base.include"><code class="xref jl jl-func docutils literal"><span class="pre">include(&quot;DummyModule.jl&quot;)</span></code></a> loads the file on just a single process (whichever one executes the statement).</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">using</span> <span class="pre">DummyModule</span></code> causes the module to be loaded on all processes; however, the module is brought into scope only on the one executing the statement.</p>
</li>
<li><p class="first">As long as <code class="docutils literal"><span class="pre">DummyModule</span></code> is loaded on process 2, commands like</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">rr</span> <span class="o">=</span> <span class="n">RemoteChannel</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">put!</span><span class="p">(</span><span class="n">rr</span><span class="p">,</span> <span class="n">MyType</span><span class="p">(</span><span class="mi">7</span><span class="p">))</span>
</pre></div>
</div>
<p>allow you to store an object of type <code class="docutils literal"><span class="pre">MyType</span></code> on process 2 even if <code class="docutils literal"><span class="pre">DummyModule</span></code> is not in scope on process 2.</p>
</li>
</ul>
<p>You can force a command to run on all processes using the <code class="xref jl jl-obj docutils literal"><span class="pre">&#64;everywhere</span></code> macro.
For example, <code class="xref jl jl-obj docutils literal"><span class="pre">&#64;everywhere</span></code> can also be used to directly define a function on all processes:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="nd">@everywhere</span> <span class="n">id</span> <span class="o">=</span> <span class="n">myid</span><span class="p">()</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">remotecall_fetch</span><span class="p">(()</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="mi">2</span>
</pre></div>
</div>
<p>A file can also be preloaded on multiple processes at startup, and a driver script can be used to drive the computation:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span> <span class="o">-</span><span class="n">p</span> <span class="o">&lt;</span><span class="n">n</span><span class="o">&gt;</span> <span class="o">-</span><span class="n">L</span> <span class="n">file1</span><span class="o">.</span><span class="n">jl</span> <span class="o">-</span><span class="n">L</span> <span class="n">file2</span><span class="o">.</span><span class="n">jl</span> <span class="n">driver</span><span class="o">.</span><span class="n">jl</span>
</pre></div>
</div>
<p>Each process has an associated identifier. The process providing the interactive Julia prompt
always has an <code class="docutils literal"><span class="pre">id</span></code> equal to 1, as would the Julia process running the driver script in the
example above.
The processes used by default for parallel operations are referred to as &#8220;workers&#8221;.
When there is only one process, process 1 is considered a worker. Otherwise, workers are
considered to be all processes other than process 1.</p>
<p>The base Julia installation has in-built support for two types of clusters:</p>
<ul class="simple">
<li>A local cluster specified with the <code class="docutils literal"><span class="pre">-p</span></code> option as shown above.</li>
<li>A cluster spanning machines using the <code class="docutils literal"><span class="pre">--machinefile</span></code> option. This uses a passwordless
<code class="docutils literal"><span class="pre">ssh</span></code> login to start Julia worker processes (from the same path as the current host)
on the specified machines.</li>
</ul>
<p>Functions <a class="reference internal" href="../../stdlib/parallel/#Base.addprocs" title="Base.addprocs"><code class="xref jl jl-func docutils literal"><span class="pre">addprocs()</span></code></a>, <a class="reference internal" href="../../stdlib/parallel/#Base.rmprocs" title="Base.rmprocs"><code class="xref jl jl-func docutils literal"><span class="pre">rmprocs()</span></code></a>, <a class="reference internal" href="../../stdlib/parallel/#Base.workers" title="Base.workers"><code class="xref jl jl-func docutils literal"><span class="pre">workers()</span></code></a>, and others are available as a programmatic means of
adding, removing and querying the processes in a cluster.</p>
<p>Note that workers do not run a <code class="docutils literal"><span class="pre">.juliarc.jl</span></code> startup script, nor do they synchronize their global state
(such as global variables, new method definitions, and loaded modules) with any of the other running processes.</p>
<p>Other types of clusters can be supported by writing your own custom
<code class="xref jl jl-class docutils literal"><span class="pre">ClusterManager</span></code>, as described below in the <a class="reference internal" href="#man-clustermanagers"><span class="std std-ref">ClusterManagers</span></a>
section.</p>
</div>
<div class="section" id="data-movement">
<h2>Data Movement<a class="headerlink" href="#data-movement" title="Permalink to this headline">¶</a></h2>
<p>Sending messages and moving data constitute most of the overhead in a
parallel program. Reducing the number of messages and the amount of data
sent is critical to achieving performance and scalability. To this end,
it is important to understand the data movement performed by Julia&#8217;s
various parallel programming constructs.</p>
<p><a class="reference internal" href="../../stdlib/parallel/#Base.fetch" title="Base.fetch"><code class="xref jl jl-func docutils literal"><span class="pre">fetch()</span></code></a> can be considered an explicit data movement operation, since
it directly asks that an object be moved to the local machine.
<a class="reference internal" href="../../stdlib/parallel/#Base.&#64;spawn" title="Base.&#64;spawn"><code class="xref jl jl-obj docutils literal"><span class="pre">&#64;spawn</span></code></a> (and a few related constructs) also moves data, but this is
not as obvious, hence it can be called an implicit data movement
operation. Consider these two approaches to constructing and squaring a
random matrix:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="c"># method 1</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">rand</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span><span class="mi">1000</span><span class="p">)</span>
<span class="n">Bref</span> <span class="o">=</span> <span class="nd">@spawn</span> <span class="n">A</span><span class="o">^</span><span class="mi">2</span>
<span class="o">...</span>
<span class="n">fetch</span><span class="p">(</span><span class="n">Bref</span><span class="p">)</span>

<span class="c"># method 2</span>
<span class="n">Bref</span> <span class="o">=</span> <span class="nd">@spawn</span> <span class="n">rand</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span><span class="mi">1000</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span>
<span class="o">...</span>
<span class="n">fetch</span><span class="p">(</span><span class="n">Bref</span><span class="p">)</span>
</pre></div>
</div>
<p>The difference seems trivial, but in fact is quite significant due to
the behavior of <a class="reference internal" href="../../stdlib/parallel/#Base.&#64;spawn" title="Base.&#64;spawn"><code class="xref jl jl-obj docutils literal"><span class="pre">&#64;spawn</span></code></a>. In the first method, a random matrix is
constructed locally, then sent to another process where it is squared.
In the second method, a random matrix is both constructed and squared on
another process. Therefore the second method sends much less data than
the first.</p>
<p>In this toy example, the two methods are easy to distinguish and choose
from. However, in a real program designing data movement might require
more thought and likely some measurement. For example, if the first
process needs matrix <code class="docutils literal"><span class="pre">A</span></code> then the first method might be better. Or,
if computing <code class="docutils literal"><span class="pre">A</span></code> is expensive and only the current process has it,
then moving it to another process might be unavoidable. Or, if the
current process has very little to do between the <a class="reference internal" href="../../stdlib/parallel/#Base.&#64;spawn" title="Base.&#64;spawn"><code class="xref jl jl-obj docutils literal"><span class="pre">&#64;spawn</span></code></a> and
<code class="docutils literal"><span class="pre">fetch(Bref)</span></code>, it might be better to eliminate the parallelism
altogether. Or imagine <code class="docutils literal"><span class="pre">rand(1000,1000)</span></code> is replaced with a more
expensive operation. Then it might make sense to add another <a class="reference internal" href="../../stdlib/parallel/#Base.&#64;spawn" title="Base.&#64;spawn"><code class="xref jl jl-obj docutils literal"><span class="pre">&#64;spawn</span></code></a>
statement just for this step.</p>
</div>
<div class="section" id="parallel-map-and-loops">
<h2>Parallel Map and Loops<a class="headerlink" href="#parallel-map-and-loops" title="Permalink to this headline">¶</a></h2>
<p>Fortunately, many useful parallel computations do not require data
movement. A common example is a Monte Carlo simulation, where multiple
processes can handle independent simulation trials simultaneously. We
can use <a class="reference internal" href="../../stdlib/parallel/#Base.&#64;spawn" title="Base.&#64;spawn"><code class="xref jl jl-obj docutils literal"><span class="pre">&#64;spawn</span></code></a> to flip coins on two processes. First, write the
following function in <code class="docutils literal"><span class="pre">count_heads.jl</span></code>:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="k">function</span> <span class="n">count_heads</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="n">c</span><span class="o">::</span><span class="kt">Int</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">:</span><span class="n">n</span>
        <span class="n">c</span> <span class="o">+=</span> <span class="n">rand</span><span class="p">(</span><span class="kt">Bool</span><span class="p">)</span>
    <span class="k">end</span>
    <span class="n">c</span>
<span class="k">end</span>
</pre></div>
</div>
<p>The function <code class="docutils literal"><span class="pre">count_heads</span></code> simply adds together <code class="docutils literal"><span class="pre">n</span></code> random bits.
Here is how we can perform some trials on two machines, and add together the
results:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="nd">@everywhere</span> <span class="n">include</span><span class="p">(</span><span class="s">&quot;count_heads.jl&quot;</span><span class="p">)</span>

<span class="n">a</span> <span class="o">=</span> <span class="nd">@spawn</span> <span class="n">count_heads</span><span class="p">(</span><span class="mi">100000000</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="nd">@spawn</span> <span class="n">count_heads</span><span class="p">(</span><span class="mi">100000000</span><span class="p">)</span>
<span class="n">fetch</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">+</span><span class="n">fetch</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>This example demonstrates a powerful and often-used
parallel programming pattern. Many iterations run independently over
several processes, and then their results are combined using some
function. The combination process is called a <em>reduction</em>, since it is
generally tensor-rank-reducing: a vector of numbers is reduced to a
single number, or a matrix is reduced to a single row or column, etc. In
code, this typically looks like the pattern <code class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">f(x,v[i])</span></code>, where
<code class="docutils literal"><span class="pre">x</span></code> is the accumulator, <code class="docutils literal"><span class="pre">f</span></code> is the reduction function, and the
<code class="docutils literal"><span class="pre">v[i]</span></code> are the elements being reduced. It is desirable for <code class="docutils literal"><span class="pre">f</span></code> to be
associative, so that it does not matter what order the operations are
performed in.</p>
<p>Notice that our use of this pattern with <code class="docutils literal"><span class="pre">count_heads</span></code> can be
generalized. We used two explicit <a class="reference internal" href="../../stdlib/parallel/#Base.&#64;spawn" title="Base.&#64;spawn"><code class="xref jl jl-obj docutils literal"><span class="pre">&#64;spawn</span></code></a> statements, which limits
the parallelism to two processes. To run on any number of processes,
we can use a <em>parallel for loop</em>, which can be written in Julia like
this:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">nheads</span> <span class="o">=</span> <span class="nd">@parallel</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">:</span><span class="mi">200000000</span>
  <span class="kt">Int</span><span class="p">(</span><span class="n">rand</span><span class="p">(</span><span class="kt">Bool</span><span class="p">))</span>
<span class="k">end</span>
</pre></div>
</div>
<p>This construct implements the pattern of assigning iterations to
multiple processes, and combining them with a specified reduction (in
this case <code class="docutils literal"><span class="pre">(+)</span></code>). The result of each iteration is taken as the value
of the last expression inside the loop. The whole parallel loop
expression itself evaluates to the final answer.</p>
<p>Note that although parallel for loops look like serial for loops, their
behavior is dramatically different. In particular, the iterations do not
happen in a specified order, and writes to variables or arrays will not
be globally visible since iterations run on different processes. Any
variables used inside the parallel loop will be copied and broadcast to
each process.</p>
<p>For example, the following code will not work as intended:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="mi">100000</span><span class="p">)</span>
<span class="nd">@parallel</span> <span class="k">for</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">:</span><span class="mi">100000</span>
  <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
<span class="k">end</span>
</pre></div>
</div>
<p>However, this code will not initialize all of <code class="docutils literal"><span class="pre">a</span></code>, since each
process will have a separate copy of it. Parallel for loops like these
must be avoided. Fortunately,  <a class="reference external" href="#shared-arrays">Shared Arrays</a>
can be used to get around this limitation:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="kt">SharedArray</span><span class="p">(</span><span class="kt">Float64</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span>
<span class="nd">@parallel</span> <span class="k">for</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">:</span><span class="mi">10</span>
  <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
<span class="k">end</span>
</pre></div>
</div>
<p>Using &#8220;outside&#8221; variables in parallel loops is perfectly reasonable if
the variables are read-only:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="n">randn</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span>
<span class="nd">@parallel</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">:</span><span class="mi">100000</span>
  <span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">rand</span><span class="p">(</span><span class="mi">1</span><span class="o">:</span><span class="k">end</span><span class="p">)])</span>
<span class="k">end</span>
</pre></div>
</div>
<p>Here each iteration applies <code class="docutils literal"><span class="pre">f</span></code> to a randomly-chosen sample from a
vector <code class="docutils literal"><span class="pre">a</span></code> shared by all processes.</p>
<p>As you could see, the reduction operator can be omitted if it is not needed.
In that case, the loop executes asynchronously, i.e. it spawns independent
tasks on all available workers and returns an array of <a class="reference internal" href="../../stdlib/parallel/#Base.Future" title="Base.Future"><code class="xref jl jl-class docutils literal"><span class="pre">Future</span></code></a>
immediately without waiting for completion.
The caller can wait for the <a class="reference internal" href="../../stdlib/parallel/#Base.Future" title="Base.Future"><code class="xref jl jl-class docutils literal"><span class="pre">Future</span></code></a> completions at a later
point by calling <a class="reference internal" href="../../stdlib/parallel/#Base.fetch" title="Base.fetch"><code class="xref jl jl-func docutils literal"><span class="pre">fetch()</span></code></a> on them, or wait for completion at the end of the
loop by prefixing it with <a class="reference internal" href="../../stdlib/parallel/#Base.&#64;sync" title="Base.&#64;sync"><code class="xref jl jl-obj docutils literal"><span class="pre">&#64;sync</span></code></a>, like <code class="docutils literal"><span class="pre">&#64;sync</span> <span class="pre">&#64;parallel</span> <span class="pre">for</span></code>.</p>
<p>In some cases no reduction operator is needed, and we merely wish to
apply a function to all integers in some range (or, more generally, to
all elements in some collection). This is another useful operation
called <em>parallel map</em>, implemented in Julia as the <a class="reference internal" href="../../stdlib/parallel/#Base.pmap" title="Base.pmap"><code class="xref jl jl-func docutils literal"><span class="pre">pmap()</span></code></a> function.
For example, we could compute the singular values of several large
random matrices in parallel as follows:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">M</span> <span class="o">=</span> <span class="kt">Matrix</span><span class="p">{</span><span class="kt">Float64</span><span class="p">}[</span><span class="n">rand</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span><span class="mi">1000</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">:</span><span class="mi">10</span><span class="p">]</span>
<span class="n">pmap</span><span class="p">(</span><span class="n">svd</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>
</pre></div>
</div>
<p>Julia&#8217;s <a class="reference internal" href="../../stdlib/parallel/#Base.pmap" title="Base.pmap"><code class="xref jl jl-func docutils literal"><span class="pre">pmap()</span></code></a> is designed for the case where each function call does
a large amount of work. In contrast, <code class="docutils literal"><span class="pre">&#64;parallel</span> <span class="pre">for</span></code> can handle
situations where each iteration is tiny, perhaps merely summing two
numbers. Only worker processes are used by both <a class="reference internal" href="../../stdlib/parallel/#Base.pmap" title="Base.pmap"><code class="xref jl jl-func docutils literal"><span class="pre">pmap()</span></code></a> and <code class="docutils literal"><span class="pre">&#64;parallel</span> <span class="pre">for</span></code>
for the parallel computation. In case of <code class="docutils literal"><span class="pre">&#64;parallel</span> <span class="pre">for</span></code>, the final reduction
is done on the calling process.</p>
</div>
<div class="section" id="synchronization-with-remote-references">
<h2>Synchronization With Remote References<a class="headerlink" href="#synchronization-with-remote-references" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="scheduling">
<h2>Scheduling<a class="headerlink" href="#scheduling" title="Permalink to this headline">¶</a></h2>
<p>Julia&#8217;s parallel programming platform uses
<a class="reference internal" href="../control-flow/#man-tasks"><span class="std std-ref">Tasks (aka Coroutines)</span></a> to switch among
multiple computations. Whenever code performs a communication operation
like <a class="reference internal" href="../../stdlib/parallel/#Base.fetch" title="Base.fetch"><code class="xref jl jl-func docutils literal"><span class="pre">fetch()</span></code></a> or <a class="reference internal" href="../../stdlib/parallel/#Base.wait" title="Base.wait"><code class="xref jl jl-func docutils literal"><span class="pre">wait()</span></code></a>, the current task is suspended and a
scheduler picks another task to run. A task is restarted when the event
it is waiting for completes.</p>
<p>For many problems, it is not necessary to think about tasks directly.
However, they can be used to wait for multiple events at the same time,
which provides for <em>dynamic scheduling</em>. In dynamic scheduling, a
program decides what to compute or where to compute it based on when
other jobs finish. This is needed for unpredictable or unbalanced
workloads, where we want to assign more work to processes only when
they finish their current tasks.</p>
<p>As an example, consider computing the singular values of matrices of
different sizes:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">M</span> <span class="o">=</span> <span class="kt">Matrix</span><span class="p">{</span><span class="kt">Float64</span><span class="p">}[</span><span class="n">rand</span><span class="p">(</span><span class="mi">800</span><span class="p">,</span><span class="mi">800</span><span class="p">),</span> <span class="n">rand</span><span class="p">(</span><span class="mi">600</span><span class="p">,</span><span class="mi">600</span><span class="p">),</span> <span class="n">rand</span><span class="p">(</span><span class="mi">800</span><span class="p">,</span><span class="mi">800</span><span class="p">),</span> <span class="n">rand</span><span class="p">(</span><span class="mi">600</span><span class="p">,</span><span class="mi">600</span><span class="p">)]</span>
<span class="n">pmap</span><span class="p">(</span><span class="n">svd</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>
</pre></div>
</div>
<p>If one process handles both 800×800 matrices and another handles both
600×600 matrices, we will not get as much scalability as we could. The
solution is to make a local task to &#8220;feed&#8221; work to each process when
it completes its current task. For example, consider a simple <a class="reference internal" href="../../stdlib/parallel/#Base.pmap" title="Base.pmap"><code class="xref jl jl-func docutils literal"><span class="pre">pmap()</span></code></a>
implementation:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="k">function</span> <span class="n">pmap</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">lst</span><span class="p">)</span>
    <span class="n">np</span> <span class="o">=</span> <span class="n">nprocs</span><span class="p">()</span>  <span class="c"># determine the number of processes available</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">length</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span>
    <span class="n">results</span> <span class="o">=</span> <span class="kt">Vector</span><span class="p">{</span><span class="kt">Any</span><span class="p">}(</span><span class="n">n</span><span class="p">)</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="c"># function to produce the next work item from the queue.</span>
    <span class="c"># in this case it&#39;s just an index.</span>
    <span class="n">nextidx</span><span class="p">()</span> <span class="o">=</span> <span class="p">(</span><span class="n">idx</span><span class="o">=</span><span class="n">i</span><span class="p">;</span> <span class="n">i</span><span class="o">+=</span><span class="mi">1</span><span class="p">;</span> <span class="n">idx</span><span class="p">)</span>
    <span class="nd">@sync</span> <span class="k">begin</span>
        <span class="k">for</span> <span class="n">p</span><span class="o">=</span><span class="mi">1</span><span class="o">:</span><span class="n">np</span>
            <span class="k">if</span> <span class="n">p</span> <span class="o">!=</span> <span class="n">myid</span><span class="p">()</span> <span class="o">||</span> <span class="n">np</span> <span class="o">==</span> <span class="mi">1</span>
                <span class="nd">@async</span> <span class="k">begin</span>
                    <span class="k">while</span> <span class="kc">true</span>
                        <span class="n">idx</span> <span class="o">=</span> <span class="n">nextidx</span><span class="p">()</span>
                        <span class="k">if</span> <span class="n">idx</span> <span class="o">&gt;</span> <span class="n">n</span>
                            <span class="k">break</span>
                        <span class="k">end</span>
                        <span class="n">results</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">remotecall_fetch</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">lst</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
                    <span class="k">end</span>
                <span class="k">end</span>
            <span class="k">end</span>
        <span class="k">end</span>
    <span class="k">end</span>
    <span class="n">results</span>
<span class="k">end</span>
</pre></div>
</div>
<p><a class="reference internal" href="../../stdlib/parallel/#Base.&#64;async" title="Base.&#64;async"><code class="xref jl jl-obj docutils literal"><span class="pre">&#64;async</span></code></a> is similar to <a class="reference internal" href="../../stdlib/parallel/#Base.&#64;spawn" title="Base.&#64;spawn"><code class="xref jl jl-obj docutils literal"><span class="pre">&#64;spawn</span></code></a>, but only runs tasks on the
local process. We use it to create a &#8220;feeder&#8221; task for each process.
Each task picks the next index that needs to be computed, then waits for
its process to finish, then repeats until we run out of indexes. Note
that the feeder tasks do not begin to execute until the main task
reaches the end of the <a class="reference internal" href="../../stdlib/parallel/#Base.&#64;sync" title="Base.&#64;sync"><code class="xref jl jl-obj docutils literal"><span class="pre">&#64;sync</span></code></a> block, at which point it surrenders
control and waits for all the local tasks to complete before returning
from the function. The feeder tasks are able to share state via
<code class="xref jl jl-func docutils literal"><span class="pre">nextidx()</span></code> because they all run on the same process. No locking is
required, since the threads are scheduled cooperatively and not
preemptively. This means context switches only occur at well-defined
points: in this case, when <a class="reference internal" href="../../stdlib/parallel/#Base.remotecall_fetch" title="Base.remotecall_fetch"><code class="xref jl jl-func docutils literal"><span class="pre">remotecall_fetch()</span></code></a> is called.</p>
</div>
<div class="section" id="channels">
<h2>Channels<a class="headerlink" href="#channels" title="Permalink to this headline">¶</a></h2>
<p>Channels provide for a fast means of inter-task communication. A
<code class="docutils literal"><span class="pre">Channel{T}(n::Int)</span></code> is a shared queue of maximum length <code class="docutils literal"><span class="pre">n</span></code>
holding objects of type <code class="docutils literal"><span class="pre">T</span></code>. Multiple readers can read off the <code class="xref jl jl-class docutils literal"><span class="pre">Channel</span></code>
via <a class="reference internal" href="../../stdlib/parallel/#Base.fetch" title="Base.fetch"><code class="xref jl jl-func docutils literal"><span class="pre">fetch()</span></code></a> and <a class="reference internal" href="../../stdlib/parallel/#Base.take!" title="Base.take!"><code class="xref jl jl-func docutils literal"><span class="pre">take!()</span></code></a>. Multiple writers can add to the <code class="xref jl jl-class docutils literal"><span class="pre">Channel</span></code> via
<a class="reference internal" href="../../stdlib/parallel/#Base.put!" title="Base.put!"><code class="xref jl jl-func docutils literal"><span class="pre">put!()</span></code></a>. <a class="reference internal" href="../../stdlib/parallel/#Base.isready" title="Base.isready"><code class="xref jl jl-func docutils literal"><span class="pre">isready()</span></code></a> tests for the presence of any object in
the channel, while <a class="reference internal" href="../../stdlib/parallel/#Base.wait" title="Base.wait"><code class="xref jl jl-func docutils literal"><span class="pre">wait()</span></code></a> waits for an object to become available.
<a class="reference internal" href="../../stdlib/parallel/#Base.close" title="Base.close"><code class="xref jl jl-func docutils literal"><span class="pre">close()</span></code></a> closes a <code class="xref jl jl-class docutils literal"><span class="pre">Channel</span></code>. On a closed <code class="xref jl jl-class docutils literal"><span class="pre">Channel</span></code>, <a class="reference internal" href="../../stdlib/parallel/#Base.put!" title="Base.put!"><code class="xref jl jl-func docutils literal"><span class="pre">put!()</span></code></a> will fail,
while <a class="reference internal" href="../../stdlib/parallel/#Base.take!" title="Base.take!"><code class="xref jl jl-func docutils literal"><span class="pre">take!()</span></code></a> and <a class="reference internal" href="../../stdlib/parallel/#Base.fetch" title="Base.fetch"><code class="xref jl jl-func docutils literal"><span class="pre">fetch()</span></code></a> successfully return any existing values
till it is emptied.</p>
<p>A <code class="xref jl jl-class docutils literal"><span class="pre">Channel</span></code> can be used as an iterable object in a <code class="docutils literal"><span class="pre">for</span></code> loop, in which
case the loop runs as long as the <code class="xref jl jl-class docutils literal"><span class="pre">Channel</span></code> has data or is open. The loop
variable takes on all values added to the <code class="xref jl jl-class docutils literal"><span class="pre">Channel</span></code>. An empty, closed <code class="xref jl jl-class docutils literal"><span class="pre">Channel</span></code>
causes the <code class="docutils literal"><span class="pre">for</span></code> loop to terminate.</p>
</div>
<div class="section" id="remote-references-and-abstractchannels">
<h2>Remote references and AbstractChannels<a class="headerlink" href="#remote-references-and-abstractchannels" title="Permalink to this headline">¶</a></h2>
<p>Remote references always refer to an implementation of an <code class="xref jl jl-class docutils literal"><span class="pre">AbstractChannel</span></code>.</p>
<p>A concrete implementation of an <code class="xref jl jl-class docutils literal"><span class="pre">AbstractChannel</span></code> (like <code class="xref jl jl-class docutils literal"><span class="pre">Channel</span></code>), is required
to implement <a class="reference internal" href="../../stdlib/parallel/#Base.put!" title="Base.put!"><code class="xref jl jl-func docutils literal"><span class="pre">put!()</span></code></a>, <a class="reference internal" href="../../stdlib/parallel/#Base.take!" title="Base.take!"><code class="xref jl jl-func docutils literal"><span class="pre">take!()</span></code></a>, <a class="reference internal" href="../../stdlib/parallel/#Base.fetch" title="Base.fetch"><code class="xref jl jl-func docutils literal"><span class="pre">fetch()</span></code></a>, <a class="reference internal" href="../../stdlib/parallel/#Base.isready" title="Base.isready"><code class="xref jl jl-func docutils literal"><span class="pre">isready()</span></code></a> and <a class="reference internal" href="../../stdlib/parallel/#Base.wait" title="Base.wait"><code class="xref jl jl-func docutils literal"><span class="pre">wait()</span></code></a>.
The remote object referred to by a <a class="reference internal" href="../../stdlib/parallel/#Base.Future" title="Base.Future"><code class="xref jl jl-class docutils literal"><span class="pre">Future</span></code></a> is stored in a <code class="docutils literal"><span class="pre">Channel{Any}(1)</span></code>,
i.e., a <code class="xref jl jl-class docutils literal"><span class="pre">Channel</span></code> of size 1 capable of holding objects of <code class="docutils literal"><span class="pre">Any</span></code> type.</p>
<p><a class="reference internal" href="../../stdlib/parallel/#Base.RemoteChannel" title="Base.RemoteChannel"><code class="xref jl jl-class docutils literal"><span class="pre">RemoteChannel</span></code></a>, which is rewritable, can point to any type and size of channels, or any other
implementation of an <code class="xref jl jl-class docutils literal"><span class="pre">AbstractChannel</span></code>.</p>
<p>The constructor <code class="xref jl jl-func docutils literal"><span class="pre">RemoteChannel(f::Function,</span> <span class="pre">pid)()</span></code> allows us to construct references to channels holding
more than one value of a specific type. <code class="docutils literal"><span class="pre">f()</span></code> is a function executed on <code class="docutils literal"><span class="pre">pid</span></code> and it must return
an <code class="xref jl jl-class docutils literal"><span class="pre">AbstractChannel</span></code>.</p>
<p>For example, <code class="docutils literal"><span class="pre">RemoteChannel(()-&gt;Channel{Int}(10),</span> <span class="pre">pid)</span></code>, will return a reference to a channel of type <code class="docutils literal"><span class="pre">Int</span></code>
and size 10. The channel exists on worker <code class="docutils literal"><span class="pre">pid</span></code>.</p>
<p>Methods <a class="reference internal" href="../../stdlib/parallel/#Base.put!" title="Base.put!"><code class="xref jl jl-func docutils literal"><span class="pre">put!()</span></code></a>, <a class="reference internal" href="../../stdlib/parallel/#Base.take!" title="Base.take!"><code class="xref jl jl-func docutils literal"><span class="pre">take!()</span></code></a>, <a class="reference internal" href="../../stdlib/parallel/#Base.fetch" title="Base.fetch"><code class="xref jl jl-func docutils literal"><span class="pre">fetch()</span></code></a>, <a class="reference internal" href="../../stdlib/parallel/#Base.isready" title="Base.isready"><code class="xref jl jl-func docutils literal"><span class="pre">isready()</span></code></a> and <a class="reference internal" href="../../stdlib/parallel/#Base.wait" title="Base.wait"><code class="xref jl jl-func docutils literal"><span class="pre">wait()</span></code></a> on a <a class="reference internal" href="../../stdlib/parallel/#Base.RemoteChannel" title="Base.RemoteChannel"><code class="xref jl jl-class docutils literal"><span class="pre">RemoteChannel</span></code></a> are proxied onto
the backing store on the remote process.</p>
<p><a class="reference internal" href="../../stdlib/parallel/#Base.RemoteChannel" title="Base.RemoteChannel"><code class="xref jl jl-class docutils literal"><span class="pre">RemoteChannel</span></code></a> can thus be used to refer to user implemented <code class="xref jl jl-class docutils literal"><span class="pre">AbstractChannel</span></code> objects. A simple
example of this is provided in <code class="docutils literal"><span class="pre">examples/dictchannel.jl</span></code> which uses a dictionary as its remote store.</p>
</div>
<div class="section" id="remote-references-and-distributed-garbage-collection">
<h2>Remote References and Distributed Garbage Collection<a class="headerlink" href="#remote-references-and-distributed-garbage-collection" title="Permalink to this headline">¶</a></h2>
<p>Objects referred to by remote references can be freed only when <em>all</em> held references in the cluster
are deleted.</p>
<p>The node where the value is stored keeps track of which of the workers have a reference to it.
Every time a <a class="reference internal" href="../../stdlib/parallel/#Base.RemoteChannel" title="Base.RemoteChannel"><code class="xref jl jl-class docutils literal"><span class="pre">RemoteChannel</span></code></a> or a (unfetched) <a class="reference internal" href="../../stdlib/parallel/#Base.Future" title="Base.Future"><code class="xref jl jl-class docutils literal"><span class="pre">Future</span></code></a> is serialized to a worker, the node pointed
to by the reference is notified. And every time a <a class="reference internal" href="../../stdlib/parallel/#Base.RemoteChannel" title="Base.RemoteChannel"><code class="xref jl jl-class docutils literal"><span class="pre">RemoteChannel</span></code></a> or a (unfetched) <a class="reference internal" href="../../stdlib/parallel/#Base.Future" title="Base.Future"><code class="xref jl jl-class docutils literal"><span class="pre">Future</span></code></a>
is garbage collected locally, the node owning the value is again notified.</p>
<p>The notifications are done via sending of &#8220;tracking&#8221; messages - an &#8220;add reference&#8221; message when
a reference is serialized to a different process and a &#8220;delete reference&#8221; message when a reference
is locally garbage collected.</p>
<p>Since <a class="reference internal" href="../../stdlib/parallel/#Base.Future" title="Base.Future"><code class="xref jl jl-class docutils literal"><span class="pre">Future</span></code></a>s are write-once and cached locally, the act of <a class="reference internal" href="../../stdlib/parallel/#Base.fetch" title="Base.fetch"><code class="xref jl jl-func docutils literal"><span class="pre">fetch()</span></code></a>ing a <a class="reference internal" href="../../stdlib/parallel/#Base.Future" title="Base.Future"><code class="xref jl jl-class docutils literal"><span class="pre">Future</span></code></a> also updates
reference tracking information on the node owning the value.</p>
<p>The node which owns the value frees it once all references to it are cleared.</p>
<p>With <a class="reference internal" href="../../stdlib/parallel/#Base.Future" title="Base.Future"><code class="xref jl jl-class docutils literal"><span class="pre">Future</span></code></a>s, serializing an already fetched <a class="reference internal" href="../../stdlib/parallel/#Base.Future" title="Base.Future"><code class="xref jl jl-class docutils literal"><span class="pre">Future</span></code></a> to a different node also sends the value
since the original remote store may have collected the value by this time.</p>
<p>It is important to note that <em>when</em> an object is locally garbage collected depends
on the size of the object and the current memory pressure in the system.</p>
<p>In case of remote references, the size of the local reference object is quite small, while the value
stored on the remote node may be quite large. Since the local object may not be collected immediately, it is
a good practice to explicitly call <a class="reference internal" href="../../stdlib/base/#Base.finalize" title="Base.finalize"><code class="xref jl jl-func docutils literal"><span class="pre">finalize()</span></code></a> on local instances of a <a class="reference internal" href="../../stdlib/parallel/#Base.RemoteChannel" title="Base.RemoteChannel"><code class="xref jl jl-class docutils literal"><span class="pre">RemoteChannel</span></code></a>, or on unfetched
<a class="reference internal" href="../../stdlib/parallel/#Base.Future" title="Base.Future"><code class="xref jl jl-class docutils literal"><span class="pre">Future</span></code></a>s. Since calling <a class="reference internal" href="../../stdlib/parallel/#Base.fetch" title="Base.fetch"><code class="xref jl jl-func docutils literal"><span class="pre">fetch()</span></code></a> on a <a class="reference internal" href="../../stdlib/parallel/#Base.Future" title="Base.Future"><code class="xref jl jl-class docutils literal"><span class="pre">Future</span></code></a> also removes its reference from the remote store, this
is not required on fetched <a class="reference internal" href="../../stdlib/parallel/#Base.Future" title="Base.Future"><code class="xref jl jl-class docutils literal"><span class="pre">Future</span></code></a>s. Explicitly calling <a class="reference internal" href="../../stdlib/base/#Base.finalize" title="Base.finalize"><code class="xref jl jl-func docutils literal"><span class="pre">finalize()</span></code></a> results in an immediate message sent to
the remote node to go ahead and remove its reference to the value.</p>
<p>Once finalized, a reference becomes invalid and cannot be used in any further calls.</p>
</div>
<div class="section" id="id2">
<h2>Shared Arrays<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>Shared Arrays use system shared memory to map the same array across
many processes.  While there are some similarities to a <a class="reference external" href="https://github.com/JuliaParallel/DistributedArrays.jl">DArray</a>,
the behavior of a <a class="reference internal" href="../../stdlib/parallel/#Base.SharedArray" title="Base.SharedArray"><code class="xref jl jl-class docutils literal"><span class="pre">SharedArray</span></code></a> is quite different. In a <a class="reference external" href="https://github.com/JuliaParallel/DistributedArrays.jl">DArray</a>,
each process has local access to just a chunk of the data, and no two
processes share the same chunk; in contrast, in a <a class="reference internal" href="../../stdlib/parallel/#Base.SharedArray" title="Base.SharedArray"><code class="xref jl jl-class docutils literal"><span class="pre">SharedArray</span></code></a> each
&#8220;participating&#8221; process has access to the entire array.  A
<a class="reference internal" href="../../stdlib/parallel/#Base.SharedArray" title="Base.SharedArray"><code class="xref jl jl-class docutils literal"><span class="pre">SharedArray</span></code></a> is a good choice when you want to have a large amount
of data jointly accessible to two or more processes on the same machine.</p>
<p><a class="reference internal" href="../../stdlib/parallel/#Base.SharedArray" title="Base.SharedArray"><code class="xref jl jl-class docutils literal"><span class="pre">SharedArray</span></code></a> indexing (assignment and accessing values) works just
as with regular arrays, and is efficient because the underlying memory
is available to the local process.  Therefore, most algorithms work
naturally on <a class="reference internal" href="../../stdlib/parallel/#Base.SharedArray" title="Base.SharedArray"><code class="xref jl jl-class docutils literal"><span class="pre">SharedArray</span></code></a>s, albeit in single-process mode.  In
cases where an algorithm insists on an <a class="reference internal" href="../../stdlib/arrays/#Base.Array" title="Base.Array"><code class="xref jl jl-class docutils literal"><span class="pre">Array</span></code></a> input, the underlying
array can be retrieved from a <a class="reference internal" href="../../stdlib/parallel/#Base.SharedArray" title="Base.SharedArray"><code class="xref jl jl-class docutils literal"><span class="pre">SharedArray</span></code></a> by calling <a class="reference internal" href="../../stdlib/parallel/#Base.sdata" title="Base.sdata"><code class="xref jl jl-func docutils literal"><span class="pre">sdata()</span></code></a>.
For other <code class="xref jl jl-class docutils literal"><span class="pre">AbstractArray</span></code> types, <a class="reference internal" href="../../stdlib/parallel/#Base.sdata" title="Base.sdata"><code class="xref jl jl-func docutils literal"><span class="pre">sdata()</span></code></a> just returns the object
itself, so it&#8217;s safe to use <a class="reference internal" href="../../stdlib/parallel/#Base.sdata" title="Base.sdata"><code class="xref jl jl-func docutils literal"><span class="pre">sdata()</span></code></a> on any <code class="docutils literal"><span class="pre">Array</span></code>-type object.</p>
<p>The constructor for a shared array is of the form:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="kt">SharedArray</span><span class="p">(</span><span class="n">T</span><span class="o">::</span><span class="kt">Type</span><span class="p">,</span> <span class="n">dims</span><span class="o">::</span><span class="kt">NTuple</span><span class="p">;</span> <span class="n">init</span><span class="o">=</span><span class="kc">false</span><span class="p">,</span> <span class="n">pids</span><span class="o">=</span><span class="kt">Int</span><span class="p">[])</span>
</pre></div>
</div>
<p>which creates a shared array of a bits type <code class="docutils literal"><span class="pre">T</span></code> and size <code class="docutils literal"><span class="pre">dims</span></code>
across the processes specified by <code class="docutils literal"><span class="pre">pids</span></code>.  Unlike distributed
arrays, a shared array is accessible only from those participating
workers specified by the <code class="docutils literal"><span class="pre">pids</span></code> named argument (and the creating
process too, if it is on the same host).</p>
<p>If an <code class="docutils literal"><span class="pre">init</span></code> function, of signature <code class="docutils literal"><span class="pre">initfn(S::SharedArray)</span></code>, is
specified, it is called on all the participating workers.  You can
specify that each worker runs the <code class="docutils literal"><span class="pre">init</span></code> function on a
distinct portion of the array, thereby parallelizing initialization.</p>
<p>Here&#8217;s a brief example:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">addprocs</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="mi">3</span><span class="o">-</span><span class="n">element</span> <span class="kt">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">1</span><span class="p">}</span><span class="o">:</span>
 <span class="mi">2</span>
 <span class="mi">3</span>
 <span class="mi">4</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">S</span> <span class="o">=</span> <span class="kt">SharedArray</span><span class="p">(</span><span class="kt">Int</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">init</span> <span class="o">=</span> <span class="n">S</span> <span class="o">-&gt;</span> <span class="n">S</span><span class="p">[</span><span class="n">Base</span><span class="o">.</span><span class="n">localindexes</span><span class="p">(</span><span class="n">S</span><span class="p">)]</span> <span class="o">=</span> <span class="n">myid</span><span class="p">())</span>
<span class="mi">3</span><span class="n">×4</span> <span class="kt">SharedArray</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">2</span><span class="p">}</span><span class="o">:</span>
 <span class="mi">2</span>  <span class="mi">2</span>  <span class="mi">3</span>  <span class="mi">4</span>
 <span class="mi">2</span>  <span class="mi">3</span>  <span class="mi">3</span>  <span class="mi">4</span>
 <span class="mi">2</span>  <span class="mi">3</span>  <span class="mi">4</span>  <span class="mi">4</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">S</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">7</span>
<span class="mi">7</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">S</span>
<span class="mi">3</span><span class="n">×4</span> <span class="kt">SharedArray</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">2</span><span class="p">}</span><span class="o">:</span>
 <span class="mi">2</span>  <span class="mi">2</span>  <span class="mi">3</span>  <span class="mi">4</span>
 <span class="mi">2</span>  <span class="mi">3</span>  <span class="mi">3</span>  <span class="mi">4</span>
 <span class="mi">2</span>  <span class="mi">7</span>  <span class="mi">4</span>  <span class="mi">4</span>
</pre></div>
</div>
<p><a class="reference internal" href="../../stdlib/parallel/#Base.localindexes" title="Base.localindexes"><code class="xref jl jl-func docutils literal"><span class="pre">Base.localindexes()</span></code></a> provides disjoint one-dimensional ranges of indexes,
and is sometimes convenient for splitting up tasks among processes.
You can, of course, divide the work any way you wish:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">S</span> <span class="o">=</span> <span class="kt">SharedArray</span><span class="p">(</span><span class="kt">Int</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">init</span> <span class="o">=</span> <span class="n">S</span> <span class="o">-&gt;</span> <span class="n">S</span><span class="p">[</span><span class="n">indexpids</span><span class="p">(</span><span class="n">S</span><span class="p">)</span><span class="o">:</span><span class="n">length</span><span class="p">(</span><span class="n">procs</span><span class="p">(</span><span class="n">S</span><span class="p">))</span><span class="o">:</span><span class="n">length</span><span class="p">(</span><span class="n">S</span><span class="p">)]</span> <span class="o">=</span> <span class="n">myid</span><span class="p">())</span>
<span class="mi">3</span><span class="n">×4</span> <span class="kt">SharedArray</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">2</span><span class="p">}</span><span class="o">:</span>
 <span class="mi">2</span>  <span class="mi">2</span>  <span class="mi">2</span>  <span class="mi">2</span>
 <span class="mi">3</span>  <span class="mi">3</span>  <span class="mi">3</span>  <span class="mi">3</span>
 <span class="mi">4</span>  <span class="mi">4</span>  <span class="mi">4</span>  <span class="mi">4</span>
</pre></div>
</div>
<p>Since all processes have access to the underlying data, you do have to
be careful not to set up conflicts.  For example:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="nd">@sync</span> <span class="k">begin</span>
    <span class="k">for</span> <span class="n">p</span> <span class="kp">in</span> <span class="n">procs</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
        <span class="nd">@async</span> <span class="k">begin</span>
            <span class="n">remotecall_wait</span><span class="p">(</span><span class="n">fill!</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
        <span class="k">end</span>
    <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
<p>would result in undefined behavior. Because each process fills the
<em>entire</em> array with its own <code class="docutils literal"><span class="pre">pid</span></code>, whichever process is the last to
execute (for any particular element of <code class="docutils literal"><span class="pre">S</span></code>) will have its <code class="docutils literal"><span class="pre">pid</span></code>
retained.</p>
<p>As a more extended and complex example, consider running the following
&#8220;kernel&#8221; in parallel:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">t</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">t</span><span class="p">]</span> <span class="o">+</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">t</span><span class="p">]</span>
</pre></div>
</div>
<p>In this case, if we try to split up the work using a one-dimensional
index, we are likely to run into trouble: if <code class="docutils literal"><span class="pre">q[i,j,t]</span></code> is near the
end of the block assigned to one worker and <code class="docutils literal"><span class="pre">q[i,j,t+1]</span></code> is near the
beginning of the block assigned to another, it&#8217;s very likely that
<code class="docutils literal"><span class="pre">q[i,j,t]</span></code> will not be ready at the time it&#8217;s needed for computing
<code class="docutils literal"><span class="pre">q[i,j,t+1]</span></code>.  In such cases, one is better off chunking the array
manually.  Let&#8217;s split along the second dimension:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="c"># This function retuns the (irange,jrange) indexes assigned to this worker</span>
<span class="nd">@everywhere</span> <span class="k">function</span> <span class="n">myrange</span><span class="p">(</span><span class="n">q</span><span class="o">::</span><span class="kt">SharedArray</span><span class="p">)</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">indexpids</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="c"># This worker is not assigned a piece</span>
        <span class="k">return</span> <span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="o">:</span><span class="mi">0</span>
    <span class="k">end</span>
    <span class="n">nchunks</span> <span class="o">=</span> <span class="n">length</span><span class="p">(</span><span class="n">procs</span><span class="p">(</span><span class="n">q</span><span class="p">))</span>
    <span class="n">splits</span> <span class="o">=</span> <span class="p">[</span><span class="n">round</span><span class="p">(</span><span class="kt">Int</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="kp">in</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">size</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span><span class="n">nchunks</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
    <span class="mi">1</span><span class="o">:</span><span class="n">size</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">splits</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="o">:</span><span class="n">splits</span><span class="p">[</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
<span class="k">end</span>

<span class="c"># Here&#39;s the kernel</span>
<span class="nd">@everywhere</span> <span class="k">function</span> <span class="n">advection_chunk!</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">irange</span><span class="p">,</span> <span class="n">jrange</span><span class="p">,</span> <span class="n">trange</span><span class="p">)</span>
    <span class="nd">@show</span> <span class="p">(</span><span class="n">irange</span><span class="p">,</span> <span class="n">jrange</span><span class="p">,</span> <span class="n">trange</span><span class="p">)</span>  <span class="c"># display so we can see what&#39;s happening</span>
    <span class="k">for</span> <span class="n">t</span> <span class="kp">in</span> <span class="n">trange</span><span class="p">,</span> <span class="n">j</span> <span class="kp">in</span> <span class="n">jrange</span><span class="p">,</span> <span class="n">i</span> <span class="kp">in</span> <span class="n">irange</span>
        <span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">t</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">t</span><span class="p">]</span> <span class="o">+</span>  <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">t</span><span class="p">]</span>
    <span class="k">end</span>
    <span class="n">q</span>
<span class="k">end</span>

<span class="c"># Here&#39;s a convenience wrapper for a SharedArray implementation</span>
<span class="nd">@everywhere</span> <span class="n">advection_shared_chunk!</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span> <span class="o">=</span> <span class="n">advection_chunk!</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">myrange</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="o">:</span><span class="n">size</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>Now let&#8217;s compare three different versions, one that runs in a single process:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">advection_serial!</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span> <span class="o">=</span> <span class="n">advection_chunk!</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="mi">1</span><span class="o">:</span><span class="n">size</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="mi">1</span><span class="o">:</span><span class="n">size</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="mi">1</span><span class="o">:</span><span class="n">size</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>one that uses <code class="docutils literal"><span class="pre">&#64;parallel</span></code>:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="k">function</span> <span class="n">advection_parallel!</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">t</span> <span class="o">=</span> <span class="mi">1</span><span class="o">:</span><span class="n">size</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
        <span class="nd">@sync</span> <span class="nd">@parallel</span> <span class="k">for</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="o">:</span><span class="n">size</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">:</span><span class="n">size</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">t</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">t</span><span class="p">]</span> <span class="o">+</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">t</span><span class="p">]</span>
            <span class="k">end</span>
        <span class="k">end</span>
    <span class="k">end</span>
    <span class="n">q</span>
<span class="k">end</span>
</pre></div>
</div>
<p>and one that delegates in chunks:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="k">function</span> <span class="n">advection_shared!</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
    <span class="nd">@sync</span> <span class="k">begin</span>
        <span class="k">for</span> <span class="n">p</span> <span class="kp">in</span> <span class="n">procs</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
            <span class="nd">@async</span> <span class="n">remotecall_wait</span><span class="p">(</span><span class="n">advection_shared_chunk!</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
        <span class="k">end</span>
    <span class="k">end</span>
    <span class="n">q</span>
<span class="k">end</span>
</pre></div>
</div>
<p>If we create SharedArrays and time these functions, we get the following results (with <code class="docutils literal"><span class="pre">julia</span> <span class="pre">-p</span> <span class="pre">4</span></code>):</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">q</span> <span class="o">=</span> <span class="kt">SharedArray</span><span class="p">(</span><span class="kt">Float64</span><span class="p">,</span> <span class="p">(</span><span class="mi">500</span><span class="p">,</span><span class="mi">500</span><span class="p">,</span><span class="mi">500</span><span class="p">))</span>
<span class="n">u</span> <span class="o">=</span> <span class="kt">SharedArray</span><span class="p">(</span><span class="kt">Float64</span><span class="p">,</span> <span class="p">(</span><span class="mi">500</span><span class="p">,</span><span class="mi">500</span><span class="p">,</span><span class="mi">500</span><span class="p">))</span>

<span class="c"># Run once to JIT-compile</span>
<span class="n">advection_serial!</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
<span class="n">advection_parallel!</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
<span class="n">advection_shared!</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">u</span><span class="p">)</span>

<span class="c"># Now the real results:</span>
<span class="n">julia</span><span class="o">&gt;</span> <span class="nd">@time</span> <span class="n">advection_serial!</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">u</span><span class="p">);</span>
<span class="p">(</span><span class="n">irange</span><span class="p">,</span><span class="n">jrange</span><span class="p">,</span><span class="n">trange</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">:</span><span class="mi">500</span><span class="p">,</span><span class="mi">1</span><span class="o">:</span><span class="mi">500</span><span class="p">,</span><span class="mi">1</span><span class="o">:</span><span class="mi">499</span><span class="p">)</span>
 <span class="mf">830.220</span> <span class="n">milliseconds</span> <span class="p">(</span><span class="mi">216</span> <span class="n">allocations</span><span class="o">:</span> <span class="mi">13820</span> <span class="n">bytes</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nd">@time</span> <span class="n">advection_parallel!</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">u</span><span class="p">);</span>
   <span class="mf">2.495</span> <span class="n">seconds</span>      <span class="p">(</span><span class="mi">3999</span> <span class="n">k</span> <span class="n">allocations</span><span class="o">:</span> <span class="mi">289</span> <span class="n">MB</span><span class="p">,</span> <span class="mf">2.09</span><span class="o">%</span> <span class="n">gc</span> <span class="n">time</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nd">@time</span> <span class="n">advection_shared!</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">u</span><span class="p">);</span>
        <span class="n">From</span> <span class="n">worker</span> <span class="mi">2</span><span class="o">:</span>       <span class="p">(</span><span class="n">irange</span><span class="p">,</span><span class="n">jrange</span><span class="p">,</span><span class="n">trange</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">:</span><span class="mi">500</span><span class="p">,</span><span class="mi">1</span><span class="o">:</span><span class="mi">125</span><span class="p">,</span><span class="mi">1</span><span class="o">:</span><span class="mi">499</span><span class="p">)</span>
        <span class="n">From</span> <span class="n">worker</span> <span class="mi">4</span><span class="o">:</span>       <span class="p">(</span><span class="n">irange</span><span class="p">,</span><span class="n">jrange</span><span class="p">,</span><span class="n">trange</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">:</span><span class="mi">500</span><span class="p">,</span><span class="mi">251</span><span class="o">:</span><span class="mi">375</span><span class="p">,</span><span class="mi">1</span><span class="o">:</span><span class="mi">499</span><span class="p">)</span>
        <span class="n">From</span> <span class="n">worker</span> <span class="mi">3</span><span class="o">:</span>       <span class="p">(</span><span class="n">irange</span><span class="p">,</span><span class="n">jrange</span><span class="p">,</span><span class="n">trange</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">:</span><span class="mi">500</span><span class="p">,</span><span class="mi">126</span><span class="o">:</span><span class="mi">250</span><span class="p">,</span><span class="mi">1</span><span class="o">:</span><span class="mi">499</span><span class="p">)</span>
        <span class="n">From</span> <span class="n">worker</span> <span class="mi">5</span><span class="o">:</span>       <span class="p">(</span><span class="n">irange</span><span class="p">,</span><span class="n">jrange</span><span class="p">,</span><span class="n">trange</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">:</span><span class="mi">500</span><span class="p">,</span><span class="mi">376</span><span class="o">:</span><span class="mi">500</span><span class="p">,</span><span class="mi">1</span><span class="o">:</span><span class="mi">499</span><span class="p">)</span>
 <span class="mf">238.119</span> <span class="n">milliseconds</span> <span class="p">(</span><span class="mi">2264</span> <span class="n">allocations</span><span class="o">:</span> <span class="mi">169</span> <span class="n">KB</span><span class="p">)</span>
</pre></div>
</div>
<p>The biggest advantage of <code class="docutils literal"><span class="pre">advection_shared!</span></code> is that it minimizes traffic
among the workers, allowing each to compute for an extended time on the
assigned piece.</p>
</div>
<div class="section" id="shared-arrays-and-distributed-garbage-collection">
<h2>Shared Arrays and Distributed Garbage Collection<a class="headerlink" href="#shared-arrays-and-distributed-garbage-collection" title="Permalink to this headline">¶</a></h2>
<p>Like remote references, shared arrays are also dependent on garbage collection
on the creating node to release references from all participating workers. Code which
creates many short lived shared array objects would benefit from explicitly
finalizing these objects as soon as possible. This results in both memory and file
handles mapping the shared segment being released sooner.</p>
</div>
<div class="section" id="clustermanagers">
<span id="man-clustermanagers"></span><h2>ClusterManagers<a class="headerlink" href="#clustermanagers" title="Permalink to this headline">¶</a></h2>
<p>The launching, management and networking of Julia processes into a logical
cluster is done via cluster managers. A <code class="xref jl jl-class docutils literal"><span class="pre">ClusterManager</span></code> is responsible for</p>
<ul class="simple">
<li>launching worker processes in a cluster environment</li>
<li>managing events during the lifetime of each worker</li>
<li>optionally, providing data transport</li>
</ul>
<p>A Julia cluster has the following characteristics:</p>
<ul class="simple">
<li>The initial Julia process, also called the <code class="docutils literal"><span class="pre">master</span></code>, is special and has an <code class="docutils literal"><span class="pre">id</span></code> of 1.</li>
<li>Only the <code class="docutils literal"><span class="pre">master</span></code> process can add or remove worker processes.</li>
<li>All processes can directly communicate with each other.</li>
</ul>
<p>Connections between workers (using the in-built TCP/IP transport) is established in the following manner:</p>
<ul class="simple">
<li><a class="reference internal" href="../../stdlib/parallel/#Base.addprocs" title="Base.addprocs"><code class="xref jl jl-func docutils literal"><span class="pre">addprocs()</span></code></a> is called on the master process with a <code class="xref jl jl-class docutils literal"><span class="pre">ClusterManager</span></code> object</li>
<li><a class="reference internal" href="../../stdlib/parallel/#Base.addprocs" title="Base.addprocs"><code class="xref jl jl-func docutils literal"><span class="pre">addprocs()</span></code></a> calls the appropriate <a class="reference internal" href="../../stdlib/parallel/#Base.launch" title="Base.launch"><code class="xref jl jl-func docutils literal"><span class="pre">launch()</span></code></a> method which spawns
required number of worker processes on appropriate machines</li>
<li>Each worker starts listening on a free port and writes out its host and port information to <a class="reference internal" href="../../stdlib/io-network/#Base.STDOUT" title="Base.STDOUT"><code class="xref jl jl-const docutils literal"><span class="pre">STDOUT</span></code></a></li>
<li>The cluster manager captures the <a class="reference internal" href="../../stdlib/io-network/#Base.STDOUT" title="Base.STDOUT"><code class="xref jl jl-const docutils literal"><span class="pre">STDOUT</span></code></a> of each worker and makes it available to the master process</li>
<li>The master process parses this information and sets up TCP/IP connections to each worker</li>
<li>Every worker is also notified of other workers in the cluster</li>
<li>Each worker connects to all workers whose <code class="docutils literal"><span class="pre">id</span></code> is less than the worker&#8217;s own <code class="docutils literal"><span class="pre">id</span></code></li>
<li>In this way a mesh network is established, wherein every worker is directly connected with every other worker</li>
</ul>
<p>While the default transport layer uses plain <code class="xref jl jl-class docutils literal"><span class="pre">TCPSocket</span></code>, it is possible for a Julia cluster to provide
its own transport.</p>
<p>Julia provides two in-built cluster managers:</p>
<ul class="simple">
<li><code class="xref jl jl-class docutils literal"><span class="pre">LocalManager</span></code>, used when <a class="reference internal" href="../../stdlib/parallel/#Base.addprocs" title="Base.addprocs"><code class="xref jl jl-func docutils literal"><span class="pre">addprocs()</span></code></a> or <a class="reference internal" href="../../stdlib/parallel/#Base.addprocs" title="Base.addprocs"><code class="xref jl jl-func docutils literal"><span class="pre">addprocs(np::Integer)</span></code></a> are called</li>
<li><code class="xref jl jl-class docutils literal"><span class="pre">SSHManager</span></code>, used when <a class="reference internal" href="../../stdlib/parallel/#Base.addprocs" title="Base.addprocs"><code class="xref jl jl-func docutils literal"><span class="pre">addprocs(hostnames::Array)</span></code></a> is called with a list of hostnames</li>
</ul>
<p><code class="xref jl jl-class docutils literal"><span class="pre">LocalManager</span></code> is used to launch additional workers on the same host, thereby leveraging multi-core
and multi-processor hardware.</p>
<p>Thus, a minimal cluster manager would need to:</p>
<ul class="simple">
<li>be a subtype of the abstract <code class="xref jl jl-class docutils literal"><span class="pre">ClusterManager</span></code></li>
<li>implement <a class="reference internal" href="../../stdlib/parallel/#Base.launch" title="Base.launch"><code class="xref jl jl-func docutils literal"><span class="pre">launch()</span></code></a>, a method responsible for launching new workers</li>
<li>implement <a class="reference internal" href="../../stdlib/parallel/#Base.manage" title="Base.manage"><code class="xref jl jl-func docutils literal"><span class="pre">manage()</span></code></a>, which is called at various events during a worker&#8217;s lifetime (for example, sending an interrupt signal)</li>
</ul>
<p><a class="reference internal" href="../../stdlib/parallel/#Base.addprocs" title="Base.addprocs"><code class="xref jl jl-func docutils literal"><span class="pre">addprocs(manager::FooManager)</span></code></a> requires <code class="docutils literal"><span class="pre">FooManager</span></code> to implement:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="k">function</span> <span class="n">launch</span><span class="p">(</span><span class="n">manager</span><span class="o">::</span><span class="n">FooManager</span><span class="p">,</span> <span class="n">params</span><span class="o">::</span><span class="kt">Dict</span><span class="p">,</span> <span class="n">launched</span><span class="o">::</span><span class="kt">Array</span><span class="p">,</span> <span class="n">c</span><span class="o">::</span><span class="kt">Condition</span><span class="p">)</span>
    <span class="o">...</span>
<span class="k">end</span>

<span class="k">function</span> <span class="n">manage</span><span class="p">(</span><span class="n">manager</span><span class="o">::</span><span class="n">FooManager</span><span class="p">,</span> <span class="n">id</span><span class="o">::</span><span class="kt">Integer</span><span class="p">,</span> <span class="n">config</span><span class="o">::</span><span class="kt">WorkerConfig</span><span class="p">,</span> <span class="n">op</span><span class="o">::</span><span class="kt">Symbol</span><span class="p">)</span>
    <span class="o">...</span>
<span class="k">end</span>
</pre></div>
</div>
<p>As an example let us see how the <code class="xref jl jl-class docutils literal"><span class="pre">LocalManager</span></code>, the manager responsible for
starting workers on the same host, is implemented:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="k">immutable</span> <span class="n">LocalManager</span> <span class="o">&lt;:</span> <span class="kt">ClusterManager</span>
    <span class="n">np</span><span class="o">::</span><span class="kt">Integer</span>
<span class="k">end</span>

<span class="k">function</span> <span class="n">launch</span><span class="p">(</span><span class="n">manager</span><span class="o">::</span><span class="n">LocalManager</span><span class="p">,</span> <span class="n">params</span><span class="o">::</span><span class="kt">Dict</span><span class="p">,</span> <span class="n">launched</span><span class="o">::</span><span class="kt">Array</span><span class="p">,</span> <span class="n">c</span><span class="o">::</span><span class="kt">Condition</span><span class="p">)</span>
    <span class="o">...</span>
<span class="k">end</span>

<span class="k">function</span> <span class="n">manage</span><span class="p">(</span><span class="n">manager</span><span class="o">::</span><span class="n">LocalManager</span><span class="p">,</span> <span class="n">id</span><span class="o">::</span><span class="kt">Integer</span><span class="p">,</span> <span class="n">config</span><span class="o">::</span><span class="kt">WorkerConfig</span><span class="p">,</span> <span class="n">op</span><span class="o">::</span><span class="kt">Symbol</span><span class="p">)</span>
    <span class="o">...</span>
<span class="k">end</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="../../stdlib/parallel/#Base.launch" title="Base.launch"><code class="xref jl jl-func docutils literal"><span class="pre">launch()</span></code></a> method takes the following arguments:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">manager::ClusterManager</span></code> - the cluster manager <a class="reference internal" href="../../stdlib/parallel/#Base.addprocs" title="Base.addprocs"><code class="xref jl jl-func docutils literal"><span class="pre">addprocs()</span></code></a> is called with</li>
<li><code class="docutils literal"><span class="pre">params::Dict</span></code> - all the keyword arguments passed to <a class="reference internal" href="../../stdlib/parallel/#Base.addprocs" title="Base.addprocs"><code class="xref jl jl-func docutils literal"><span class="pre">addprocs()</span></code></a></li>
<li><code class="docutils literal"><span class="pre">launched::Array</span></code> - the array to append one or more <code class="docutils literal"><span class="pre">WorkerConfig</span></code> objects to</li>
<li><code class="docutils literal"><span class="pre">c::Condition</span></code> - the condition variable to be notified as and when workers are launched</li>
</ul>
<p>The <a class="reference internal" href="../../stdlib/parallel/#Base.launch" title="Base.launch"><code class="xref jl jl-func docutils literal"><span class="pre">launch()</span></code></a> method is called asynchronously in a separate task. The termination of this task
signals that all requested workers have been launched. Hence the <a class="reference internal" href="../../stdlib/parallel/#Base.launch" title="Base.launch"><code class="xref jl jl-func docutils literal"><span class="pre">launch()</span></code></a> function MUST exit as soon
as all the requested workers have been launched.</p>
<p>Newly launched workers are connected to each other, and the master process, in a all-to-all manner.
Specifying the command argument <code class="docutils literal"><span class="pre">--worker</span> <span class="pre">&lt;cookie&gt;</span></code> results in the launched processes initializing themselves
as workers and connections being setup via TCP/IP sockets. Optionally, <code class="docutils literal"><span class="pre">--bind-to</span> <span class="pre">bind_addr[:port]</span></code>
may also be specified to enable other workers to connect to it at the specified <code class="docutils literal"><span class="pre">bind_addr</span></code> and <code class="docutils literal"><span class="pre">port</span></code>.
This is useful for multi-homed hosts.</p>
<p>As an example of a non-TCP/IP transport, an implementation may choose to use MPI, in which case
<code class="docutils literal"><span class="pre">--worker</span></code> must NOT be specified. Instead, newly launched workers should call <code class="docutils literal"><span class="pre">init_worker(cookie)</span></code>
before using any of the parallel constructs.</p>
<p>For every worker launched, the <a class="reference internal" href="../../stdlib/parallel/#Base.launch" title="Base.launch"><code class="xref jl jl-func docutils literal"><span class="pre">launch()</span></code></a> method must add a <code class="xref jl jl-class docutils literal"><span class="pre">WorkerConfig</span></code>
object (with appropriate fields initialized) to <code class="docutils literal"><span class="pre">launched</span></code></p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="k">type</span> <span class="kt">WorkerConfig</span>
    <span class="c"># Common fields relevant to all cluster managers</span>
    <span class="n">io</span><span class="o">::</span><span class="kt">Nullable</span><span class="p">{</span><span class="kt">IO</span><span class="p">}</span>
    <span class="n">host</span><span class="o">::</span><span class="kt">Nullable</span><span class="p">{</span><span class="kt">AbstractString</span><span class="p">}</span>
    <span class="n">port</span><span class="o">::</span><span class="kt">Nullable</span><span class="p">{</span><span class="kt">Integer</span><span class="p">}</span>

    <span class="c"># Used when launching additional workers at a host</span>
    <span class="n">count</span><span class="o">::</span><span class="kt">Nullable</span><span class="p">{</span><span class="kt">Union</span><span class="p">{</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">Symbol</span><span class="p">}}</span>
    <span class="n">exename</span><span class="o">::</span><span class="kt">Nullable</span><span class="p">{</span><span class="kt">AbstractString</span><span class="p">}</span>
    <span class="n">exeflags</span><span class="o">::</span><span class="kt">Nullable</span><span class="p">{</span><span class="kt">Cmd</span><span class="p">}</span>

    <span class="c"># External cluster managers can use this to store information at a per-worker level</span>
    <span class="c"># Can be a dict if multiple fields need to be stored.</span>
    <span class="n">userdata</span><span class="o">::</span><span class="kt">Nullable</span><span class="p">{</span><span class="kt">Any</span><span class="p">}</span>

    <span class="c"># SSHManager / SSH tunnel connections to workers</span>
    <span class="n">tunnel</span><span class="o">::</span><span class="kt">Nullable</span><span class="p">{</span><span class="kt">Bool</span><span class="p">}</span>
    <span class="n">bind_addr</span><span class="o">::</span><span class="kt">Nullable</span><span class="p">{</span><span class="kt">AbstractString</span><span class="p">}</span>
    <span class="n">sshflags</span><span class="o">::</span><span class="kt">Nullable</span><span class="p">{</span><span class="kt">Cmd</span><span class="p">}</span>
    <span class="n">max_parallel</span><span class="o">::</span><span class="kt">Nullable</span><span class="p">{</span><span class="kt">Integer</span><span class="p">}</span>

    <span class="n">connect_at</span><span class="o">::</span><span class="kt">Nullable</span><span class="p">{</span><span class="kt">Any</span><span class="p">}</span>

    <span class="o">.....</span>
<span class="k">end</span>
</pre></div>
</div>
<p>Most of the fields in <code class="xref jl jl-class docutils literal"><span class="pre">WorkerConfig</span></code> are used by the inbuilt managers.
Custom cluster managers would typically specify only <code class="docutils literal"><span class="pre">io</span></code> or <code class="docutils literal"><span class="pre">host</span></code> / <code class="docutils literal"><span class="pre">port</span></code>:</p>
<ul class="simple">
<li>If <code class="docutils literal"><span class="pre">io</span></code> is specified, it is used to read host/port information. A Julia
worker prints out its bind address and port at startup. This allows Julia
workers to listen on any free port available instead of requiring worker ports
to be configured manually.</li>
<li>If <code class="docutils literal"><span class="pre">io</span></code> is not specified, <code class="docutils literal"><span class="pre">host</span></code> and <code class="docutils literal"><span class="pre">port</span></code> are used to connect.</li>
<li><code class="docutils literal"><span class="pre">count</span></code>, <code class="docutils literal"><span class="pre">exename</span></code> and <code class="docutils literal"><span class="pre">exeflags</span></code> are relevant for launching additional workers from a worker.
For example, a cluster manager may launch a single worker per node, and use that to launch
additional workers.<ul>
<li><code class="docutils literal"><span class="pre">count</span></code> with an integer value <code class="docutils literal"><span class="pre">n</span></code> will launch a total of <code class="docutils literal"><span class="pre">n</span></code> workers.</li>
<li><code class="docutils literal"><span class="pre">count</span></code> with a value of <code class="docutils literal"><span class="pre">:auto</span></code> will launch as many workers as the number of cores on that machine.</li>
<li><code class="docutils literal"><span class="pre">exename</span></code> is the name of the <code class="docutils literal"><span class="pre">julia</span></code> executable including the full path.</li>
<li><code class="docutils literal"><span class="pre">exeflags</span></code> should be set to the required command line arguments for new workers.</li>
</ul>
</li>
<li><code class="docutils literal"><span class="pre">tunnel</span></code>, <code class="docutils literal"><span class="pre">bind_addr</span></code>, <code class="docutils literal"><span class="pre">sshflags</span></code> and <code class="docutils literal"><span class="pre">max_parallel</span></code> are used when a ssh tunnel is
required to connect to the workers from the master process.</li>
<li><code class="docutils literal"><span class="pre">userdata</span></code> is provided for custom cluster managers to store their own worker specific information.</li>
</ul>
<p><code class="docutils literal"><span class="pre">manage(manager::FooManager,</span> <span class="pre">id::Integer,</span> <span class="pre">config::WorkerConfig,</span> <span class="pre">op::Symbol)</span></code> is called at different
times during the worker&#8217;s lifetime with appropriate <code class="docutils literal"><span class="pre">op</span></code> values:</p>
<ul class="simple">
<li>with <code class="docutils literal"><span class="pre">:register</span></code>/<code class="docutils literal"><span class="pre">:deregister</span></code> when a worker is added / removed
from the Julia worker pool.</li>
<li>with <code class="docutils literal"><span class="pre">:interrupt</span></code> when <code class="docutils literal"><span class="pre">interrupt(workers)</span></code> is called. The
<code class="xref jl jl-class docutils literal"><span class="pre">ClusterManager</span></code> should signal the appropriate worker with an
interrupt signal.</li>
<li>with <code class="docutils literal"><span class="pre">:finalize</span></code> for cleanup purposes.</li>
</ul>
</div>
<div class="section" id="cluster-managers-with-custom-transports">
<h2>Cluster Managers with custom transports<a class="headerlink" href="#cluster-managers-with-custom-transports" title="Permalink to this headline">¶</a></h2>
<p>Replacing the default TCP/IP all-to-all socket connections with a custom transport layer is a little more involved.
Each Julia process has as many communication tasks as the workers it is connected to. For example, consider a Julia cluster of
32 processes in a all-to-all mesh network:</p>
<ul class="simple">
<li>Each Julia process thus has 31 communication tasks</li>
<li>Each task handles all incoming messages from a single remote worker in a message processing loop</li>
<li>The message processing loop waits on an <code class="xref jl jl-class docutils literal"><span class="pre">IO</span></code> object (for example, a <code class="xref jl jl-class docutils literal"><span class="pre">TCPSocket</span></code> in the default implementation), reads an entire
message, processes it and waits for the next one</li>
<li>Sending messages to a process is done directly from any Julia task - not just communication tasks - again, via the appropriate
<code class="xref jl jl-class docutils literal"><span class="pre">IO</span></code> object</li>
</ul>
<p>Replacing the default transport involves the new implementation to setup connections to remote workers, and to provide appropriate
<code class="xref jl jl-class docutils literal"><span class="pre">IO</span></code> objects that the message processing loops can wait on. The manager specific callbacks to be implemented are:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">connect</span><span class="p">(</span><span class="n">manager</span><span class="o">::</span><span class="n">FooManager</span><span class="p">,</span> <span class="n">pid</span><span class="o">::</span><span class="kt">Integer</span><span class="p">,</span> <span class="n">config</span><span class="o">::</span><span class="kt">WorkerConfig</span><span class="p">)</span>
<span class="n">kill</span><span class="p">(</span><span class="n">manager</span><span class="o">::</span><span class="n">FooManager</span><span class="p">,</span> <span class="n">pid</span><span class="o">::</span><span class="kt">Int</span><span class="p">,</span> <span class="n">config</span><span class="o">::</span><span class="kt">WorkerConfig</span><span class="p">)</span>
</pre></div>
</div>
<p>The default implementation (which uses TCP/IP sockets) is implemented as <code class="docutils literal"><span class="pre">connect(manager::ClusterManager,</span> <span class="pre">pid::Integer,</span> <span class="pre">config::WorkerConfig)</span></code>.</p>
<p><code class="docutils literal"><span class="pre">connect</span></code> should return a pair of <code class="xref jl jl-class docutils literal"><span class="pre">IO</span></code> objects, one for reading data sent from worker <code class="docutils literal"><span class="pre">pid</span></code>,
and the other to write data that needs to be sent to worker <code class="docutils literal"><span class="pre">pid</span></code>. Custom cluster managers can use an in-memory <code class="xref jl jl-class docutils literal"><span class="pre">BufferStream</span></code>
as the plumbing to proxy data between the custom, possibly non-<code class="xref jl jl-class docutils literal"><span class="pre">IO</span></code> transport and Julia&#8217;s in-built parallel infrastructure.</p>
<p>A <code class="xref jl jl-class docutils literal"><span class="pre">BufferStream</span></code> is an in-memory <code class="docutils literal"><span class="pre">IOBuffer</span></code> which behaves like an <code class="xref jl jl-class docutils literal"><span class="pre">IO</span></code> - it is a stream which can be handled asynchronously.</p>
<p>Folder <code class="docutils literal"><span class="pre">examples/clustermanager/0mq</span></code> contains an example of using ZeroMQ to connect Julia workers in a star topology with a 0MQ broker in the middle.
Note: The Julia processes are still all <em>logically</em> connected to each other - any worker can message any other worker directly without any
awareness of 0MQ being used as the transport layer.</p>
<p>When using custom transports:</p>
<ul class="simple">
<li>Julia workers must NOT be started with <code class="docutils literal"><span class="pre">--worker</span></code>. Starting with <code class="docutils literal"><span class="pre">--worker</span></code> will result in the newly launched
workers defaulting to the TCP/IP socket transport implementation</li>
<li>For every incoming logical connection with a worker, <code class="xref jl jl-func docutils literal"><span class="pre">Base.process_messages(rd::IO,</span> <span class="pre">wr::IO)()</span></code> must be called.
This launches a new task that handles reading and writing of messages from/to the worker represented by the <code class="xref jl jl-class docutils literal"><span class="pre">IO</span></code> objects</li>
<li><code class="docutils literal"><span class="pre">init_worker(cookie,</span> <span class="pre">manager::FooManager)</span></code> MUST be called as part of worker process initialization</li>
<li>Field <code class="docutils literal"><span class="pre">connect_at::Any</span></code> in <code class="xref jl jl-class docutils literal"><span class="pre">WorkerConfig</span></code> can be set by the cluster manager when <a class="reference internal" href="../../stdlib/parallel/#Base.launch" title="Base.launch"><code class="xref jl jl-func docutils literal"><span class="pre">launch()</span></code></a> is called. The value of
this field is passed in in all <a class="reference internal" href="../../stdlib/parallel/#Base.connect" title="Base.connect"><code class="xref jl jl-func docutils literal"><span class="pre">connect()</span></code></a> callbacks. Typically, it carries information on <em>how to connect</em> to a worker. For example,
the TCP/IP socket transport uses this field to specify the <code class="docutils literal"><span class="pre">(host,</span> <span class="pre">port)</span></code> tuple at which to connect to a worker</li>
</ul>
<p><code class="docutils literal"><span class="pre">kill(manager,</span> <span class="pre">pid,</span> <span class="pre">config)</span></code> is called to remove a worker from the cluster.
On the master process, the corresponding <code class="xref jl jl-class docutils literal"><span class="pre">IO</span></code> objects must be closed by the implementation to ensure proper cleanup.
The default implementation simply executes an <code class="docutils literal"><span class="pre">exit()</span></code> call on the specified remote worker.</p>
<p><code class="docutils literal"><span class="pre">examples/clustermanager/simple</span></code> is an example that shows a simple implementation using UNIX domain sockets for cluster setup.</p>
</div>
<div class="section" id="network-requirements-for-localmanager-and-sshmanager">
<h2>Network requirements for LocalManager and SSHManager<a class="headerlink" href="#network-requirements-for-localmanager-and-sshmanager" title="Permalink to this headline">¶</a></h2>
<p>Julia clusters are designed to be executed on already secured environments on infrastructure such as local laptops,
departmental clusters, or even on the cloud. This section covers network security requirements for the inbuilt <code class="xref jl jl-class docutils literal"><span class="pre">LocalManager</span></code>
and <code class="xref jl jl-class docutils literal"><span class="pre">SSHManager</span></code>:</p>
<ul>
<li><p class="first">The master process does not listen on any port. It only connects out to the workers.</p>
</li>
<li><p class="first">Each worker binds to only one of the local interfaces and listens on the first free port starting from <code class="docutils literal"><span class="pre">9009</span></code>.</p>
</li>
<li><p class="first"><code class="xref jl jl-class docutils literal"><span class="pre">LocalManager</span></code>, i.e. <code class="docutils literal"><span class="pre">addprocs(N)</span></code>, by default binds only to the loopback interface.
This means that workers consequently started on remote hosts, or anyone with malicious intentions
is unable to connect to the cluster. A <code class="docutils literal"><span class="pre">addprocs(4)</span></code> followed by a <code class="docutils literal"><span class="pre">addprocs([&quot;remote_host&quot;])</span></code>
will fail. Some users may need to create a cluster comprised of their local system and a few remote systems.
This can be done by explicitly requesting <code class="xref jl jl-class docutils literal"><span class="pre">LocalManager</span></code> to bind to an external network interface via the
<code class="docutils literal"><span class="pre">restrict</span></code> keyword argument. For example, <code class="docutils literal"><span class="pre">addprocs(4;</span> <span class="pre">restrict=false)</span></code>.</p>
</li>
<li><p class="first"><code class="xref jl jl-class docutils literal"><span class="pre">SSHManager</span></code>, i.e. <code class="docutils literal"><span class="pre">addprocs(list_of_remote_hosts)</span></code> launches workers on remote hosts via SSH.
It is to be noted that by default SSH is only used to launch Julia workers.
Subsequent master-worker and worker-worker connections use plain, unencrypted TCP/IP sockets. The remote hosts
must have passwordless login enabled. Additional SSH flags or credentials may be specified via keyword
argument <code class="docutils literal"><span class="pre">sshflags</span></code>.</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">addprocs(list_of_remote_hosts;</span> <span class="pre">tunnel=true,</span> <span class="pre">sshflags=&lt;ssh</span> <span class="pre">keys</span> <span class="pre">and</span> <span class="pre">other</span> <span class="pre">flags&gt;)</span></code> is useful when we wish to use
SSH connections for master-worker too. A typical scenario for this is a local laptop running the Julia REPL (i.e., the master)
with the rest of the cluster on the cloud, say on Amazon EC2. In this case only port 22 needs to be
opened at the remote cluster coupled with SSH client authenticated via public key infrastructure (PKI).
Authentication credentials can be supplied via <code class="docutils literal"><span class="pre">sshflags</span></code>, for example <code class="docutils literal"><span class="pre">sshflags=`-e</span> <span class="pre">&lt;keyfile&gt;`</span></code>.</p>
<p>Note that worker-worker connections are still plain TCP and the local security policy on the remote cluster
must allow for free connections between worker nodes, at least for ports 9009 and above.</p>
<p>Securing and encrypting all worker-worker traffic (via SSH), or encrypting individual messages can be done via
a custom ClusterManager.</p>
</li>
</ul>
</div>
<div class="section" id="cluster-cookie">
<h2>Cluster cookie<a class="headerlink" href="#cluster-cookie" title="Permalink to this headline">¶</a></h2>
<p>All processes in a cluster share the same cookie which, by default, is a randomly generated string on the master process:</p>
<ul class="simple">
<li><a class="reference internal" href="../../stdlib/parallel/#Base.Base.cluster_cookie" title="Base.Base.cluster_cookie"><code class="xref jl jl-func docutils literal"><span class="pre">Base.cluster_cookie()</span></code></a> returns the cookie, while <code class="xref jl jl-func docutils literal"><span class="pre">Base.cluster_cookie(cookie)()</span></code> sets it and returns the new cookie.</li>
<li>All connections are authenticated on both sides to ensure that only workers started by the master are allowed
to connect to each other.</li>
<li>The cookie must be passed to the workers at startup via argument <code class="docutils literal"><span class="pre">--worker</span> <span class="pre">&lt;cookie&gt;</span></code>.
Custom ClusterManagers can retrieve the cookie on the master by calling
<a class="reference internal" href="../../stdlib/parallel/#Base.Base.cluster_cookie" title="Base.Base.cluster_cookie"><code class="xref jl jl-func docutils literal"><span class="pre">Base.cluster_cookie()</span></code></a>. Cluster managers not using the default TCP/IP transport (and hence not specifying <code class="docutils literal"><span class="pre">--worker</span></code>)
must call <code class="docutils literal"><span class="pre">init_worker(cookie,</span> <span class="pre">manager)</span></code> with the same cookie as on the master.</li>
</ul>
<p>Note that environments requiring higher levels of security can implement this via a custom <code class="xref jl jl-class docutils literal"><span class="pre">ClusterManager</span></code>.
For example, cookies can be pre-shared and hence not specified as a startup argument.</p>
</div>
<div class="section" id="specifying-network-topology-experimental">
<h2>Specifying network topology (Experimental)<a class="headerlink" href="#specifying-network-topology-experimental" title="Permalink to this headline">¶</a></h2>
<p>Keyword argument <code class="docutils literal"><span class="pre">topology</span></code> to <code class="docutils literal"><span class="pre">addprocs</span></code> is used to specify how the workers must be connected to each other:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">:all_to_all</span></code> : is the default, where all workers are connected to each other.</li>
<li><code class="docutils literal"><span class="pre">:master_slave</span></code> : only the driver process, i.e. <code class="docutils literal"><span class="pre">pid</span></code> 1 has connections to the workers.</li>
<li><code class="docutils literal"><span class="pre">:custom</span></code> : the <code class="docutils literal"><span class="pre">launch</span></code> method of the cluster manager specifies the connection topology.
Fields <code class="docutils literal"><span class="pre">ident</span></code> and <code class="docutils literal"><span class="pre">connect_idents</span></code> in <code class="docutils literal"><span class="pre">WorkerConfig</span></code> are used to specify the  same.
<code class="docutils literal"><span class="pre">connect_idents</span></code> is a list of <code class="xref jl jl-class docutils literal"><span class="pre">ClusterManager</span></code> provided identifiers to workers that worker
with identified by <code class="docutils literal"><span class="pre">ident</span></code> must connect to.</li>
</ul>
<p>Currently, sending a message between unconnected workers results in an error. This behaviour, as with the
functionality and interface, should be considered experimental in nature and may change in future releases.</p>
</div>
<div class="section" id="multi-threading-experimental">
<h2>Multi-threading (Experimental)<a class="headerlink" href="#multi-threading-experimental" title="Permalink to this headline">¶</a></h2>
<p>In addition to tasks, remote calls, and remote references, Julia from <code class="docutils literal"><span class="pre">v0.5</span></code> forwards will natively support
multi-threading. Note that this section is experimental and the interfaces may change in the
future.</p>
<div class="section" id="setup">
<h3>Setup<a class="headerlink" href="#setup" title="Permalink to this headline">¶</a></h3>
<p>By default, Julia starts up with a single thread of execution. This can be verified by
using the command <a class="reference internal" href="../../stdlib/parallel/#Base.Threads.nthreads" title="Base.Threads.nthreads"><code class="xref jl jl-obj docutils literal"><span class="pre">Threads.nthreads()</span></code></a>:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">Threads</span><span class="o">.</span><span class="n">nthreads</span><span class="p">()</span>
<span class="mi">1</span>
</pre></div>
</div>
<p>The number of threads Julia starts up with is controlled by an environment variable
called <code class="docutils literal"><span class="pre">JULIA_NUM_THREADS</span></code>. Now, let&#8217;s start up Julia with 4 threads:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="k">export</span> <span class="n">JULIA_NUM_THREADS</span><span class="o">=</span><span class="mi">4</span>
</pre></div>
</div>
<p>(The above command works on bourne shells on Linux and OSX. Note that if you&#8217;re using
a C shell on these platforms, you should use the keyword <code class="docutils literal"><span class="pre">set</span></code> instead of <code class="docutils literal"><span class="pre">export</span></code>.
If you&#8217;re on Windows, start up the command line in the location of <code class="docutils literal"><span class="pre">julia.exe</span></code> and
use <code class="docutils literal"><span class="pre">set</span></code> instead of <code class="docutils literal"><span class="pre">export</span></code>.)</p>
<p>Let&#8217;s verify there are 4 threads at our disposal.</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">Threads</span><span class="o">.</span><span class="n">nthreads</span><span class="p">()</span>
<span class="mi">4</span>
</pre></div>
</div>
<p>But we are currently on the master thread. To check, we use the command <a class="reference internal" href="../../stdlib/parallel/#Base.Threads.threadid" title="Base.Threads.threadid"><code class="xref jl jl-obj docutils literal"><span class="pre">Threads.threadid()</span></code></a></p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">Threads</span><span class="o">.</span><span class="n">threadid</span><span class="p">()</span>
<span class="mi">1</span>
</pre></div>
</div>
</div>
<div class="section" id="the-threads-macro">
<h3>The <code class="docutils literal"><span class="pre">&#64;threads</span></code> Macro<a class="headerlink" href="#the-threads-macro" title="Permalink to this headline">¶</a></h3>
<p>Let&#8217;s work a simple example using our native threads. Let us create an array of zeros:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="mi">10</span><span class="o">-</span><span class="n">element</span> <span class="kt">Array</span><span class="p">{</span><span class="kt">Float64</span><span class="p">,</span><span class="mi">1</span><span class="p">}</span><span class="o">:</span>
 <span class="mf">0.0</span>
 <span class="mf">0.0</span>
 <span class="mf">0.0</span>
 <span class="mf">0.0</span>
 <span class="mf">0.0</span>
 <span class="mf">0.0</span>
 <span class="mf">0.0</span>
 <span class="mf">0.0</span>
 <span class="mf">0.0</span>
 <span class="mf">0.0</span>
</pre></div>
</div>
<p>Let us operate on this array simultaneously using 4 threads. We&#8217;ll have each thread write
its thread ID into each location.</p>
<p>Julia supports parallel loops using the <a class="reference internal" href="../../stdlib/parallel/#Base.Threads.&#64;threads" title="Base.Threads.&#64;threads"><code class="xref jl jl-obj docutils literal"><span class="pre">Threads.&#64;threads</span></code></a> macro. This macro is affixed in front
of a <code class="docutils literal"><span class="pre">for</span></code> loop to indicate to Julia that the loop is a multi-threaded region.</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">Threads</span><span class="o">.</span><span class="nd">@threads</span> <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">:</span><span class="mi">10</span>
    <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">Threads</span><span class="o">.</span><span class="n">threadid</span><span class="p">()</span>
<span class="k">end</span>
</pre></div>
</div>
<p>The iteration space is split amongst the threads, after which each thread writes its thread ID to its assigned locations.:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">a</span>
<span class="mi">10</span><span class="o">-</span><span class="n">element</span> <span class="kt">Array</span><span class="p">{</span><span class="kt">Float64</span><span class="p">,</span><span class="mi">1</span><span class="p">}</span><span class="o">:</span>
 <span class="mf">1.0</span>
 <span class="mf">1.0</span>
 <span class="mf">1.0</span>
 <span class="mf">2.0</span>
 <span class="mf">2.0</span>
 <span class="mf">2.0</span>
 <span class="mf">3.0</span>
 <span class="mf">3.0</span>
 <span class="mf">4.0</span>
 <span class="mf">4.0</span>
</pre></div>
</div>
<p>Note that <a class="reference internal" href="../../stdlib/parallel/#Base.Threads.&#64;threads" title="Base.Threads.&#64;threads"><code class="xref jl jl-obj docutils literal"><span class="pre">Threads.&#64;threads</span></code></a> does not have an optional reduction parameter like <a class="reference internal" href="../../stdlib/parallel/#Base.&#64;parallel" title="Base.&#64;parallel"><code class="xref jl jl-obj docutils literal"><span class="pre">&#64;parallel</span></code></a>.</p>
</div>
</div>
<div class="section" id="threadcall-experimental">
<h2>&#64;threadcall (Experimental)<a class="headerlink" href="#threadcall-experimental" title="Permalink to this headline">¶</a></h2>
<p>All I/O tasks, timers, REPL commands, etc are multiplexed onto a single OS thread via an event loop.
A patched version of libuv (<a class="reference external" href="http://docs.libuv.org/en/v1.x/">http://docs.libuv.org/en/v1.x/</a>) provides this functionality. Yield points provide
for co-operatively scheduling multiple tasks onto the same OS thread. I/O tasks and timers yield implicitly while
waiting for the event to occur. Calling <code class="docutils literal"><span class="pre">yield()</span></code> explicitly allows for other tasks to be scheduled.</p>
<p>Thus, a task executing a <code class="docutils literal"><span class="pre">ccall</span></code> effectively prevents the Julia scheduler from executing any other
tasks till the call returns. This is true for all calls into external libraries. Exceptions are calls into
custom C code that call back into Julia (which may then yield) or C code that calls <code class="docutils literal"><span class="pre">jl_yield()</span></code> (C equivalent of <code class="docutils literal"><span class="pre">yield()</span></code>).</p>
<p>Note that while Julia code runs on a single thread (by default), libraries used by Julia may launch their own internal
threads. For example, the BLAS library may start as many threads as there are cores on a machine.</p>
<p>The <code class="docutils literal"><span class="pre">&#64;threadcall</span></code> macro addresses scenarios where we do not want a <code class="docutils literal"><span class="pre">ccall</span></code> to block the main Julia event loop.
It schedules a C function for execution in a separate thread. A threadpool with a default size of 4 is used for this.
The size of the threadpool is controlled via environment variable <code class="docutils literal"><span class="pre">UV_THREADPOOL_SIZE</span></code>. While waiting for a free thread,
and during function execution once a thread is available, the requesting task (on the main Julia event loop)
yields to other tasks. Note that <code class="docutils literal"><span class="pre">&#64;threadcall</span></code> does not return till the execution is complete. From a user point of
view, it is therefore a blocking call like other Julia APIs.</p>
<p>It is very important that the called function does not call back into Julia.</p>
<p><code class="docutils literal"><span class="pre">&#64;threadcall</span></code> may be removed/changed in future versions of Julia.</p>
<p class="rubric">Footnotes</p>
<table class="docutils footnote" frame="void" id="mpi2rma" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>In this context, MPI refers to the MPI-1 standard. Beginning with MPI-2, the MPI standards committee introduced a new set of communication mechanisms, collectively referred to as Remote Memory Access (RMA). The motivation for adding RMA to the MPI standard was to facilitate one-sided communication patterns. For additional information on the latest MPI standard, see <a class="reference external" href="http://mpi-forum.org/docs">http://mpi-forum.org/docs</a>.</td></tr>
</tbody>
</table>
</div>
</div>


          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../dates/" class="btn btn-neutral float-right" title="Date and DateTime">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../networking-and-streams/" class="btn btn-neutral" title="Networking and Streams"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
    </p>
  </div>

  <a href="https://github.com/snide/sphinx_rtd_theme">Sphinx theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>
</footer>
        </div>
      </div>

    </section>

  </div>
  

  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'0.5.3-pre',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>