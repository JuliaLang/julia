<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Arrays · The Julia Language</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-28835595-6', 'auto');
ga('send', 'pageview');
</script><link rel="canonical" href="https://docs.julialang.org/en/stable/stdlib/arrays/index.html"/><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../../assets/julia-manual.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../../index.html"><img class="logo" src="../../assets/logo.png" alt="The Julia Language logo"/></a><h1>The Julia Language</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../../manual/introduction/">Introduction</a></li><li><a class="toctext" href="../../manual/getting-started/">Getting Started</a></li><li><a class="toctext" href="../../manual/variables/">Variables</a></li><li><a class="toctext" href="../../manual/integers-and-floating-point-numbers/">Integers and Floating-Point Numbers</a></li><li><a class="toctext" href="../../manual/mathematical-operations/">Mathematical Operations and Elementary Functions</a></li><li><a class="toctext" href="../../manual/complex-and-rational-numbers/">Complex and Rational Numbers</a></li><li><a class="toctext" href="../../manual/strings/">Strings</a></li><li><a class="toctext" href="../../manual/functions/">Functions</a></li><li><a class="toctext" href="../../manual/control-flow/">Control Flow</a></li><li><a class="toctext" href="../../manual/variables-and-scoping/">Scope of Variables</a></li><li><a class="toctext" href="../../manual/types/">Types</a></li><li><a class="toctext" href="../../manual/methods/">Methods</a></li><li><a class="toctext" href="../../manual/constructors/">Constructors</a></li><li><a class="toctext" href="../../manual/conversion-and-promotion/">Conversion and Promotion</a></li><li><a class="toctext" href="../../manual/interfaces/">Interfaces</a></li><li><a class="toctext" href="../../manual/modules/">Modules</a></li><li><a class="toctext" href="../../manual/documentation/">Documentation</a></li><li><a class="toctext" href="../../manual/metaprogramming/">Metaprogramming</a></li><li><a class="toctext" href="../../manual/arrays/">Multi-dimensional Arrays</a></li><li><a class="toctext" href="../../manual/linear-algebra/">Linear algebra</a></li><li><a class="toctext" href="../../manual/networking-and-streams/">Networking and Streams</a></li><li><a class="toctext" href="../../manual/parallel-computing/">Parallel Computing</a></li><li><a class="toctext" href="../../manual/dates/">Date and DateTime</a></li><li><a class="toctext" href="../../manual/interacting-with-julia/">Interacting With Julia</a></li><li><a class="toctext" href="../../manual/running-external-programs/">Running External Programs</a></li><li><a class="toctext" href="../../manual/calling-c-and-fortran-code/">Calling C and Fortran Code</a></li><li><a class="toctext" href="../../manual/handling-operating-system-variation/">Handling Operating System Variation</a></li><li><a class="toctext" href="../../manual/environment-variables/">Environment Variables</a></li><li><a class="toctext" href="../../manual/embedding/">Embedding Julia</a></li><li><a class="toctext" href="../../manual/packages/">Packages</a></li><li><a class="toctext" href="../../manual/profile/">Profiling</a></li><li><a class="toctext" href="../../manual/stacktraces/">Stack Traces</a></li><li><a class="toctext" href="../../manual/performance-tips/">Performance Tips</a></li><li><a class="toctext" href="../../manual/workflow-tips/">Workflow Tips</a></li><li><a class="toctext" href="../../manual/style-guide/">Style Guide</a></li><li><a class="toctext" href="../../manual/faq/">Frequently Asked Questions</a></li><li><a class="toctext" href="../../manual/noteworthy-differences/">Noteworthy Differences from other Languages</a></li><li><a class="toctext" href="../../manual/unicode-input/">Unicode Input</a></li></ul></li><li><span class="toctext">Standard Library</span><ul><li><a class="toctext" href="../base/">Essentials</a></li><li><a class="toctext" href="../collections/">Collections and Data Structures</a></li><li><a class="toctext" href="../math/">Mathematics</a></li><li><a class="toctext" href="../numbers/">Numbers</a></li><li><a class="toctext" href="../strings/">Strings</a></li><li class="current"><a class="toctext" href>Arrays</a><ul class="internal"><li><a class="toctext" href="#Constructors-and-Types-1">Constructors and Types</a></li><li><a class="toctext" href="#Basic-functions-1">Basic functions</a></li><li><a class="toctext" href="#Broadcast-and-vectorization-1">Broadcast and vectorization</a></li><li><a class="toctext" href="#Indexing-and-assignment-1">Indexing and assignment</a></li><li><a class="toctext" href="#Views-(SubArrays-and-other-view-types)-1">Views (SubArrays and other view types)</a></li><li><a class="toctext" href="#Concatenation-and-permutation-1">Concatenation and permutation</a></li><li><a class="toctext" href="#Array-functions-1">Array functions</a></li><li><a class="toctext" href="#Combinatorics-1">Combinatorics</a></li><li><a class="toctext" href="#BitArrays-1">BitArrays</a></li><li><a class="toctext" href="#stdlib-sparse-arrays-1">Sparse Vectors and Matrices</a></li></ul></li><li><a class="toctext" href="../parallel/">Tasks and Parallel Computing</a></li><li><a class="toctext" href="../linalg/">Linear Algebra</a></li><li><a class="toctext" href="../constants/">Constants</a></li><li><a class="toctext" href="../file/">Filesystem</a></li><li><a class="toctext" href="../io-network/">I/O and Network</a></li><li><a class="toctext" href="../punctuation/">Punctuation</a></li><li><a class="toctext" href="../sort/">Sorting and Related Functions</a></li><li><a class="toctext" href="../pkg/">Package Manager Functions</a></li><li><a class="toctext" href="../dates/">Dates and Time</a></li><li><a class="toctext" href="../iterators/">Iteration utilities</a></li><li><a class="toctext" href="../test/">Unit Testing</a></li><li><a class="toctext" href="../c/">C Interface</a></li><li><a class="toctext" href="../libc/">C Standard Library</a></li><li><a class="toctext" href="../libdl/">Dynamic Linker</a></li><li><a class="toctext" href="../profile/">Profiling</a></li><li><a class="toctext" href="../stacktraces/">StackTraces</a></li><li><a class="toctext" href="../simd-types/">SIMD Support</a></li></ul></li><li><span class="toctext">Developer Documentation</span><ul><li><a class="toctext" href="../../devdocs/reflection/">Reflection and introspection</a></li><li><span class="toctext">Documentation of Julia&#39;s Internals</span><ul><li><a class="toctext" href="../../devdocs/init/">Initialization of the Julia runtime</a></li><li><a class="toctext" href="../../devdocs/ast/">Julia ASTs</a></li><li><a class="toctext" href="../../devdocs/types/">More about types</a></li><li><a class="toctext" href="../../devdocs/object/">Memory layout of Julia Objects</a></li><li><a class="toctext" href="../../devdocs/eval/">Eval of Julia code</a></li><li><a class="toctext" href="../../devdocs/callconv/">Calling Conventions</a></li><li><a class="toctext" href="../../devdocs/compiler/">High-level Overview of the Native-Code Generation Process</a></li><li><a class="toctext" href="../../devdocs/functions/">Julia Functions</a></li><li><a class="toctext" href="../../devdocs/cartesian/">Base.Cartesian</a></li><li><a class="toctext" href="../../devdocs/meta/">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="../../devdocs/subarrays/">SubArrays</a></li><li><a class="toctext" href="../../devdocs/sysimg/">System Image Building</a></li><li><a class="toctext" href="../../devdocs/llvm/">Working with LLVM</a></li><li><a class="toctext" href="../../devdocs/stdio/">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="../../devdocs/boundscheck/">Bounds checking</a></li><li><a class="toctext" href="../../devdocs/locks/">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="../../devdocs/offset-arrays/">Arrays with custom indices</a></li><li><a class="toctext" href="../../devdocs/libgit2/">Base.LibGit2</a></li><li><a class="toctext" href="../../devdocs/require/">Module loading</a></li></ul></li><li><span class="toctext">Developing/debugging Julia&#39;s C code</span><ul><li><a class="toctext" href="../../devdocs/backtraces/">Reporting and analyzing crashes (segfaults)</a></li><li><a class="toctext" href="../../devdocs/debuggingtips/">gdb debugging tips</a></li><li><a class="toctext" href="../../devdocs/valgrind/">Using Valgrind with Julia</a></li><li><a class="toctext" href="../../devdocs/sanitizers/">Sanitizer support</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Standard Library</li><li><a href>Arrays</a></li></ul><a class="edit-page" href="https://github.com/JuliaLang/julia/blob/master/doc/src/stdlib/arrays.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Arrays</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="lib-arrays-1" href="#lib-arrays-1">Arrays</a></h1><h2><a class="nav-anchor" id="Constructors-and-Types-1" href="#Constructors-and-Types-1">Constructors and Types</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Core.AbstractArray" href="#Core.AbstractArray"><code>Core.AbstractArray</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">AbstractArray{T, N}</code></pre><p>Abstract array supertype which arrays inherit from.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/abstractarray.jl#L5-L9">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Core.Array" href="#Core.Array"><code>Core.Array</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Array{T}(dims)
Array{T,N}(dims)</code></pre><p>Construct an uninitialized <code>N</code>-dimensional dense array with element type <code>T</code>, where <code>N</code> is determined from the length or number of <code>dims</code>. <code>dims</code> may be a tuple or a series of integer arguments corresponding to the lengths in each dimension. If the rank <code>N</code> is supplied explicitly as in <code>Array{T,N}(dims)</code>, then it must match the length or number of <code>dims</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; A = Array{Float64, 2}(2, 2);

julia&gt; ndims(A)
2

julia&gt; eltype(A)
Float64</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/array.jl#L51-L72">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.getindex-Tuple{Type,Vararg{Any,N} where N}" href="#Base.getindex-Tuple{Type,Vararg{Any,N} where N}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">getindex(type[, elements...])</code></pre><p>Construct a 1-d array of the specified type. This is usually called with the syntax <code>Type[]</code>. Element values can be specified using <code>Type[a,b,c,...]</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; Int8[1, 2, 3]
3-element Array{Int8,1}:
 1
 2
 3

julia&gt; getindex(Int8, 1, 2, 3)
3-element Array{Int8,1}:
 1
 2
 3</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/docs/helpdb/Base.jl#L96-L116">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.zeros" href="#Base.zeros"><code>Base.zeros</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">zeros([A::AbstractArray,] [T=eltype(A)::Type,] [dims=size(A)::Tuple])</code></pre><p>Create an array of all zeros with the same layout as <code>A</code>, element type <code>T</code> and size <code>dims</code>. The <code>A</code> argument can be skipped, which behaves like <code>Array{Float64,0}()</code> was passed. For convenience <code>dims</code> may also be passed in variadic form.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; zeros(1)
1-element Array{Float64,1}:
 0.0

julia&gt; zeros(Int8, 2, 3)
2×3 Array{Int8,2}:
 0  0  0
 0  0  0

julia&gt; A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; zeros(A)
2×2 Array{Int64,2}:
 0  0
 0  0

julia&gt; zeros(A, Float64)
2×2 Array{Float64,2}:
 0.0  0.0
 0.0  0.0

julia&gt; zeros(A, Bool, (3,))
3-element Array{Bool,1}:
 false
 false
 false</code></pre><p>See also <a href="#Base.ones"><code>ones</code></a>, <a href="#Base.similar-Tuple{AbstractArray}"><code>similar</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/docs/helpdb/Base.jl#L2353-L2393">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.ones" href="#Base.ones"><code>Base.ones</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">ones([A::AbstractArray,] [T=eltype(A)::Type,] [dims=size(A)::Tuple])</code></pre><p>Create an array of all ones with the same layout as <code>A</code>, element type <code>T</code> and size <code>dims</code>. The <code>A</code> argument can be skipped, which behaves like <code>Array{Float64,0}()</code> was passed. For convenience <code>dims</code> may also be passed in variadic form.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; ones(Complex128, 2, 3)
2×3 Array{Complex{Float64},2}:
 1.0+0.0im  1.0+0.0im  1.0+0.0im
 1.0+0.0im  1.0+0.0im  1.0+0.0im

julia&gt; ones(1,2)
1×2 Array{Float64,2}:
 1.0  1.0

julia&gt; A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; ones(A)
2×2 Array{Int64,2}:
 1  1
 1  1

julia&gt; ones(A, Float64)
2×2 Array{Float64,2}:
 1.0  1.0
 1.0  1.0

julia&gt; ones(A, Bool, (3,))
3-element Array{Bool,1}:
 true
 true
 true</code></pre><p>See also <a href="#Base.zeros"><code>zeros</code></a>, <a href="#Base.similar-Tuple{AbstractArray}"><code>similar</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/docs/helpdb/Base.jl#L429-L469">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.BitArray" href="#Base.BitArray"><code>Base.BitArray</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">BitArray(dims::Integer...)
BitArray{N}(dims::NTuple{N,Int})</code></pre><p>Construct an uninitialized <code>BitArray</code> with the given dimensions. Behaves identically to the <a href="#Core.Array"><code>Array</code></a> constructor.</p><pre><code class="language-julia-repl">julia&gt; BitArray(2, 2)
2×2 BitArray{2}:
 false  false
 false  true

julia&gt; BitArray((3, 1))
3×1 BitArray{2}:
 false
 true
 false</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/bitarray.jl#L31-L50">source</a><div><pre><code class="language-none">BitArray(itr)</code></pre><p>Construct a <code>BitArray</code> generated by the given iterable object. The shape is inferred from the <code>itr</code> object.</p><pre><code class="language-julia-repl">julia&gt; BitArray([1 0; 0 1])
2×2 BitArray{2}:
  true  false
 false   true

julia&gt; BitArray(x+y == 3 for x = 1:2, y = 1:3)
2×3 BitArray{2}:
 false   true  false
  true  false  false

julia&gt; BitArray(x+y == 3 for x = 1:2 for y = 1:3)
6-element BitArray{1}:
 false
  true
 false
  true
 false
 false</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/bitarray.jl#L548-L574">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.trues" href="#Base.trues"><code>Base.trues</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">trues(dims)</code></pre><p>Create a <code>BitArray</code> with all values set to <code>true</code>.</p><pre><code class="language-julia-repl">julia&gt; trues(2,3)
2×3 BitArray{2}:
 true  true  true
 true  true  true</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/bitarray.jl#L393-L404">source</a><div><pre><code class="language-none">trues(A)</code></pre><p>Create a <code>BitArray</code> with all values set to <code>true</code> of the same shape as <code>A</code>.</p><pre><code class="language-julia-repl">julia&gt; A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; trues(A)
2×2 BitArray{2}:
 true  true
 true  true</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/bitarray.jl#L407-L423">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.falses" href="#Base.falses"><code>Base.falses</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">falses(dims)</code></pre><p>Create a <code>BitArray</code> with all values set to <code>false</code>.</p><pre><code class="language-julia-repl">julia&gt; falses(2,3)
2×3 BitArray{2}:
 false  false  false
 false  false  false</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/bitarray.jl#L360-L371">source</a><div><pre><code class="language-none">falses(A)</code></pre><p>Create a <code>BitArray</code> with all values set to <code>false</code> of the same shape as <code>A</code>.</p><pre><code class="language-julia-repl">julia&gt; A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; falses(A)
2×2 BitArray{2}:
 false  false
 false  false</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/bitarray.jl#L374-L390">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.fill" href="#Base.fill"><code>Base.fill</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">fill(x, dims)</code></pre><p>Create an array filled with the value <code>x</code>. For example, <code>fill(1.0, (5,5))</code> returns a 5×5 array of floats, with each element initialized to <code>1.0</code>.</p><pre><code class="language-julia-repl">julia&gt; fill(1.0, (5,5))
5×5 Array{Float64,2}:
 1.0  1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0  1.0</code></pre><p>If <code>x</code> is an object reference, all elements will refer to the same object. <code>fill(Foo(), dims)</code> will return an array filled with the result of evaluating <code>Foo()</code> once.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/array.jl#L229-L247">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.fill!" href="#Base.fill!"><code>Base.fill!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">fill!(A, x)</code></pre><p>Fill array <code>A</code> with the value <code>x</code>. If <code>x</code> is an object reference, all elements will refer to the same object. <code>fill!(A, Foo())</code> will return <code>A</code> filled with the result of evaluating <code>Foo()</code> once.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = zeros(2,3)
2×3 Array{Float64,2}:
 0.0  0.0  0.0
 0.0  0.0  0.0

julia&gt; fill!(A, 2.)
2×3 Array{Float64,2}:
 2.0  2.0  2.0
 2.0  2.0  2.0

julia&gt; a = [1, 1, 1]; A = fill!(Vector{Vector{Int}}(3), a); a[1] = 2; A
3-element Array{Array{Int64,1},1}:
 [2, 1, 1]
 [2, 1, 1]
 [2, 1, 1]

julia&gt; x = 0; f() = (global x += 1; x); fill!(Vector{Int}(3), f())
3-element Array{Int64,1}:
 1
 1
 1</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/docs/helpdb/Base.jl#L5-L36">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.similar-Tuple{AbstractArray}" href="#Base.similar-Tuple{AbstractArray}"><code>Base.similar</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">similar(array, [element_type=eltype(array)], [dims=size(array)])</code></pre><p>Create an uninitialized mutable array with the given element type and size, based upon the given source array. The second and third arguments are both optional, defaulting to the given array&#39;s <code>eltype</code> and <code>size</code>. The dimensions may be specified either as a single tuple argument or as a series of integer arguments.</p><p>Custom AbstractArray subtypes may choose which specific array type is best-suited to return for the given element type and dimensionality. If they do not specialize this method, the default is an <code>Array{element_type}(dims...)</code>.</p><p>For example, <code>similar(1:10, 1, 4)</code> returns an uninitialized <code>Array{Int,2}</code> since ranges are neither mutable nor support 2 dimensions:</p><pre><code class="language-julia-repl">julia&gt; similar(1:10, 1, 4)
1×4 Array{Int64,2}:
 4419743872  4374413872  4419743888  0</code></pre><p>Conversely, <code>similar(trues(10,10), 2)</code> returns an uninitialized <code>BitVector</code> with two elements since <code>BitArray</code>s are both mutable and can support 1-dimensional arrays:</p><pre><code class="language-julia-repl">julia&gt; similar(trues(10,10), 2)
2-element BitArray{1}:
 false
 false</code></pre><p>Since <code>BitArray</code>s can only store elements of type <a href="../numbers/#Core.Bool"><code>Bool</code></a>, however, if you request a different element type it will create a regular <code>Array</code> instead:</p><pre><code class="language-julia-repl">julia&gt; similar(falses(10), Float64, 2, 4)
2×4 Array{Float64,2}:
 2.18425e-314  2.18425e-314  2.18425e-314  2.18425e-314
 2.18425e-314  2.18425e-314  2.18425e-314  2.18425e-314</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/abstractarray.jl#L478-L519">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.similar-Tuple{Any,Tuple}" href="#Base.similar-Tuple{Any,Tuple}"><code>Base.similar</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">similar(storagetype, indices)</code></pre><p>Create an uninitialized mutable array analogous to that specified by <code>storagetype</code>, but with <code>indices</code> specified by the last argument. <code>storagetype</code> might be a type or a function.</p><p><strong>Examples</strong>:</p><pre><code class="language-none">similar(Array{Int}, indices(A))</code></pre><p>creates an array that &quot;acts like&quot; an <code>Array{Int}</code> (and might indeed be backed by one), but which is indexed identically to <code>A</code>. If <code>A</code> has conventional indexing, this will be identical to <code>Array{Int}(size(A))</code>, but if <code>A</code> has unconventional indexing then the indices of the result will match <code>A</code>.</p><pre><code class="language-none">similar(BitArray, (indices(A, 2),))</code></pre><p>would create a 1-dimensional logical array whose indices match those of the columns of <code>A</code>.</p><pre><code class="language-none">similar(dims-&gt;zeros(Int, dims), indices(A))</code></pre><p>would create an array of <code>Int</code>, initialized to zero, matching the indices of <code>A</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/abstractarray.jl#L538-L564">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.eye" href="#Base.eye"><code>Base.eye</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">eye([T::Type=Float64,] m::Integer, n::Integer)</code></pre><p><code>m</code>-by-<code>n</code> identity matrix. The default element type is <a href="../numbers/#Core.Float64"><code>Float64</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; eye(3, 4)
3×4 Array{Float64,2}:
 1.0  0.0  0.0  0.0
 0.0  1.0  0.0  0.0
 0.0  0.0  1.0  0.0

julia&gt; eye(2, 2)
2×2 Array{Float64,2}:
 1.0  0.0
 0.0  1.0

julia&gt; eye(Int, 2, 2)
2×2 Array{Int64,2}:
 1  0
 0  1</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/array.jl#L265-L290">source</a><div><pre><code class="language-none">eye(m, n)</code></pre><p><code>m</code>-by-<code>n</code> identity matrix.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/array.jl#L299-L303">source</a><div><pre><code class="language-none">eye([T::Type=Float64,] n::Integer)</code></pre><p><code>n</code>-by-<code>n</code> identity matrix. The default element type is <a href="../numbers/#Core.Float64"><code>Float64</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; eye(Int, 2)
2×2 Array{Int64,2}:
 1  0
 0  1

julia&gt; eye(2)
2×2 Array{Float64,2}:
 1.0  0.0
 0.0  1.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/array.jl#L306-L324">source</a><div><pre><code class="language-none">eye(A)</code></pre><p>Constructs an identity matrix of the same dimensions and type as <code>A</code>.</p><pre><code class="language-julia-repl">julia&gt; A = [1 2 3; 4 5 6; 7 8 9]
3×3 Array{Int64,2}:
 1  2  3
 4  5  6
 7  8  9

julia&gt; eye(A)
3×3 Array{Int64,2}:
 1  0  0
 0  1  0
 0  0  1</code></pre><p>Note the difference from <a href="#Base.ones"><code>ones</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/array.jl#L327-L347">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.linspace" href="#Base.linspace"><code>Base.linspace</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">linspace(start, stop, n=50)</code></pre><p>Construct a range of <code>n</code> linearly spaced elements from <code>start</code> to <code>stop</code>.</p><pre><code class="language-julia-repl">julia&gt; linspace(1.3,2.9,9)
1.3:0.2:2.9</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/range.jl#L230-L239">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.logspace" href="#Base.logspace"><code>Base.logspace</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">logspace(start::Real, stop::Real, n::Integer=50)</code></pre><p>Construct a vector of <code>n</code> logarithmically spaced numbers from <code>10^start</code> to <code>10^stop</code>.</p><pre><code class="language-julia-repl">julia&gt; logspace(1.,10.,5)
5-element Array{Float64,1}:
   10.0
 1778.28
    3.16228e5
    5.62341e7
    1.0e10</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/range.jl#L316-L330">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Random.randsubseq" href="#Base.Random.randsubseq"><code>Base.Random.randsubseq</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">randsubseq(A, p) -&gt; Vector</code></pre><p>Return a vector consisting of a random subsequence of the given array <code>A</code>, where each element of <code>A</code> is included (in order) with independent probability <code>p</code>. (Complexity is linear in <code>p*length(A)</code>, so this function is efficient even if <code>p</code> is small and <code>A</code> is large.) Technically, this process is known as &quot;Bernoulli sampling&quot; of <code>A</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/random.jl#L1571-L1578">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Random.randsubseq!" href="#Base.Random.randsubseq!"><code>Base.Random.randsubseq!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">randsubseq!(S, A, p)</code></pre><p>Like <a href="#Base.Random.randsubseq"><code>randsubseq</code></a>, but the results are stored in <code>S</code> (which is resized as needed).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/docs/helpdb/Base.jl#L472-L477">source</a></section><h2><a class="nav-anchor" id="Basic-functions-1" href="#Basic-functions-1">Basic functions</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.ndims" href="#Base.ndims"><code>Base.ndims</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">ndims(A::AbstractArray) -&gt; Integer</code></pre><p>Returns the number of dimensions of <code>A</code>.</p><pre><code class="language-julia-repl">julia&gt; A = ones(3,4,5);

julia&gt; ndims(A)
3</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/abstractarray.jl#L103-L114">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.size" href="#Base.size"><code>Base.size</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">size(A::AbstractArray, [dim...])</code></pre><p>Returns a tuple containing the dimensions of <code>A</code>. Optionally you can specify the dimension(s) you want the length of, and get the length of that dimension, or a tuple of the lengths of dimensions you asked for.</p><pre><code class="language-julia-repl">julia&gt; A = ones(2,3,4);

julia&gt; size(A, 2)
3

julia&gt; size(A,3,2)
(4, 3)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/abstractarray.jl#L12-L28">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.indices-Tuple{Any}" href="#Base.indices-Tuple{Any}"><code>Base.indices</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">indices(A)</code></pre><p>Returns the tuple of valid indices for array <code>A</code>.</p><pre><code class="language-julia-repl">julia&gt; A = ones(5,6,7);

julia&gt; indices(A)
(Base.OneTo(5), Base.OneTo(6), Base.OneTo(7))</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/abstractarray.jl#L50-L61">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.indices-Tuple{AbstractArray,Any}" href="#Base.indices-Tuple{AbstractArray,Any}"><code>Base.indices</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">indices(A, d)</code></pre><p>Returns the valid range of indices for array <code>A</code> along dimension <code>d</code>.</p><pre><code class="language-julia-repl">julia&gt; A = ones(5,6,7);

julia&gt; indices(A,2)
Base.OneTo(6)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/abstractarray.jl#L33-L44">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.length-Tuple{AbstractArray}" href="#Base.length-Tuple{AbstractArray}"><code>Base.length</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">length(A::AbstractArray) -&gt; Integer</code></pre><p>Returns the number of elements in <code>A</code>.</p><pre><code class="language-julia-repl">julia&gt; A = ones(3,4,5);

julia&gt; length(A)
60</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/abstractarray.jl#L119-L130">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.eachindex" href="#Base.eachindex"><code>Base.eachindex</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">eachindex(A...)</code></pre><p>Creates an iterable object for visiting each index of an AbstractArray <code>A</code> in an efficient manner. For array types that have opted into fast linear indexing (like <code>Array</code>), this is simply the range <code>1:length(A)</code>. For other array types, this returns a specialized Cartesian range to efficiently index into the array with indices specified for every dimension. For other iterables, including strings and dictionaries, this returns an iterator object supporting arbitrary index types (e.g. unevenly spaced or non-integer indices).</p><p>Example for a sparse 2-d array:</p><pre><code class="language-julia-repl">julia&gt; A = sparse([1, 1, 2], [1, 3, 1], [1, 2, -5])
2×3 SparseMatrixCSC{Int64,Int64} with 3 stored entries:
  [1, 1]  =  1
  [2, 1]  =  -5
  [1, 3]  =  2

julia&gt; for iter in eachindex(A)
           @show iter.I[1], iter.I[2]
           @show A[iter]
       end
(iter.I[1], iter.I[2]) = (1, 1)
A[iter] = 1
(iter.I[1], iter.I[2]) = (2, 1)
A[iter] = -5
(iter.I[1], iter.I[2]) = (1, 2)
A[iter] = 0
(iter.I[1], iter.I[2]) = (2, 2)
A[iter] = 0
(iter.I[1], iter.I[2]) = (1, 3)
A[iter] = 2
(iter.I[1], iter.I[2]) = (2, 3)
A[iter] = 0</code></pre><p>If you supply more than one <code>AbstractArray</code> argument, <code>eachindex</code> will create an iterable object that is fast for all arguments (a <code>UnitRange</code> if all inputs have fast linear indexing, a <a href="#Base.IteratorsMD.CartesianRange"><code>CartesianRange</code></a> otherwise). If the arrays have different sizes and/or dimensionalities, <code>eachindex</code> returns an iterable that spans the largest range along each dimension.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/abstractarray.jl#L766-L809">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.linearindices" href="#Base.linearindices"><code>Base.linearindices</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">linearindices(A)</code></pre><p>Returns a <code>UnitRange</code> specifying the valid range of indices for <code>A[i]</code> where <code>i</code> is an <code>Int</code>. For arrays with conventional indexing (indices start at 1), or any multidimensional array, this is <code>1:length(A)</code>; however, for one-dimensional arrays with unconventional indices, this is <code>indices(A, 1)</code>.</p><p>Calling this function is the &quot;safe&quot; way to write algorithms that exploit linear indexing.</p><pre><code class="language-julia-repl">julia&gt; A = ones(5,6,7);

julia&gt; b = linearindices(A);

julia&gt; extrema(b)
(1, 210)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/abstractarray.jl#L77-L97">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.IndexStyle" href="#Base.IndexStyle"><code>Base.IndexStyle</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">IndexStyle(A)
IndexStyle(typeof(A))</code></pre><p><code>IndexStyle</code> specifies the &quot;native indexing style&quot; for array <code>A</code>. When you define a new <code>AbstractArray</code> type, you can choose to implement either linear indexing or cartesian indexing.  If you decide to implement linear indexing, then you must set this trait for your array type:</p><pre><code class="language-none">Base.IndexStyle(::Type{&lt;:MyArray}) = IndexLinear()</code></pre><p>The default is <code>IndexCartesian()</code>.</p><p>Julia&#39;s internal indexing machinery will automatically (and invisibly) convert all indexing operations into the preferred style using <a href="#Base.sub2ind"><code>sub2ind</code></a> or <a href="#Base.ind2sub"><code>ind2sub</code></a>. This allows users to access elements of your array using any indexing style, even when explicit methods have not been provided.</p><p>If you define both styles of indexing for your <code>AbstractArray</code>, this trait can be used to select the most performant indexing style. Some methods check this trait on their inputs, and dispatch to different algorithms depending on the most efficient access pattern. In particular, <a href="#Base.eachindex"><code>eachindex</code></a> creates an iterator whose type depends on the setting of this trait.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/abstractarray.jl#L260-L286">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.countnz" href="#Base.countnz"><code>Base.countnz</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">countnz(A) -&gt; Integer</code></pre><p>Counts the number of nonzero values in array <code>A</code> (dense or sparse). Note that this is not a constant-time operation. For sparse matrices, one should usually use <a href="#Base.SparseArrays.nnz"><code>nnz</code></a>, which returns the number of stored values.</p><pre><code class="language-julia-repl">julia&gt; A = [1 2 4; 0 0 1; 1 1 0]
3×3 Array{Int64,2}:
 1  2  4
 0  0  1
 1  1  0

julia&gt; countnz(A)
6</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/reduce.jl#L705-L721">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.conj!" href="#Base.conj!"><code>Base.conj!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">conj!(A)</code></pre><p>Transform an array to its complex conjugate in-place.</p><p>See also <a href="../math/#Base.conj"><code>conj</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1+im 2-im; 2+2im 3+im]
2×2 Array{Complex{Int64},2}:
 1+1im  2-1im
 2+2im  3+1im

julia&gt; conj!(A);

julia&gt; A
2×2 Array{Complex{Int64},2}:
 1-1im  2+1im
 2-2im  3-1im</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/arraymath.jl#L5-L26">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.stride" href="#Base.stride"><code>Base.stride</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">stride(A, k::Integer)</code></pre><p>Returns the distance in memory (in number of elements) between adjacent elements in dimension <code>k</code>.</p><pre><code class="language-julia-repl">julia&gt; A = ones(3,4,5);

julia&gt; stride(A,2)
3

julia&gt; stride(A,3)
12</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/abstractarray.jl#L174-L188">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.strides" href="#Base.strides"><code>Base.strides</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">strides(A)</code></pre><p>Returns a tuple of the memory strides in each dimension.</p><pre><code class="language-julia-repl">julia&gt; A = ones(3,4,5);

julia&gt; strides(A)
(1, 3, 12)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/abstractarray.jl#L200-L211">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.ind2sub" href="#Base.ind2sub"><code>Base.ind2sub</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">ind2sub(a, index) -&gt; subscripts</code></pre><p>Returns a tuple of subscripts into array <code>a</code> corresponding to the linear index <code>index</code>.</p><pre><code class="language-julia-repl">julia&gt; A = ones(5,6,7);

julia&gt; ind2sub(A,35)
(5, 1, 2)

julia&gt; ind2sub(A,70)
(5, 2, 3)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/abstractarray.jl#L1542-L1556">source</a><div><pre><code class="language-none">ind2sub(dims, index) -&gt; subscripts</code></pre><p>Returns a tuple of subscripts into an array with dimensions <code>dims</code>, corresponding to the linear index <code>index</code>.</p><p><strong>Example</strong>:</p><pre><code class="language-none">i, j, ... = ind2sub(size(A), indmax(A))</code></pre><p>provides the indices of the maximum element.</p><pre><code class="language-julia-repl">julia&gt; ind2sub((3,4),2)
(2, 1)

julia&gt; ind2sub((3,4),3)
(3, 1)

julia&gt; ind2sub((3,4),4)
(1, 2)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/abstractarray.jl#L1609-L1633">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.sub2ind" href="#Base.sub2ind"><code>Base.sub2ind</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">sub2ind(dims, i, j, k...) -&gt; index</code></pre><p>The inverse of <a href="#Base.ind2sub"><code>ind2sub</code></a>, returns the linear index corresponding to the provided subscripts.</p><pre><code class="language-julia-repl">julia&gt; sub2ind((5,6,7),1,2,3)
66

julia&gt; sub2ind((5,6,7),1,6,3)
86</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/abstractarray.jl#L1569-L1581">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.checksquare" href="#Base.LinAlg.checksquare"><code>Base.LinAlg.checksquare</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">LinAlg.checksquare(A)</code></pre><p>Check that a matrix is square, then return its common dimension. For multiple arguments, return a vector.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; A = ones(4,4); B = zeros(5,5);

julia&gt; LinAlg.checksquare(A, B)
2-element Array{Int64,1}:
 4
 5</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/linalg.jl#L198-L214">source</a></section><h2><a class="nav-anchor" id="Broadcast-and-vectorization-1" href="#Broadcast-and-vectorization-1">Broadcast and vectorization</a></h2><p>See also the <a href="../../manual/functions/#man-vectorized-1">dot syntax for vectorizing functions</a>; for example, <code>f.(args...)</code> implicitly calls <code>broadcast(f, args...)</code>. Rather than relying on &quot;vectorized&quot; methods of functions like <code>sin</code> to operate on arrays, you should use <code>sin.(a)</code> to vectorize via <code>broadcast</code>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.broadcast" href="#Base.broadcast"><code>Base.broadcast</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">broadcast(f, As...)</code></pre><p>Broadcasts the arrays, tuples, <code>Ref</code>s, nullables, and/or scalars <code>As</code> to a container of the appropriate type and dimensions. In this context, anything that is not a subtype of <code>AbstractArray</code>, <code>Ref</code> (except for <code>Ptr</code>s), <code>Tuple</code>, or <code>Nullable</code> is considered a scalar. The resulting container is established by the following rules:</p><ul><li><p>If all the arguments are scalars, it returns a scalar.</p></li><li><p>If the arguments are tuples and zero or more scalars, it returns a tuple.</p></li><li><p>If the arguments contain at least one array or <code>Ref</code>, it returns an array (expanding singleton dimensions), and treats <code>Ref</code>s as 0-dimensional arrays, and tuples as 1-dimensional arrays.</p></li></ul><p>The following additional rule applies to <code>Nullable</code> arguments: If there is at least one <code>Nullable</code>, and all the arguments are scalars or <code>Nullable</code>, it returns a <code>Nullable</code> treating <code>Nullable</code>s as &quot;containers&quot;.</p><p>A special syntax exists for broadcasting: <code>f.(args...)</code> is equivalent to <code>broadcast(f, args...)</code>, and nested <code>f.(g.(args...))</code> calls are fused into a single broadcast loop.</p><pre><code class="language-julia-repl">julia&gt; A = [1, 2, 3, 4, 5]
5-element Array{Int64,1}:
 1
 2
 3
 4
 5

julia&gt; B = [1 2; 3 4; 5 6; 7 8; 9 10]
5×2 Array{Int64,2}:
 1   2
 3   4
 5   6
 7   8
 9  10

julia&gt; broadcast(+, A, B)
5×2 Array{Int64,2}:
  2   3
  5   6
  8   9
 11  12
 14  15

julia&gt; parse.(Int, [&quot;1&quot;, &quot;2&quot;])
2-element Array{Int64,1}:
 1
 2

julia&gt; abs.((1, -2))
(1, 2)

julia&gt; broadcast(+, 1.0, (0, -2.0))
(1.0, -1.0)

julia&gt; broadcast(+, 1.0, (0, -2.0), Ref(1))
2-element Array{Float64,1}:
 2.0
 0.0

julia&gt; (+).([[0,2], [1,3]], Ref{Vector{Int}}([1,-1]))
2-element Array{Array{Int64,1},1}:
 [1, 1]
 [2, 2]

julia&gt; string.((&quot;one&quot;,&quot;two&quot;,&quot;three&quot;,&quot;four&quot;), &quot;: &quot;, 1:4)
4-element Array{String,1}:
 &quot;one: 1&quot;
 &quot;two: 2&quot;
 &quot;three: 3&quot;
 &quot;four: 4&quot;

julia&gt; Nullable(&quot;X&quot;) .* &quot;Y&quot;
Nullable{String}(&quot;XY&quot;)

julia&gt; broadcast(/, 1.0, Nullable(2.0))
Nullable{Float64}(0.5)

julia&gt; (1 + im) ./ Nullable{Int}()
Nullable{Complex{Float64}}()</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/broadcast.jl#L369-L454">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.broadcast!" href="#Base.broadcast!"><code>Base.broadcast!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">broadcast!(f, dest, As...)</code></pre><p>Like <a href="#Base.broadcast"><code>broadcast</code></a>, but store the result of <code>broadcast(f, As...)</code> in the <code>dest</code> array. Note that <code>dest</code> is only used to store the result, and does not supply arguments to <code>f</code> unless it is also listed in the <code>As</code>, as in <code>broadcast!(f, A, A, B)</code> to perform <code>A[:] = broadcast(f, A, B)</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/broadcast.jl#L197-L205">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Broadcast.@__dot__" href="#Base.Broadcast.@__dot__"><code>Base.Broadcast.@__dot__</code></a> — <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@. expr</code></pre><p>Convert every function call or operator in <code>expr</code> into a &quot;dot call&quot; (e.g. convert <code>f(x)</code> to <code>f.(x)</code>), and convert every assignment in <code>expr</code> to a &quot;dot assignment&quot; (e.g. convert <code>+=</code> to <code>.+=</code>).</p><p>If you want to <em>avoid</em> adding dots for selected function calls in <code>expr</code>, splice those function calls in with <code>$</code>.  For example, <code>@. sqrt(abs($sort(x)))</code> is equivalent to <code>sqrt.(abs.(sort(x)))</code> (no dot for <code>sort</code>).</p><p>(<code>@.</code> is equivalent to a call to <code>@__dot__</code>.)</p><pre><code class="language-julia-repl">julia&gt; x = 1.0:3.0; y = similar(x);

julia&gt; @. y = x + 3 * sin(x)
3-element Array{Float64,1}:
 3.52441
 4.72789
 3.42336</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/broadcast.jl#L603-L626">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Broadcast.broadcast_getindex" href="#Base.Broadcast.broadcast_getindex"><code>Base.Broadcast.broadcast_getindex</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">broadcast_getindex(A, inds...)</code></pre><p>Broadcasts the <code>inds</code> arrays to a common size like <a href="#Base.broadcast"><code>broadcast</code></a> and returns an array of the results <code>A[ks...]</code>, where <code>ks</code> goes over the positions in the broadcast result <code>A</code>.</p><pre><code class="language-julia-repl">julia&gt; A = [1, 2, 3, 4, 5]
5-element Array{Int64,1}:
 1
 2
 3
 4
 5

julia&gt; B = [1 2; 3 4; 5 6; 7 8; 9 10]
5×2 Array{Int64,2}:
 1   2
 3   4
 5   6
 7   8
 9  10

julia&gt; C = broadcast(+,A,B)
5×2 Array{Int64,2}:
  2   3
  5   6
  8   9
 11  12
 14  15

julia&gt; broadcast_getindex(C,[1,2,10])
3-element Array{Int64,1}:
  2
  5
 15</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/broadcast.jl#L457-L495">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Broadcast.broadcast_setindex!" href="#Base.Broadcast.broadcast_setindex!"><code>Base.Broadcast.broadcast_setindex!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">broadcast_setindex!(A, X, inds...)</code></pre><p>Broadcasts the <code>X</code> and <code>inds</code> arrays to a common size and stores the value from each position in <code>X</code> at the indices in <code>A</code> given by the same positions in <code>inds</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/broadcast.jl#L513-L518">source</a></section><h2><a class="nav-anchor" id="Indexing-and-assignment-1" href="#Indexing-and-assignment-1">Indexing and assignment</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.getindex-Tuple{AbstractArray,Vararg{Any,N} where N}" href="#Base.getindex-Tuple{AbstractArray,Vararg{Any,N} where N}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">getindex(A, inds...)</code></pre><p>Returns a subset of array <code>A</code> as specified by <code>inds</code>, where each <code>ind</code> may be an <code>Int</code>, a <code>Range</code>, or a <code>Vector</code>. See the manual section on <a href="../../manual/arrays/#man-array-indexing-1">array indexing</a> for details.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; getindex(A, 1)
1

julia&gt; getindex(A, [2, 1])
2-element Array{Int64,1}:
 3
 1

julia&gt; getindex(A, 2:4)
3-element Array{Int64,1}:
 3
 2
 4</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/docs/helpdb/Base.jl#L119-L147">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.setindex!-Tuple{AbstractArray,Any,Vararg{Any,N} where N}" href="#Base.setindex!-Tuple{AbstractArray,Any,Vararg{Any,N} where N}"><code>Base.setindex!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">setindex!(A, X, inds...)</code></pre><p>Store values from array <code>X</code> within some subset of <code>A</code> as specified by <code>inds</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/docs/helpdb/Base.jl#L2288-L2292">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.copy!-Tuple{AbstractArray,CartesianRange,AbstractArray,CartesianRange}" href="#Base.copy!-Tuple{AbstractArray,CartesianRange,AbstractArray,CartesianRange}"><code>Base.copy!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">copy!(dest, Rdest::CartesianRange, src, Rsrc::CartesianRange) -&gt; dest</code></pre><p>Copy the block of <code>src</code> in the range of <code>Rsrc</code> to the block of <code>dest</code> in the range of <code>Rdest</code>. The sizes of the two regions must match.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/multidimensional.jl#L887-L892">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isassigned" href="#Base.isassigned"><code>Base.isassigned</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">isassigned(array, i) -&gt; Bool</code></pre><p>Tests whether the given array has a value associated with index <code>i</code>. Returns <code>false</code> if the index is out of bounds, or has an undefined reference.</p><pre><code class="language-julia-repl">julia&gt; isassigned(rand(3, 3), 5)
true

julia&gt; isassigned(rand(3, 3), 3 * 3 + 1)
false

julia&gt; mutable struct Foo end

julia&gt; v = similar(rand(3), Foo)
3-element Array{Foo,1}:
 #undef
 #undef
 #undef

julia&gt; isassigned(v, 1)
false</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/essentials.jl#L278-L302">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Colon" href="#Base.Colon"><code>Base.Colon</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Colon()</code></pre><p>Colons (:) are used to signify indexing entire objects or dimensions at once.</p><p>Very few operations are defined on Colons directly; instead they are converted by <a href="#Base.to_indices"><code>to_indices</code></a> to an internal vector type (<code>Base.Slice</code>) to represent the collection of indices they span before being used.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/essentials.jl#L311-L319">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.IteratorsMD.CartesianIndex" href="#Base.IteratorsMD.CartesianIndex"><code>Base.IteratorsMD.CartesianIndex</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">CartesianIndex(i, j, k...)   -&gt; I
CartesianIndex((i, j, k...)) -&gt; I</code></pre><p>Create a multidimensional index <code>I</code>, which can be used for indexing a multidimensional array <code>A</code>.  In particular, <code>A[I]</code> is equivalent to <code>A[i,j,k...]</code>.  One can freely mix integer and <code>CartesianIndex</code> indices; for example, <code>A[Ipre, i, Ipost]</code> (where <code>Ipre</code> and <code>Ipost</code> are <code>CartesianIndex</code> indices and <code>i</code> is an <code>Int</code>) can be a useful expression when writing algorithms that work along a single dimension of an array of arbitrary dimensionality.</p><p>A <code>CartesianIndex</code> is sometimes produced by <a href="#Base.eachindex"><code>eachindex</code></a>, and always when iterating with an explicit <a href="#Base.IteratorsMD.CartesianRange"><code>CartesianRange</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; A = reshape(collect(1:16), (2, 2, 2, 2))
2×2×2×2 Array{Int64,4}:
[:, :, 1, 1] =
 1  3
 2  4

[:, :, 2, 1] =
 5  7
 6  8

[:, :, 1, 2] =
  9  11
 10  12

[:, :, 2, 2] =
 13  15
 14  16

julia&gt; A[CartesianIndex((1, 1, 1, 1))]
1

julia&gt; A[CartesianIndex((1, 1, 1, 2))]
9

julia&gt; A[CartesianIndex((1, 1, 2, 1))]
5</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/multidimensional.jl#L15-L61">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.IteratorsMD.CartesianRange" href="#Base.IteratorsMD.CartesianRange"><code>Base.IteratorsMD.CartesianRange</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">CartesianRange(Istart::CartesianIndex, Istop::CartesianIndex) -&gt; R
CartesianRange(sz::Dims) -&gt; R
CartesianRange(istart:istop, jstart:jstop, ...) -&gt; R</code></pre><p>Define a region <code>R</code> spanning a multidimensional rectangular range of integer indices. These are most commonly encountered in the context of iteration, where <code>for I in R ... end</code> will return <a href="#Base.IteratorsMD.CartesianIndex"><code>CartesianIndex</code></a> indices <code>I</code> equivalent to the nested loops</p><pre><code class="language-none">for j = jstart:jstop
    for i = istart:istop
        ...
    end
end</code></pre><p>Consequently these can be useful for writing algorithms that work in arbitrary dimensions.</p><pre><code class="language-julia-repl">julia&gt; foreach(println, CartesianRange((2, 2, 2)))
CartesianIndex{3}((1, 1, 1))
CartesianIndex{3}((2, 1, 1))
CartesianIndex{3}((1, 2, 1))
CartesianIndex{3}((2, 2, 1))
CartesianIndex{3}((1, 1, 2))
CartesianIndex{3}((2, 1, 2))
CartesianIndex{3}((1, 2, 2))
CartesianIndex{3}((2, 2, 2))</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/multidimensional.jl#L137-L167">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.to_indices" href="#Base.to_indices"><code>Base.to_indices</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">to_indices(A, I::Tuple)</code></pre><p>Convert the tuple <code>I</code> to a tuple of indices for use in indexing into array <code>A</code>.</p><p>The returned tuple must only contain either <code>Int</code>s or <code>AbstractArray</code>s of scalar indices that are supported by array <code>A</code>. It will error upon encountering a novel index type that it does not know how to process.</p><p>For simple index types, it defers to the unexported <code>Base.to_index(A, i)</code> to process each index <code>i</code>. While this internal function is not intended to be called directly, <code>Base.to_index</code> may be extended by custom array or index types to provide custom indexing behaviors.</p><p>More complicated index types may require more context about the dimension into which they index. To support those cases, <code>to_indices(A, I)</code> calls <code>to_indices(A, indices(A), I)</code>, which then recursively walks through both the given tuple of indices and the dimensional indices of <code>A</code> in tandem. As such, not all index types are guaranteed to propagate to <code>Base.to_index</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/indices.jl#L193-L212">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.checkbounds" href="#Base.checkbounds"><code>Base.checkbounds</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">checkbounds(Bool, A, I...)</code></pre><p>Return <code>true</code> if the specified indices <code>I</code> are in bounds for the given array <code>A</code>. Subtypes of <code>AbstractArray</code> should specialize this method if they need to provide custom bounds checking behaviors; however, in many cases one can rely on <code>A</code>&#39;s indices and <a href="#Base.checkindex"><code>checkindex</code></a>.</p><p>See also <a href="#Base.checkindex"><code>checkindex</code></a>.</p><pre><code class="language-julia-repl">julia&gt; A = rand(3, 3);

julia&gt; checkbounds(Bool, A, 2)
true

julia&gt; checkbounds(Bool, A, 3, 4)
false

julia&gt; checkbounds(Bool, A, 1:3)
true

julia&gt; checkbounds(Bool, A, 1:3, 2:4)
false</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/abstractarray.jl#L314-L339">source</a><div><pre><code class="language-none">checkbounds(A, I...)</code></pre><p>Throw an error if the specified indices <code>I</code> are not in bounds for the given array <code>A</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/abstractarray.jl#L355-L359">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.checkindex" href="#Base.checkindex"><code>Base.checkindex</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">checkindex(Bool, inds::AbstractUnitRange, index)</code></pre><p>Return <code>true</code> if the given <code>index</code> is within the bounds of <code>inds</code>. Custom types that would like to behave as indices for all arrays can extend this method in order to provide a specialized bounds checking implementation.</p><pre><code class="language-julia-repl">julia&gt; checkindex(Bool,1:20,8)
true

julia&gt; checkindex(Bool,1:20,21)
false</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/abstractarray.jl#L437-L452">source</a></section><h2><a class="nav-anchor" id="Views-(SubArrays-and-other-view-types)-1" href="#Views-(SubArrays-and-other-view-types)-1">Views (SubArrays and other view types)</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.view" href="#Base.view"><code>Base.view</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">view(A, inds...)</code></pre><p>Like <a href="#Base.getindex-Tuple{Type,Vararg{Any,N} where N}"><code>getindex</code></a>, but returns a view into the parent array <code>A</code> with the given indices instead of making a copy.  Calling <a href="#Base.getindex-Tuple{Type,Vararg{Any,N} where N}"><code>getindex</code></a> or <a href="#Base.setindex!-Tuple{AbstractArray,Any,Vararg{Any,N} where N}"><code>setindex!</code></a> on the returned <code>SubArray</code> computes the indices to the parent array on the fly without checking bounds.</p><pre><code class="language-julia-repl">julia&gt; A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; b = view(A, :, 1)
2-element SubArray{Int64,1,Array{Int64,2},Tuple{Base.Slice{Base.OneTo{Int64}},Int64},true}:
 1
 3

julia&gt; fill!(b, 0)
2-element SubArray{Int64,1,Array{Int64,2},Tuple{Base.Slice{Base.OneTo{Int64}},Int64},true}:
 0
 0

julia&gt; A # Note A has changed even though we modified b
2×2 Array{Int64,2}:
 0  2
 0  4</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/subarray.jl#L80-L109">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.@view" href="#Base.@view"><code>Base.@view</code></a> — <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@view A[inds...]</code></pre><p>Creates a <code>SubArray</code> from an indexing expression. This can only be applied directly to a reference expression (e.g. <code>@view A[1,2:end]</code>), and should <em>not</em> be used as the target of an assignment (e.g. <code>@view(A[1,2:end]) = ...</code>).  See also <a href="#Base.@views"><code>@views</code></a> to switch an entire block of code to use views for slicing.</p><pre><code class="language-julia-repl">julia&gt; A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; b = @view A[:, 1]
2-element SubArray{Int64,1,Array{Int64,2},Tuple{Base.Slice{Base.OneTo{Int64}},Int64},true}:
 1
 3

julia&gt; fill!(b, 0)
2-element SubArray{Int64,1,Array{Int64,2},Tuple{Base.Slice{Base.OneTo{Int64}},Int64},true}:
 0
 0

julia&gt; A
2×2 Array{Int64,2}:
 0  2
 0  4</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/subarray.jl#L418-L447">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.@views" href="#Base.@views"><code>Base.@views</code></a> — <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@views expression</code></pre><p>Convert every array-slicing operation in the given expression (which may be a <code>begin</code>/<code>end</code> block, loop, function, etc.) to return a view.   Scalar indices, non-array types, and explicit <code>getindex</code> calls (as opposed to <code>array[...]</code>) are unaffected.</p><p>Note that the <code>@views</code> macro only affects <code>array[...]</code> expressions that appear explicitly in the given <code>expression</code>, not array slicing that occurs in functions called by that code.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/subarray.jl#L527-L539">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.parent" href="#Base.parent"><code>Base.parent</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">parent(A)</code></pre><p>Returns the &quot;parent array&quot; of an array view type (e.g., <code>SubArray</code>), or the array itself if it is not a view.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/docs/helpdb/Base.jl#L1798-L1803">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.parentindexes" href="#Base.parentindexes"><code>Base.parentindexes</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">parentindexes(A)</code></pre><p>From an array view <code>A</code>, returns the corresponding indexes in the parent.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/subarray.jl#L64-L68">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.slicedim" href="#Base.slicedim"><code>Base.slicedim</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">slicedim(A, d::Integer, i)</code></pre><p>Return all the data of <code>A</code> where the index for dimension <code>d</code> equals <code>i</code>. Equivalent to <code>A[:,:,...,i,:,:,...]</code> where <code>i</code> is in position <code>d</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1 2 3 4; 5 6 7 8]
2×4 Array{Int64,2}:
 1  2  3  4
 5  6  7  8

julia&gt; slicedim(A,2,3)
2-element Array{Int64,1}:
 3
 7</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/abstractarraymath.jl#L100-L118">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.reinterpret" href="#Base.reinterpret"><code>Base.reinterpret</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">reinterpret(type, A)</code></pre><p>Change the type-interpretation of a block of memory. For arrays, this constructs an array with the same binary data as the given array, but with the specified element type. For example, <code>reinterpret(Float32, UInt32(7))</code> interprets the 4 bytes corresponding to <code>UInt32(7)</code> as a <a href="../numbers/#Core.Float32"><code>Float32</code></a>.</p><div class="admonition warning"><div class="admonition-title">Warning</div><div class="admonition-text"><p>It is not allowed to <code>reinterpret</code> an array to an element type with a larger alignment then the alignment of the array. For a normal <code>Array</code>, this is the alignment of its element type. For a reinterpreted array, this is the alignment of the <code>Array</code> it was reinterpreted from. For example, <code>reinterpret(UInt32, UInt8[0, 0, 0, 0])</code> is not allowed but <code>reinterpret(UInt32, reinterpret(UInt8, Float32[1.0]))</code> is allowed.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; reinterpret(Float32, UInt32(7))
1.0f-44

julia&gt; reinterpret(Float32, UInt32[1 2 3 4 5])
1×5 Array{Float32,2}:
 1.4013f-45  2.8026f-45  4.2039f-45  5.60519f-45  7.00649f-45</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/docs/helpdb/Base.jl#L1245-L1272">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.reshape" href="#Base.reshape"><code>Base.reshape</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">reshape(A, dims...) -&gt; R
reshape(A, dims) -&gt; R</code></pre><p>Return an array <code>R</code> with the same data as <code>A</code>, but with different dimension sizes or number of dimensions. The two arrays share the same underlying data, so that setting elements of <code>R</code> alters the values of <code>A</code> and vice versa.</p><p>The new dimensions may be specified either as a list of arguments or as a shape tuple. At most one dimension may be specified with a <code>:</code>, in which case its length is computed such that its product with all the specified dimensions is equal to the length of the original array <code>A</code>. The total number of elements must not change.</p><pre><code class="language-julia-repl">julia&gt; A = collect(1:16)
16-element Array{Int64,1}:
  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16

julia&gt; reshape(A, (4, 4))
4×4 Array{Int64,2}:
 1  5   9  13
 2  6  10  14
 3  7  11  15
 4  8  12  16

julia&gt; reshape(A, 2, :)
2×8 Array{Int64,2}:
 1  3  5  7   9  11  13  15
 2  4  6  8  10  12  14  16</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/reshapedarray.jl#L39-L87">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.squeeze" href="#Base.squeeze"><code>Base.squeeze</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">squeeze(A, dims)</code></pre><p>Remove the dimensions specified by <code>dims</code> from array <code>A</code>. Elements of <code>dims</code> must be unique and within the range <code>1:ndims(A)</code>. <code>size(A,i)</code> must equal 1 for all <code>i</code> in <code>dims</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; a = reshape(collect(1:4),(2,2,1,1))
2×2×1×1 Array{Int64,4}:
[:, :, 1, 1] =
 1  3
 2  4

julia&gt; squeeze(a,3)
2×2×1 Array{Int64,3}:
[:, :, 1] =
 1  3
 2  4</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/abstractarraymath.jl#L45-L66">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.vec" href="#Base.vec"><code>Base.vec</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">vec(a::AbstractArray) -&gt; Vector</code></pre><p>Reshape the array <code>a</code> as a one-dimensional column vector. The resulting array shares the same underlying data as <code>a</code>, so modifying one will also modify the other.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; a = [1 2 3; 4 5 6]
2×3 Array{Int64,2}:
 1  2  3
 4  5  6

julia&gt; vec(a)
6-element Array{Int64,1}:
 1
 4
 2
 5
 3
 6</code></pre><p>See also <a href="#Base.reshape"><code>reshape</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/abstractarraymath.jl#L12-L37">source</a></section><h2><a class="nav-anchor" id="Concatenation-and-permutation-1" href="#Concatenation-and-permutation-1">Concatenation and permutation</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.cat" href="#Base.cat"><code>Base.cat</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">cat(dims, A...)</code></pre><p>Concatenate the input arrays along the specified dimensions in the iterable <code>dims</code>. For dimensions not in <code>dims</code>, all input arrays should have the same size, which will also be the size of the output array along that dimension. For dimensions in <code>dims</code>, the size of the output array is the sum of the sizes of the input arrays along that dimension. If <code>dims</code> is a single number, the different arrays are tightly stacked along that dimension. If <code>dims</code> is an iterable containing several dimensions, this allows one to construct block diagonal matrices and their higher-dimensional analogues by simultaneously increasing several dimensions for every new input array and putting zero blocks elsewhere. For example, <code>cat([1,2], matrices...)</code> builds a block diagonal matrix, i.e. a block matrix with <code>matrices[1]</code>, <code>matrices[2]</code>, ... as diagonal blocks and matching zero blocks away from the diagonal.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/docs/helpdb/Base.jl#L1836-L1850">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.vcat" href="#Base.vcat"><code>Base.vcat</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">vcat(A...)</code></pre><p>Concatenate along dimension 1.</p><pre><code class="language-julia-repl">julia&gt; a = [1 2 3 4 5]
1×5 Array{Int64,2}:
 1  2  3  4  5

julia&gt; b = [6 7 8 9 10; 11 12 13 14 15]
2×5 Array{Int64,2}:
  6   7   8   9  10
 11  12  13  14  15

julia&gt; vcat(a,b)
3×5 Array{Int64,2}:
  1   2   3   4   5
  6   7   8   9  10
 11  12  13  14  15

julia&gt; c = ([1 2 3], [4 5 6])
([1 2 3], [4 5 6])

julia&gt; vcat(c...)
2×3 Array{Int64,2}:
 1  2  3
 4  5  6</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/abstractarray.jl#L1230-L1259">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.hcat" href="#Base.hcat"><code>Base.hcat</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">hcat(A...)</code></pre><p>Concatenate along dimension 2.</p><pre><code class="language-julia-repl">julia&gt; a = [1; 2; 3; 4; 5]
5-element Array{Int64,1}:
 1
 2
 3
 4
 5

julia&gt; b = [6 7; 8 9; 10 11; 12 13; 14 15]
5×2 Array{Int64,2}:
  6   7
  8   9
 10  11
 12  13
 14  15

julia&gt; hcat(a,b)
5×3 Array{Int64,2}:
 1   6   7
 2   8   9
 3  10  11
 4  12  13
 5  14  15

julia&gt; c = ([1; 2; 3], [4; 5; 6])
([1, 2, 3], [4, 5, 6])

julia&gt; hcat(c...)
3×2 Array{Int64,2}:
 1  4
 2  5
 3  6</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/abstractarray.jl#L1261-L1300">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.hvcat" href="#Base.hvcat"><code>Base.hvcat</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">hvcat(rows::Tuple{Vararg{Int}}, values...)</code></pre><p>Horizontal and vertical concatenation in one call. This function is called for block matrix syntax. The first argument specifies the number of arguments to concatenate in each block row.</p><pre><code class="language-julia-repl">julia&gt; a, b, c, d, e, f = 1, 2, 3, 4, 5, 6
(1, 2, 3, 4, 5, 6)

julia&gt; [a b c; d e f]
2×3 Array{Int64,2}:
 1  2  3
 4  5  6

julia&gt; hvcat((3,3), a,b,c,d,e,f)
2×3 Array{Int64,2}:
 1  2  3
 4  5  6

julia&gt; [a b;c d; e f]
3×2 Array{Int64,2}:
 1  2
 3  4
 5  6

julia&gt; hvcat((2,2,2), a,b,c,d,e,f)
3×2 Array{Int64,2}:
 1  2
 3  4
 5  6</code></pre><p>If the first argument is a single integer <code>n</code>, then all block rows are assumed to have <code>n</code> block columns.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/abstractarray.jl#L1335-L1371">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.flipdim" href="#Base.flipdim"><code>Base.flipdim</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">flipdim(A, d::Integer)</code></pre><p>Reverse <code>A</code> in dimension <code>d</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; b = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; flipdim(b,2)
2×2 Array{Int64,2}:
 2  1
 4  3</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/abstractarraymath.jl#L126-L143">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.circshift" href="#Base.circshift"><code>Base.circshift</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">circshift(A, shifts)</code></pre><p>Circularly shift the data in an array. The second argument is a vector giving the amount to shift in each dimension.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; b = reshape(collect(1:16), (4,4))
4×4 Array{Int64,2}:
 1  5   9  13
 2  6  10  14
 3  7  11  15
 4  8  12  16

julia&gt; circshift(b, (0,2))
4×4 Array{Int64,2}:
  9  13  1  5
 10  14  2  6
 11  15  3  7
 12  16  4  8

julia&gt; circshift(b, (-1,0))
4×4 Array{Int64,2}:
 2  6  10  14
 3  7  11  15
 4  8  12  16
 1  5   9  13</code></pre><p>See also <a href="#Base.circshift!"><code>circshift!</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/abstractarraymath.jl#L178-L209">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.circshift!" href="#Base.circshift!"><code>Base.circshift!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">circshift!(dest, src, shifts)</code></pre><p>Circularly shift the data in <code>src</code>, storing the result in <code>dest</code>. <code>shifts</code> specifies the amount to shift in each dimension.</p><p>The <code>dest</code> array must be distinct from the <code>src</code> array (they cannot alias each other).</p><p>See also <a href="#Base.circshift"><code>circshift</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/multidimensional.jl#L897-L907">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.circcopy!" href="#Base.circcopy!"><code>Base.circcopy!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">circcopy!(dest, src)</code></pre><p>Copy <code>src</code> to <code>dest</code>, indexing each dimension modulo its length. <code>src</code> and <code>dest</code> must have the same size, but can be offset in their indices; any offset results in a (circular) wraparound. If the arrays have overlapping indices, then on the domain of the overlap <code>dest</code> agrees with <code>src</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; src = reshape(collect(1:16), (4,4))
4×4 Array{Int64,2}:
 1  5   9  13
 2  6  10  14
 3  7  11  15
 4  8  12  16

julia&gt; dest = OffsetArray{Int}((0:3,2:5))

julia&gt; circcopy!(dest, src)
OffsetArrays.OffsetArray{Int64,2,Array{Int64,2}} with indices 0:3×2:5:
 8  12  16  4
 5   9  13  1
 6  10  14  2
 7  11  15  3

julia&gt; dest[1:3,2:4] == src[1:3,2:4]
true</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/multidimensional.jl#L950-L980">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.contains-Tuple{Function,Any,Any}" href="#Base.contains-Tuple{Function,Any,Any}"><code>Base.contains</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">contains(fun, itr, x) -&gt; Bool</code></pre><p>Returns <code>true</code> if there is at least one element <code>y</code> in <code>itr</code> such that <code>fun(y,x)</code> is <code>true</code>.</p><pre><code class="language-julia-repl">julia&gt; vec = [10, 100, 200]
3-element Array{Int64,1}:
  10
 100
 200

julia&gt; contains(==, vec, 200)
true

julia&gt; contains(==, vec, 300)
false

julia&gt; contains(&gt;, vec, 100)
true

julia&gt; contains(&gt;, vec, 200)
false</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/reduce.jl#L638-L662">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.find-Tuple{Any}" href="#Base.find-Tuple{Any}"><code>Base.find</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">find(A)</code></pre><p>Return a vector of the linear indexes of the non-zeros in <code>A</code> (determined by <code>A[i]!=0</code>). A common use of this is to convert a boolean array to an array of indexes of the <code>true</code> elements. If there are no non-zero elements of <code>A</code>, <code>find</code> returns an empty array.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [true false; false true]
2×2 Array{Bool,2}:
  true  false
 false   true

julia&gt; find(A)
2-element Array{Int64,1}:
 1
 4

julia&gt; find(zeros(3))
0-element Array{Int64,1}</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/array.jl#L1527-L1549">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.find-Tuple{Function,Any}" href="#Base.find-Tuple{Function,Any}"><code>Base.find</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">find(f::Function, A)</code></pre><p>Return a vector <code>I</code> of the linear indexes of <code>A</code> where <code>f(A[I])</code> returns <code>true</code>. If there are no such elements of <code>A</code>, find returns an empty array.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; find(isodd,A)
2-element Array{Int64,1}:
 1
 2

julia&gt; find(isodd, [2, 4])
0-element Array{Int64,1}</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/array.jl#L1488-L1509">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.findn" href="#Base.findn"><code>Base.findn</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">findn(A)</code></pre><p>Return a vector of indexes for each dimension giving the locations of the non-zeros in <code>A</code> (determined by <code>A[i]!=0</code>). If there are no non-zero elements of <code>A</code>, <code>findn</code> returns a 2-tuple of empty arrays.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1 2 0; 0 0 3; 0 4 0]
3×3 Array{Int64,2}:
 1  2  0
 0  0  3
 0  4  0

julia&gt; findn(A)
([1, 1, 3, 2], [1, 2, 2, 3])

julia&gt; A = zeros(2,2)
2×2 Array{Float64,2}:
 0.0  0.0
 0.0  0.0

julia&gt; findn(A)
(Int64[], Int64[])</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/array.jl#L1569-L1595">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.findnz" href="#Base.findnz"><code>Base.findnz</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">findnz(A)</code></pre><p>Return a tuple <code>(I, J, V)</code> where <code>I</code> and <code>J</code> are the row and column indexes of the non-zero values in matrix <code>A</code>, and <code>V</code> is a vector of the non-zero values.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1 2 0; 0 0 3; 0 4 0]
3×3 Array{Int64,2}:
 1  2  0
 0  0  3
 0  4  0

julia&gt; findnz(A)
([1, 1, 3, 2], [1, 2, 2, 3], [1, 2, 4, 3])</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/array.jl#L1611-L1628">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.findfirst-Tuple{Any}" href="#Base.findfirst-Tuple{Any}"><code>Base.findfirst</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">findfirst(A)</code></pre><p>Return the linear index of the first non-zero value in <code>A</code> (determined by <code>A[i]!=0</code>). Returns <code>0</code> if no such value is found.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [0 0; 1 0]
2×2 Array{Int64,2}:
 0  0
 1  0

julia&gt; findfirst(A)
2

julia&gt; findfirst(zeros(3))
0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/array.jl#L1214-L1233">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.findfirst-Tuple{Any,Any}" href="#Base.findfirst-Tuple{Any,Any}"><code>Base.findfirst</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">findfirst(A, v)</code></pre><p>Return the linear index of the first element equal to <code>v</code> in <code>A</code>. Returns <code>0</code> if <code>v</code> is not found.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [4 6; 2 2]
2×2 Array{Int64,2}:
 4  6
 2  2

julia&gt; findfirst(A,2)
2

julia&gt; findfirst(A,3)
0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/array.jl#L1263-L1282">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.findfirst-Tuple{Function,Any}" href="#Base.findfirst-Tuple{Function,Any}"><code>Base.findfirst</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">findfirst(predicate::Function, A)</code></pre><p>Return the linear index of the first element of <code>A</code> for which <code>predicate</code> returns <code>true</code>. Returns <code>0</code> if there is no such element.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1 4; 2 2]
2×2 Array{Int64,2}:
 1  4
 2  2

julia&gt; findfirst(iseven, A)
2

julia&gt; findfirst(x -&gt; x&gt;10, A)
0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/array.jl#L1313-L1332">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.findlast-Tuple{Any}" href="#Base.findlast-Tuple{Any}"><code>Base.findlast</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">findlast(A)</code></pre><p>Return the linear index of the last non-zero value in <code>A</code> (determined by <code>A[i]!=0</code>). Returns <code>0</code> if there is no non-zero value in <code>A</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1 0; 1 0]
2×2 Array{Int64,2}:
 1  0
 1  0

julia&gt; findlast(A)
2

julia&gt; A = zeros(2,2)
2×2 Array{Float64,2}:
 0.0  0.0
 0.0  0.0

julia&gt; findlast(A)
0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/array.jl#L1361-L1385">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.findlast-Tuple{Any,Any}" href="#Base.findlast-Tuple{Any,Any}"><code>Base.findlast</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">findlast(A, v)</code></pre><p>Return the linear index of the last element equal to <code>v</code> in <code>A</code>. Returns <code>0</code> if there is no element of <code>A</code> equal to <code>v</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1 2; 2 1]
2×2 Array{Int64,2}:
 1  2
 2  1

julia&gt; findlast(A,1)
4

julia&gt; findlast(A,2)
3

julia&gt; findlast(A,3)
0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/array.jl#L1414-L1436">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.findlast-Tuple{Function,Any}" href="#Base.findlast-Tuple{Function,Any}"><code>Base.findlast</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">findlast(predicate::Function, A)</code></pre><p>Return the linear index of the last element of <code>A</code> for which <code>predicate</code> returns <code>true</code>. Returns <code>0</code> if there is no such element.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; findlast(isodd, A)
2

julia&gt; findlast(x -&gt; x &gt; 5, A)
0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/array.jl#L1466-L1485">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.findnext-Tuple{Any,Integer}" href="#Base.findnext-Tuple{Any,Integer}"><code>Base.findnext</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">findnext(A, i::Integer)</code></pre><p>Find the next linear index &gt;= <code>i</code> of a non-zero element of <code>A</code>, or <code>0</code> if not found.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [0 0; 1 0]
2×2 Array{Int64,2}:
 0  0
 1  0

julia&gt; findnext(A,1)
2

julia&gt; findnext(A,3)
0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/array.jl#L1186-L1204">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.findnext-Tuple{Function,Any,Integer}" href="#Base.findnext-Tuple{Function,Any,Integer}"><code>Base.findnext</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">findnext(predicate::Function, A, i::Integer)</code></pre><p>Find the next linear index &gt;= <code>i</code> of an element of <code>A</code> for which <code>predicate</code> returns <code>true</code>, or <code>0</code> if not found.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1 4; 2 2]
2×2 Array{Int64,2}:
 1  4
 2  2

julia&gt; findnext(isodd, A, 1)
1

julia&gt; findnext(isodd, A, 2)
0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/array.jl#L1285-L1303">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.findnext-Tuple{Any,Any,Integer}" href="#Base.findnext-Tuple{Any,Any,Integer}"><code>Base.findnext</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">findnext(A, v, i::Integer)</code></pre><p>Find the next linear index &gt;= <code>i</code> of an element of <code>A</code> equal to <code>v</code> (using <code>==</code>), or <code>0</code> if not found.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1 4; 2 2]
2×2 Array{Int64,2}:
 1  4
 2  2

julia&gt; findnext(A,4,4)
0

julia&gt; findnext(A,4,3)
3</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/array.jl#L1236-L1254">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.findprev-Tuple{Any,Integer}" href="#Base.findprev-Tuple{Any,Integer}"><code>Base.findprev</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">findprev(A, i::Integer)</code></pre><p>Find the previous linear index &lt;= <code>i</code> of a non-zero element of <code>A</code>, or <code>0</code> if not found.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [0 0; 1 2]
2×2 Array{Int64,2}:
 0  0
 1  2

julia&gt; findprev(A,2)
2

julia&gt; findprev(A,1)
0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/array.jl#L1335-L1353">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.findprev-Tuple{Function,Any,Integer}" href="#Base.findprev-Tuple{Function,Any,Integer}"><code>Base.findprev</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">findprev(predicate::Function, A, i::Integer)</code></pre><p>Find the previous linear index &lt;= <code>i</code> of an element of <code>A</code> for which <code>predicate</code> returns <code>true</code>, or <code>0</code> if not found.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [4 6; 1 2]
2×2 Array{Int64,2}:
 4  6
 1  2

julia&gt; findprev(isodd, A, 1)
0

julia&gt; findprev(isodd, A, 3)
2</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/array.jl#L1439-L1458">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.findprev-Tuple{Any,Any,Integer}" href="#Base.findprev-Tuple{Any,Any,Integer}"><code>Base.findprev</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">findprev(A, v, i::Integer)</code></pre><p>Find the previous linear index &lt;= <code>i</code> of an element of <code>A</code> equal to <code>v</code> (using <code>==</code>), or <code>0</code> if not found.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [0 0; 1 2]
2×2 Array{Int64,2}:
 0  0
 1  2

julia&gt; findprev(A, 1, 4)
2

julia&gt; findprev(A, 1, 1)
0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/array.jl#L1388-L1406">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.permutedims" href="#Base.permutedims"><code>Base.permutedims</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">permutedims(A, perm)</code></pre><p>Permute the dimensions of array <code>A</code>. <code>perm</code> is a vector specifying a permutation of length <code>ndims(A)</code>. This is a generalization of transpose for multi-dimensional arrays. Transpose is equivalent to <code>permutedims(A, [2,1])</code>.</p><p>See also: <a href="#Base.PermutedDimsArrays.PermutedDimsArray"><code>PermutedDimsArray</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; A = reshape(collect(1:8), (2,2,2))
2×2×2 Array{Int64,3}:
[:, :, 1] =
 1  3
 2  4

[:, :, 2] =
 5  7
 6  8

julia&gt; permutedims(A, [3, 2, 1])
2×2×2 Array{Int64,3}:
[:, :, 1] =
 1  3
 5  7

[:, :, 2] =
 2  4
 6  8</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/permuteddimsarray.jl#L83-L114">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.permutedims!" href="#Base.permutedims!"><code>Base.permutedims!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">permutedims!(dest, src, perm)</code></pre><p>Permute the dimensions of array <code>src</code> and store the result in the array <code>dest</code>. <code>perm</code> is a vector specifying a permutation of length <code>ndims(src)</code>. The preallocated array <code>dest</code> should have <code>size(dest) == size(src)[perm]</code> and is completely overwritten. No in-place permutation is supported and unexpected results will happen if <code>src</code> and <code>dest</code> have overlapping memory regions.</p><p>See also <a href="#Base.permutedims"><code>permutedims</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/permuteddimsarray.jl#L120-L130">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.PermutedDimsArrays.PermutedDimsArray" href="#Base.PermutedDimsArrays.PermutedDimsArray"><code>Base.PermutedDimsArrays.PermutedDimsArray</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">PermutedDimsArray(A, perm) -&gt; B</code></pre><p>Given an AbstractArray <code>A</code>, create a view <code>B</code> such that the dimensions appear to be permuted. Similar to <code>permutedims</code>, except that no copying occurs (<code>B</code> shares storage with <code>A</code>).</p><p>See also: <a href="#Base.permutedims"><code>permutedims</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; A = rand(3,5,4);

julia&gt; B = PermutedDimsArray(A, (3,1,2));

julia&gt; size(B)
(4, 3, 5)

julia&gt; B[3,1,2] == A[1,2,3]
true</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/permuteddimsarray.jl#L19-L41">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.promote_shape" href="#Base.promote_shape"><code>Base.promote_shape</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">promote_shape(s1, s2)</code></pre><p>Check two array shapes for compatibility, allowing trailing singleton dimensions, and return whichever shape has more dimensions.</p><pre><code class="language-julia-repl">julia&gt; a = ones(3,4,1,1,1);

julia&gt; b = ones(3,4);

julia&gt; promote_shape(a,b)
(Base.OneTo(3), Base.OneTo(4), Base.OneTo(1), Base.OneTo(1), Base.OneTo(1))

julia&gt; promote_shape((2,3,1,4), (2, 3, 1, 4, 1))
(2, 3, 1, 4, 1)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/indices.jl#L34-L51">source</a></section><h2><a class="nav-anchor" id="Array-functions-1" href="#Array-functions-1">Array functions</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.accumulate-Tuple{Any,Any,Integer}" href="#Base.accumulate-Tuple{Any,Any,Integer}"><code>Base.accumulate</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">accumulate(op, A, dim=1)</code></pre><p>Cumulative operation <code>op</code> along a dimension <code>dim</code> (defaults to 1). See also <a href="#Base.accumulate!"><code>accumulate!</code></a> to use a preallocated output array, both for performance and to control the precision of the output (e.g. to avoid overflow). For common operations there are specialized variants of <code>accumulate</code>, see: <a href="#Base.cumsum"><code>cumsum</code></a>, <a href="#Base.cumprod"><code>cumprod</code></a></p><pre><code class="language-julia-repl">julia&gt; accumulate(+, [1,2,3])
3-element Array{Int64,1}:
 1
 3
 6

julia&gt; accumulate(*, [1,2,3])
3-element Array{Int64,1}:
 1
 2
 6</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/multidimensional.jl#L710-L732">source</a><div><pre><code class="language-none">accumulate(op, v0, A)</code></pre><p>Like <code>accumulate</code>, but using a starting element <code>v0</code>. The first entry of the result will be <code>op(v0, first(A))</code>. For example:</p><pre><code class="language-julia-repl">julia&gt; accumulate(+, 100, [1,2,3])
3-element Array{Int64,1}:
 101
 103
 106

julia&gt; accumulate(min, 0, [1,2,-1])
3-element Array{Int64,1}:
  0
  0
 -1</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/multidimensional.jl#L739-L758">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.accumulate!" href="#Base.accumulate!"><code>Base.accumulate!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">accumulate!(op, B, A, dim=1)</code></pre><p>Cumulative operation <code>op</code> on <code>A</code> along a dimension, storing the result in <code>B</code>. The dimension defaults to 1. See also <a href="#Base.accumulate-Tuple{Any,Any,Integer}"><code>accumulate</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/multidimensional.jl#L793-L798">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.cumprod" href="#Base.cumprod"><code>Base.cumprod</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">cumprod(A, dim=1)</code></pre><p>Cumulative product along a dimension <code>dim</code> (defaults to 1). See also <a href="#Base.cumprod!"><code>cumprod!</code></a> to use a preallocated output array, both for performance and to control the precision of the output (e.g. to avoid overflow).</p><pre><code class="language-julia-repl">julia&gt; a = [1 2 3; 4 5 6]
2×3 Array{Int64,2}:
 1  2  3
 4  5  6

julia&gt; cumprod(a,1)
2×3 Array{Int64,2}:
 1   2   3
 4  10  18

julia&gt; cumprod(a,2)
2×3 Array{Int64,2}:
 1   2    6
 4  20  120</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/multidimensional.jl#L676-L699">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.cumprod!" href="#Base.cumprod!"><code>Base.cumprod!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">cumprod!(B, A, dim::Integer=1)</code></pre><p>Cumulative product of <code>A</code> along a dimension, storing the result in <code>B</code>. The dimension defaults to 1. See also <a href="#Base.cumprod"><code>cumprod</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/multidimensional.jl#L702-L707">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.cumsum" href="#Base.cumsum"><code>Base.cumsum</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">cumsum(A, dim=1)</code></pre><p>Cumulative sum along a dimension <code>dim</code> (defaults to 1). See also <a href="#Base.cumsum!"><code>cumsum!</code></a> to use a preallocated output array, both for performance and to control the precision of the output (e.g. to avoid overflow).</p><pre><code class="language-julia-repl">julia&gt; a = [1 2 3; 4 5 6]
2×3 Array{Int64,2}:
 1  2  3
 4  5  6

julia&gt; cumsum(a,1)
2×3 Array{Int64,2}:
 1  2  3
 5  7  9

julia&gt; cumsum(a,2)
2×3 Array{Int64,2}:
 1  3   6
 4  9  15</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/multidimensional.jl#L639-L662">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.cumsum!" href="#Base.cumsum!"><code>Base.cumsum!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">cumsum!(B, A, dim::Integer=1)</code></pre><p>Cumulative sum of <code>A</code> along a dimension, storing the result in <code>B</code>. The dimension defaults to 1. See also <a href="#Base.cumsum"><code>cumsum</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/multidimensional.jl#L668-L673">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.cumsum_kbn" href="#Base.cumsum_kbn"><code>Base.cumsum_kbn</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">cumsum_kbn(A, [dim::Integer=1])</code></pre><p>Cumulative sum along a dimension, using the Kahan-Babuska-Neumaier compensated summation algorithm for additional accuracy. The dimension defaults to 1.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/abstractarraymath.jl#L240-L245">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.diff" href="#Base.LinAlg.diff"><code>Base.LinAlg.diff</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">diff(A, [dim::Integer=1])</code></pre><p>Finite difference operator of matrix or vector <code>A</code>. If <code>A</code> is a matrix, compute the finite difference over a dimension <code>dim</code> (default <code>1</code>).</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; a = [2 4; 6 16]
2×2 Array{Int64,2}:
 2   4
 6  16

julia&gt; diff(a,2)
2×1 Array{Int64,2}:
  2
 10</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/generic.jl#L251-L270">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.gradient" href="#Base.LinAlg.gradient"><code>Base.LinAlg.gradient</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">gradient(F::AbstractVector, [h::Real])</code></pre><p>Compute differences along vector <code>F</code>, using <code>h</code> as the spacing between points. The default spacing is one.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; a = [2,4,6,8];

julia&gt; gradient(a)
4-element Array{Float64,1}:
 2.0
 2.0
 2.0
 2.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/generic.jl#L284-L302">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.rot180" href="#Base.rot180"><code>Base.rot180</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">rot180(A)</code></pre><p>Rotate matrix <code>A</code> 180 degrees.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; a = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; rot180(a)
2×2 Array{Int64,2}:
 4  3
 2  1</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/arraymath.jl#L170-L187">source</a><div><pre><code class="language-none">rot180(A, k)</code></pre><p>Rotate matrix <code>A</code> 180 degrees an integer <code>k</code> number of times. If <code>k</code> is even, this is equivalent to a <code>copy</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; rot180(a,1)
2×2 Array{Int64,2}:
 4  3
 2  1

julia&gt; rot180(a,2)
2×2 Array{Int64,2}:
 1  2
 3  4</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/arraymath.jl#L272-L295">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.rotl90" href="#Base.rotl90"><code>Base.rotl90</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">rotl90(A)</code></pre><p>Rotate matrix <code>A</code> left 90 degrees.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; a = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; rotl90(a)
2×2 Array{Int64,2}:
 2  4
 1  3</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/arraymath.jl#L115-L132">source</a><div><pre><code class="language-none">rotl90(A, k)</code></pre><p>Rotate matrix <code>A</code> left 90 degrees an integer <code>k</code> number of times. If <code>k</code> is zero or a multiple of four, this is equivalent to a <code>copy</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; rotl90(a,1)
2×2 Array{Int64,2}:
 2  4
 1  3

julia&gt; rotl90(a,2)
2×2 Array{Int64,2}:
 4  3
 2  1

julia&gt; rotl90(a,3)
2×2 Array{Int64,2}:
 3  1
 4  2

julia&gt; rotl90(a,4)
2×2 Array{Int64,2}:
 1  2
 3  4</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/arraymath.jl#L197-L230">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.rotr90" href="#Base.rotr90"><code>Base.rotr90</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">rotr90(A)</code></pre><p>Rotate matrix <code>A</code> right 90 degrees.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; a = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; rotr90(a)
2×2 Array{Int64,2}:
 3  1
 4  2</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/arraymath.jl#L143-L160">source</a><div><pre><code class="language-none">rotr90(A, k)</code></pre><p>Rotate matrix <code>A</code> right 90 degrees an integer <code>k</code> number of times. If <code>k</code> is zero or a multiple of four, this is equivalent to a <code>copy</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; rotr90(a,1)
2×2 Array{Int64,2}:
 3  1
 4  2

julia&gt; rotr90(a,2)
2×2 Array{Int64,2}:
 4  3
 2  1

julia&gt; rotr90(a,3)
2×2 Array{Int64,2}:
 2  4
 1  3

julia&gt; rotr90(a,4)
2×2 Array{Int64,2}:
 1  2
 3  4</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/arraymath.jl#L237-L270">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.reducedim" href="#Base.reducedim"><code>Base.reducedim</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">reducedim(f, A, region[, v0])</code></pre><p>Reduce 2-argument function <code>f</code> along dimensions of <code>A</code>. <code>region</code> is a vector specifying the dimensions to reduce, and <code>v0</code> is the initial value to use in the reductions. For <code>+</code>, <code>*</code>, <code>max</code> and <code>min</code> the <code>v0</code> argument is optional.</p><p>The associativity of the reduction is implementation-dependent; if you need a particular associativity, e.g. left-to-right, you should write your own loop. See documentation for <a href="../collections/#Base.reduce-Tuple{Any,Any,Any}"><code>reduce</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = reshape(collect(1:16), (4,4))
4×4 Array{Int64,2}:
 1  5   9  13
 2  6  10  14
 3  7  11  15
 4  8  12  16

julia&gt; reducedim(max, a, 2)
4×1 Array{Int64,2}:
 13
 14
 15
 16

julia&gt; reducedim(max, a, 1)
1×4 Array{Int64,2}:
 4  8  12  16</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/reducedim.jl#L245-L276">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.mapreducedim" href="#Base.mapreducedim"><code>Base.mapreducedim</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">mapreducedim(f, op, A, region[, v0])</code></pre><p>Evaluates to the same as <code>reducedim(op, map(f, A), region, f(v0))</code>, but is generally faster because the intermediate array is avoided.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = reshape(collect(1:16), (4,4))
4×4 Array{Int64,2}:
 1  5   9  13
 2  6  10  14
 3  7  11  15
 4  8  12  16

julia&gt; mapreducedim(isodd, *, a, 1)
1×4 Array{Bool,2}:
 false  false  false  false

julia&gt; mapreducedim(isodd, |, a, 1, true)
1×4 Array{Bool,2}:
 true  true  true  true</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/reducedim.jl#L216-L239">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.mapslices" href="#Base.mapslices"><code>Base.mapslices</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">mapslices(f, A, dims)</code></pre><p>Transform the given dimensions of array <code>A</code> using function <code>f</code>. <code>f</code> is called on each slice of <code>A</code> of the form <code>A[...,:,...,:,...]</code>. <code>dims</code> is an integer vector specifying where the colons go in this expression. The results are concatenated along the remaining dimensions. For example, if <code>dims</code> is <code>[1,2]</code> and <code>A</code> is 4-dimensional, <code>f</code> is called on <code>A[:,:,i,j]</code> for all <code>i</code> and <code>j</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = reshape(collect(1:16),(2,2,2,2))
2×2×2×2 Array{Int64,4}:
[:, :, 1, 1] =
 1  3
 2  4

[:, :, 2, 1] =
 5  7
 6  8

[:, :, 1, 2] =
  9  11
 10  12

[:, :, 2, 2] =
 13  15
 14  16

julia&gt; mapslices(sum, a, [1,2])
1×1×2×2 Array{Int64,4}:
[:, :, 1, 1] =
 10

[:, :, 2, 1] =
 26

[:, :, 1, 2] =
 42

[:, :, 2, 2] =
 58</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/abstractarray.jl#L1741-L1784">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.sum_kbn" href="#Base.sum_kbn"><code>Base.sum_kbn</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">sum_kbn(A)</code></pre><p>Returns the sum of all elements of <code>A</code>, using the Kahan-Babuska-Neumaier compensated summation algorithm for additional accuracy.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/reduce.jl#L366-L371">source</a></section><h2><a class="nav-anchor" id="Combinatorics-1" href="#Combinatorics-1">Combinatorics</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Random.randperm" href="#Base.Random.randperm"><code>Base.Random.randperm</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">randperm([rng=GLOBAL_RNG,] n::Integer)</code></pre><p>Construct a random permutation of length <code>n</code>. The optional <code>rng</code> argument specifies a random number generator (see <a href="../numbers/#Random-Numbers-1">Random Numbers</a>). To randomly permute a arbitrary vector, see <a href="#Base.Random.shuffle"><code>shuffle</code></a> or <a href="#Base.Random.shuffle!"><code>shuffle!</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; rng = MersenneTwister(1234);

julia&gt; randperm(rng, 4)
4-element Array{Int64,1}:
 2
 1
 4
 3</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/random.jl#L1666-L1686">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.invperm" href="#Base.invperm"><code>Base.invperm</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">invperm(v)</code></pre><p>Return the inverse permutation of <code>v</code>. If <code>B = A[v]</code>, then <code>A == B[invperm(v)]</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; v = [2; 4; 3; 1];

julia&gt; invperm(v)
4-element Array{Int64,1}:
 4
 1
 3
 2

julia&gt; A = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;];

julia&gt; B = A[v]
4-element Array{Char,1}:
 &#39;b&#39;
 &#39;d&#39;
 &#39;c&#39;
 &#39;a&#39;

julia&gt; B[invperm(v)]
4-element Array{Char,1}:
 &#39;a&#39;
 &#39;b&#39;
 &#39;c&#39;
 &#39;d&#39;</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/combinatorics.jl#L182-L215">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isperm" href="#Base.isperm"><code>Base.isperm</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">isperm(v) -&gt; Bool</code></pre><p>Returns <code>true</code> if <code>v</code> is a valid permutation.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; isperm([1; 2])
true

julia&gt; isperm([1; 3])
false</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/combinatorics.jl#L59-L72">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.permute!-Tuple{Any,AbstractArray{T,1} where T}" href="#Base.permute!-Tuple{Any,AbstractArray{T,1} where T}"><code>Base.permute!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">permute!(v, p)</code></pre><p>Permute vector <code>v</code> in-place, according to permutation <code>p</code>. No checking is done to verify that <code>p</code> is a permutation.</p><p>To return a new permutation, use <code>v[p]</code>. Note that this is generally faster than <code>permute!(v,p)</code> for large vectors.</p><p>See also <a href="#Base.ipermute!"><code>ipermute!</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1, 1, 3, 4];

julia&gt; perm = [2, 4, 3, 1];

julia&gt; permute!(A, perm);

julia&gt; A
4-element Array{Int64,1}:
 1
 4
 3
 1</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/combinatorics.jl#L107-L133">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.ipermute!" href="#Base.ipermute!"><code>Base.ipermute!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">ipermute!(v, p)</code></pre><p>Like <a href="#Base.permute!-Tuple{Any,AbstractArray{T,1} where T}"><code>permute!</code></a>, but the inverse of the given permutation is applied.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1, 1, 3, 4];

julia&gt; perm = [2, 4, 3, 1];

julia&gt; ipermute!(A, perm);

julia&gt; A
4-element Array{Int64,1}:
 4
 1
 3
 1</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/combinatorics.jl#L159-L179">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Random.randcycle" href="#Base.Random.randcycle"><code>Base.Random.randcycle</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">randcycle([rng=GLOBAL_RNG,] n::Integer)</code></pre><p>Construct a random cyclic permutation of length <code>n</code>. The optional <code>rng</code> argument specifies a random number generator, see <a href="../numbers/#Random-Numbers-1">Random Numbers</a>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; rng = MersenneTwister(1234);

julia&gt; randcycle(rng, 6)
6-element Array{Int64,1}:
 3
 5
 4
 6
 1
 2</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/random.jl#L1707-L1727">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Random.shuffle" href="#Base.Random.shuffle"><code>Base.Random.shuffle</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">shuffle([rng=GLOBAL_RNG,] v)</code></pre><p>Return a randomly permuted copy of <code>v</code>. The optional <code>rng</code> argument specifies a random number generator (see <a href="../numbers/#Random-Numbers-1">Random Numbers</a>). To permute <code>v</code> in-place, see <a href="#Base.Random.shuffle!"><code>shuffle!</code></a>.  To obtain randomly permuted indices, see <a href="#Base.Random.randperm"><code>randperm</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; rng = MersenneTwister(1234);

julia&gt; shuffle(rng, collect(1:10))
10-element Array{Int64,1}:
  6
  1
 10
  2
  3
  9
  5
  7
  4
  8</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/random.jl#L1636-L1662">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Random.shuffle!" href="#Base.Random.shuffle!"><code>Base.Random.shuffle!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">shuffle!([rng=GLOBAL_RNG,] v)</code></pre><p>In-place version of <a href="#Base.Random.shuffle"><code>shuffle</code></a>: randomly permute the array <code>v</code> in-place, optionally supplying the random-number generator <code>rng</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; rng = MersenneTwister(1234);

julia&gt; shuffle!(rng, collect(1:16))
16-element Array{Int64,1}:
  2
 15
  5
 14
  1
  9
 10
  6
 11
  3
 16
  7
  4
 12
  8
 13</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/random.jl#L1591-L1621">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.reverse" href="#Base.reverse"><code>Base.reverse</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">reverse(v [, start=1 [, stop=length(v) ]] )</code></pre><p>Return a copy of <code>v</code> reversed from start to stop.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = collect(1:5)
5-element Array{Int64,1}:
 1
 2
 3
 4
 5

julia&gt; reverse(A)
5-element Array{Int64,1}:
 5
 4
 3
 2
 1

julia&gt; reverse(A, 1, 4)
5-element Array{Int64,1}:
 4
 3
 2
 1
 5

julia&gt; reverse(A, 3, 5)
5-element Array{Int64,1}:
 1
 2
 5
 4
 3</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/docs/helpdb/Base.jl#L700-L739">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.reverseind" href="#Base.reverseind"><code>Base.reverseind</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">reverseind(v, i)</code></pre><p>Given an index <code>i</code> in <code>reverse(v)</code>, return the corresponding index in <code>v</code> so that <code>v[reverseind(v,i)] == reverse(v)[i]</code>. (This can be nontrivial in the case where <code>v</code> is a Unicode string.)</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/docs/helpdb/Base.jl#L2440-L2446">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.reverse!" href="#Base.reverse!"><code>Base.reverse!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">reverse!(v [, start=1 [, stop=length(v) ]]) -&gt; v</code></pre><p>In-place version of <a href="#Base.reverse"><code>reverse</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/docs/helpdb/Base.jl#L742-L746">source</a></section><h2><a class="nav-anchor" id="BitArrays-1" href="#BitArrays-1">BitArrays</a></h2><p><code>BitArray</code>s are space-efficient &quot;packed&quot; boolean arrays, which store one bit per boolean value.  They can be used similarly to <code>Array{Bool}</code> arrays (which store one byte per boolean value), and can be converted to/from the latter via <code>Array(bitarray)</code> and <code>BitArray(array)</code>, respectively.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.flipbits!" href="#Base.flipbits!"><code>Base.flipbits!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">flipbits!(B::BitArray{N}) -&gt; BitArray{N}</code></pre><p>Performs a bitwise not operation on <code>B</code>. See <a href="../math/#Base.:~"><code>~</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; A = trues(2,2)
2×2 BitArray{2}:
 true  true
 true  true

julia&gt; flipbits!(A)
2×2 BitArray{2}:
 false  false
 false  false</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/bitarray.jl#L1143-L1160">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.rol!" href="#Base.rol!"><code>Base.rol!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">rol!(dest::BitVector, src::BitVector, i::Integer) -&gt; BitVector</code></pre><p>Performs a left rotation operation on <code>src</code> and puts the result into <code>dest</code>. <code>i</code> controls how far to rotate the bits.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/bitarray.jl#L1468-L1473">source</a><div><pre><code class="language-none">rol!(B::BitVector, i::Integer) -&gt; BitVector</code></pre><p>Performs a left rotation operation in-place on <code>B</code>. <code>i</code> controls how far to rotate the bits.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/bitarray.jl#L1486-L1491">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.rol" href="#Base.rol"><code>Base.rol</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">rol(B::BitVector, i::Integer) -&gt; BitVector</code></pre><p>Performs a left rotation operation, returning a new <code>BitVector</code>. <code>i</code> controls how far to rotate the bits. See also <a href="#Base.rol!"><code>rol!</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = BitArray([true, true, false, false, true])
5-element BitArray{1}:
  true
  true
 false
 false
  true

julia&gt; rol(A,1)
5-element BitArray{1}:
  true
 false
 false
  true
  true

julia&gt; rol(A,2)
5-element BitArray{1}:
 false
 false
  true
  true
  true

julia&gt; rol(A,5)
5-element BitArray{1}:
  true
  true
 false
 false
  true</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/bitarray.jl#L1494-L1535">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.ror!" href="#Base.ror!"><code>Base.ror!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">ror!(dest::BitVector, src::BitVector, i::Integer) -&gt; BitVector</code></pre><p>Performs a right rotation operation on <code>src</code> and puts the result into <code>dest</code>. <code>i</code> controls how far to rotate the bits.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/bitarray.jl#L1538-L1543">source</a><div><pre><code class="language-none">ror!(B::BitVector, i::Integer) -&gt; BitVector</code></pre><p>Performs a right rotation operation in-place on <code>B</code>. <code>i</code> controls how far to rotate the bits.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/bitarray.jl#L1556-L1561">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.ror" href="#Base.ror"><code>Base.ror</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">ror(B::BitVector, i::Integer) -&gt; BitVector</code></pre><p>Performs a right rotation operation on <code>B</code>, returning a new <code>BitVector</code>. <code>i</code> controls how far to rotate the bits. See also <a href="#Base.ror!"><code>ror!</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = BitArray([true, true, false, false, true])
5-element BitArray{1}:
  true
  true
 false
 false
  true

julia&gt; ror(A,1)
5-element BitArray{1}:
  true
  true
  true
 false
 false

julia&gt; ror(A,2)
5-element BitArray{1}:
 false
  true
  true
  true
 false

julia&gt; ror(A,5)
5-element BitArray{1}:
  true
  true
 false
 false
  true</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/bitarray.jl#L1564-L1605">source</a></section><h2><a class="nav-anchor" id="stdlib-sparse-arrays-1" href="#stdlib-sparse-arrays-1">Sparse Vectors and Matrices</a></h2><p>Sparse vectors and matrices largely support the same set of operations as their dense counterparts. The following functions are specific to sparse arrays.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.SparseArrays.SparseVector" href="#Base.SparseArrays.SparseVector"><code>Base.SparseArrays.SparseVector</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">SparseVector{Tv,Ti&lt;:Integer} &lt;: AbstractSparseVector{Tv,Ti}</code></pre><p>Vector type for storing sparse vectors.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/sparse/sparsevector.jl#L12-L16">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.SparseArrays.SparseMatrixCSC" href="#Base.SparseArrays.SparseMatrixCSC"><code>Base.SparseArrays.SparseMatrixCSC</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">SparseMatrixCSC{Tv,Ti&lt;:Integer} &lt;: AbstractSparseMatrix{Tv,Ti}</code></pre><p>Matrix type for storing sparse matrices in the <a href="../../manual/arrays/#man-csc-1">Compressed Sparse Column</a> format.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/sparse/sparsematrix.jl#L8-L13">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.SparseArrays.sparse" href="#Base.SparseArrays.sparse"><code>Base.SparseArrays.sparse</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">sparse(A)</code></pre><p>Convert an AbstractMatrix <code>A</code> into a sparse matrix.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; A = eye(3)
3×3 Array{Float64,2}:
 1.0  0.0  0.0
 0.0  1.0  0.0
 0.0  0.0  1.0

julia&gt; sparse(A)
3×3 SparseMatrixCSC{Float64,Int64} with 3 stored entries:
  [1, 1]  =  1.0
  [2, 2]  =  1.0
  [3, 3]  =  1.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/sparse/sparsematrix.jl#L386-L405">source</a><div><pre><code class="language-none">sparse(I, J, V,[ m, n, combine])</code></pre><p>Create a sparse matrix <code>S</code> of dimensions <code>m x n</code> such that <code>S[I[k], J[k]] = V[k]</code>. The <code>combine</code> function is used to combine duplicates. If <code>m</code> and <code>n</code> are not specified, they are set to <code>maximum(I)</code> and <code>maximum(J)</code> respectively. If the <code>combine</code> function is not supplied, <code>combine</code> defaults to <code>+</code> unless the elements of <code>V</code> are Booleans in which case <code>combine</code> defaults to <code>|</code>. All elements of <code>I</code> must satisfy <code>1 &lt;= I[k] &lt;= m</code>, and all elements of <code>J</code> must satisfy <code>1 &lt;= J[k] &lt;= n</code>. Numerical zeros in (<code>I</code>, <code>J</code>, <code>V</code>) are retained as structural nonzeros; to drop numerical zeros, use <a href="#Base.SparseArrays.dropzeros!-Tuple{SparseMatrixCSC,Bool}"><code>dropzeros!</code></a>.</p><p>For additional documentation and an expert driver, see <code>Base.SparseArrays.sparse!</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; Is = [1; 2; 3];

julia&gt; Js = [1; 2; 3];

julia&gt; Vs = [1; 2; 3];

julia&gt; sparse(Is, Js, Vs)
3×3 SparseMatrixCSC{Int64,Int64} with 3 stored entries:
  [1, 1]  =  1
  [2, 2]  =  2
  [3, 3]  =  3</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/sparse/sparsematrix.jl#L459-L486">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.SparseArrays.sparsevec" href="#Base.SparseArrays.sparsevec"><code>Base.SparseArrays.sparsevec</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">sparsevec(I, V, [m, combine])</code></pre><p>Create a sparse vector <code>S</code> of length <code>m</code> such that <code>S[I[k]] = V[k]</code>. Duplicates are combined using the <code>combine</code> function, which defaults to <code>+</code> if no <code>combine</code> argument is provided, unless the elements of <code>V</code> are Booleans in which case <code>combine</code> defaults to <code>|</code>.</p><pre><code class="language-julia-repl">julia&gt; II = [1, 3, 3, 5]; V = [0.1, 0.2, 0.3, 0.2];

julia&gt; sparsevec(II, V)
5-element SparseVector{Float64,Int64} with 3 stored entries:
  [1]  =  0.1
  [3]  =  0.5
  [5]  =  0.2

julia&gt; sparsevec(II, V, 8, -)
8-element SparseVector{Float64,Int64} with 3 stored entries:
  [1]  =  0.1
  [3]  =  -0.1
  [5]  =  0.2

julia&gt; sparsevec([1, 3, 1, 2, 2], [true, true, false, false, false])
3-element SparseVector{Bool,Int64} with 3 stored entries:
  [1]  =  true
  [2]  =  false
  [3]  =  true</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/sparse/sparsevector.jl#L103-L132">source</a><div><pre><code class="language-none">sparsevec(d::Dict, [m])</code></pre><p>Create a sparse vector of length <code>m</code> where the nonzero indices are keys from the dictionary, and the nonzero values are the values from the dictionary.</p><pre><code class="language-julia-repl">julia&gt; sparsevec(Dict(1 =&gt; 3, 2 =&gt; 2))
2-element SparseVector{Int64,Int64} with 2 stored entries:
  [1]  =  3
  [2]  =  2</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/sparse/sparsevector.jl#L178-L190">source</a><div><pre><code class="language-none">sparsevec(A)</code></pre><p>Convert a vector <code>A</code> into a sparse vector of length <code>m</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; sparsevec([1.0, 2.0, 0.0, 0.0, 3.0, 0.0])
6-element SparseVector{Float64,Int64} with 3 stored entries:
  [1]  =  1.0
  [2]  =  2.0
  [5]  =  3.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/sparse/sparsevector.jl#L309-L322">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.SparseArrays.issparse" href="#Base.SparseArrays.issparse"><code>Base.SparseArrays.issparse</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">issparse(S)</code></pre><p>Returns <code>true</code> if <code>S</code> is sparse, and <code>false</code> otherwise.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/sparse/abstractsparse.jl#L8-L12">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.full" href="#Base.full"><code>Base.full</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">full(S)</code></pre><p>Convert a sparse matrix or vector <code>S</code> into a dense matrix or vector.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; A = speye(3)
3×3 SparseMatrixCSC{Float64,Int64} with 3 stored entries:
  [1, 1]  =  1.0
  [2, 2]  =  1.0
  [3, 3]  =  1.0

julia&gt; full(A)
3×3 Array{Float64,2}:
 1.0  0.0  0.0
 0.0  1.0  0.0
 0.0  0.0  1.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/sparse/sparsematrix.jl#L355-L374">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.SparseArrays.nnz" href="#Base.SparseArrays.nnz"><code>Base.SparseArrays.nnz</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">nnz(A)</code></pre><p>Returns the number of stored (filled) elements in a sparse array.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; A = speye(3)
3×3 SparseMatrixCSC{Float64,Int64} with 3 stored entries:
  [1, 1]  =  1.0
  [2, 2]  =  1.0
  [3, 3]  =  1.0

julia&gt; nnz(A)
3</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/sparse/sparsematrix.jl#L36-L52">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.SparseArrays.spzeros" href="#Base.SparseArrays.spzeros"><code>Base.SparseArrays.spzeros</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">spzeros([type,]m[,n])</code></pre><p>Create a sparse vector of length <code>m</code> or sparse matrix of size <code>m x n</code>. This sparse array will not contain any nonzero values. No storage will be allocated for nonzero values during construction. The type defaults to <a href="../numbers/#Core.Float64"><code>Float64</code></a> if not specified.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; spzeros(3, 3)
3×3 SparseMatrixCSC{Float64,Int64} with 0 stored entries

julia&gt; spzeros(Float32, 4)
4-element SparseVector{Float32,Int64} with 0 stored entries</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/sparse/sparsematrix.jl#L1435-L1451">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.SparseArrays.spones" href="#Base.SparseArrays.spones"><code>Base.SparseArrays.spones</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">spones(S)</code></pre><p>Create a sparse array with the same structure as that of <code>S</code>, but with every nonzero element having the value <code>1.0</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; A = sparse([1,2,3,4],[2,4,3,1],[5.,4.,3.,2.])
4×4 SparseMatrixCSC{Float64,Int64} with 4 stored entries:
  [4, 1]  =  2.0
  [1, 2]  =  5.0
  [3, 3]  =  3.0
  [2, 4]  =  4.0

julia&gt; spones(A)
4×4 SparseMatrixCSC{Float64,Int64} with 4 stored entries:
  [4, 1]  =  1.0
  [1, 2]  =  1.0
  [3, 3]  =  1.0
  [2, 4]  =  1.0</code></pre><p>Note the difference from <a href="#Base.SparseArrays.speye-Tuple{Type,Integer,Integer}"><code>speye</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/sparse/sparsematrix.jl#L1407-L1431">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.SparseArrays.speye-Tuple{Type,Integer,Integer}" href="#Base.SparseArrays.speye-Tuple{Type,Integer,Integer}"><code>Base.SparseArrays.speye</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">speye([type,]m[,n])</code></pre><p>Create a sparse identity matrix of size <code>m x m</code>. When <code>n</code> is supplied, create a sparse identity matrix of size <code>m x n</code>. The type defaults to <a href="../numbers/#Core.Float64"><code>Float64</code></a> if not specified.</p><p><code>sparse(I, m, n)</code> is equivalent to <code>speye(Int, m, n)</code>, and <code>sparse(α*I, m, n)</code> can be used to efficiently create a sparse multiple <code>α</code> of the identity matrix.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/sparse/sparsematrix.jl#L1494-L1504">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.SparseArrays.speye-Tuple{SparseMatrixCSC}" href="#Base.SparseArrays.speye-Tuple{SparseMatrixCSC}"><code>Base.SparseArrays.speye</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">speye(S)</code></pre><p>Create a sparse identity matrix with the same size as <code>S</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; A = sparse([1,2,3,4],[2,4,3,1],[5.,4.,3.,2.])
4×4 SparseMatrixCSC{Float64,Int64} with 4 stored entries:
  [4, 1]  =  2.0
  [1, 2]  =  5.0
  [3, 3]  =  3.0
  [2, 4]  =  4.0

julia&gt; speye(A)
4×4 SparseMatrixCSC{Float64,Int64} with 4 stored entries:
  [1, 1]  =  1.0
  [2, 2]  =  1.0
  [3, 3]  =  1.0
  [4, 4]  =  1.0</code></pre><p>Note the difference from <a href="#Base.SparseArrays.spones"><code>spones</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/sparse/sparsematrix.jl#L1467-L1490">source</a><div><pre><code class="language-none">speye([type,]m[,n])</code></pre><p>Create a sparse identity matrix of size <code>m x m</code>. When <code>n</code> is supplied, create a sparse identity matrix of size <code>m x n</code>. The type defaults to <a href="numbers/#Core.Float64"><code>Float64</code></a> if not specified.</p><p><code>sparse(I, m, n)</code> is equivalent to <code>speye(Int, m, n)</code>, and <code>sparse(α*I, m, n)</code> can be used to efficiently create a sparse multiple <code>α</code> of the identity matrix.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/sparse/sparsematrix.jl#L1494-L1504">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.SparseArrays.spdiagm" href="#Base.SparseArrays.spdiagm"><code>Base.SparseArrays.spdiagm</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">spdiagm(B, d[, m, n])</code></pre><p>Construct a sparse diagonal matrix. <code>B</code> is a tuple of vectors containing the diagonals and <code>d</code> is a tuple containing the positions of the diagonals. In the case the input contains only one diagonal, <code>B</code> can be a vector (instead of a tuple) and <code>d</code> can be the diagonal position (instead of a tuple), defaulting to 0 (diagonal). Optionally, <code>m</code> and <code>n</code> specify the size of the resulting sparse matrix.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; spdiagm(([1,2,3,4],[4,3,2,1]),(-1,1))
5×5 SparseMatrixCSC{Int64,Int64} with 8 stored entries:
  [2, 1]  =  1
  [1, 2]  =  4
  [3, 2]  =  2
  [2, 3]  =  3
  [4, 3]  =  3
  [3, 4]  =  2
  [5, 4]  =  4
  [4, 5]  =  1</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/sparse/sparsematrix.jl#L3288-L3310">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.SparseArrays.sprand" href="#Base.SparseArrays.sprand"><code>Base.SparseArrays.sprand</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">sprand([rng],[type],m,[n],p::AbstractFloat,[rfn])</code></pre><p>Create a random length <code>m</code> sparse vector or <code>m</code> by <code>n</code> sparse matrix, in which the probability of any element being nonzero is independently given by <code>p</code> (and hence the mean density of nonzeros is also exactly <code>p</code>). Nonzero values are sampled from the distribution specified by <code>rfn</code> and have the type <code>type</code>. The uniform distribution is used in case <code>rfn</code> is not specified. The optional <code>rng</code> argument specifies a random number generator, see <a href="../numbers/#Random-Numbers-1">Random Numbers</a>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; rng = MersenneTwister(1234);

julia&gt; sprand(rng, Bool, 2, 2, 0.5)
2×2 SparseMatrixCSC{Bool,Int64} with 2 stored entries:
  [1, 1]  =  true
  [2, 1]  =  true

julia&gt; sprand(rng, Float64, 3, 0.75)
3-element SparseVector{Float64,Int64} with 1 stored entry:
  [3]  =  0.298614</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/sparse/sparsematrix.jl#L1330-L1353">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.SparseArrays.sprandn" href="#Base.SparseArrays.sprandn"><code>Base.SparseArrays.sprandn</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">sprandn([rng], m[,n],p::AbstractFloat)</code></pre><p>Create a random sparse vector of length <code>m</code> or sparse matrix of size <code>m</code> by <code>n</code> with the specified (independent) probability <code>p</code> of any entry being nonzero, where nonzero values are sampled from the normal distribution. The optional <code>rng</code> argument specifies a random number generator, see <a href="../numbers/#Random-Numbers-1">Random Numbers</a>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; rng = MersenneTwister(1234);

julia&gt; sprandn(rng, 2, 2, 0.75)
2×2 SparseMatrixCSC{Float64,Int64} with 3 stored entries:
  [1, 1]  =  0.532813
  [2, 1]  =  -0.271735
  [2, 2]  =  0.502334</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/sparse/sparsematrix.jl#L1384-L1402">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.SparseArrays.nonzeros" href="#Base.SparseArrays.nonzeros"><code>Base.SparseArrays.nonzeros</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">nonzeros(A)</code></pre><p>Return a vector of the structural nonzero values in sparse array <code>A</code>. This includes zeros that are explicitly stored in the sparse array. The returned vector points directly to the internal nonzero storage of <code>A</code>, and any modifications to the returned vector will mutate <code>A</code> as well. See <a href="#Base.SparseArrays.rowvals"><code>rowvals</code></a> and <a href="#Base.SparseArrays.nzrange"><code>nzrange</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; A = speye(3)
3×3 SparseMatrixCSC{Float64,Int64} with 3 stored entries:
  [1, 1]  =  1.0
  [2, 2]  =  1.0
  [3, 3]  =  1.0

julia&gt; nonzeros(A)
3-element Array{Float64,1}:
 1.0
 1.0
 1.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/sparse/sparsematrix.jl#L57-L80">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.SparseArrays.rowvals" href="#Base.SparseArrays.rowvals"><code>Base.SparseArrays.rowvals</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">rowvals(A::SparseMatrixCSC)</code></pre><p>Return a vector of the row indices of <code>A</code>. Any modifications to the returned vector will mutate <code>A</code> as well. Providing access to how the row indices are stored internally can be useful in conjunction with iterating over structural nonzero values. See also <a href="#Base.SparseArrays.nonzeros"><code>nonzeros</code></a> and <a href="#Base.SparseArrays.nzrange"><code>nzrange</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; A = speye(3)
3×3 SparseMatrixCSC{Float64,Int64} with 3 stored entries:
  [1, 1]  =  1.0
  [2, 2]  =  1.0
  [3, 3]  =  1.0

julia&gt; rowvals(A)
3-element Array{Int64,1}:
 1
 2
 3</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/sparse/sparsematrix.jl#L83-L105">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.SparseArrays.nzrange" href="#Base.SparseArrays.nzrange"><code>Base.SparseArrays.nzrange</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">nzrange(A::SparseMatrixCSC, col::Integer)</code></pre><p>Return the range of indices to the structural nonzero values of a sparse matrix column. In conjunction with <a href="#Base.SparseArrays.nonzeros"><code>nonzeros</code></a> and <a href="#Base.SparseArrays.rowvals"><code>rowvals</code></a>, this allows for convenient iterating over a sparse matrix :</p><pre><code class="language-none">A = sparse(I,J,V)
rows = rowvals(A)
vals = nonzeros(A)
m, n = size(A)
for i = 1:n
   for j in nzrange(A, i)
      row = rows[j]
      val = vals[j]
      # perform sparse wizardry...
   end
end</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/sparse/sparsematrix.jl#L108-L126">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.SparseArrays.dropzeros!-Tuple{SparseMatrixCSC,Bool}" href="#Base.SparseArrays.dropzeros!-Tuple{SparseMatrixCSC,Bool}"><code>Base.SparseArrays.dropzeros!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">dropzeros!(A::SparseMatrixCSC, trim::Bool = true)</code></pre><p>Removes stored numerical zeros from <code>A</code>, optionally trimming resulting excess space from <code>A.rowval</code> and <code>A.nzval</code> when <code>trim</code> is <code>true</code>.</p><p>For an out-of-place version, see <a href="#Base.SparseArrays.dropzeros-Tuple{SparseMatrixCSC,Bool}"><code>dropzeros</code></a>. For algorithmic information, see <code>fkeep!</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/sparse/sparsematrix.jl#L1199-L1207">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.SparseArrays.dropzeros-Tuple{SparseMatrixCSC,Bool}" href="#Base.SparseArrays.dropzeros-Tuple{SparseMatrixCSC,Bool}"><code>Base.SparseArrays.dropzeros</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">dropzeros(A::SparseMatrixCSC, trim::Bool = true)</code></pre><p>Generates a copy of <code>A</code> and removes stored numerical zeros from that copy, optionally trimming excess space from the result&#39;s <code>rowval</code> and <code>nzval</code> arrays when <code>trim</code> is <code>true</code>.</p><p>For an in-place version and algorithmic information, see <a href="#Base.SparseArrays.dropzeros!-Tuple{SparseMatrixCSC,Bool}"><code>dropzeros!</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; A = sparse([1, 2, 3], [1, 2, 3], [1.0, 0.0, 1.0])
3×3 SparseMatrixCSC{Float64,Int64} with 3 stored entries:
  [1, 1]  =  1.0
  [2, 2]  =  0.0
  [3, 3]  =  1.0

julia&gt; dropzeros(A)
3×3 SparseMatrixCSC{Float64,Int64} with 2 stored entries:
  [1, 1]  =  1.0
  [3, 3]  =  1.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/sparse/sparsematrix.jl#L1209-L1230">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.SparseArrays.dropzeros!-Tuple{SparseVector,Bool}" href="#Base.SparseArrays.dropzeros!-Tuple{SparseVector,Bool}"><code>Base.SparseArrays.dropzeros!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">dropzeros!(x::SparseVector, trim::Bool = true)</code></pre><p>Removes stored numerical zeros from <code>x</code>, optionally trimming resulting excess space from <code>x.nzind</code> and <code>x.nzval</code> when <code>trim</code> is <code>true</code>.</p><p>For an out-of-place version, see <a href="#Base.SparseArrays.dropzeros-Tuple{SparseMatrixCSC,Bool}"><code>dropzeros</code></a>. For algorithmic information, see <code>fkeep!</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/sparse/sparsevector.jl#L1921-L1929">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.SparseArrays.dropzeros-Tuple{SparseVector,Bool}" href="#Base.SparseArrays.dropzeros-Tuple{SparseVector,Bool}"><code>Base.SparseArrays.dropzeros</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">dropzeros(x::SparseVector, trim::Bool = true)</code></pre><p>Generates a copy of <code>x</code> and removes numerical zeros from that copy, optionally trimming excess space from the result&#39;s <code>nzind</code> and <code>nzval</code> arrays when <code>trim</code> is <code>true</code>.</p><p>For an in-place version and algorithmic information, see <a href="#Base.SparseArrays.dropzeros!-Tuple{SparseMatrixCSC,Bool}"><code>dropzeros!</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; A = sparsevec([1, 2, 3], [1.0, 0.0, 1.0])
3-element SparseVector{Float64,Int64} with 3 stored entries:
  [1]  =  1.0
  [2]  =  0.0
  [3]  =  1.0

julia&gt; dropzeros(A)
3-element SparseVector{Float64,Int64} with 2 stored entries:
  [1]  =  1.0
  [3]  =  1.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/sparse/sparsevector.jl#L1931-L1952">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.SparseArrays.permute" href="#Base.SparseArrays.permute"><code>Base.SparseArrays.permute</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">permute{Tv,Ti}(A::SparseMatrixCSC{Tv,Ti}, p::AbstractVector{&lt;:Integer},
    q::AbstractVector{&lt;:Integer})</code></pre><p>Bilaterally permute <code>A</code>, returning <code>PAQ</code> (<code>A[p,q]</code>). Column-permutation <code>q</code>&#39;s length must match <code>A</code>&#39;s column count (<code>length(q) == A.n</code>). Row-permutation <code>p</code>&#39;s length must match <code>A</code>&#39;s row count (<code>length(p) == A.m</code>).</p><p>For expert drivers and additional information, see <a href="#Base.permute!-Tuple{Any,AbstractArray{T,1} where T}"><code>permute!</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; A = spdiagm([1, 2, 3, 4], 0, 4, 4) + spdiagm([5, 6, 7], 1, 4, 4)
4×4 SparseMatrixCSC{Int64,Int64} with 7 stored entries:
  [1, 1]  =  1
  [1, 2]  =  5
  [2, 2]  =  2
  [2, 3]  =  6
  [3, 3]  =  3
  [3, 4]  =  7
  [4, 4]  =  4

julia&gt; permute(A, [4, 3, 2, 1], [1, 2, 3, 4])
4×4 SparseMatrixCSC{Int64,Int64} with 7 stored entries:
  [4, 1]  =  1
  [3, 2]  =  2
  [4, 2]  =  5
  [2, 3]  =  3
  [3, 3]  =  6
  [1, 4]  =  4
  [2, 4]  =  7

julia&gt; permute(A, [1, 2, 3, 4], [4, 3, 2, 1])
4×4 SparseMatrixCSC{Int64,Int64} with 7 stored entries:
  [3, 1]  =  7
  [4, 1]  =  4
  [2, 2]  =  6
  [3, 2]  =  3
  [1, 3]  =  5
  [2, 3]  =  2
  [1, 4]  =  1</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/sparse/sparsematrix.jl#L1060-L1102">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.permute!-Union{Tuple{SparseMatrixCSC{Tv,Ti},SparseMatrixCSC{Tv,Ti},AbstractArray{Tp,1},AbstractArray{Tq,1}}, Tuple{Ti}, Tuple{Tp}, Tuple{Tq}, Tuple{Tv}} where Tq&lt;:Integer where Tp&lt;:Integer where Ti where Tv" href="#Base.permute!-Union{Tuple{SparseMatrixCSC{Tv,Ti},SparseMatrixCSC{Tv,Ti},AbstractArray{Tp,1},AbstractArray{Tq,1}}, Tuple{Ti}, Tuple{Tp}, Tuple{Tq}, Tuple{Tv}} where Tq&lt;:Integer where Tp&lt;:Integer where Ti where Tv"><code>Base.permute!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">permute!{Tv,Ti}(X::SparseMatrixCSC{Tv,Ti}, A::SparseMatrixCSC{Tv,Ti},
    p::AbstractVector{&lt;:Integer}, q::AbstractVector{&lt;:Integer}[, C::SparseMatrixCSC{Tv,Ti}])</code></pre><p>Bilaterally permute <code>A</code>, storing result <code>PAQ</code> (<code>A[p,q]</code>) in <code>X</code>. Stores intermediate result <code>(AQ)^T</code> (<code>transpose(A[:,q])</code>) in optional argument <code>C</code> if present. Requires that none of <code>X</code>, <code>A</code>, and, if present, <code>C</code> alias each other; to store result <code>PAQ</code> back into <code>A</code>, use the following method lacking <code>X</code>:</p><pre><code class="language-none">permute!{Tv,Ti}(A::SparseMatrixCSC{Tv,Ti}, p::AbstractVector{&lt;:Integer},
    q::AbstractVector{&lt;:Integer}[, C::SparseMatrixCSC{Tv,Ti}[, workcolptr::Vector{Ti}]])</code></pre><p><code>X</code>&#39;s dimensions must match those of <code>A</code> (<code>X.m == A.m</code> and <code>X.n == A.n</code>), and <code>X</code> must have enough storage to accommodate all allocated entries in <code>A</code> (<code>length(X.rowval) &gt;= nnz(A)</code> and <code>length(X.nzval) &gt;= nnz(A)</code>). Column-permutation <code>q</code>&#39;s length must match <code>A</code>&#39;s column count (<code>length(q) == A.n</code>). Row-permutation <code>p</code>&#39;s length must match <code>A</code>&#39;s row count (<code>length(p) == A.m</code>).</p><p><code>C</code>&#39;s dimensions must match those of <code>transpose(A)</code> (<code>C.m == A.n</code> and <code>C.n == A.m</code>), and <code>C</code> must have enough storage to accommodate all allocated entries in <code>A</code> (<code>length(C.rowval) &gt;= nnz(A)</code> and <code>length(C.nzval) &gt;= nnz(A)</code>).</p><p>For additional (algorithmic) information, and for versions of these methods that forgo argument checking, see (unexported) parent methods <code>unchecked_noalias_permute!</code> and <code>unchecked_aliasing_permute!</code>.</p><p>See also: <a href="#Base.SparseArrays.permute"><code>permute</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/sparse/sparsematrix.jl#L990-L1017">source</a></section><footer><hr/><a class="previous" href="../strings/"><span class="direction">Previous</span><span class="title">Strings</span></a><a class="next" href="../parallel/"><span class="direction">Next</span><span class="title">Tasks and Parallel Computing</span></a></footer></article></body></html>
