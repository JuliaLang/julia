<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Linear Algebra · The Julia Language</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-28835595-6', 'auto');
ga('send', 'pageview');
</script><link rel="canonical" href="https://docs.julialang.org/en/stable/stdlib/linalg/index.html"/><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../../assets/julia-manual.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../../index.html"><img class="logo" src="../../assets/logo.png" alt="The Julia Language logo"/></a><h1>The Julia Language</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../../manual/introduction/">Introduction</a></li><li><a class="toctext" href="../../manual/getting-started/">Getting Started</a></li><li><a class="toctext" href="../../manual/variables/">Variables</a></li><li><a class="toctext" href="../../manual/integers-and-floating-point-numbers/">Integers and Floating-Point Numbers</a></li><li><a class="toctext" href="../../manual/mathematical-operations/">Mathematical Operations and Elementary Functions</a></li><li><a class="toctext" href="../../manual/complex-and-rational-numbers/">Complex and Rational Numbers</a></li><li><a class="toctext" href="../../manual/strings/">Strings</a></li><li><a class="toctext" href="../../manual/functions/">Functions</a></li><li><a class="toctext" href="../../manual/control-flow/">Control Flow</a></li><li><a class="toctext" href="../../manual/variables-and-scoping/">Scope of Variables</a></li><li><a class="toctext" href="../../manual/types/">Types</a></li><li><a class="toctext" href="../../manual/methods/">Methods</a></li><li><a class="toctext" href="../../manual/constructors/">Constructors</a></li><li><a class="toctext" href="../../manual/conversion-and-promotion/">Conversion and Promotion</a></li><li><a class="toctext" href="../../manual/interfaces/">Interfaces</a></li><li><a class="toctext" href="../../manual/modules/">Modules</a></li><li><a class="toctext" href="../../manual/documentation/">Documentation</a></li><li><a class="toctext" href="../../manual/metaprogramming/">Metaprogramming</a></li><li><a class="toctext" href="../../manual/arrays/">Multi-dimensional Arrays</a></li><li><a class="toctext" href="../../manual/linear-algebra/">Linear algebra</a></li><li><a class="toctext" href="../../manual/networking-and-streams/">Networking and Streams</a></li><li><a class="toctext" href="../../manual/parallel-computing/">Parallel Computing</a></li><li><a class="toctext" href="../../manual/dates/">Date and DateTime</a></li><li><a class="toctext" href="../../manual/interacting-with-julia/">Interacting With Julia</a></li><li><a class="toctext" href="../../manual/running-external-programs/">Running External Programs</a></li><li><a class="toctext" href="../../manual/calling-c-and-fortran-code/">Calling C and Fortran Code</a></li><li><a class="toctext" href="../../manual/handling-operating-system-variation/">Handling Operating System Variation</a></li><li><a class="toctext" href="../../manual/environment-variables/">Environment Variables</a></li><li><a class="toctext" href="../../manual/embedding/">Embedding Julia</a></li><li><a class="toctext" href="../../manual/packages/">Packages</a></li><li><a class="toctext" href="../../manual/profile/">Profiling</a></li><li><a class="toctext" href="../../manual/stacktraces/">Stack Traces</a></li><li><a class="toctext" href="../../manual/performance-tips/">Performance Tips</a></li><li><a class="toctext" href="../../manual/workflow-tips/">Workflow Tips</a></li><li><a class="toctext" href="../../manual/style-guide/">Style Guide</a></li><li><a class="toctext" href="../../manual/faq/">Frequently Asked Questions</a></li><li><a class="toctext" href="../../manual/noteworthy-differences/">Noteworthy Differences from other Languages</a></li><li><a class="toctext" href="../../manual/unicode-input/">Unicode Input</a></li></ul></li><li><span class="toctext">Standard Library</span><ul><li><a class="toctext" href="../base/">Essentials</a></li><li><a class="toctext" href="../collections/">Collections and Data Structures</a></li><li><a class="toctext" href="../math/">Mathematics</a></li><li><a class="toctext" href="../numbers/">Numbers</a></li><li><a class="toctext" href="../strings/">Strings</a></li><li><a class="toctext" href="../arrays/">Arrays</a></li><li><a class="toctext" href="../parallel/">Tasks and Parallel Computing</a></li><li class="current"><a class="toctext" href>Linear Algebra</a><ul class="internal"><li><a class="toctext" href="#Standard-Functions-1">Standard Functions</a></li><li><a class="toctext" href="#Low-level-matrix-operations-1">Low-level matrix operations</a></li><li><a class="toctext" href="#BLAS-Functions-1">BLAS Functions</a></li><li><a class="toctext" href="#LAPACK-Functions-1">LAPACK Functions</a></li></ul></li><li><a class="toctext" href="../constants/">Constants</a></li><li><a class="toctext" href="../file/">Filesystem</a></li><li><a class="toctext" href="../io-network/">I/O and Network</a></li><li><a class="toctext" href="../punctuation/">Punctuation</a></li><li><a class="toctext" href="../sort/">Sorting and Related Functions</a></li><li><a class="toctext" href="../pkg/">Package Manager Functions</a></li><li><a class="toctext" href="../dates/">Dates and Time</a></li><li><a class="toctext" href="../iterators/">Iteration utilities</a></li><li><a class="toctext" href="../test/">Unit Testing</a></li><li><a class="toctext" href="../c/">C Interface</a></li><li><a class="toctext" href="../libc/">C Standard Library</a></li><li><a class="toctext" href="../libdl/">Dynamic Linker</a></li><li><a class="toctext" href="../profile/">Profiling</a></li><li><a class="toctext" href="../stacktraces/">StackTraces</a></li><li><a class="toctext" href="../simd-types/">SIMD Support</a></li></ul></li><li><span class="toctext">Developer Documentation</span><ul><li><a class="toctext" href="../../devdocs/reflection/">Reflection and introspection</a></li><li><span class="toctext">Documentation of Julia&#39;s Internals</span><ul><li><a class="toctext" href="../../devdocs/init/">Initialization of the Julia runtime</a></li><li><a class="toctext" href="../../devdocs/ast/">Julia ASTs</a></li><li><a class="toctext" href="../../devdocs/types/">More about types</a></li><li><a class="toctext" href="../../devdocs/object/">Memory layout of Julia Objects</a></li><li><a class="toctext" href="../../devdocs/eval/">Eval of Julia code</a></li><li><a class="toctext" href="../../devdocs/callconv/">Calling Conventions</a></li><li><a class="toctext" href="../../devdocs/compiler/">High-level Overview of the Native-Code Generation Process</a></li><li><a class="toctext" href="../../devdocs/functions/">Julia Functions</a></li><li><a class="toctext" href="../../devdocs/cartesian/">Base.Cartesian</a></li><li><a class="toctext" href="../../devdocs/meta/">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="../../devdocs/subarrays/">SubArrays</a></li><li><a class="toctext" href="../../devdocs/sysimg/">System Image Building</a></li><li><a class="toctext" href="../../devdocs/llvm/">Working with LLVM</a></li><li><a class="toctext" href="../../devdocs/stdio/">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="../../devdocs/boundscheck/">Bounds checking</a></li><li><a class="toctext" href="../../devdocs/locks/">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="../../devdocs/offset-arrays/">Arrays with custom indices</a></li><li><a class="toctext" href="../../devdocs/libgit2/">Base.LibGit2</a></li><li><a class="toctext" href="../../devdocs/require/">Module loading</a></li></ul></li><li><span class="toctext">Developing/debugging Julia&#39;s C code</span><ul><li><a class="toctext" href="../../devdocs/backtraces/">Reporting and analyzing crashes (segfaults)</a></li><li><a class="toctext" href="../../devdocs/debuggingtips/">gdb debugging tips</a></li><li><a class="toctext" href="../../devdocs/valgrind/">Using Valgrind with Julia</a></li><li><a class="toctext" href="../../devdocs/sanitizers/">Sanitizer support</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Standard Library</li><li><a href>Linear Algebra</a></li></ul><a class="edit-page" href="https://github.com/JuliaLang/julia/blob/master/doc/src/stdlib/linalg.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Linear Algebra</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Linear-Algebra-1" href="#Linear-Algebra-1">Linear Algebra</a></h1><h2><a class="nav-anchor" id="Standard-Functions-1" href="#Standard-Functions-1">Standard Functions</a></h2><p>Linear algebra functions in Julia are largely implemented by calling functions from <a href="http://www.netlib.org/lapack/">LAPACK</a>.  Sparse factorizations call functions from <a href="http://faculty.cse.tamu.edu/davis/suitesparse.html">SuiteSparse</a>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:*-Tuple{AbstractArray,AbstractArray}" href="#Base.:*-Tuple{AbstractArray,AbstractArray}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">*(x, y...)</code></pre><p>Multiplication operator. <code>x*y*z*...</code> calls this function with all arguments, i.e. <code>*(x, y, z, ...)</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/docs/helpdb/Base.jl#L1917-L1923">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:\\-Tuple{AbstractArray,Any}" href="#Base.:\\-Tuple{AbstractArray,Any}"><code>Base.:\</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">\(x, y)</code></pre><p>Left division operator: multiplication of <code>y</code> by the inverse of <code>x</code> on the left. Gives floating-point results for integer arguments.</p><pre><code class="language-julia-repl">julia&gt; 3 \ 6
2.0

julia&gt; inv(3) * 6
2.0

julia&gt; A = [1 2; 3 4]; x = [5, 6];

julia&gt; A \ x
2-element Array{Float64,1}:
 -4.0
  4.5

julia&gt; inv(A) * x
2-element Array{Float64,1}:
 -4.0
  4.5</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/operators.jl#L431-L456">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.dot" href="#Base.LinAlg.dot"><code>Base.LinAlg.dot</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">dot(n, X, incx, Y, incy)</code></pre><p>Dot product of two vectors consisting of <code>n</code> elements of array <code>X</code> with stride <code>incx</code> and <code>n</code> elements of array <code>Y</code> with stride <code>incy</code>.</p><p><strong>Example:</strong></p><pre><code class="language-julia-repl">julia&gt; dot(10, ones(10), 1, ones(20), 2)
10.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/blas.jl#L213-L224">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.vecdot" href="#Base.LinAlg.vecdot"><code>Base.LinAlg.vecdot</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">vecdot(x, y)</code></pre><p>For any iterable containers <code>x</code> and <code>y</code> (including arrays of any dimension) of numbers (or any element type for which <code>dot</code> is defined), compute the Euclidean dot product (the sum of <code>dot(x[i],y[i])</code>) as if they were vectors.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; vecdot(1:5, 2:6)
70

julia&gt; x = fill(2., (5,5));

julia&gt; y = fill(3., (5,5));

julia&gt; vecdot(x, y)
150.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/generic.jl#L624-L643">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.cross" href="#Base.LinAlg.cross"><code>Base.LinAlg.cross</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">cross(x, y)
×(x,y)</code></pre><p>Compute the cross product of two 3-vectors.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; a = [0;1;0]
3-element Array{Int64,1}:
 0
 1
 0

julia&gt; b = [0;0;1]
3-element Array{Int64,1}:
 0
 0
 1

julia&gt; cross(a,b)
3-element Array{Int64,1}:
 1
 0
 0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/generic.jl#L88-L115">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.factorize" href="#Base.LinAlg.factorize"><code>Base.LinAlg.factorize</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">factorize(A)</code></pre><p>Compute a convenient factorization of <code>A</code>, based upon the type of the input matrix. <code>factorize</code> checks <code>A</code> to see if it is symmetric/triangular/etc. if <code>A</code> is passed as a generic matrix. <code>factorize</code> checks every element of <code>A</code> to verify/rule out each property. It will short-circuit as soon as it can rule out symmetry/triangular structure. The return value can be reused for efficient solving of multiple systems. For example: <code>A=factorize(A); x=A\b; y=A\C</code>.</p><table><tr><th>Properties of <code>A</code></th><th>type of factorization</th></tr><tr><td>Positive-definite</td><td>Cholesky (see <a href="#Base.LinAlg.cholfact"><code>cholfact</code></a>)</td></tr><tr><td>Dense Symmetric/Hermitian</td><td>Bunch-Kaufman (see <a href="#Base.LinAlg.bkfact"><code>bkfact</code></a>)</td></tr><tr><td>Sparse Symmetric/Hermitian</td><td>LDLt (see <a href="#Base.LinAlg.ldltfact"><code>ldltfact</code></a>)</td></tr><tr><td>Triangular</td><td>Triangular</td></tr><tr><td>Diagonal</td><td>Diagonal</td></tr><tr><td>Bidiagonal</td><td>Bidiagonal</td></tr><tr><td>Tridiagonal</td><td>LU (see <a href="#Base.LinAlg.lufact"><code>lufact</code></a>)</td></tr><tr><td>Symmetric real tridiagonal</td><td>LDLt (see <a href="#Base.LinAlg.ldltfact"><code>ldltfact</code></a>)</td></tr><tr><td>General square</td><td>LU (see <a href="#Base.LinAlg.lufact"><code>lufact</code></a>)</td></tr><tr><td>General non-square</td><td>QR (see <a href="#Base.LinAlg.qrfact"><code>qrfact</code></a>)</td></tr></table><p>If <code>factorize</code> is called on a Hermitian positive-definite matrix, for instance, then <code>factorize</code> will return a Cholesky factorization.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; A = Array(Bidiagonal(ones(5, 5), true))
5×5 Array{Float64,2}:
 1.0  1.0  0.0  0.0  0.0
 0.0  1.0  1.0  0.0  0.0
 0.0  0.0  1.0  1.0  0.0
 0.0  0.0  0.0  1.0  1.0
 0.0  0.0  0.0  0.0  1.0

julia&gt; factorize(A) # factorize will check to see that A is already factorized
5×5 Bidiagonal{Float64}:
 1.0  1.0   ⋅    ⋅    ⋅
  ⋅   1.0  1.0   ⋅    ⋅
  ⋅    ⋅   1.0  1.0   ⋅
  ⋅    ⋅    ⋅   1.0  1.0
  ⋅    ⋅    ⋅    ⋅   1.0</code></pre><p>This returns a <code>5×5 Bidiagonal{Float64}</code>, which can now be passed to other linear algebra functions (e.g. eigensolvers) which will use specialized methods for <code>Bidiagonal</code> types.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/dense.jl#L664-L711">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.Diagonal" href="#Base.LinAlg.Diagonal"><code>Base.LinAlg.Diagonal</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Diagonal(A::AbstractMatrix)</code></pre><p>Constructs a matrix from the diagonal of <code>A</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1 2 3; 4 5 6; 7 8 9]
3×3 Array{Int64,2}:
 1  2  3
 4  5  6
 7  8  9

julia&gt; Diagonal(A)
3×3 Diagonal{Int64}:
 1  ⋅  ⋅
 ⋅  5  ⋅
 ⋅  ⋅  9</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/diagonal.jl#L8-L28">source</a><div><pre><code class="language-none">Diagonal(V::AbstractVector)</code></pre><p>Constructs a matrix with <code>V</code> as its diagonal.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; V = [1; 2]
2-element Array{Int64,1}:
 1
 2

julia&gt; Diagonal(V)
2×2 Diagonal{Int64}:
 1  ⋅
 ⋅  2</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/diagonal.jl#L30-L48">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.Bidiagonal" href="#Base.LinAlg.Bidiagonal"><code>Base.LinAlg.Bidiagonal</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Bidiagonal(dv, ev, isupper::Bool)</code></pre><p>Constructs an upper (<code>isupper=true</code>) or lower (<code>isupper=false</code>) bidiagonal matrix using the given diagonal (<code>dv</code>) and off-diagonal (<code>ev</code>) vectors.  The result is of type <code>Bidiagonal</code> and provides efficient specialized linear solvers, but may be converted into a regular matrix with <a href="../base/#Base.convert"><code>convert(Array, _)</code></a> (or <code>Array(_)</code> for short). <code>ev</code>&#39;s length must be one less than the length of <code>dv</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; dv = [1; 2; 3; 4]
4-element Array{Int64,1}:
 1
 2
 3
 4

julia&gt; ev = [7; 8; 9]
3-element Array{Int64,1}:
 7
 8
 9

julia&gt; Bu = Bidiagonal(dv, ev, true) # ev is on the first superdiagonal
4×4 Bidiagonal{Int64}:
 1  7  ⋅  ⋅
 ⋅  2  8  ⋅
 ⋅  ⋅  3  9
 ⋅  ⋅  ⋅  4

julia&gt; Bl = Bidiagonal(dv, ev, false) # ev is on the first subdiagonal
4×4 Bidiagonal{Int64}:
 1  ⋅  ⋅  ⋅
 7  2  ⋅  ⋅
 ⋅  8  3  ⋅
 ⋅  ⋅  9  4</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/bidiag.jl#L15-L54">source</a><div><pre><code class="language-none">Bidiagonal(dv, ev, uplo::Char)</code></pre><p>Constructs an upper (<code>uplo=&#39;U&#39;</code>) or lower (<code>uplo=&#39;L&#39;</code>) bidiagonal matrix using the given diagonal (<code>dv</code>) and off-diagonal (<code>ev</code>) vectors.  The result is of type <code>Bidiagonal</code> and provides efficient specialized linear solvers, but may be converted into a regular matrix with <a href="../base/#Base.convert"><code>convert(Array, _)</code></a> (or <code>Array(_)</code> for short). <code>ev</code>&#39;s length must be one less than the length of <code>dv</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; dv = [1; 2; 3; 4]
4-element Array{Int64,1}:
 1
 2
 3
 4

julia&gt; ev = [7; 8; 9]
3-element Array{Int64,1}:
 7
 8
 9

julia&gt; Bu = Bidiagonal(dv, ev, &#39;U&#39;) #e is on the first superdiagonal
4×4 Bidiagonal{Int64}:
 1  7  ⋅  ⋅
 ⋅  2  8  ⋅
 ⋅  ⋅  3  9
 ⋅  ⋅  ⋅  4

julia&gt; Bl = Bidiagonal(dv, ev, &#39;L&#39;) #e is on the first subdiagonal
4×4 Bidiagonal{Int64}:
 1  ⋅  ⋅  ⋅
 7  2  ⋅  ⋅
 ⋅  8  3  ⋅
 ⋅  ⋅  9  4</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/bidiag.jl#L58-L97">source</a><div><pre><code class="language-none">Bidiagonal(A, isupper::Bool)</code></pre><p>Construct a <code>Bidiagonal</code> matrix from the main diagonal of <code>A</code> and its first super- (if <code>isupper=true</code>) or sub-diagonal (if <code>isupper=false</code>).</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1 1 1 1; 2 2 2 2; 3 3 3 3; 4 4 4 4]
4×4 Array{Int64,2}:
 1  1  1  1
 2  2  2  2
 3  3  3  3
 4  4  4  4

julia&gt; Bidiagonal(A, true) #contains the main diagonal and first superdiagonal of A
4×4 Bidiagonal{Int64}:
 1  1  ⋅  ⋅
 ⋅  2  2  ⋅
 ⋅  ⋅  3  3
 ⋅  ⋅  ⋅  4

julia&gt; Bidiagonal(A, false) #contains the main diagonal and first subdiagonal of A
4×4 Bidiagonal{Int64}:
 1  ⋅  ⋅  ⋅
 2  2  ⋅  ⋅
 ⋅  3  3  ⋅
 ⋅  ⋅  4  4</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/bidiag.jl#L114-L144">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.SymTridiagonal" href="#Base.LinAlg.SymTridiagonal"><code>Base.LinAlg.SymTridiagonal</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">SymTridiagonal(dv, ev)</code></pre><p>Construct a symmetric tridiagonal matrix from the diagonal and first sub/super-diagonal, respectively. The result is of type <code>SymTridiagonal</code> and provides efficient specialized eigensolvers, but may be converted into a regular matrix with <a href="../base/#Base.convert"><code>convert(Array, _)</code></a> (or <code>Array(_)</code> for short).</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; dv = [1; 2; 3; 4]
4-element Array{Int64,1}:
 1
 2
 3
 4

julia&gt; ev = [7; 8; 9]
3-element Array{Int64,1}:
 7
 8
 9

julia&gt; SymTridiagonal(dv, ev)
4×4 SymTridiagonal{Int64}:
 1  7  ⋅  ⋅
 7  2  8  ⋅
 ⋅  8  3  9
 ⋅  ⋅  9  4</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/tridiag.jl#L17-L48">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.Tridiagonal" href="#Base.LinAlg.Tridiagonal"><code>Base.LinAlg.Tridiagonal</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Tridiagonal(dl, d, du)</code></pre><p>Construct a tridiagonal matrix from the first subdiagonal, diagonal, and first superdiagonal, respectively.  The result is of type <code>Tridiagonal</code> and provides efficient specialized linear solvers, but may be converted into a regular matrix with <a href="../base/#Base.convert"><code>convert(Array, _)</code></a> (or <code>Array(_)</code> for short). The lengths of <code>dl</code> and <code>du</code> must be one less than the length of <code>d</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; dl = [1; 2; 3]
3-element Array{Int64,1}:
 1
 2
 3

julia&gt; du = [4; 5; 6]
3-element Array{Int64,1}:
 4
 5
 6

julia&gt; d = [7; 8; 9; 0]
4-element Array{Int64,1}:
 7
 8
 9
 0

julia&gt; Tridiagonal(dl, d, du)
4×4 Tridiagonal{Int64}:
 7  4  ⋅  ⋅
 1  8  5  ⋅
 ⋅  2  9  6
 ⋅  ⋅  3  0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/tridiag.jl#L400-L438">source</a><div><pre><code class="language-none">Tridiagonal(A)</code></pre><p>returns a <code>Tridiagonal</code> array based on (abstract) matrix <code>A</code>, using its first lower diagonal, main diagonal, and first upper diagonal.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1 2 3 4; 1 2 3 4; 1 2 3 4; 1 2 3 4]
4×4 Array{Int64,2}:
 1  2  3  4
 1  2  3  4
 1  2  3  4
 1  2  3  4

julia&gt; Tridiagonal(A)
4×4 Tridiagonal{Int64}:
 1  2  ⋅  ⋅
 1  2  3  ⋅
 ⋅  2  3  4
 ⋅  ⋅  3  4</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/tridiag.jl#L454-L477">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.Symmetric" href="#Base.LinAlg.Symmetric"><code>Base.LinAlg.Symmetric</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Symmetric(A, uplo=:U)</code></pre><p>Construct a <code>Symmetric</code> view of the upper (if <code>uplo = :U</code>) or lower (if <code>uplo = :L</code>) triangle of the matrix <code>A</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1 0 2 0 3; 0 4 0 5 0; 6 0 7 0 8; 0 9 0 1 0; 2 0 3 0 4]
5×5 Array{Int64,2}:
 1  0  2  0  3
 0  4  0  5  0
 6  0  7  0  8
 0  9  0  1  0
 2  0  3  0  4

julia&gt; Supper = Symmetric(A)
5×5 Symmetric{Int64,Array{Int64,2}}:
 1  0  2  0  3
 0  4  0  5  0
 2  0  7  0  8
 0  5  0  1  0
 3  0  8  0  4

julia&gt; Slower = Symmetric(A, :L)
5×5 Symmetric{Int64,Array{Int64,2}}:
 1  0  6  0  2
 0  4  0  9  0
 6  0  7  0  3
 0  9  0  1  0
 2  0  3  0  4</code></pre><p>Note that <code>Supper</code> will not be equal to <code>Slower</code> unless <code>A</code> is itself symmetric (e.g. if <code>A == A.&#39;</code>).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/symmetric.jl#L8-L43">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.Hermitian" href="#Base.LinAlg.Hermitian"><code>Base.LinAlg.Hermitian</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Hermitian(A, uplo=:U)</code></pre><p>Construct a <code>Hermitian</code> view of the upper (if <code>uplo = :U</code>) or lower (if <code>uplo = :L</code>) triangle of the matrix <code>A</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1 0 2+2im 0 3-3im; 0 4 0 5 0; 6-6im 0 7 0 8+8im; 0 9 0 1 0; 2+2im 0 3-3im 0 4];

julia&gt; Hupper = Hermitian(A)
5×5 Hermitian{Complex{Int64},Array{Complex{Int64},2}}:
 1+0im  0+0im  2+2im  0+0im  3-3im
 0+0im  4+0im  0+0im  5+0im  0+0im
 2-2im  0+0im  7+0im  0+0im  8+8im
 0+0im  5+0im  0+0im  1+0im  0+0im
 3+3im  0+0im  8-8im  0+0im  4+0im

julia&gt; Hlower = Hermitian(A, :L)
5×5 Hermitian{Complex{Int64},Array{Complex{Int64},2}}:
 1+0im  0+0im  6+6im  0+0im  2-2im
 0+0im  4+0im  0+0im  9+0im  0+0im
 6-6im  0+0im  7+0im  0+0im  3+3im
 0+0im  9+0im  0+0im  1+0im  0+0im
 2+2im  0+0im  3-3im  0+0im  4+0im</code></pre><p>Note that <code>Hupper</code> will not be equal to <code>Hlower</code> unless <code>A</code> is itself Hermitian (e.g. if <code>A == A&#39;</code>).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/symmetric.jl#L58-L87">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LowerTriangular" href="#Base.LinAlg.LowerTriangular"><code>Base.LinAlg.LowerTriangular</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">LowerTriangular(A::AbstractMatrix)</code></pre><p>Construct a <code>LowerTriangular</code> view of the the matrix <code>A</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1.0 2.0 3.0; 4.0 5.0 6.0; 7.0 8.0 9.0]
3×3 Array{Float64,2}:
 1.0  2.0  3.0
 4.0  5.0  6.0
 7.0  8.0  9.0

julia&gt; LowerTriangular(A)
3×3 LowerTriangular{Float64,Array{Float64,2}}:
 1.0   ⋅    ⋅
 4.0  5.0   ⋅
 7.0  8.0  9.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/triangular.jl#L53-L73">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.UpperTriangular" href="#Base.LinAlg.UpperTriangular"><code>Base.LinAlg.UpperTriangular</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">UpperTriangular(A::AbstractMatrix)</code></pre><p>Construct an <code>UpperTriangular</code> view of the the matrix <code>A</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1.0 2.0 3.0; 4.0 5.0 6.0; 7.0 8.0 9.0]
3×3 Array{Float64,2}:
 1.0  2.0  3.0
 4.0  5.0  6.0
 7.0  8.0  9.0

julia&gt; UpperTriangular(A)
3×3 UpperTriangular{Float64,Array{Float64,2}}:
 1.0  2.0  3.0
  ⋅   5.0  6.0
  ⋅    ⋅   9.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/triangular.jl#L75-L95">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.lu" href="#Base.LinAlg.lu"><code>Base.LinAlg.lu</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">lu(A, pivot=Val{true}) -&gt; L, U, p</code></pre><p>Compute the LU factorization of <code>A</code>, such that <code>A[p,:] = L*U</code>. By default, pivoting is used. This can be overridden by passing <code>Val{false}</code> for the second argument.</p><p>See also <a href="#Base.LinAlg.lufact"><code>lufact</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; A = [4. 3.; 6. 3.]
2×2 Array{Float64,2}:
 4.0  3.0
 6.0  3.0

julia&gt; L, U, p = lu(A)
([1.0 0.0; 0.666667 1.0], [6.0 3.0; 0.0 1.0], [2, 1])

julia&gt; A[p, :] == L * U
true</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lu.jl#L165-L188">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.lufact" href="#Base.LinAlg.lufact"><code>Base.LinAlg.lufact</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">lufact(A::SparseMatrixCSC) -&gt; F::UmfpackLU</code></pre><p>Compute the LU factorization of a sparse matrix <code>A</code>.</p><p>For sparse <code>A</code> with real or complex element type, the return type of <code>F</code> is <code>UmfpackLU{Tv, Ti}</code>, with <code>Tv</code> = <a href="../numbers/#Core.Float64"><code>Float64</code></a> or <code>Complex128</code> respectively and <code>Ti</code> is an integer type (<a href="../numbers/#Core.Int32"><code>Int32</code></a> or <a href="../numbers/#Core.Int64"><code>Int64</code></a>).</p><p>The individual components of the factorization <code>F</code> can be accessed by indexing:</p><table><tr><th>Component</th><th>Description</th></tr><tr><td><code>F[:L]</code></td><td><code>L</code> (lower triangular) part of <code>LU</code></td></tr><tr><td><code>F[:U]</code></td><td><code>U</code> (upper triangular) part of <code>LU</code></td></tr><tr><td><code>F[:p]</code></td><td>right permutation <code>Vector</code></td></tr><tr><td><code>F[:q]</code></td><td>left permutation <code>Vector</code></td></tr><tr><td><code>F[:Rs]</code></td><td><code>Vector</code> of scaling factors</td></tr><tr><td><code>F[:(:)]</code></td><td><code>(L,U,p,q,Rs)</code> components</td></tr></table><p>The relation between <code>F</code> and <code>A</code> is</p><p><code>F[:L]*F[:U] == (F[:Rs] .* A)[F[:p], F[:q]]</code></p><p><code>F</code> further supports the following functions:</p><ul><li><p><a href="#Base.:\\-Tuple{AbstractArray,Any}"><code>\</code></a></p></li><li><p><a href="#Base.LinAlg.cond"><code>cond</code></a></p></li><li><p><a href="#Base.LinAlg.det"><code>det</code></a></p></li></ul><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p><code>lufact(A::SparseMatrixCSC)</code> uses the UMFPACK library that is part of SuiteSparse. As this library only supports sparse matrices with <a href="../numbers/#Core.Float64"><code>Float64</code></a> or <code>Complex128</code> elements, <code>lufact</code> converts <code>A</code> into a copy that is of type <code>SparseMatrixCSC{Float64}</code> or <code>SparseMatrixCSC{Complex128}</code> as appropriate.</p></div></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/sparse/umfpack.jl#L104-L139">source</a><div><pre><code class="language-none">lufact(A [,pivot=Val{true}]) -&gt; F::LU</code></pre><p>Compute the LU factorization of <code>A</code>.</p><p>In most cases, if <code>A</code> is a subtype <code>S</code> of <code>AbstractMatrix{T}</code> with an element type <code>T</code> supporting <code>+</code>, <code>-</code>, <code>*</code> and <code>/</code>, the return type is <code>LU{T,S{T}}</code>. If pivoting is chosen (default) the element type should also support <code>abs</code> and <code>&lt;</code>.</p><p>The individual components of the factorization <code>F</code> can be accessed by indexing:</p><table><tr><th>Component</th><th>Description</th></tr><tr><td><code>F[:L]</code></td><td><code>L</code> (lower triangular) part of <code>LU</code></td></tr><tr><td><code>F[:U]</code></td><td><code>U</code> (upper triangular) part of <code>LU</code></td></tr><tr><td><code>F[:p]</code></td><td>(right) permutation <code>Vector</code></td></tr><tr><td><code>F[:P]</code></td><td>(right) permutation <code>Matrix</code></td></tr></table><p>The relationship between <code>F</code> and <code>A</code> is</p><p><code>F[:L]*F[:U] == A[F[:p], :]</code></p><p><code>F</code> further supports the following functions:</p><table><tr><th>Supported function</th><th><code>LU</code></th><th><code>LU{T,Tridiagonal{T}}</code></th></tr><tr><td><a href="../math/#Base.:/"><code>/</code></a></td><td>✓</td><td></td></tr><tr><td><a href="#Base.:\\-Tuple{AbstractArray,Any}"><code>\</code></a></td><td>✓</td><td>✓</td></tr><tr><td><a href="#Base.LinAlg.cond"><code>cond</code></a></td><td>✓</td><td></td></tr><tr><td><a href="#Base.inv"><code>inv</code></a></td><td>✓</td><td>✓</td></tr><tr><td><a href="#Base.LinAlg.det"><code>det</code></a></td><td>✓</td><td>✓</td></tr><tr><td><a href="#Base.LinAlg.logdet"><code>logdet</code></a></td><td>✓</td><td>✓</td></tr><tr><td><a href="#Base.LinAlg.logabsdet"><code>logabsdet</code></a></td><td>✓</td><td>✓</td></tr><tr><td><a href="../arrays/#Base.size"><code>size</code></a></td><td>✓</td><td>✓</td></tr></table><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; A = [4 3; 6 3]
2×2 Array{Int64,2}:
 4  3
 6  3

julia&gt; F = lufact(A)
Base.LinAlg.LU{Float64,Array{Float64,2}} with factors L and U:
[1.0 0.0; 1.5 1.0]
[4.0 3.0; 0.0 -1.5]

julia&gt; F[:L] * F[:U] == A[F[:p], :]
true</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lu.jl#L86-L138">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.lufact!" href="#Base.LinAlg.lufact!"><code>Base.LinAlg.lufact!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">lufact!(A, pivot=Val{true}) -&gt; LU</code></pre><p><code>lufact!</code> is the same as <a href="#Base.LinAlg.lufact"><code>lufact</code></a>, but saves space by overwriting the input <code>A</code>, instead of creating a copy. An <a href="../base/#Core.InexactError"><code>InexactError</code></a> exception is thrown if the factorization produces a number not representable by the element type of <code>A</code>, e.g. for integer types.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lu.jl#L23-L30">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.chol" href="#Base.LinAlg.chol"><code>Base.LinAlg.chol</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">chol(A) -&gt; U</code></pre><p>Compute the Cholesky factorization of a positive definite matrix <code>A</code> and return the <a href="#Base.LinAlg.UpperTriangular"><code>UpperTriangular</code></a> matrix <code>U</code> such that <code>A = U&#39;U</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1. 2.; 2. 50.]
2×2 Array{Float64,2}:
 1.0   2.0
 2.0  50.0

julia&gt; U = chol(A)
2×2 UpperTriangular{Float64,Array{Float64,2}}:
 1.0  2.0
  ⋅   6.78233

julia&gt; U&#39;U
2×2 Array{Float64,2}:
 1.0   2.0
 2.0  50.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/cholesky.jl#L159-L183">source</a><div><pre><code class="language-none">chol(x::Number) -&gt; y</code></pre><p>Compute the square root of a non-negative number <code>x</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; chol(16)
4.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/cholesky.jl#L190-L201">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.cholfact" href="#Base.LinAlg.cholfact"><code>Base.LinAlg.cholfact</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">cholfact(A; shift = 0.0, perm = Int[]) -&gt; CHOLMOD.Factor</code></pre><p>Compute the Cholesky factorization of a sparse positive definite matrix <code>A</code>. <code>A</code> must be a <a href="../arrays/#Base.SparseArrays.SparseMatrixCSC"><code>SparseMatrixCSC</code></a> or a <a href="#Base.LinAlg.Symmetric"><code>Symmetric</code></a>/<a href="#Base.LinAlg.Hermitian"><code>Hermitian</code></a> view of a <code>SparseMatrixCSC</code>. Note that even if <code>A</code> doesn&#39;t have the type tag, it must still be symmetric or Hermitian. A fill-reducing permutation is used. <code>F = cholfact(A)</code> is most frequently used to solve systems of equations with <code>F\b</code>, but also the methods <a href="#Base.LinAlg.diag"><code>diag</code></a>, <a href="#Base.LinAlg.det"><code>det</code></a>, and <a href="#Base.LinAlg.logdet"><code>logdet</code></a> are defined for <code>F</code>. You can also extract individual factors from <code>F</code>, using <code>F[:L]</code>. However, since pivoting is on by default, the factorization is internally represented as <code>A == P&#39;*L*L&#39;*P</code> with a permutation matrix <code>P</code>; using just <code>L</code> without accounting for <code>P</code> will give incorrect answers. To include the effects of permutation, it&#39;s typically preferable to extract &quot;combined&quot; factors like <code>PtL = F[:PtL]</code> (the equivalent of <code>P&#39;*L</code>) and <code>LtP = F[:UP]</code> (the equivalent of <code>L&#39;*P</code>).</p><p>Setting the optional <code>shift</code> keyword argument computes the factorization of <code>A+shift*I</code> instead of <code>A</code>. If the <code>perm</code> argument is nonempty, it should be a permutation of <code>1:size(A,1)</code> giving the ordering to use (instead of CHOLMOD&#39;s default AMD ordering).</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>This method uses the CHOLMOD library from SuiteSparse, which only supports doubles or complex doubles. Input matrices not of those element types will be converted to <code>SparseMatrixCSC{Float64}</code> or <code>SparseMatrixCSC{Complex128}</code> as appropriate.</p><p>Many other functions from CHOLMOD are wrapped but not exported from the <code>Base.SparseArrays.CHOLMOD</code> module.</p></div></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/sparse/cholmod.jl#L1405-L1437">source</a><div><pre><code class="language-none">cholfact(A, [uplo::Symbol,] Val{false}) -&gt; Cholesky</code></pre><p>Compute the Cholesky factorization of a dense symmetric positive definite matrix <code>A</code> and return a <code>Cholesky</code> factorization. The matrix <code>A</code> can either be a <a href="#Base.LinAlg.Symmetric"><code>Symmetric</code></a> or <a href="#Base.LinAlg.Hermitian"><code>Hermitian</code></a> <code>StridedMatrix</code> or a <em>perfectly</em> symmetric or Hermitian <code>StridedMatrix</code>. In the latter case, the optional argument <code>uplo</code> may be <code>:L</code> for using the lower part or <code>:U</code> for the upper part of <code>A</code>. The default is to use <code>:U</code>. The triangular Cholesky factor can be obtained from the factorization <code>F</code> with: <code>F[:L]</code> and <code>F[:U]</code>. The following functions are available for <code>Cholesky</code> objects: <a href="../arrays/#Base.size"><code>size</code></a>, <a href="#Base.:\\-Tuple{AbstractArray,Any}"><code>\</code></a>, <a href="#Base.inv"><code>inv</code></a>, and <a href="#Base.LinAlg.det"><code>det</code></a>. A <code>PosDefException</code> exception is thrown in case the matrix is not positive definite.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; A = [4. 12. -16.; 12. 37. -43.; -16. -43. 98.]
3×3 Array{Float64,2}:
   4.0   12.0  -16.0
  12.0   37.0  -43.0
 -16.0  -43.0   98.0

julia&gt; C = cholfact(A)
Base.LinAlg.Cholesky{Float64,Array{Float64,2}} with factor:
[2.0 6.0 -8.0; 0.0 1.0 5.0; 0.0 0.0 3.0]

julia&gt; C[:U]
3×3 UpperTriangular{Float64,Array{Float64,2}}:
 2.0  6.0  -8.0
  ⋅   1.0   5.0
  ⋅    ⋅    3.0

julia&gt; C[:L]
3×3 LowerTriangular{Float64,Array{Float64,2}}:
  2.0   ⋅    ⋅
  6.0  1.0   ⋅
 -8.0  5.0  3.0

julia&gt; C[:L] * C[:U] == A
true</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/cholesky.jl#L297-L338">source</a><div><pre><code class="language-none">cholfact(A, [uplo::Symbol,] Val{true}; tol = 0.0) -&gt; CholeskyPivoted</code></pre><p>Compute the pivoted Cholesky factorization of a dense symmetric positive semi-definite matrix <code>A</code> and return a <code>CholeskyPivoted</code> factorization. The matrix <code>A</code> can either be a <a href="#Base.LinAlg.Symmetric"><code>Symmetric</code></a> or <a href="#Base.LinAlg.Hermitian"><code>Hermitian</code></a> <code>StridedMatrix</code> or a <em>perfectly</em> symmetric or Hermitian <code>StridedMatrix</code>. In the latter case, the optional argument <code>uplo</code> may be <code>:L</code> for using the lower part or <code>:U</code> for the upper part of <code>A</code>. The default is to use <code>:U</code>. The triangular Cholesky factor can be obtained from the factorization <code>F</code> with: <code>F[:L]</code> and <code>F[:U]</code>. The following functions are available for <code>PivotedCholesky</code> objects: <a href="../arrays/#Base.size"><code>size</code></a>, <a href="#Base.:\\-Tuple{AbstractArray,Any}"><code>\</code></a>, <a href="#Base.inv"><code>inv</code></a>, <a href="#Base.LinAlg.det"><code>det</code></a>, and <a href="#Base.LinAlg.rank"><code>rank</code></a>. The argument <code>tol</code> determines the tolerance for determining the rank. For negative values, the tolerance is the machine precision.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/cholesky.jl#L363-L376">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.cholfact!" href="#Base.LinAlg.cholfact!"><code>Base.LinAlg.cholfact!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">cholfact!(F::Factor, A; shift = 0.0) -&gt; CHOLMOD.Factor</code></pre><p>Compute the Cholesky (<span>$LL&#39;$</span>) factorization of <code>A</code>, reusing the symbolic factorization <code>F</code>. <code>A</code> must be a <a href="../arrays/#Base.SparseArrays.SparseMatrixCSC"><code>SparseMatrixCSC</code></a> or a <a href="#Base.LinAlg.Symmetric"><code>Symmetric</code></a>/ <a href="#Base.LinAlg.Hermitian"><code>Hermitian</code></a> view of a <code>SparseMatrixCSC</code>. Note that even if <code>A</code> doesn&#39;t have the type tag, it must still be symmetric or Hermitian.</p><p>See also <a href="#Base.LinAlg.cholfact"><code>cholfact</code></a>.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>This method uses the CHOLMOD library from SuiteSparse, which only supports doubles or complex doubles. Input matrices not of those element types will be converted to <code>SparseMatrixCSC{Float64}</code> or <code>SparseMatrixCSC{Complex128}</code> as appropriate.</p></div></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/sparse/cholmod.jl#L1364-L1379">source</a><div><pre><code class="language-none">cholfact!(A, [uplo::Symbol,] Val{false}) -&gt; Cholesky</code></pre><p>The same as <a href="#Base.LinAlg.cholfact"><code>cholfact</code></a>, but saves space by overwriting the input <code>A</code>, instead of creating a copy. An <a href="../base/#Core.InexactError"><code>InexactError</code></a> exception is thrown if the factorization produces a number not representable by the element type of <code>A</code>, e.g. for integer types.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1 2; 2 50]
2×2 Array{Int64,2}:
 1   2
 2  50

julia&gt; cholfact!(A)
ERROR: InexactError()</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/cholesky.jl#L225-L244">source</a><div><pre><code class="language-none">cholfact!(A, [uplo::Symbol,] Val{true}; tol = 0.0) -&gt; CholeskyPivoted</code></pre><p>The same as <a href="#Base.LinAlg.cholfact"><code>cholfact</code></a>, but saves space by overwriting the input <code>A</code>, instead of creating a copy. An <a href="../base/#Core.InexactError"><code>InexactError</code></a> exception is thrown if the factorization produces a number not representable by the element type of <code>A</code>, e.g. for integer types.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/cholesky.jl#L275-L282">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.lowrankupdate" href="#Base.LinAlg.lowrankupdate"><code>Base.LinAlg.lowrankupdate</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">lowrankupdate(C::Cholesky, v::StridedVector) -&gt; CC::Cholesky</code></pre><p>Update a Cholesky factorization <code>C</code> with the vector <code>v</code>. If <code>A = C[:U]&#39;C[:U]</code> then <code>CC = cholfact(C[:U]&#39;C[:U] + v*v&#39;)</code> but the computation of <code>CC</code> only uses <code>O(n^2)</code> operations.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/cholesky.jl#L653-L659">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.lowrankdowndate" href="#Base.LinAlg.lowrankdowndate"><code>Base.LinAlg.lowrankdowndate</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">lowrankdowndate(C::Cholesky, v::StridedVector) -&gt; CC::Cholesky</code></pre><p>Downdate a Cholesky factorization <code>C</code> with the vector <code>v</code>. If <code>A = C[:U]&#39;C[:U]</code> then <code>CC = cholfact(C[:U]&#39;C[:U] - v*v&#39;)</code> but the computation of <code>CC</code> only uses <code>O(n^2)</code> operations.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/cholesky.jl#L662-L668">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.lowrankupdate!" href="#Base.LinAlg.lowrankupdate!"><code>Base.LinAlg.lowrankupdate!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">lowrankupdate!(C::Cholesky, v::StridedVector) -&gt; CC::Cholesky</code></pre><p>Update a Cholesky factorization <code>C</code> with the vector <code>v</code>. If <code>A = C[:U]&#39;C[:U]</code> then <code>CC = cholfact(C[:U]&#39;C[:U] + v*v&#39;)</code> but the computation of <code>CC</code> only uses <code>O(n^2)</code> operations. The input factorization <code>C</code> is updated in place such that on exit <code>C == CC</code>. The vector <code>v</code> is destroyed during the computation.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/cholesky.jl#L554-L561">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.lowrankdowndate!" href="#Base.LinAlg.lowrankdowndate!"><code>Base.LinAlg.lowrankdowndate!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">lowrankdowndate!(C::Cholesky, v::StridedVector) -&gt; CC::Cholesky</code></pre><p>Downdate a Cholesky factorization <code>C</code> with the vector <code>v</code>. If <code>A = C[:U]&#39;C[:U]</code> then <code>CC = cholfact(C[:U]&#39;C[:U] - v*v&#39;)</code> but the computation of <code>CC</code> only uses <code>O(n^2)</code> operations. The input factorization <code>C</code> is updated in place such that on exit <code>C == CC</code>. The vector <code>v</code> is destroyed during the computation.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/cholesky.jl#L600-L607">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.ldltfact" href="#Base.LinAlg.ldltfact"><code>Base.LinAlg.ldltfact</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">ldltfact(A; shift = 0.0, perm=Int[]) -&gt; CHOLMOD.Factor</code></pre><p>Compute the <span>$LDL&#39;$</span> factorization of a sparse matrix <code>A</code>. <code>A</code> must be a <a href="../arrays/#Base.SparseArrays.SparseMatrixCSC"><code>SparseMatrixCSC</code></a> or a <a href="#Base.LinAlg.Symmetric"><code>Symmetric</code></a>/<a href="#Base.LinAlg.Hermitian"><code>Hermitian</code></a> view of a <code>SparseMatrixCSC</code>. Note that even if <code>A</code> doesn&#39;t have the type tag, it must still be symmetric or Hermitian. A fill-reducing permutation is used. <code>F = ldltfact(A)</code> is most frequently used to solve systems of equations <code>A*x = b</code> with <code>F\b</code>. The returned factorization object <code>F</code> also supports the methods <a href="#Base.LinAlg.diag"><code>diag</code></a>, <a href="#Base.LinAlg.det"><code>det</code></a>, <a href="#Base.LinAlg.logdet"><code>logdet</code></a>, and <a href="#Base.inv"><code>inv</code></a>. You can extract individual factors from <code>F</code> using <code>F[:L]</code>. However, since pivoting is on by default, the factorization is internally represented as <code>A == P&#39;*L*D*L&#39;*P</code> with a permutation matrix <code>P</code>; using just <code>L</code> without accounting for <code>P</code> will give incorrect answers. To include the effects of permutation, it is typically preferable to extract &quot;combined&quot; factors like <code>PtL = F[:PtL]</code> (the equivalent of <code>P&#39;*L</code>) and <code>LtP = F[:UP]</code> (the equivalent of <code>L&#39;*P</code>). The complete list of supported factors is <code>:L, :PtL, :D, :UP, :U, :LD, :DU, :PtLD, :DUP</code>.</p><p>Setting the optional <code>shift</code> keyword argument computes the factorization of <code>A+shift*I</code> instead of <code>A</code>. If the <code>perm</code> argument is nonempty, it should be a permutation of <code>1:size(A,1)</code> giving the ordering to use (instead of CHOLMOD&#39;s default AMD ordering).</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>This method uses the CHOLMOD library from SuiteSparse, which only supports doubles or complex doubles. Input matrices not of those element types will be converted to <code>SparseMatrixCSC{Float64}</code> or <code>SparseMatrixCSC{Complex128}</code> as appropriate.</p><p>Many other functions from CHOLMOD are wrapped but not exported from the <code>Base.SparseArrays.CHOLMOD</code> module.</p></div></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/sparse/cholmod.jl#L1504-L1537">source</a><div><pre><code class="language-none">ldltfact(S::SymTridiagonal) -&gt; LDLt</code></pre><p>Compute an <code>LDLt</code> factorization of a real symmetric tridiagonal matrix such that <code>A = L*Diagonal(d)*L&#39;</code> where <code>L</code> is a unit lower triangular matrix and <code>d</code> is a vector. The main use of an <code>LDLt</code> factorization <code>F = ldltfact(A)</code> is to solve the linear system of equations <code>Ax = b</code> with <code>F\b</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/ldlt.jl#L35-L41">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.ldltfact!" href="#Base.LinAlg.ldltfact!"><code>Base.LinAlg.ldltfact!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">ldltfact!(F::Factor, A; shift = 0.0) -&gt; CHOLMOD.Factor</code></pre><p>Compute the <span>$LDL&#39;$</span> factorization of <code>A</code>, reusing the symbolic factorization <code>F</code>. <code>A</code> must be a <a href="../arrays/#Base.SparseArrays.SparseMatrixCSC"><code>SparseMatrixCSC</code></a> or a <a href="#Base.LinAlg.Symmetric"><code>Symmetric</code></a>/<a href="#Base.LinAlg.Hermitian"><code>Hermitian</code></a> view of a <code>SparseMatrixCSC</code>. Note that even if <code>A</code> doesn&#39;t have the type tag, it must still be symmetric or Hermitian.</p><p>See also <a href="#Base.LinAlg.ldltfact"><code>ldltfact</code></a>.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>This method uses the CHOLMOD library from SuiteSparse, which only supports doubles or complex doubles. Input matrices not of those element types will be converted to <code>SparseMatrixCSC{Float64}</code> or <code>SparseMatrixCSC{Complex128}</code> as appropriate.</p></div></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/sparse/cholmod.jl#L1456-L1471">source</a><div><pre><code class="language-none">ldltfact!(S::SymTridiagonal) -&gt; LDLt</code></pre><p>Same as <a href="#Base.LinAlg.ldltfact"><code>ldltfact</code></a>, but saves space by overwriting the input <code>A</code>, instead of creating a copy.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/ldlt.jl#L19-L23">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.qr" href="#Base.LinAlg.qr"><code>Base.LinAlg.qr</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">qr(A, pivot=Val{false}; thin::Bool=true) -&gt; Q, R, [p]</code></pre><p>Compute the (pivoted) QR factorization of <code>A</code> such that either <code>A = Q*R</code> or <code>A[:,p] = Q*R</code>. Also see <a href="#Base.LinAlg.qrfact"><code>qrfact</code></a>. The default is to compute a thin factorization. Note that <code>R</code> is not extended with zeros when the full <code>Q</code> is requested.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/qr.jl#L285-L292">source</a><div><pre><code class="language-none">qr(v::AbstractVector) -&gt; w, r</code></pre><p>Computes the polar decomposition of a vector. Returns <code>w</code>, a unit vector in the direction of <code>v</code>, and <code>r</code>, the norm of <code>v</code>.</p><p>See also <a href="#Base.LinAlg.normalize"><code>normalize</code></a>, <a href="#Base.LinAlg.normalize!"><code>normalize!</code></a>, and <a href="#Base.LinAlg.qr!"><code>LinAlg.qr!</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; v = [1; 2]
2-element Array{Int64,1}:
 1
 2

julia&gt; w, r = qr(v)
([0.447214, 0.894427], 2.23606797749979)

julia&gt; w*r == v
true</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/qr.jl#L304-L328">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.qr!" href="#Base.LinAlg.qr!"><code>Base.LinAlg.qr!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">LinAlg.qr!(v::AbstractVector) -&gt; w, r</code></pre><p>Computes the polar decomposition of a vector. Instead of returning a new vector as <code>qr(v::AbstractVector)</code>, this function mutates the input vector <code>v</code> in place. Returns <code>w</code>, a unit vector in the direction of <code>v</code> (this is a mutation of <code>v</code>), and <code>r</code>, the norm of <code>v</code>.</p><p>See also <a href="#Base.LinAlg.normalize"><code>normalize</code></a>, <a href="#Base.LinAlg.normalize!"><code>normalize!</code></a>, and <a href="#Base.LinAlg.qr"><code>qr</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/qr.jl#L340-L350">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.qrfact" href="#Base.LinAlg.qrfact"><code>Base.LinAlg.qrfact</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">qrfact(A) -&gt; SPQR.Factorization</code></pre><p>Compute the <code>QR</code> factorization of a sparse matrix <code>A</code>. A fill-reducing permutation is used. The main application of this type is to solve least squares problems with <a href="#Base.:\\-Tuple{AbstractArray,Any}"><code>\</code></a>. The function calls the C library SPQR and a few additional functions from the library are wrapped but not exported.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/sparse/spqr.jl#L142-L149">source</a><div><pre><code class="language-none">qrfact(A, pivot=Val{false}) -&gt; F</code></pre><p>Compute the QR factorization of the matrix <code>A</code>: an orthogonal (or unitary if <code>A</code> is complex-valued) matrix <code>Q</code>, and an upper triangular matrix <code>R</code> such that</p><div>\[A = Q R\]</div><p>The returned object <code>F</code> stores the factorization in a packed format:</p><ul><li><p>if <code>pivot == Val{true}</code> then <code>F</code> is a <a href="#Base.LinAlg.QRPivoted"><code>QRPivoted</code></a> object,</p></li><li><p>otherwise if the element type of <code>A</code> is a BLAS type (<a href="../numbers/#Core.Float32"><code>Float32</code></a>, <a href="../numbers/#Core.Float64"><code>Float64</code></a>, <code>Complex64</code> or <code>Complex128</code>), then <code>F</code> is a <a href="#Base.LinAlg.QRCompactWY"><code>QRCompactWY</code></a> object,</p></li><li><p>otherwise <code>F</code> is a <a href="#Base.LinAlg.QR"><code>QR</code></a> object.</p></li></ul><p>The individual components of the factorization <code>F</code> can be accessed by indexing with a symbol:</p><ul><li><p><code>F[:Q]</code>: the orthogonal/unitary matrix <code>Q</code></p></li><li><p><code>F[:R]</code>: the upper triangular matrix <code>R</code></p></li><li><p><code>F[:p]</code>: the permutation vector of the pivot (<a href="#Base.LinAlg.QRPivoted"><code>QRPivoted</code></a> only)</p></li><li><p><code>F[:P]</code>: the permutation matrix of the pivot (<a href="#Base.LinAlg.QRPivoted"><code>QRPivoted</code></a> only)</p></li></ul><p>The following functions are available for the <code>QR</code> objects: <a href="#Base.inv"><code>inv</code></a>, <a href="../arrays/#Base.size"><code>size</code></a>, and <a href="#Base.:\\-Tuple{AbstractArray,Any}"><code>\</code></a>. When <code>A</code> is rectangular, <code>\</code> will return a least squares solution and if the solution is not unique, the one with smallest norm is returned.</p><p>Multiplication with respect to either thin or full <code>Q</code> is allowed, i.e. both <code>F[:Q]*F[:R]</code> and <code>F[:Q]*A</code> are supported. A <code>Q</code> matrix can be converted into a regular matrix with <a href="../arrays/#Base.full"><code>full</code></a> which has a named argument <code>thin</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; A = [3.0 -6.0; 4.0 -8.0; 0.0 1.0]
3×2 Array{Float64,2}:
 3.0  -6.0
 4.0  -8.0
 0.0   1.0

julia&gt; F = qrfact(A)
Base.LinAlg.QRCompactWY{Float64,Array{Float64,2}} with factors Q and R:
[-0.6 0.0 0.8; -0.8 0.0 -0.6; 0.0 -1.0 0.0]
[-5.0 10.0; 0.0 -1.0]

julia&gt; F[:Q] * F[:R] == A
true</code></pre><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p><code>qrfact</code> returns multiple types because LAPACK uses several representations that minimize the memory storage requirements of products of Householder elementary reflectors, so that the <code>Q</code> and <code>R</code> matrices can be stored compactly rather as two separate dense matrices.</p></div></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/qr.jl#L215-L272">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.qrfact!" href="#Base.LinAlg.qrfact!"><code>Base.LinAlg.qrfact!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">qrfact!(A, pivot=Val{false})</code></pre><p><code>qrfact!</code> is the same as <a href="#Base.LinAlg.qrfact"><code>qrfact</code></a> when <code>A</code> is a subtype of <code>StridedMatrix</code>, but saves space by overwriting the input <code>A</code>, instead of creating a copy. An <a href="../base/#Core.InexactError"><code>InexactError</code></a> exception is thrown if the factorization produces a number not representable by the element type of <code>A</code>, e.g. for integer types.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/qr.jl#L203-L210">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.QR" href="#Base.LinAlg.QR"><code>Base.LinAlg.QR</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">QR &lt;: Factorization</code></pre><p>A QR matrix factorization stored in a packed format, typically obtained from <a href="#Base.LinAlg.qrfact"><code>qrfact</code></a>. If <span>$A$</span> is an <code>m</code>×<code>n</code> matrix, then</p><div>\[A = Q R\]</div><p>where <span>$Q$</span> is an orthogonal/unitary matrix and <span>$R$</span> is upper triangular. The matrix <span>$Q$</span> is stored as a sequence of Householder reflectors <span>$v_i$</span> and coefficients <span>$\tau_i$</span> where:</p><div>\[Q = \prod_{i=1}^{\min(m,n)} (I - \tau_i v_i v_i^T).\]</div><p>The object has two fields:</p><ul><li><p><code>factors</code> is an <code>m</code>×<code>n</code> matrix.</p><ul><li><p>The upper triangular part contains the elements of <span>$R$</span>, that is <code>R = triu(F.factors)</code> for a <code>QR</code> object <code>F</code>.</p></li><li><p>The subdiagonal part contains the reflectors <span>$v_i$</span> stored in a packed format where <span>$v_i$</span> is the <span>$i$</span>th column of the matrix <code>V = eye(m,n) + tril(F.factors,-1)</code>.</p></li></ul></li><li><p><code>τ</code> is a vector  of length <code>min(m,n)</code> containing the coefficients <span>$au_i$</span>.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/qr.jl#L4-L34">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.QRCompactWY" href="#Base.LinAlg.QRCompactWY"><code>Base.LinAlg.QRCompactWY</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">QRCompactWY &lt;: Factorization</code></pre><p>A QR matrix factorization stored in a compact blocked format, typically obtained from <a href="#Base.LinAlg.qrfact"><code>qrfact</code></a>. If <span>$A$</span> is an <code>m</code>×<code>n</code> matrix, then</p><div>\[A = Q R\]</div><p>where <span>$Q$</span> is an orthogonal/unitary matrix and <span>$R$</span> is upper triangular. It is similar to the <a href="#Base.LinAlg.QR"><code>QR</code></a> format except that the orthogonal/unitary matrix <span>$Q$</span> is stored in <em>Compact WY</em> format <a href="#footnote-Schreiber1989">[Schreiber1989]</a>, as a lower trapezoidal matrix <span>$V$</span> and an upper triangular matrix <span>$T$</span> where</p><div>\[Q = \prod_{i=1}^{\min(m,n)} (I - \tau_i v_i v_i^T) = I - V T V^T\]</div><p>such that <span>$v_i$</span> is the <span>$i$</span>th column of <span>$V$</span>, and <span>$au_i$</span> is the <span>$i$</span>th diagonal element of <span>$T$</span>.</p><p>The object has two fields:</p><ul><li><p><code>factors</code>, as in the <a href="#Base.LinAlg.QR"><code>QR</code></a> type, is an <code>m</code>×<code>n</code> matrix.</p><ul><li><p>The upper triangular part contains the elements of <span>$R$</span>, that is <code>R = triu(F.factors)</code> for a <code>QR</code> object <code>F</code>.</p></li><li><p>The subdiagonal part contains the reflectors <span>$v_i$</span> stored in a packed format such that <code>V = eye(m,n) + tril(F.factors,-1)</code>.</p></li></ul></li><li><p><code>T</code> is a square matrix with <code>min(m,n)</code> columns, whose upper triangular part gives the matrix <span>$T$</span> above (the subdiagonal elements are ignored).</p></li></ul><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>This format should not to be confused with the older <em>WY</em> representation <a href="#footnote-Bischof1987">[Bischof1987]</a>.</p></div></div><div class="footnote" id="footnote-Bischof1987"><a href="#footnote-Bischof1987"><strong>[Bischof1987]</strong></a><p>C Bischof and C Van Loan, &quot;The WY representation for products of Householder matrices&quot;, SIAM J Sci Stat Comput 8 (1987), s2-s13. <a href="http://dx.doi.org/10.1137/0908009">doi:10.1137/0908009</a></p></div><div class="footnote" id="footnote-Schreiber1989"><a href="#footnote-Schreiber1989"><strong>[Schreiber1989]</strong></a><p>R Schreiber and C Van Loan, &quot;A storage-efficient WY representation for products of Householder transformations&quot;, SIAM J Sci Stat Comput 10 (1989), 53-57. <a href="http://dx.doi.org/10.1137/0910005">doi:10.1137/0910005</a></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/qr.jl#L43-L87">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.QRPivoted" href="#Base.LinAlg.QRPivoted"><code>Base.LinAlg.QRPivoted</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">QRPivoted &lt;: Factorization</code></pre><p>A QR matrix factorization with column pivoting in a packed format, typically obtained from <a href="#Base.LinAlg.qrfact"><code>qrfact</code></a>. If <span>$A$</span> is an <code>m</code>×<code>n</code> matrix, then</p><div>\[A P = Q R\]</div><p>where <span>$P$</span> is a permutation matrix, <span>$Q$</span> is an orthogonal/unitary matrix and <span>$R$</span> is upper triangular. The matrix <span>$Q$</span> is stored as a sequence of Householder reflectors:</p><div>\[Q = \prod_{i=1}^{\min(m,n)} (I - \tau_i v_i v_i^T).\]</div><p>The object has three fields:</p><ul><li><p><code>factors</code> is an <code>m</code>×<code>n</code> matrix.</p><ul><li><p>The upper triangular part contains the elements of <span>$R$</span>, that is <code>R = triu(F.factors)</code> for a <code>QR</code> object <code>F</code>.</p></li><li><p>The subdiagonal part contains the reflectors <span>$v_i$</span> stored in a packed format where <span>$v_i$</span> is the <span>$i$</span>th column of the matrix <code>V = eye(m,n) + tril(F.factors,-1)</code>.</p></li></ul></li><li><p><code>τ</code> is a vector of length <code>min(m,n)</code> containing the coefficients <span>$au_i$</span>.</p></li><li><p><code>jpvt</code> is an integer vector of length <code>n</code> corresponding to the permutation <span>$P$</span>.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/qr.jl#L95-L125">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.lqfact!" href="#Base.LinAlg.lqfact!"><code>Base.LinAlg.lqfact!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">lqfact!(A) -&gt; LQ</code></pre><p>Compute the LQ factorization of <code>A</code>, using the input matrix as a workspace. See also <a href="#Base.LinAlg.lq"><code>lq</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lq.jl#L20-L25">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.lqfact" href="#Base.LinAlg.lqfact"><code>Base.LinAlg.lqfact</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">lqfact(A) -&gt; LQ</code></pre><p>Compute the LQ factorization of <code>A</code>. See also <a href="#Base.LinAlg.lq"><code>lq</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lq.jl#L27-L31">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.lq" href="#Base.LinAlg.lq"><code>Base.LinAlg.lq</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">lq(A; [thin=true]) -&gt; L, Q</code></pre><p>Perform an LQ factorization of <code>A</code> such that <code>A = L*Q</code>. The default is to compute a thin factorization. The LQ factorization is the QR factorization of <code>A.&#39;</code>. <code>L</code> is not extended with zeros if the full <code>Q</code> is requested.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lq.jl#L35-L42">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.bkfact" href="#Base.LinAlg.bkfact"><code>Base.LinAlg.bkfact</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">bkfact(A, uplo::Symbol=:U, symmetric::Bool=issymmetric(A), rook::Bool=false) -&gt; BunchKaufman</code></pre><p>Compute the Bunch-Kaufman <a href="#footnote-Bunch1977">[Bunch1977]</a> factorization of a symmetric or Hermitian matrix <code>A</code> and return a <code>BunchKaufman</code> object. <code>uplo</code> indicates which triangle of matrix <code>A</code> to reference. If <code>symmetric</code> is <code>true</code>, <code>A</code> is assumed to be symmetric. If <code>symmetric</code> is <code>false</code>, <code>A</code> is assumed to be Hermitian. If <code>rook</code> is <code>true</code>, rook pivoting is used. If <code>rook</code> is false, rook pivoting is not used. The following functions are available for <code>BunchKaufman</code> objects: <a href="../arrays/#Base.size"><code>size</code></a>, <code>\</code>, <a href="#Base.inv"><code>inv</code></a>, <a href="#Base.LinAlg.issymmetric"><code>issymmetric</code></a>, <a href="#Base.LinAlg.ishermitian"><code>ishermitian</code></a>.</p><div class="footnote" id="footnote-Bunch1977"><a href="#footnote-Bunch1977"><strong>[Bunch1977]</strong></a><p>J R Bunch and L Kaufman, Some stable methods for calculating inertia and solving symmetric linear systems, Mathematics of Computation 31:137 (1977), 163-179. <a href="http://www.ams.org/journals/mcom/1977-31-137/S0025-5718-1977-0428694-0/">url</a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/bunchkaufman.jl#L57-L71">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.bkfact!" href="#Base.LinAlg.bkfact!"><code>Base.LinAlg.bkfact!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">bkfact!(A, uplo::Symbol=:U, symmetric::Bool=issymmetric(A), rook::Bool=false) -&gt; BunchKaufman</code></pre><p><code>bkfact!</code> is the same as <a href="#Base.LinAlg.bkfact"><code>bkfact</code></a>, but saves space by overwriting the input <code>A</code>, instead of creating a copy.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/bunchkaufman.jl#L19-L24">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.eig" href="#Base.LinAlg.eig"><code>Base.LinAlg.eig</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">eig(A::Union{SymTridiagonal, Hermitian, Symmetric}, irange::UnitRange) -&gt; D, V
eig(A::Union{SymTridiagonal, Hermitian, Symmetric}, vl::Real, vu::Real) -&gt; D, V
eig(A, permute::Bool=true, scale::Bool=true) -&gt; D, V</code></pre><p>Computes eigenvalues (<code>D</code>) and eigenvectors (<code>V</code>) of <code>A</code>. See <a href="#Base.LinAlg.eigfact"><code>eigfact</code></a> for details on the <code>irange</code>, <code>vl</code>, and <code>vu</code> arguments (for <a href="#Base.LinAlg.SymTridiagonal"><code>SymTridiagonal</code></a>, <code>Hermitian</code>, and <code>Symmetric</code> matrices) and the <code>permute</code> and <code>scale</code> keyword arguments. The eigenvectors are returned columnwise.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; eig([1.0 0.0 0.0; 0.0 3.0 0.0; 0.0 0.0 18.0])
([1.0, 3.0, 18.0], [1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0])</code></pre><p><code>eig</code> is a wrapper around <a href="#Base.LinAlg.eigfact"><code>eigfact</code></a>, extracting all parts of the factorization to a tuple; where possible, using <a href="#Base.LinAlg.eigfact"><code>eigfact</code></a> is recommended.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/eigen.jl#L112-L134">source</a><div><pre><code class="language-none">eig(A, B) -&gt; D, V</code></pre><p>Computes generalized eigenvalues (<code>D</code>) and vectors (<code>V</code>) of <code>A</code> with respect to <code>B</code>.</p><p><code>eig</code> is a wrapper around <a href="#Base.LinAlg.eigfact"><code>eigfact</code></a>, extracting all parts of the factorization to a tuple; where possible, using <a href="#Base.LinAlg.eigfact"><code>eigfact</code></a> is recommended.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1 0; 0 -1]
2×2 Array{Int64,2}:
 1   0
 0  -1

julia&gt; B = [0 1; 1 0]
2×2 Array{Int64,2}:
 0  1
 1  0

julia&gt; eig(A, B)
(Complex{Float64}[0.0+1.0im, 0.0-1.0im], Complex{Float64}[0.0-1.0im 0.0+1.0im; -1.0-0.0im -1.0+0.0im])</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/eigen.jl#L333-L357">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.eigvals" href="#Base.LinAlg.eigvals"><code>Base.LinAlg.eigvals</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">eigvals(A; permute::Bool=true, scale::Bool=true) -&gt; values</code></pre><p>Returns the eigenvalues of <code>A</code>.</p><p>For general non-symmetric matrices it is possible to specify how the matrix is balanced before the eigenvalue calculation. The option <code>permute=true</code> permutes the matrix to become closer to upper triangular, and <code>scale=true</code> scales the matrix by its diagonal elements to make rows and columns more equal in norm. The default is <code>true</code> for both options.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/eigen.jl#L181-L191">source</a><div><pre><code class="language-none">eigvals(A, B) -&gt; values</code></pre><p>Computes the generalized eigenvalues of <code>A</code> and <code>B</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1 0; 0 -1]
2×2 Array{Int64,2}:
 1   0
 0  -1

julia&gt; B = [0 1; 1 0]
2×2 Array{Int64,2}:
 0  1
 1  0

julia&gt; eigvals(A,B)
2-element Array{Complex{Float64},1}:
 0.0+1.0im
 0.0-1.0im</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/eigen.jl#L383-L406">source</a><div><pre><code class="language-none">eigvals(A::Union{SymTridiagonal, Hermitian, Symmetric}, irange::UnitRange) -&gt; values</code></pre><p>Returns the eigenvalues of <code>A</code>. It is possible to calculate only a subset of the eigenvalues by specifying a <code>UnitRange</code> <code>irange</code> covering indices of the sorted eigenvalues, e.g. the 2nd to 8th eigenvalues.</p><pre><code class="language-julia-repl">julia&gt; A = SymTridiagonal([1.; 2.; 1.], [2.; 3.])
3×3 SymTridiagonal{Float64}:
 1.0  2.0   ⋅
 2.0  2.0  3.0
  ⋅   3.0  1.0

julia&gt; eigvals(A, 2:2)
1-element Array{Float64,1}:
 1.0

julia&gt; eigvals(A)
3-element Array{Float64,1}:
 -2.14005
  1.0
  5.14005</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/symmetric.jl#L366-L390">source</a><div><pre><code class="language-none">eigvals(A::Union{SymTridiagonal, Hermitian, Symmetric}, vl::Real, vu::Real) -&gt; values</code></pre><p>Returns the eigenvalues of <code>A</code>. It is possible to calculate only a subset of the eigenvalues by specifying a pair <code>vl</code> and <code>vu</code> for the lower and upper boundaries of the eigenvalues.</p><pre><code class="language-julia-repl">julia&gt; A = SymTridiagonal([1.; 2.; 1.], [2.; 3.])
3×3 SymTridiagonal{Float64}:
 1.0  2.0   ⋅
 2.0  2.0  3.0
  ⋅   3.0  1.0

julia&gt; eigvals(A, -1, 2)
1-element Array{Float64,1}:
 1.0

julia&gt; eigvals(A)
3-element Array{Float64,1}:
 -2.14005
  1.0
  5.14005</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/symmetric.jl#L406-L429">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.eigvals!" href="#Base.LinAlg.eigvals!"><code>Base.LinAlg.eigvals!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">eigvals!(A; permute::Bool=true, scale::Bool=true) -&gt; values</code></pre><p>Same as <a href="#Base.LinAlg.eigvals"><code>eigvals</code></a>, but saves space by overwriting the input <code>A</code>, instead of creating a copy. The option <code>permute=true</code> permutes the matrix to become closer to upper triangular, and <code>scale=true</code> scales the matrix by its diagonal elements to make rows and columns more equal in norm.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/eigen.jl#L163-L170">source</a><div><pre><code class="language-none">eigvals!(A, B) -&gt; values</code></pre><p>Same as <a href="#Base.LinAlg.eigvals"><code>eigvals</code></a>, but saves space by overwriting the input <code>A</code> (and <code>B</code>), instead of creating copies.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/eigen.jl#L367-L371">source</a><div><pre><code class="language-none">eigvals!(A::Union{SymTridiagonal, Hermitian, Symmetric}, irange::UnitRange) -&gt; values</code></pre><p>Same as <a href="#Base.LinAlg.eigvals"><code>eigvals</code></a>, but saves space by overwriting the input <code>A</code>, instead of creating a copy. <code>irange</code> is a range of eigenvalue <em>indices</em> to search for - for instance, the 2nd to 8th eigenvalues.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/symmetric.jl#L357-L362">source</a><div><pre><code class="language-none">eigvals!(A::Union{SymTridiagonal, Hermitian, Symmetric}, vl::Real, vu::Real) -&gt; values</code></pre><p>Same as <a href="#Base.LinAlg.eigvals"><code>eigvals</code></a>, but saves space by overwriting the input <code>A</code>, instead of creating a copy. <code>vl</code> is the lower bound of the interval to search for eigenvalues, and <code>vu</code> is the upper bound.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/symmetric.jl#L397-L402">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.eigmax" href="#Base.LinAlg.eigmax"><code>Base.LinAlg.eigmax</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">eigmax(A; permute::Bool=true, scale::Bool=true)</code></pre><p>Returns the largest eigenvalue of <code>A</code>. The option <code>permute=true</code> permutes the matrix to become closer to upper triangular, and <code>scale=true</code> scales the matrix by its diagonal elements to make rows and columns more equal in norm. Note that if the eigenvalues of <code>A</code> are complex, this method will fail, since complex numbers cannot be sorted.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; A = [0 im; -im 0]
2×2 Array{Complex{Int64},2}:
 0+0im  0+1im
 0-1im  0+0im

julia&gt; eigmax(A)
1.0

julia&gt; A = [0 im; -1 0]
2×2 Array{Complex{Int64},2}:
  0+0im  0+1im
 -1+0im  0+0im

julia&gt; eigmax(A)
ERROR: DomainError:
Stacktrace:
 [1] #eigmax#46(::Bool, ::Bool, ::Function, ::Array{Complex{Int64},2}) at ./linalg/eigen.jl:238
 [2] eigmax(::Array{Complex{Int64},2}) at ./linalg/eigen.jl:236</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/eigen.jl#L201-L234">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.eigmin" href="#Base.LinAlg.eigmin"><code>Base.LinAlg.eigmin</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">eigmin(A; permute::Bool=true, scale::Bool=true)</code></pre><p>Returns the smallest eigenvalue of <code>A</code>. The option <code>permute=true</code> permutes the matrix to become closer to upper triangular, and <code>scale=true</code> scales the matrix by its diagonal elements to make rows and columns more equal in norm. Note that if the eigenvalues of <code>A</code> are complex, this method will fail, since complex numbers cannot be sorted.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; A = [0 im; -im 0]
2×2 Array{Complex{Int64},2}:
 0+0im  0+1im
 0-1im  0+0im

julia&gt; eigmin(A)
-1.0

julia&gt; A = [0 im; -1 0]
2×2 Array{Complex{Int64},2}:
  0+0im  0+1im
 -1+0im  0+0im

julia&gt; eigmin(A)
ERROR: DomainError:
Stacktrace:
 [1] #eigmin#47(::Bool, ::Bool, ::Function, ::Array{Complex{Int64},2}) at ./linalg/eigen.jl:280
 [2] eigmin(::Array{Complex{Int64},2}) at ./linalg/eigen.jl:278</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/eigen.jl#L243-L276">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.eigvecs" href="#Base.LinAlg.eigvecs"><code>Base.LinAlg.eigvecs</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">eigvecs(A::SymTridiagonal[, eigvals]) -&gt; Matrix</code></pre><p>Returns a matrix <code>M</code> whose columns are the eigenvectors of <code>A</code>. (The <code>k</code>th eigenvector can be obtained from the slice <code>M[:, k]</code>.)</p><p>If the optional vector of eigenvalues <code>eigvals</code> is specified, <code>eigvecs</code> returns the specific corresponding eigenvectors.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; A = SymTridiagonal([1.; 2.; 1.], [2.; 3.])
3×3 SymTridiagonal{Float64}:
 1.0  2.0   ⋅
 2.0  2.0  3.0
  ⋅   3.0  1.0

julia&gt; eigvals(A)
3-element Array{Float64,1}:
 -2.14005
  1.0
  5.14005

julia&gt; eigvecs(A)
3×3 Array{Float64,2}:
  0.418304  -0.83205      0.364299
 -0.656749  -7.39009e-16  0.754109
  0.627457   0.5547       0.546448

julia&gt; eigvecs(A, [1.])
3×1 Array{Float64,2}:
  0.83205
  4.26351e-17
 -0.5547</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/tridiag.jl#L217-L253">source</a><div><pre><code class="language-none">eigvecs(A; permute::Bool=true, scale::Bool=true) -&gt; Matrix</code></pre><p>Returns a matrix <code>M</code> whose columns are the eigenvectors of <code>A</code>. (The <code>k</code>th eigenvector can be obtained from the slice <code>M[:, k]</code>.) The <code>permute</code> and <code>scale</code> keywords are the same as for <a href="#Base.LinAlg.eigfact"><code>eigfact</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; eigvecs([1.0 0.0 0.0; 0.0 3.0 0.0; 0.0 0.0 18.0])
3×3 Array{Float64,2}:
 1.0  0.0  0.0
 0.0  1.0  0.0
 0.0  0.0  1.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/eigen.jl#L140-L156">source</a><div><pre><code class="language-none">eigvecs(A, B) -&gt; Matrix</code></pre><p>Returns a matrix <code>M</code> whose columns are the generalized eigenvectors of <code>A</code> and <code>B</code>. (The <code>k</code>th eigenvector can be obtained from the slice <code>M[:, k]</code>.)</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1 0; 0 -1]
2×2 Array{Int64,2}:
 1   0
 0  -1

julia&gt; B = [0 1; 1 0]
2×2 Array{Int64,2}:
 0  1
 1  0

julia&gt; eigvecs(A, B)
2×2 Array{Complex{Float64},2}:
  0.0-1.0im   0.0+1.0im
 -1.0-0.0im  -1.0+0.0im</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/eigen.jl#L412-L436">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.eigfact" href="#Base.LinAlg.eigfact"><code>Base.LinAlg.eigfact</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">eigfact(A; permute::Bool=true, scale::Bool=true) -&gt; Eigen</code></pre><p>Computes the eigenvalue decomposition of <code>A</code>, returning an <code>Eigen</code> factorization object <code>F</code> which contains the eigenvalues in <code>F[:values]</code> and the eigenvectors in the columns of the matrix <code>F[:vectors]</code>. (The <code>k</code>th eigenvector can be obtained from the slice <code>F[:vectors][:, k]</code>.)</p><p>The following functions are available for <code>Eigen</code> objects: <a href="#Base.inv"><code>inv</code></a>, <a href="#Base.LinAlg.det"><code>det</code></a>, and <a href="#Base.LinAlg.isposdef"><code>isposdef</code></a>.</p><p>For general nonsymmetric matrices it is possible to specify how the matrix is balanced before the eigenvector calculation. The option <code>permute=true</code> permutes the matrix to become closer to upper triangular, and <code>scale=true</code> scales the matrix by its diagonal elements to make rows and columns more equal in norm. The default is <code>true</code> for both options.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; F = eigfact([1.0 0.0 0.0; 0.0 3.0 0.0; 0.0 0.0 18.0])
Base.LinAlg.Eigen{Float64,Float64,Array{Float64,2},Array{Float64,1}}([1.0, 3.0, 18.0], [1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0])

julia&gt; F[:values]
3-element Array{Float64,1}:
  1.0
  3.0
 18.0

julia&gt; F[:vectors]
3×3 Array{Float64,2}:
 1.0  0.0  0.0
 0.0  1.0  0.0
 0.0  0.0  1.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/eigen.jl#L68-L100">source</a><div><pre><code class="language-none">eigfact(A, B) -&gt; GeneralizedEigen</code></pre><p>Computes the generalized eigenvalue decomposition of <code>A</code> and <code>B</code>, returning a <code>GeneralizedEigen</code> factorization object <code>F</code> which contains the generalized eigenvalues in <code>F[:values]</code> and the generalized eigenvectors in the columns of the matrix <code>F[:vectors]</code>. (The <code>k</code>th generalized eigenvector can be obtained from the slice <code>F[:vectors][:, k]</code>.)</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/eigen.jl#L318-L325">source</a><div><pre><code class="language-none">eigfact(A::Union{SymTridiagonal, Hermitian, Symmetric}, irange::UnitRange) -&gt; Eigen</code></pre><p>Computes the eigenvalue decomposition of <code>A</code>, returning an <code>Eigen</code> factorization object <code>F</code> which contains the eigenvalues in <code>F[:values]</code> and the eigenvectors in the columns of the matrix <code>F[:vectors]</code>. (The <code>k</code>th eigenvector can be obtained from the slice <code>F[:vectors][:, k]</code>.)</p><p>The following functions are available for <code>Eigen</code> objects: <a href="#Base.inv"><code>inv</code></a>, <a href="#Base.LinAlg.det"><code>det</code></a>, and <a href="#Base.LinAlg.isposdef"><code>isposdef</code></a>.</p><p>The <code>UnitRange</code> <code>irange</code> specifies indices of the sorted eigenvalues to search for.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>If <code>irange</code> is not <code>1:n</code>, where <code>n</code> is the dimension of <code>A</code>, then the returned factorization will be a <em>truncated</em> factorization.</p></div></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/symmetric.jl#L303-L317">source</a><div><pre><code class="language-none">eigfact(A::Union{SymTridiagonal, Hermitian, Symmetric}, vl::Real, vu::Real) -&gt; Eigen</code></pre><p>Computes the eigenvalue decomposition of <code>A</code>, returning an <code>Eigen</code> factorization object <code>F</code> which contains the eigenvalues in <code>F[:values]</code> and the eigenvectors in the columns of the matrix <code>F[:vectors]</code>. (The <code>k</code>th eigenvector can be obtained from the slice <code>F[:vectors][:, k]</code>.)</p><p>The following functions are available for <code>Eigen</code> objects: <a href="#Base.inv"><code>inv</code></a>, <a href="#Base.LinAlg.det"><code>det</code></a>, and <a href="#Base.LinAlg.isposdef"><code>isposdef</code></a>.</p><p><code>vl</code> is the lower bound of the window of eigenvalues to search for, and <code>vu</code> is the upper bound.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>If [<code>vl</code>, <code>vu</code>] does not contain all eigenvalues of <code>A</code>, then the returned factorization will be a <em>truncated</em> factorization.</p></div></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/symmetric.jl#L327-L341">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.eigfact!" href="#Base.LinAlg.eigfact!"><code>Base.LinAlg.eigfact!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">eigfact!(A, [B])</code></pre><p>Same as <a href="#Base.LinAlg.eigfact"><code>eigfact</code></a>, but saves space by overwriting the input <code>A</code> (and <code>B</code>), instead of creating a copy.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/eigen.jl#L32-L37">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.hessfact" href="#Base.LinAlg.hessfact"><code>Base.LinAlg.hessfact</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">hessfact(A) -&gt; Hessenberg</code></pre><p>Compute the Hessenberg decomposition of <code>A</code> and return a <code>Hessenberg</code> object. If <code>F</code> is the factorization object, the unitary matrix can be accessed with <code>F[:Q]</code> and the Hessenberg matrix with <code>F[:H]</code>. When <code>Q</code> is extracted, the resulting type is the <code>HessenbergQ</code> object, and may be converted to a regular matrix with <a href="../base/#Base.convert"><code>convert(Array, _)</code></a>  (or <code>Array(_)</code> for short).</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; A = [4. 9. 7.; 4. 4. 1.; 4. 3. 2.]
3×3 Array{Float64,2}:
 4.0  9.0  7.0
 4.0  4.0  1.0
 4.0  3.0  2.0

julia&gt; F = hessfact(A);

julia&gt; F[:Q] * F[:H] * F[:Q]&#39;
3×3 Array{Float64,2}:
 4.0  9.0  7.0
 4.0  4.0  1.0
 4.0  3.0  2.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/hessenberg.jl#L24-L50">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.hessfact!" href="#Base.LinAlg.hessfact!"><code>Base.LinAlg.hessfact!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">hessfact!(A) -&gt; Hessenberg</code></pre><p><code>hessfact!</code> is the same as <a href="#Base.LinAlg.hessfact"><code>hessfact</code></a>, but saves space by overwriting the input <code>A</code>, instead of creating a copy.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/hessenberg.jl#L14-L19">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.schurfact" href="#Base.LinAlg.schurfact"><code>Base.LinAlg.schurfact</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">schurfact(A::StridedMatrix) -&gt; F::Schur</code></pre><p>Computes the Schur factorization of the matrix <code>A</code>. The (quasi) triangular Schur factor can be obtained from the <code>Schur</code> object <code>F</code> with either <code>F[:Schur]</code> or <code>F[:T]</code> and the orthogonal/unitary Schur vectors can be obtained with <code>F[:vectors]</code> or <code>F[:Z]</code> such that <code>A = F[:vectors]*F[:Schur]*F[:vectors]&#39;</code>. The eigenvalues of <code>A</code> can be obtained with <code>F[:values]</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; A = [-2. 1. 3.; 2. 1. -1.; -7. 2. 7.]
3×3 Array{Float64,2}:
 -2.0  1.0   3.0
  2.0  1.0  -1.0
 -7.0  2.0   7.0

julia&gt; F = schurfact(A)
Base.LinAlg.Schur{Float64,Array{Float64,2}} with factors T and Z:
[2.0 0.801792 6.63509; -8.55988e-11 2.0 8.08286; 0.0 0.0 1.99999]
[0.577351 0.154299 -0.801784; 0.577346 -0.77152 0.267262; 0.577354 0.617211 0.534522]
and values:
Complex{Float64}[2.0+8.28447e-6im, 2.0-8.28447e-6im, 1.99999+0.0im]

julia&gt; F[:vectors] * F[:Schur] * F[:vectors]&#39;
3×3 Array{Float64,2}:
 -2.0  1.0   3.0
  2.0  1.0  -1.0
 -7.0  2.0   7.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/schur.jl#L19-L49">source</a><div><pre><code class="language-none">schurfact(A::StridedMatrix, B::StridedMatrix) -&gt; F::GeneralizedSchur</code></pre><p>Computes the Generalized Schur (or QZ) factorization of the matrices <code>A</code> and <code>B</code>. The (quasi) triangular Schur factors can be obtained from the <code>Schur</code> object <code>F</code> with <code>F[:S]</code> and <code>F[:T]</code>, the left unitary/orthogonal Schur vectors can be obtained with <code>F[:left]</code> or <code>F[:Q]</code> and the right unitary/orthogonal Schur vectors can be obtained with <code>F[:right]</code> or <code>F[:Z]</code> such that <code>A=F[:left]*F[:S]*F[:right]&#39;</code> and <code>B=F[:left]*F[:T]*F[:right]&#39;</code>. The generalized eigenvalues of <code>A</code> and <code>B</code> can be obtained with <code>F[:alpha]./F[:beta]</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/schur.jl#L187-L196">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.schurfact!" href="#Base.LinAlg.schurfact!"><code>Base.LinAlg.schurfact!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">schurfact!(A::StridedMatrix) -&gt; F::Schur</code></pre><p>Same as <a href="#Base.LinAlg.schurfact"><code>schurfact</code></a> but uses the input argument as workspace.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/schur.jl#L12-L16">source</a><div><pre><code class="language-none">schurfact!(A::StridedMatrix, B::StridedMatrix) -&gt; F::GeneralizedSchur</code></pre><p>Same as <a href="#Base.LinAlg.schurfact"><code>schurfact</code></a> but uses the input matrices <code>A</code> and <code>B</code> as workspace.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/schur.jl#L179-L183">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.schur" href="#Base.LinAlg.schur"><code>Base.LinAlg.schur</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">schur(A::StridedMatrix) -&gt; T::Matrix, Z::Matrix, λ::Vector</code></pre><p>Computes the Schur factorization of the matrix <code>A</code>. The methods return the (quasi) triangular Schur factor <code>T</code> and the orthogonal/unitary Schur vectors <code>Z</code> such that <code>A = Z*T*Z&#39;</code>. The eigenvalues of <code>A</code> are returned in the vector <code>λ</code>.</p><p>See <a href="#Base.LinAlg.schurfact"><code>schurfact</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; A = [-2. 1. 3.; 2. 1. -1.; -7. 2. 7.]
3×3 Array{Float64,2}:
 -2.0  1.0   3.0
  2.0  1.0  -1.0
 -7.0  2.0   7.0

julia&gt; T, Z, lambda = schur(A)
([2.0 0.801792 6.63509; -8.55988e-11 2.0 8.08286; 0.0 0.0 1.99999], [0.577351 0.154299 -0.801784; 0.577346 -0.77152 0.267262; 0.577354 0.617211 0.534522], Complex{Float64}[2.0+8.28447e-6im, 2.0-8.28447e-6im, 1.99999+0.0im])

julia&gt; Z * T * Z&#39;
3×3 Array{Float64,2}:
 -2.0  1.0   3.0
  2.0  1.0  -1.0
 -7.0  2.0   7.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/schur.jl#L78-L105">source</a><div><pre><code class="language-none">schur(A::StridedMatrix, B::StridedMatrix) -&gt; S::StridedMatrix, T::StridedMatrix, Q::StridedMatrix, Z::StridedMatrix, α::Vector, β::Vector</code></pre><p>See <a href="#Base.LinAlg.schurfact"><code>schurfact</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/schur.jl#L271-L275">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.ordschur" href="#Base.LinAlg.ordschur"><code>Base.LinAlg.ordschur</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">ordschur(F::Schur, select::Union{Vector{Bool},BitVector}) -&gt; F::Schur</code></pre><p>Reorders the Schur factorization <code>F</code> of a matrix <code>A = Z*T*Z&#39;</code> according to the logical array <code>select</code> returning the reordered factorization <code>F</code> object. The selected eigenvalues appear in the leading diagonal of <code>F[:Schur]</code> and the corresponding leading columns of <code>F[:vectors]</code> form an orthogonal/unitary basis of the corresponding right invariant subspace. In the real case, a complex conjugate pair of eigenvalues must be either both included or both excluded via <code>select</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/schur.jl#L128-L137">source</a><div><pre><code class="language-none">ordschur(T::StridedMatrix, Z::StridedMatrix, select::Union{Vector{Bool},BitVector}) -&gt; T::StridedMatrix, Z::StridedMatrix, λ::Vector</code></pre><p>Reorders the Schur factorization of a real matrix <code>A = Z*T*Z&#39;</code> according to the logical array <code>select</code> returning the reordered matrices <code>T</code> and <code>Z</code> as well as the vector of eigenvalues <code>λ</code>. The selected eigenvalues appear in the leading diagonal of <code>T</code> and the corresponding leading columns of <code>Z</code> form an orthogonal/unitary basis of the corresponding right invariant subspace. In the real case, a complex conjugate pair of eigenvalues must be either both included or both excluded via <code>select</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/schur.jl#L149-L158">source</a><div><pre><code class="language-none">ordschur(F::GeneralizedSchur, select::Union{Vector{Bool},BitVector}) -&gt; F::GeneralizedSchur</code></pre><p>Reorders the Generalized Schur factorization <code>F</code> of a matrix pair <code>(A, B) = (Q*S*Z&#39;, Q*T*Z&#39;)</code> according to the logical array <code>select</code> and returns a GeneralizedSchur object <code>F</code>. The selected eigenvalues appear in the leading diagonal of both <code>F[:S]</code> and <code>F[:T]</code>, and the left and right orthogonal/unitary Schur vectors are also reordered such that <code>(A, B) = F[:Q]*(F[:S], F[:T])*F[:Z]&#39;</code> still holds and the generalized eigenvalues of <code>A</code> and <code>B</code> can still be obtained with <code>F[:alpha]./F[:beta]</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/schur.jl#L215-L224">source</a><div><pre><code class="language-none">ordschur(S::StridedMatrix, T::StridedMatrix, Q::StridedMatrix, Z::StridedMatrix, select) -&gt; S::StridedMatrix, T::StridedMatrix, Q::StridedMatrix, Z::StridedMatrix, α::Vector, β::Vector</code></pre><p>Reorders the Generalized Schur factorization of a matrix pair <code>(A, B) = (Q*S*Z&#39;, Q*T*Z&#39;)</code> according to the logical array <code>select</code> and returns the matrices <code>S</code>, <code>T</code>, <code>Q</code>, <code>Z</code> and vectors <code>α</code> and <code>β</code>.  The selected eigenvalues appear in the leading diagonal of both <code>S</code> and <code>T</code>, and the left and right unitary/orthogonal Schur vectors are also reordered such that <code>(A, B) = Q*(S, T)*Z&#39;</code> still holds and the generalized eigenvalues of <code>A</code> and <code>B</code> can still be obtained with <code>α./β</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/schur.jl#L237-L246">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.ordschur!" href="#Base.LinAlg.ordschur!"><code>Base.LinAlg.ordschur!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">ordschur!(F::Schur, select::Union{Vector{Bool},BitVector}) -&gt; F::Schur</code></pre><p>Same as <a href="#Base.LinAlg.ordschur"><code>ordschur</code></a> but overwrites the factorization <code>F</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/schur.jl#L117-L121">source</a><div><pre><code class="language-none">ordschur!(T::StridedMatrix, Z::StridedMatrix, select::Union{Vector{Bool},BitVector}) -&gt; T::StridedMatrix, Z::StridedMatrix, λ::Vector</code></pre><p>Same as <a href="#Base.LinAlg.ordschur"><code>ordschur</code></a> but overwrites the input arguments.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/schur.jl#L141-L145">source</a><div><pre><code class="language-none">ordschur!(F::GeneralizedSchur, select::Union{Vector{Bool},BitVector}) -&gt; F::GeneralizedSchur</code></pre><p>Same as <code>ordschur</code> but overwrites the factorization <code>F</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/schur.jl#L203-L207">source</a><div><pre><code class="language-none">ordschur!(S::StridedMatrix, T::StridedMatrix, Q::StridedMatrix, Z::StridedMatrix, select) -&gt; S::StridedMatrix, T::StridedMatrix, Q::StridedMatrix, Z::StridedMatrix, α::Vector, β::Vector</code></pre><p>Same as <a href="#Base.LinAlg.ordschur"><code>ordschur</code></a> but overwrites the factorization the input arguments.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/schur.jl#L228-L232">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.svdfact" href="#Base.LinAlg.svdfact"><code>Base.LinAlg.svdfact</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">svdfact(A; thin::Bool=true) -&gt; SVD</code></pre><p>Compute the singular value decomposition (SVD) of <code>A</code> and return an <code>SVD</code> object.</p><p><code>U</code>, <code>S</code>, <code>V</code> and <code>Vt</code> can be obtained from the factorization <code>F</code> with <code>F[:U]</code>, <code>F[:S]</code>, <code>F[:V]</code> and <code>F[:Vt]</code>, such that <code>A = U*diagm(S)*Vt</code>. The algorithm produces <code>Vt</code> and hence <code>Vt</code> is more efficient to extract than <code>V</code>. The singular values in <code>S</code> are sorted in descending order.</p><p>If <code>thin=true</code> (default), a thin SVD is returned. For a <span>$M \times N$</span> matrix <code>A</code>, <code>U</code> is <span>$M \times M$</span> for a full SVD (<code>thin=false</code>) and <span>$M \times \min(M, N)$</span> for a thin SVD.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1. 0. 0. 0. 2.; 0. 0. 3. 0. 0.; 0. 0. 0. 0. 0.; 0. 2. 0. 0. 0.]
4×5 Array{Float64,2}:
 1.0  0.0  0.0  0.0  2.0
 0.0  0.0  3.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0
 0.0  2.0  0.0  0.0  0.0

julia&gt; F = svdfact(A)
Base.LinAlg.SVD{Float64,Float64,Array{Float64,2}}([0.0 1.0 0.0 0.0; 1.0 0.0 0.0 0.0; 0.0 0.0 0.0 -1.0; 0.0 0.0 1.0 0.0], [3.0, 2.23607, 2.0, 0.0], [-0.0 0.0 … -0.0 0.0; 0.447214 0.0 … 0.0 0.894427; -0.0 1.0 … -0.0 0.0; 0.0 0.0 … 1.0 0.0])

julia&gt; F[:U] * diagm(F[:S]) * F[:Vt]
4×5 Array{Float64,2}:
 1.0  0.0  0.0  0.0  2.0
 0.0  0.0  3.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0
 0.0  2.0  0.0  0.0  0.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/svd.jl#L29-L62">source</a><div><pre><code class="language-none">svdfact(A, B) -&gt; GeneralizedSVD</code></pre><p>Compute the generalized SVD of <code>A</code> and <code>B</code>, returning a <code>GeneralizedSVD</code> factorization object <code>F</code>, such that <code>A = F[:U]*F[:D1]*F[:R0]*F[:Q]&#39;</code> and <code>B = F[:V]*F[:D2]*F[:R0]*F[:Q]&#39;</code>.</p><p>For an M-by-N matrix <code>A</code> and P-by-N matrix <code>B</code>,</p><ul><li><p><code>F[:U]</code> is a M-by-M orthogonal matrix,</p></li><li><p><code>F[:V]</code> is a P-by-P orthogonal matrix,</p></li><li><p><code>F[:Q]</code> is a N-by-N orthogonal matrix,</p></li><li><p><code>F[:R0]</code> is a (K+L)-by-N matrix whose rightmost (K+L)-by-(K+L) block is          nonsingular upper block triangular,</p></li><li><p><code>F[:D1]</code> is a M-by-(K+L) diagonal matrix with 1s in the first K entries,</p></li><li><p><code>F[:D2]</code> is a P-by-(K+L) matrix whose top right L-by-L block is diagonal,</p></li></ul><p><code>K+L</code> is the effective numerical rank of the matrix <code>[A; B]</code>.</p><p>The entries of <code>F[:D1]</code> and <code>F[:D2]</code> are related, as explained in the LAPACK documentation for the <a href="http://www.netlib.org/lapack/lug/node36.html">generalized SVD</a> and the <a href="http://www.netlib.org/lapack/explore-html/d6/db3/dggsvd3_8f.html">xGGSVD3</a> routine which is called underneath (in LAPACK 3.6.0 and newer).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/svd.jl#L206-L229">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.svdfact!" href="#Base.LinAlg.svdfact!"><code>Base.LinAlg.svdfact!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">svdfact!(A, thin::Bool=true) -&gt; SVD</code></pre><p><code>svdfact!</code> is the same as <a href="#Base.LinAlg.svdfact"><code>svdfact</code></a>, but saves space by overwriting the input <code>A</code>, instead of creating a copy.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/svd.jl#L13-L18">source</a><div><pre><code class="language-none">svdfact!(A, B) -&gt; GeneralizedSVD</code></pre><p><code>svdfact!</code> is the same as <a href="#Base.LinAlg.svdfact"><code>svdfact</code></a>, but modifies the arguments <code>A</code> and <code>B</code> in-place, instead of making copies.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/svd.jl#L189-L194">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.svd" href="#Base.LinAlg.svd"><code>Base.LinAlg.svd</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">svd(A; thin::Bool=true) -&gt; U, S, V</code></pre><p>Computes the SVD of <code>A</code>, returning <code>U</code>, vector <code>S</code>, and <code>V</code> such that <code>A == U*diagm(S)*V&#39;</code>. The singular values in <code>S</code> are sorted in descending order.</p><p>If <code>thin=true</code> (default), a thin SVD is returned. For a <span>$M \times N$</span> matrix <code>A</code>, <code>U</code> is <span>$M \times M$</span> for a full SVD (<code>thin=false</code>) and <span>$M \times \min(M, N)$</span> for a thin SVD.</p><p><code>svd</code> is a wrapper around <a href="#Base.LinAlg.svdfact"><code>svdfact</code></a>, extracting all parts of the <code>SVD</code> factorization to a tuple. Direct use of <code>svdfact</code> is therefore more efficient.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1. 0. 0. 0. 2.; 0. 0. 3. 0. 0.; 0. 0. 0. 0. 0.; 0. 2. 0. 0. 0.]
4×5 Array{Float64,2}:
 1.0  0.0  0.0  0.0  2.0
 0.0  0.0  3.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0
 0.0  2.0  0.0  0.0  0.0

julia&gt; U, S, V = svd(A)
([0.0 1.0 0.0 0.0; 1.0 0.0 0.0 0.0; 0.0 0.0 0.0 -1.0; 0.0 0.0 1.0 0.0], [3.0, 2.23607, 2.0, 0.0], [-0.0 0.447214 -0.0 0.0; 0.0 0.0 1.0 0.0; … ; -0.0 0.0 -0.0 1.0; 0.0 0.894427 0.0 0.0])

julia&gt; U*diagm(S)*V&#39;
4×5 Array{Float64,2}:
 1.0  0.0  0.0  0.0  2.0
 0.0  0.0  3.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0
 0.0  2.0  0.0  0.0  0.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/svd.jl#L70-L104">source</a><div><pre><code class="language-none">svd(A, B) -&gt; U, V, Q, D1, D2, R0</code></pre><p>Wrapper around <a href="#Base.LinAlg.svdfact"><code>svdfact</code></a> extracting all parts of the factorization to a tuple. Direct use of <code>svdfact</code> is therefore generally more efficient. The function returns the generalized SVD of <code>A</code> and <code>B</code>, returning <code>U</code>, <code>V</code>, <code>Q</code>, <code>D1</code>, <code>D2</code>, and <code>R0</code> such that <code>A = U*D1*R0*Q&#39;</code> and <code>B = V*D2*R0*Q&#39;</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/svd.jl#L235-L243">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.svdvals" href="#Base.LinAlg.svdvals"><code>Base.LinAlg.svdvals</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">svdvals(A)</code></pre><p>Returns the singular values of <code>A</code> in descending order.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1. 0. 0. 0. 2.; 0. 0. 3. 0. 0.; 0. 0. 0. 0. 0.; 0. 2. 0. 0. 0.]
4×5 Array{Float64,2}:
 1.0  0.0  0.0  0.0  2.0
 0.0  0.0  3.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0
 0.0  2.0  0.0  0.0  0.0

julia&gt; svdvals(A)
4-element Array{Float64,1}:
 3.0
 2.23607
 2.0
 0.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/svd.jl#L133-L155">source</a><div><pre><code class="language-none">svdvals(A, B)</code></pre><p>Return the generalized singular values from the generalized singular value decomposition of <code>A</code> and <code>B</code>. See also <a href="#Base.LinAlg.svdfact"><code>svdfact</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/svd.jl#L298-L303">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.Givens" href="#Base.LinAlg.Givens"><code>Base.LinAlg.Givens</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">LinAlg.Givens(i1,i2,c,s) -&gt; G</code></pre><p>A Givens rotation linear operator. The fields <code>c</code> and <code>s</code> represent the cosine and sine of the rotation angle, respectively. The <code>Givens</code> type supports left multiplication <code>G*A</code> and conjugated transpose right multiplication <code>A*G&#39;</code>. The type doesn&#39;t have a <code>size</code> and can therefore be multiplied with matrices of arbitrary size as long as <code>i2&lt;=size(A,2)</code> for <code>G*A</code> or <code>i2&lt;=size(A,1)</code> for <code>A*G&#39;</code>.</p><p>See also: <a href="#Base.LinAlg.givens"><code>givens</code></a></p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/givens.jl#L16-L26">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.givens" href="#Base.LinAlg.givens"><code>Base.LinAlg.givens</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">givens{T}(f::T, g::T, i1::Integer, i2::Integer) -&gt; (G::Givens, r::T)</code></pre><p>Computes the Givens rotation <code>G</code> and scalar <code>r</code> such that for any vector <code>x</code> where</p><pre><code class="language-none">x[i1] = f
x[i2] = g</code></pre><p>the result of the multiplication</p><pre><code class="language-none">y = G*x</code></pre><p>has the property that</p><pre><code class="language-none">y[i1] = r
y[i2] = 0</code></pre><p>See also: <a href="#Base.LinAlg.Givens"><code>LinAlg.Givens</code></a></p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/givens.jl#L234-L254">source</a><div><pre><code class="language-none">givens(A::AbstractArray, i1::Integer, i2::Integer, j::Integer) -&gt; (G::Givens, r)</code></pre><p>Computes the Givens rotation <code>G</code> and scalar <code>r</code> such that the result of the multiplication</p><pre><code class="language-none">B = G*A</code></pre><p>has the property that</p><pre><code class="language-none">B[i1,j] = r
B[i2,j] = 0</code></pre><p>See also: <a href="#Base.LinAlg.Givens"><code>LinAlg.Givens</code></a></p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/givens.jl#L266-L280">source</a><div><pre><code class="language-none">givens(x::AbstractVector, i1::Integer, i2::Integer) -&gt; (G::Givens, r)</code></pre><p>Computes the Givens rotation <code>G</code> and scalar <code>r</code> such that the result of the multiplication</p><pre><code class="language-none">B = G*x</code></pre><p>has the property that</p><pre><code class="language-none">B[i1] = r
B[i2] = 0</code></pre><p>See also: <a href="#Base.LinAlg.Givens"><code>LinAlg.Givens</code></a></p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/givens.jl#L285-L299">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.triu" href="#Base.LinAlg.triu"><code>Base.LinAlg.triu</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">triu(M)</code></pre><p>Upper triangle of a matrix.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; a = ones(4,4)
4×4 Array{Float64,2}:
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0

julia&gt; triu(a)
4×4 Array{Float64,2}:
 1.0  1.0  1.0  1.0
 0.0  1.0  1.0  1.0
 0.0  0.0  1.0  1.0
 0.0  0.0  0.0  1.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/generic.jl#L119-L141">source</a><div><pre><code class="language-none">triu(M, k::Integer)</code></pre><p>Returns the upper triangle of <code>M</code> starting from the <code>k</code>th superdiagonal.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; a = ones(4,4)
4×4 Array{Float64,2}:
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0

julia&gt; triu(a,3)
4×4 Array{Float64,2}:
 0.0  0.0  0.0  1.0
 0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0

julia&gt; triu(a,-3)
4×4 Array{Float64,2}:
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/generic.jl#L169-L198">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.triu!" href="#Base.LinAlg.triu!"><code>Base.LinAlg.triu!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">triu!(M)</code></pre><p>Upper triangle of a matrix, overwriting <code>M</code> in the process. See also <a href="#Base.LinAlg.triu"><code>triu</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/generic.jl#L233-L238">source</a><div><pre><code class="language-none">triu!(M, k::Integer)</code></pre><p>Returns the upper triangle of <code>M</code> starting from the <code>k</code>th superdiagonal, overwriting <code>M</code> in the process.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; M = [1 2 3 4 5; 1 2 3 4 5; 1 2 3 4 5; 1 2 3 4 5; 1 2 3 4 5]
5×5 Array{Int64,2}:
 1  2  3  4  5
 1  2  3  4  5
 1  2  3  4  5
 1  2  3  4  5
 1  2  3  4  5

julia&gt; triu!(M, 1)
5×5 Array{Int64,2}:
 0  2  3  4  5
 0  0  3  4  5
 0  0  0  4  5
 0  0  0  0  5
 0  0  0  0  0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/dense.jl#L99-L123">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.tril" href="#Base.LinAlg.tril"><code>Base.LinAlg.tril</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">tril(M)</code></pre><p>Lower triangle of a matrix.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; a = ones(4,4)
4×4 Array{Float64,2}:
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0

julia&gt; tril(a)
4×4 Array{Float64,2}:
 1.0  0.0  0.0  0.0
 1.0  1.0  0.0  0.0
 1.0  1.0  1.0  0.0
 1.0  1.0  1.0  1.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/generic.jl#L144-L166">source</a><div><pre><code class="language-none">tril(M, k::Integer)</code></pre><p>Returns the lower triangle of <code>M</code> starting from the <code>k</code>th superdiagonal.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; a = ones(4,4)
4×4 Array{Float64,2}:
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0

julia&gt; tril(a,3)
4×4 Array{Float64,2}:
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0

julia&gt; tril(a,-3)
4×4 Array{Float64,2}:
 0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0
 1.0  0.0  0.0  0.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/generic.jl#L201-L230">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.tril!" href="#Base.LinAlg.tril!"><code>Base.LinAlg.tril!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">tril!(M)</code></pre><p>Lower triangle of a matrix, overwriting <code>M</code> in the process. See also <a href="#Base.LinAlg.tril"><code>tril</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/generic.jl#L241-L246">source</a><div><pre><code class="language-none">tril!(M, k::Integer)</code></pre><p>Returns the lower triangle of <code>M</code> starting from the <code>k</code>th superdiagonal, overwriting <code>M</code> in the process.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; M = [1 2 3 4 5; 1 2 3 4 5; 1 2 3 4 5; 1 2 3 4 5; 1 2 3 4 5]
5×5 Array{Int64,2}:
 1  2  3  4  5
 1  2  3  4  5
 1  2  3  4  5
 1  2  3  4  5
 1  2  3  4  5

julia&gt; tril!(M, 2)
5×5 Array{Int64,2}:
 1  2  3  0  0
 1  2  3  4  0
 1  2  3  4  5
 1  2  3  4  5
 1  2  3  4  5</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/dense.jl#L142-L167">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.diagind" href="#Base.LinAlg.diagind"><code>Base.LinAlg.diagind</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">diagind(M, k::Integer=0)</code></pre><p>A <code>Range</code> giving the indices of the <code>k</code>th diagonal of the matrix <code>M</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1 2 3; 4 5 6; 7 8 9]
3×3 Array{Int64,2}:
 1  2  3
 4  5  6
 7  8  9

julia&gt; diagind(A,-1)
2:4:6</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/dense.jl#L209-L226">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.diag" href="#Base.LinAlg.diag"><code>Base.LinAlg.diag</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">diag(M, k::Integer=0)</code></pre><p>The <code>k</code>th diagonal of a matrix, as a vector. Use <a href="#Base.LinAlg.diagm"><code>diagm</code></a> to construct a diagonal matrix.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1 2 3; 4 5 6; 7 8 9]
3×3 Array{Int64,2}:
 1  2  3
 4  5  6
 7  8  9

julia&gt; diag(A,1)
2-element Array{Int64,1}:
 2
 6</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/dense.jl#L229-L249">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.diagm" href="#Base.LinAlg.diagm"><code>Base.LinAlg.diagm</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">diagm(v, k::Integer=0)</code></pre><p>Construct a matrix by placing <code>v</code> on the <code>k</code>th diagonal.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; diagm([1,2,3],1)
4×4 Array{Int64,2}:
 0  1  0  0
 0  0  2  0
 0  0  0  3
 0  0  0  0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/dense.jl#L252-L267">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.scale!" href="#Base.LinAlg.scale!"><code>Base.LinAlg.scale!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">scale!(A, b)
scale!(b, A)</code></pre><p>Scale an array <code>A</code> by a scalar <code>b</code> overwriting <code>A</code> in-place.</p><p>If <code>A</code> is a matrix and <code>b</code> is a vector, then <code>scale!(A,b)</code> scales each column <code>i</code> of <code>A</code> by <code>b[i]</code> (similar to <code>A*Diagonal(b)</code>), while <code>scale!(b,A)</code> scales each row <code>i</code> of <code>A</code> by <code>b[i]</code> (similar to <code>Diagonal(b)*A</code>), again operating in-place on <code>A</code>. An <code>InexactError</code> exception is thrown if the scaling produces a number not representable by the element type of <code>A</code>, e.g. for integer types.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; a = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; b = [1; 2]
2-element Array{Int64,1}:
 1
 2

julia&gt; scale!(a,b)
2×2 Array{Int64,2}:
 1  4
 3  8

julia&gt; a = [1 2; 3 4];

julia&gt; b = [1; 2];

julia&gt; scale!(b,a)
2×2 Array{Int64,2}:
 1  2
 6  8</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/generic.jl#L45-L84">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.rank" href="#Base.LinAlg.rank"><code>Base.LinAlg.rank</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">rank(M[, tol::Real])</code></pre><p>Compute the rank of a matrix by counting how many singular values of <code>M</code> have magnitude greater than <code>tol</code>. By default, the value of <code>tol</code> is the largest dimension of <code>M</code> multiplied by the <a href="../dates/#Base.eps"><code>eps</code></a> of the <a href="../collections/#Base.eltype"><code>eltype</code></a> of <code>M</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; rank(eye(3))
3

julia&gt; rank(diagm([1, 0, 2]))
2

julia&gt; rank(diagm([1, 0.001, 2]), 0.1)
2

julia&gt; rank(diagm([1, 0.001, 2]), 0.00001)
3</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/generic.jl#L697-L720">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.norm" href="#Base.LinAlg.norm"><code>Base.LinAlg.norm</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">norm(A::AbstractArray, p::Real=2)</code></pre><p>Compute the <code>p</code>-norm of a vector or the operator norm of a matrix <code>A</code>, defaulting to the 2-norm.</p><pre><code class="language-none">norm(A::AbstractVector, p::Real=2)</code></pre><p>For vectors, this is equivalent to <a href="#Base.LinAlg.vecnorm"><code>vecnorm</code></a> and equal to:</p><div>\[\|A\|_p = \left( \sum_{i=1}^n | a_i | ^p \right)^{1/p}\]</div><p>with <span>$a_i$</span> the entries of <span>$A$</span> and <span>$n$</span> its length.</p><p><code>p</code> can assume any numeric value (even though not all values produce a mathematically valid vector norm). In particular, <code>norm(A, Inf)</code> returns the largest value in <code>abs(A)</code>, whereas <code>norm(A, -Inf)</code> returns the smallest.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; v = [3, -2, 6]
3-element Array{Int64,1}:
  3
 -2
  6

julia&gt; norm(v)
7.0

julia&gt; norm(v, Inf)
6.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/generic.jl#L506-L539">source</a><div><pre><code class="language-none">norm(A::AbstractMatrix, p::Real=2)</code></pre><p>For matrices, the matrix norm induced by the vector <code>p</code>-norm is used, where valid values of <code>p</code> are <code>1</code>, <code>2</code>, or <code>Inf</code>. (Note that for sparse matrices, <code>p=2</code> is currently not implemented.) Use <a href="#Base.LinAlg.vecnorm"><code>vecnorm</code></a> to compute the Frobenius norm.</p><p>When <code>p=1</code>, the matrix norm is the maximum absolute column sum of <code>A</code>:</p><div>\[\|A\|_1 = \max_{1 ≤ j ≤ n} \sum_{i=1}^m | a_{ij} |\]</div><p>with <span>$a_{ij}$</span> the entries of <span>$A$</span>, and <span>$m$</span> and <span>$n$</span> its dimensions.</p><p>When <code>p=2</code>, the matrix norm is the spectral norm, equal to the largest singular value of <code>A</code>.</p><p>When <code>p=Inf</code>, the matrix norm is the maximum absolute row sum of <code>A</code>:</p><div>\[\|A\|_\infty = \max_{1 ≤ i ≤ m} \sum _{j=1}^n | a_{ij} |\]</div><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1 -2 -3; 2 3 -1]
2×3 Array{Int64,2}:
 1  -2  -3
 2   3  -1

julia&gt; norm(A, Inf)
6.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/generic.jl#L542-L574">source</a><div><pre><code class="language-none">norm(x::Number, p::Real=2)</code></pre><p>For numbers, return <span>$\left( |x|^p \right)^{1/p}$</span>. This is equivalent to <a href="#Base.LinAlg.vecnorm"><code>vecnorm</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/generic.jl#L587-L592">source</a><div><pre><code class="language-none">norm(A::RowVector, q::Real=2)</code></pre><p>For row vectors, return the <span>$q$</span>-norm of <code>A</code>, which is equivalent to the p-norm with value <code>p = q/(q-1)</code>. They coincide at <code>p = q = 2</code>.</p><p>The difference in norm between a vector space and its dual arises to preserve the relationship between duality and the inner product, and the result is consistent with the p-norm of <code>1 × n</code> matrix.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/generic.jl#L597-L606">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.vecnorm" href="#Base.LinAlg.vecnorm"><code>Base.LinAlg.vecnorm</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">vecnorm(A, p::Real=2)</code></pre><p>For any iterable container <code>A</code> (including arrays of any dimension) of numbers (or any element type for which <code>norm</code> is defined), compute the <code>p</code>-norm (defaulting to <code>p=2</code>) as if <code>A</code> were a vector of the corresponding length.</p><p>The <code>p</code>-norm is defined as:</p><div>\[\|A\|_p = \left( \sum_{i=1}^n | a_i | ^p \right)^{1/p}\]</div><p>with <span>$a_i$</span> the entries of <span>$A$</span> and <span>$n$</span> its length.</p><p><code>p</code> can assume any numeric value (even though not all values produce a mathematically valid vector norm). In particular, <code>vecnorm(A, Inf)</code> returns the largest value in <code>abs(A)</code>, whereas <code>vecnorm(A, -Inf)</code> returns the smallest. If <code>A</code> is a matrix and <code>p=2</code>, then this is equivalent to the Frobenius norm.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; vecnorm([1 2 3; 4 5 6; 7 8 9])
16.881943016134134

julia&gt; vecnorm([1 2 3 4 5 6 7 8 9])
16.881943016134134</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/generic.jl#L414-L441">source</a><div><pre><code class="language-none">vecnorm(x::Number, p::Real=2)</code></pre><p>For numbers, return <span>$\left( |x|^p \right) ^{1/p}$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/generic.jl#L460-L464">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.normalize!" href="#Base.LinAlg.normalize!"><code>Base.LinAlg.normalize!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">normalize!(v::AbstractVector, p::Real=2)</code></pre><p>Normalize the vector <code>v</code> in-place so that its <code>p</code>-norm equals unity, i.e. <code>norm(v, p) == 1</code>. See also <a href="#Base.LinAlg.normalize"><code>normalize</code></a> and <a href="#Base.LinAlg.vecnorm"><code>vecnorm</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/generic.jl#L1306-L1312">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.normalize" href="#Base.LinAlg.normalize"><code>Base.LinAlg.normalize</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">normalize(v::AbstractVector, p::Real=2)</code></pre><p>Normalize the vector <code>v</code> so that its <code>p</code>-norm equals unity, i.e. <code>norm(v, p) == vecnorm(v, p) == 1</code>. See also <a href="#Base.LinAlg.normalize!"><code>normalize!</code></a> and <a href="#Base.LinAlg.vecnorm"><code>vecnorm</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = [1,2,4];

julia&gt; b = normalize(a)
3-element Array{Float64,1}:
 0.218218
 0.436436
 0.872872

julia&gt; norm(b)
1.0

julia&gt; c = normalize(a, 1)
3-element Array{Float64,1}:
 0.142857
 0.285714
 0.571429

julia&gt; norm(c, 1)
1.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/generic.jl#L1335-L1365">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.cond" href="#Base.LinAlg.cond"><code>Base.LinAlg.cond</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">cond(M, p::Real=2)</code></pre><p>Condition number of the matrix <code>M</code>, computed using the operator <code>p</code>-norm. Valid values for <code>p</code> are <code>1</code>, <code>2</code> (default), or <code>Inf</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/dense.jl#L904-L909">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.condskeel" href="#Base.LinAlg.condskeel"><code>Base.LinAlg.condskeel</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">condskeel(M, [x, p::Real=Inf])</code></pre><div>\[\kappa_S(M, p) = \left\Vert \left\vert M \right\vert \left\vert M^{-1} \right\vert \right\Vert_p \\
\kappa_S(M, x, p) = \left\Vert \left\vert M \right\vert \left\vert M^{-1} \right\vert \left\vert x \right\vert \right\Vert_p\]</div><p>Skeel condition number <span>$\kappa_S$</span> of the matrix <code>M</code>, optionally with respect to the vector <code>x</code>, as computed using the operator <code>p</code>-norm. <span>$\left\vert M \right\vert$</span> denotes the matrix of (entry wise) absolute values of <span>$M$</span>; <span>$\left\vert M \right\vert_{ij} = \left\vert M_{ij} \right\vert$</span>. Valid values for <code>p</code> are <code>1</code>, <code>2</code> and <code>Inf</code> (default).</p><p>This quantity is also known in the literature as the Bauer condition number, relative condition number, or componentwise relative condition number.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/generic.jl#L848-L864">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.trace" href="#Base.LinAlg.trace"><code>Base.LinAlg.trace</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">trace(M)</code></pre><p>Matrix trace. Sums the diagonal elements of <code>M</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; trace(A)
5</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/generic.jl#L730-L746">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.det" href="#Base.LinAlg.det"><code>Base.LinAlg.det</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">det(M)</code></pre><p>Matrix determinant.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; M = [1 0; 2 2]
2×2 Array{Int64,2}:
 1  0
 2  2

julia&gt; det(M)
2.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/generic.jl#L1204-L1220">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.logdet" href="#Base.LinAlg.logdet"><code>Base.LinAlg.logdet</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">logdet(M)</code></pre><p>Log of matrix determinant. Equivalent to <code>log(det(M))</code>, but may provide increased accuracy and/or speed.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; M = [1 0; 2 2]
2×2 Array{Int64,2}:
 1  0
 2  2

julia&gt; logdet(M)
0.6931471805599453

julia&gt; logdet(eye(3))
0.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/generic.jl#L1238-L1258">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.logabsdet" href="#Base.LinAlg.logabsdet"><code>Base.LinAlg.logabsdet</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">logabsdet(M)</code></pre><p>Log of absolute value of matrix determinant. Equivalent to <code>(log(abs(det(M))), sign(det(M)))</code>, but may provide increased accuracy and/or speed.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/generic.jl#L1230-L1235">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.inv" href="#Base.inv"><code>Base.inv</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">inv(M)</code></pre><p>Matrix inverse. Computes matrix <code>N</code> such that <code>M * N = I</code>, where <code>I</code> is the identity matrix. Computed by solving the left-division <code>N = M \ I</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; M = [2 5; 1 3]
2×2 Array{Int64,2}:
 2  5
 1  3

julia&gt; N = inv(M)
2×2 Array{Float64,2}:
  3.0  -5.0
 -1.0   2.0

julia&gt; M*N == N*M == eye(2)
true</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/generic.jl#L758-L782">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.pinv" href="#Base.LinAlg.pinv"><code>Base.LinAlg.pinv</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">pinv(M[, tol::Real])</code></pre><p>Computes the Moore-Penrose pseudoinverse.</p><p>For matrices <code>M</code> with floating point elements, it is convenient to compute the pseudoinverse by inverting only singular values above a given threshold, <code>tol</code>.</p><p>The optimal choice of <code>tol</code> varies both with the value of <code>M</code> and the intended application of the pseudoinverse. The default value of <code>tol</code> is <code>eps(real(float(one(eltype(M)))))*maximum(size(A))</code>, which is essentially machine epsilon for the real part of a matrix element multiplied by the larger matrix dimension. For inverting dense ill-conditioned matrices in a least-squares sense, <code>tol = sqrt(eps(real(float(one(eltype(M))))))</code> is recommended.</p><p>For more information, see <a href="#footnote-issue8859">[issue8859]</a>, <a href="#footnote-B96">[B96]</a>, <a href="#footnote-S84">[S84]</a>, <a href="#footnote-KY88">[KY88]</a>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; M = [1.5 1.3; 1.2 1.9]
2×2 Array{Float64,2}:
 1.5  1.3
 1.2  1.9

julia&gt; N = pinv(M)
2×2 Array{Float64,2}:
  1.47287   -1.00775
 -0.930233   1.16279

julia&gt; M * N
2×2 Array{Float64,2}:
 1.0          -2.22045e-16
 4.44089e-16   1.0</code></pre><div class="footnote" id="footnote-issue8859"><a href="#footnote-issue8859"><strong>[issue8859]</strong></a><p>Issue 8859, &quot;Fix least squares&quot;, https://github.com/JuliaLang/julia/pull/8859</p></div><div class="footnote" id="footnote-B96"><a href="#footnote-B96"><strong>[B96]</strong></a><p>Åke Björck, &quot;Numerical Methods for Least Squares Problems&quot;,  SIAM Press, Philadelphia, 1996, &quot;Other Titles in Applied Mathematics&quot;, Vol. 51. <a href="http://epubs.siam.org/doi/book/10.1137/1.9781611971484">doi:10.1137/1.9781611971484</a></p></div><div class="footnote" id="footnote-S84"><a href="#footnote-S84"><strong>[S84]</strong></a><p>G. W. Stewart, &quot;Rank Degeneracy&quot;, SIAM Journal on Scientific and Statistical Computing, 5(2), 1984, 403-413. <a href="http://epubs.siam.org/doi/abs/10.1137/0905030">doi:10.1137/0905030</a></p></div><div class="footnote" id="footnote-KY88"><a href="#footnote-KY88"><strong>[KY88]</strong></a><p>Konstantinos Konstantinides and Kung Yao, &quot;Statistical analysis of effective singular values in matrix rank determination&quot;, IEEE Transactions on Acoustics, Speech and Signal Processing, 36(5), 1988, 757-763. <a href="http://dx.doi.org/10.1109/29.1585">doi:10.1109/29.1585</a></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/dense.jl#L788-L832">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.nullspace" href="#Base.LinAlg.nullspace"><code>Base.LinAlg.nullspace</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">nullspace(M)</code></pre><p>Basis for nullspace of <code>M</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; M = [1 0 0; 0 1 0; 0 0 0]
3×3 Array{Int64,2}:
 1  0  0
 0  1  0
 0  0  0

julia&gt; nullspace(M)
3×1 Array{Float64,2}:
 0.0
 0.0
 1.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/dense.jl#L874-L894">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.repmat" href="#Base.repmat"><code>Base.repmat</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">repmat(A, m::Integer, n::Integer=1)</code></pre><p>Construct a matrix by repeating the given matrix (or vector) <code>m</code> times in dimension 1 and <code>n</code> times in dimension 2.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; repmat([1, 2, 3], 2)
6-element Array{Int64,1}:
 1
 2
 3
 1
 2
 3

julia&gt; repmat([1, 2, 3], 2, 3)
6×3 Array{Int64,2}:
 1  1  1
 2  2  2
 3  3  3
 1  1  1
 2  2  2
 3  3  3</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/abstractarraymath.jl#L283-L309">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.repeat" href="#Base.repeat"><code>Base.repeat</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">repeat(A::AbstractArray; inner=ntuple(x-&gt;1, ndims(A)), outer=ntuple(x-&gt;1, ndims(A)))</code></pre><p>Construct an array by repeating the entries of <code>A</code>. The i-th element of <code>inner</code> specifies the number of times that the individual entries of the i-th dimension of <code>A</code> should be repeated. The i-th element of <code>outer</code> specifies the number of times that a slice along the i-th dimension of <code>A</code> should be repeated. If <code>inner</code> or <code>outer</code> are omitted, no repetition is performed.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; repeat(1:2, inner=2)
4-element Array{Int64,1}:
 1
 1
 2
 2

julia&gt; repeat(1:2, outer=2)
4-element Array{Int64,1}:
 1
 2
 1
 2

julia&gt; repeat([1 2; 3 4], inner=(2, 1), outer=(1, 3))
4×6 Array{Int64,2}:
 1  2  1  2  1  2
 1  2  1  2  1  2
 3  4  3  4  3  4
 3  4  3  4  3  4</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/abstractarraymath.jl#L337-L369">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.kron" href="#Base.kron"><code>Base.kron</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">kron(A, B)</code></pre><p>Kronecker tensor product of two vectors or two matrices.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; B = [im 1; 1 -im]
2×2 Array{Complex{Int64},2}:
 0+1im  1+0im
 1+0im  0-1im

julia&gt; kron(A, B)
4×4 Array{Complex{Int64},2}:
 0+1im  1+0im  0+2im  2+0im
 1+0im  0-1im  2+0im  0-2im
 0+3im  3+0im  0+4im  4+0im
 3+0im  0-3im  4+0im  0-4im</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/dense.jl#L286-L311">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.SparseArrays.blkdiag" href="#Base.SparseArrays.blkdiag"><code>Base.SparseArrays.blkdiag</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">blkdiag(A...)</code></pre><p>Concatenate matrices block-diagonally. Currently only implemented for sparse matrices.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; blkdiag(speye(3), 2*speye(2))
5×5 SparseMatrixCSC{Float64,Int64} with 5 stored entries:
  [1, 1]  =  1.0
  [2, 2]  =  1.0
  [3, 3]  =  1.0
  [4, 4]  =  2.0
  [5, 5]  =  2.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/sparse/sparsematrix.jl#L3083-L3098">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.linreg" href="#Base.LinAlg.linreg"><code>Base.LinAlg.linreg</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">linreg(x, y)</code></pre><p>Perform simple linear regression using Ordinary Least Squares. Returns <code>a</code> and <code>b</code> such that <code>a + b*x</code> is the closest straight line to the given points <code>(x, y)</code>, i.e., such that the squared error between <code>y</code> and <code>a + b*x</code> is minimized.</p><p><strong>Examples:</strong></p><pre><code class="language-none">using PyPlot
x = 1.0:12.0
y = [5.5, 6.3, 7.6, 8.8, 10.9, 11.79, 13.48, 15.02, 17.77, 20.81, 22.0, 22.99]
a, b = linreg(x, y)          # Linear regression
plot(x, y, &quot;o&quot;)              # Plot (x, y) points
plot(x, a + b*x)             # Plot line determined by linear regression</code></pre><p>See also:</p><p><code>\</code>, <a href="../math/#Base.cov"><code>cov</code></a>, <a href="../math/#Base.std"><code>std</code></a>, <a href="../math/#Base.mean"><code>mean</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/generic.jl#L1048-L1068">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.expm" href="#Base.LinAlg.expm"><code>Base.LinAlg.expm</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">expm(A)</code></pre><p>Compute the matrix exponential of <code>A</code>, defined by</p><div>\[e^A = \sum_{n=0}^{\infty} \frac{A^n}{n!}.\]</div><p>For symmetric or Hermitian <code>A</code>, an eigendecomposition (<a href="#Base.LinAlg.eigfact"><code>eigfact</code></a>) is used, otherwise the scaling and squaring algorithm (see <a href="#footnote-H05">[H05]</a>) is chosen.</p><div class="footnote" id="footnote-H05"><a href="#footnote-H05"><strong>[H05]</strong></a><p>Nicholas J. Higham, &quot;The squaring and scaling method for the matrix exponential revisited&quot;, SIAM Journal on Matrix Analysis and Applications, 26(4), 2005, 1179-1193. <a href="http://dx.doi.org/10.1137/090768539">doi:10.1137/090768539</a></p></div><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; A = eye(2, 2)
2×2 Array{Float64,2}:
 1.0  0.0
 0.0  1.0

julia&gt; expm(A)
2×2 Array{Float64,2}:
 2.71828  0.0
 0.0      2.71828</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/dense.jl#L395-L422">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.logm" href="#Base.LinAlg.logm"><code>Base.LinAlg.logm</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">logm(A{T}::StridedMatrix{T})</code></pre><p>If <code>A</code> has no negative real eigenvalue, compute the principal matrix logarithm of <code>A</code>, i.e. the unique matrix <span>$X$</span> such that <span>$e^X = A$</span> and <span>$-\pi &lt; Im(\lambda) &lt; \pi$</span> for all the eigenvalues <span>$\lambda$</span> of <span>$X$</span>. If <code>A</code> has nonpositive eigenvalues, a nonprincipal matrix function is returned whenever possible.</p><p>If <code>A</code> is symmetric or Hermitian, its eigendecomposition (<a href="#Base.LinAlg.eigfact"><code>eigfact</code></a>) is used, if <code>A</code> is triangular an improved version of the inverse scaling and squaring method is employed (see <a href="#footnote-AH12">[AH12]</a> and <a href="#footnote-AHR13">[AHR13]</a>). For general matrices, the complex Schur form (<a href="#Base.LinAlg.schur"><code>schur</code></a>) is computed and the triangular algorithm is used on the triangular factor.</p><div class="footnote" id="footnote-AH12"><a href="#footnote-AH12"><strong>[AH12]</strong></a><p>Awad H. Al-Mohy and Nicholas J. Higham, &quot;Improved inverse  scaling and squaring algorithms for the matrix logarithm&quot;, SIAM Journal on Scientific Computing, 34(4), 2012, C153-C169. <a href="http://dx.doi.org/10.1137/110852553">doi:10.1137/110852553</a></p></div><div class="footnote" id="footnote-AHR13"><a href="#footnote-AHR13"><strong>[AHR13]</strong></a><p>Awad H. Al-Mohy, Nicholas J. Higham and Samuel D. Relton, &quot;Computing the Fréchet derivative of the matrix logarithm and estimating the condition number&quot;, SIAM Journal on Scientific Computing, 35(4), 2013, C394-C410. <a href="http://dx.doi.org/10.1137/120885991">doi:10.1137/120885991</a></p></div><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; A = 2.7182818 * eye(2)
2×2 Array{Float64,2}:
 2.71828  0.0
 0.0      2.71828

julia&gt; logm(A)
2×2 Symmetric{Float64,Array{Float64,2}}:
 1.0  0.0
 0.0  1.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/dense.jl#L522-L553">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.sqrtm" href="#Base.LinAlg.sqrtm"><code>Base.LinAlg.sqrtm</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">sqrtm(A)</code></pre><p>If <code>A</code> has no negative real eigenvalues, compute the principal matrix square root of <code>A</code>, that is the unique matrix <span>$X$</span> with eigenvalues having positive real part such that <span>$X^2 = A$</span>. Otherwise, a nonprincipal square root is returned.</p><p>If <code>A</code> is symmetric or Hermitian, its eigendecomposition (<a href="#Base.LinAlg.eigfact"><code>eigfact</code></a>) is used to compute the square root. Otherwise, the square root is determined by means of the Björck-Hammarling method <a href="#footnote-BH83">[BH83]</a>, which computes the complex Schur form (<a href="#Base.LinAlg.schur"><code>schur</code></a>) and then the complex square root of the triangular factor.</p><div class="footnote" id="footnote-BH83"><a href="#footnote-BH83"><strong>[BH83]</strong></a><p>Åke Björck and Sven Hammarling, &quot;A Schur method for the square root of a matrix&quot;, Linear Algebra and its Applications, 52-53, 1983, 127-140. <a href="http://dx.doi.org/10.1016/0024-3795(83)80010-X">doi:10.1016/0024-3795(83)80010-X</a></p></div><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; A = [4 0; 0 4]
2×2 Array{Int64,2}:
 4  0
 0  4

julia&gt; sqrtm(A)
2×2 Array{Float64,2}:
 2.0  0.0
 0.0  2.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/dense.jl#L589-L620">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.lyap" href="#Base.LinAlg.lyap"><code>Base.LinAlg.lyap</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">lyap(A, C)</code></pre><p>Computes the solution <code>X</code> to the continuous Lyapunov equation <code>AX + XA&#39; + C = 0</code>, where no eigenvalue of <code>A</code> has a zero real part and no two eigenvalues are negative complex conjugates of each other.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/dense.jl#L946-L952">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.sylvester" href="#Base.LinAlg.sylvester"><code>Base.LinAlg.sylvester</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">sylvester(A, B, C)</code></pre><p>Computes the solution <code>X</code> to the Sylvester equation <code>AX + XB + C = 0</code>, where <code>A</code>, <code>B</code> and <code>C</code> have compatible dimensions and <code>A</code> and <code>-B</code> have no eigenvalues with equal real part.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/dense.jl#L926-L931">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.issymmetric" href="#Base.LinAlg.issymmetric"><code>Base.LinAlg.issymmetric</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">issymmetric(A) -&gt; Bool</code></pre><p>Test whether a matrix is symmetric.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = [1 2; 2 -1]
2×2 Array{Int64,2}:
 1   2
 2  -1

julia&gt; issymmetric(a)
true

julia&gt; b = [1 im; -im 1]
2×2 Array{Complex{Int64},2}:
 1+0im  0+1im
 0-1im  1+0im

julia&gt; issymmetric(b)
false</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/generic.jl#L867-L891">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.isposdef" href="#Base.LinAlg.isposdef"><code>Base.LinAlg.isposdef</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">isposdef(A) -&gt; Bool</code></pre><p>Test whether a matrix is positive definite.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1 2; 2 50]
2×2 Array{Int64,2}:
 1   2
 2  50

julia&gt; isposdef(A)
true</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/dense.jl#L60-L76">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.isposdef!" href="#Base.LinAlg.isposdef!"><code>Base.LinAlg.isposdef!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">isposdef!(A) -&gt; Bool</code></pre><p>Test whether a matrix is positive definite, overwriting <code>A</code> in the process.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1. 2.; 2. 50.];

julia&gt; isposdef!(A)
true

julia&gt; A
2×2 Array{Float64,2}:
 1.0  2.0
 2.0  6.78233</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/dense.jl#L35-L53">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.istril" href="#Base.LinAlg.istril"><code>Base.LinAlg.istril</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">istril(A) -&gt; Bool</code></pre><p>Test whether a matrix is lower triangular.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = [1 2; 2 -1]
2×2 Array{Int64,2}:
 1   2
 2  -1

julia&gt; istril(a)
false

julia&gt; b = [1 0; -im -1]
2×2 Array{Complex{Int64},2}:
 1+0im   0+0im
 0-1im  -1+0im

julia&gt; istril(b)
true</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/generic.jl#L982-L1006">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.istriu" href="#Base.LinAlg.istriu"><code>Base.LinAlg.istriu</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">istriu(A) -&gt; Bool</code></pre><p>Test whether a matrix is upper triangular.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = [1 2; 2 -1]
2×2 Array{Int64,2}:
 1   2
 2  -1

julia&gt; istriu(a)
false

julia&gt; b = [1 im; 0 -1]
2×2 Array{Complex{Int64},2}:
 1+0im   0+1im
 0+0im  -1+0im

julia&gt; istriu(b)
true</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/generic.jl#L947-L971">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.isdiag" href="#Base.LinAlg.isdiag"><code>Base.LinAlg.isdiag</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">isdiag(A) -&gt; Bool</code></pre><p>Test whether a matrix is diagonal.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = [1 2; 2 -1]
2×2 Array{Int64,2}:
 1   2
 2  -1

julia&gt; isdiag(a)
false

julia&gt; b = [im 0; 0 -im]
2×2 Array{Complex{Int64},2}:
 0+1im  0+0im
 0+0im  0-1im

julia&gt; isdiag(b)
true</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/generic.jl#L1017-L1041">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.ishermitian" href="#Base.LinAlg.ishermitian"><code>Base.LinAlg.ishermitian</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">ishermitian(A) -&gt; Bool</code></pre><p>Test whether a matrix is Hermitian.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = [1 2; 2 -1]
2×2 Array{Int64,2}:
 1   2
 2  -1

julia&gt; ishermitian(a)
true

julia&gt; b = [1 im; -im 1]
2×2 Array{Complex{Int64},2}:
 1+0im  0+1im
 0-1im  1+0im

julia&gt; ishermitian(b)
true</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/generic.jl#L907-L931">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.RowVector" href="#Base.LinAlg.RowVector"><code>Base.LinAlg.RowVector</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">RowVector(vector)</code></pre><p>A lazy-view wrapper of an <code>AbstractVector</code>, which turns a length-<code>n</code> vector into a <code>1×n</code> shaped row vector and represents the transpose of a vector (the elements are also transposed recursively). This type is usually constructed (and unwrapped) via the <a href="#Base.transpose"><code>transpose</code></a> function or <code>.&#39;</code> operator (or related <a href="#Base.ctranspose"><code>ctranspose</code></a> or <code>&#39;</code> operator).</p><p>By convention, a vector can be multiplied by a matrix on its left (<code>A * v</code>) whereas a row vector can be multiplied by a matrix on its right (such that <code>v.&#39; * A = (A.&#39; * v).&#39;</code>). It differs from a <code>1×n</code>-sized matrix by the facts that its transpose returns a vector and the inner product <code>v1.&#39; * v2</code> returns a scalar, but will otherwise behave similarly.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/rowvector.jl#L3-L15">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.ConjArray" href="#Base.LinAlg.ConjArray"><code>Base.LinAlg.ConjArray</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ConjArray(array)</code></pre><p>A lazy-view wrapper of an <code>AbstractArray</code>, taking the elementwise complex conjugate. This type is usually constructed (and unwrapped) via the <a href="../math/#Base.conj"><code>conj</code></a> function (or related <a href="#Base.ctranspose"><code>ctranspose</code></a>), but currently this is the default behavior for <code>RowVector</code> only. For other arrays, the <code>ConjArray</code> constructor can be used directly.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; [1+im, 1-im]&#39;
1×2 RowVector{Complex{Int64},ConjArray{Complex{Int64},1,Array{Complex{Int64},1}}}:
 1-1im  1+1im

julia&gt; ConjArray([1+im 0; 0 1-im])
2×2 ConjArray{Complex{Int64},2,Array{Complex{Int64},2}}:
 1-1im  0+0im
 0+0im  1+1im</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/conjarray.jl#L3-L23">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.transpose" href="#Base.transpose"><code>Base.transpose</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">transpose(A::AbstractMatrix)</code></pre><p>The transposition operator (<code>.&#39;</code>).</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1 2 3; 4 5 6; 7 8 9]
3×3 Array{Int64,2}:
 1  2  3
 4  5  6
 7  8  9

julia&gt; transpose(A)
3×3 Array{Int64,2}:
 1  4  7
 2  5  8
 3  6  9</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/transpose.jl#L97-L117">source</a><div><pre><code class="language-none">transpose(v::AbstractVector)</code></pre><p>The transposition operator (<code>.&#39;</code>).</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; v = [1,2,3]
3-element Array{Int64,1}:
 1
 2
 3

julia&gt; transpose(v)
1×3 RowVector{Int64,Array{Int64,1}}:
 1  2  3</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/rowvector.jl#L59-L77">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.transpose!" href="#Base.LinAlg.transpose!"><code>Base.LinAlg.transpose!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">transpose!(dest,src)</code></pre><p>Transpose array <code>src</code> and store the result in the preallocated array <code>dest</code>, which should have a size corresponding to <code>(size(src,2),size(src,1))</code>. No in-place transposition is supported and unexpected results will happen if <code>src</code> and <code>dest</code> have overlapping memory regions.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/transpose.jl#L8-L15">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.ctranspose" href="#Base.ctranspose"><code>Base.ctranspose</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">ctranspose(A)</code></pre><p>The conjugate transposition operator (<code>&#39;</code>).</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; A =  [3+2im 9+2im; 8+7im  4+6im]
2×2 Array{Complex{Int64},2}:
 3+2im  9+2im
 8+7im  4+6im

julia&gt; ctranspose(A)
2×2 Array{Complex{Int64},2}:
 3-2im  8-7im
 9-2im  4-6im</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/operators.jl#L689-L707">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.ctranspose!" href="#Base.LinAlg.ctranspose!"><code>Base.LinAlg.ctranspose!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">ctranspose!(dest,src)</code></pre><p>Conjugate transpose array <code>src</code> and store the result in the preallocated array <code>dest</code>, which should have a size corresponding to <code>(size(src,2),size(src,1))</code>. No in-place transposition is supported and unexpected results will happen if <code>src</code> and <code>dest</code> have overlapping memory regions.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/transpose.jl#L18-L25">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.eigs-Tuple{Any}" href="#Base.LinAlg.eigs-Tuple{Any}"><code>Base.LinAlg.eigs</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">eigs(A; nev=6, ncv=max(20,2*nev+1), which=:LM, tol=0.0, maxiter=300, sigma=nothing, ritzvec=true, v0=zeros((0,))) -&gt; (d,[v,],nconv,niter,nmult,resid)</code></pre><p>Computes eigenvalues <code>d</code> of <code>A</code> using implicitly restarted Lanczos or Arnoldi iterations for real symmetric or general nonsymmetric matrices respectively.</p><p>The following keyword arguments are supported:</p><ul><li><p><code>nev</code>: Number of eigenvalues</p></li><li><p><code>ncv</code>: Number of Krylov vectors used in the computation; should satisfy <code>nev+1 &lt;= ncv &lt;= n</code> for real symmetric problems and <code>nev+2 &lt;= ncv &lt;= n</code> for other problems, where <code>n</code> is the size of the input matrix <code>A</code>. The default is <code>ncv = max(20,2*nev+1)</code>. Note that these restrictions limit the input matrix <code>A</code> to be of dimension at least 2.</p></li><li><p><code>which</code>: type of eigenvalues to compute. See the note below.</p></li></ul><table><tr><th><code>which</code></th><th>type of eigenvalues</th></tr><tr><td><code>:LM</code></td><td>eigenvalues of largest magnitude (default)</td></tr><tr><td><code>:SM</code></td><td>eigenvalues of smallest magnitude</td></tr><tr><td><code>:LR</code></td><td>eigenvalues of largest real part</td></tr><tr><td><code>:SR</code></td><td>eigenvalues of smallest real part</td></tr><tr><td><code>:LI</code></td><td>eigenvalues of largest imaginary part (nonsymmetric or complex <code>A</code> only)</td></tr><tr><td><code>:SI</code></td><td>eigenvalues of smallest imaginary part (nonsymmetric or complex <code>A</code> only)</td></tr><tr><td><code>:BE</code></td><td>compute half of the eigenvalues from each end of the spectrum, biased in favor of the high end. (real symmetric <code>A</code> only)</td></tr></table><ul><li><p><code>tol</code>: parameter defining the relative tolerance for convergence of Ritz values (eigenvalue estimates).    A Ritz value <span>$θ$</span> is considered converged when its associated residual    is less than or equal to the product of <code>tol</code> and <span>$max(ɛ^{2/3}, |θ|)$</span>,    where <code>ɛ = eps(real(eltype(A)))/2</code> is LAPACK&#39;s machine epsilon.    The residual associated with <span>$θ$</span> and its corresponding Ritz vector <span>$v$</span>    is defined as the norm <span>$||Av - vθ||$</span>.    The specified value of <code>tol</code> should be positive; otherwise, it is ignored    and <span>$ɛ$</span> is used instead.    Default: <span>$ɛ$</span>.</p></li><li><p><code>maxiter</code>: Maximum number of iterations (default = 300)</p></li><li><p><code>sigma</code>: Specifies the level shift used in inverse iteration. If <code>nothing</code> (default), defaults to ordinary (forward) iterations. Otherwise, find eigenvalues close to <code>sigma</code> using shift and invert iterations.</p></li><li><p><code>ritzvec</code>: Returns the Ritz vectors <code>v</code> (eigenvectors) if <code>true</code></p></li><li><p><code>v0</code>: starting vector from which to start the iterations</p></li></ul><p><code>eigs</code> returns the <code>nev</code> requested eigenvalues in <code>d</code>, the corresponding Ritz vectors <code>v</code> (only if <code>ritzvec=true</code>), the number of converged eigenvalues <code>nconv</code>, the number of iterations <code>niter</code> and the number of matrix vector multiplications <code>nmult</code>, as well as the final residual vector <code>resid</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; A = spdiagm(1:4);

julia&gt; λ, ϕ = eigs(A, nev = 2);

julia&gt; λ
2-element Array{Float64,1}:
 4.0
 3.0</code></pre><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>The <code>sigma</code> and <code>which</code> keywords interact: the description of eigenvalues searched for by <code>which</code> do <em>not</em> necessarily refer to the eigenvalues of <code>A</code>, but rather the linear operator constructed by the specification of the iteration mode implied by <code>sigma</code>.</p><table><tr><th><code>sigma</code></th><th>iteration mode</th><th><code>which</code> refers to eigenvalues of</th></tr><tr><td><code>nothing</code></td><td>ordinary (forward)</td><td><span>$A$</span></td></tr><tr><td>real or complex</td><td>inverse with level shift <code>sigma</code></td><td><span>$(A - \sigma I )^{-1}$</span></td></tr></table></div></div><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Although <code>tol</code> has a default value, the best choice depends strongly on the matrix <code>A</code>. We recommend that users _always_ specify a value for <code>tol</code> which suits their specific needs.</p><p>For details of how the errors in the computed eigenvalues are estimated, see:</p><ul><li><p>B. N. Parlett, &quot;The Symmetric Eigenvalue Problem&quot;, SIAM: Philadelphia, 2/e (1998), Ch. 13.2, &quot;Accessing Accuracy in Lanczos Problems&quot;, pp. 290-292 ff.</p></li><li><p>R. B. Lehoucq and D. C. Sorensen, &quot;Deflation Techniques for an Implicitly Restarted Arnoldi Iteration&quot;, SIAM Journal on Matrix Analysis and Applications (1996), 17(4), 789–821.  doi:10.1137/S0895479895281484</p></li></ul></div></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/arnoldi.jl#L6-L89">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.eigs-Tuple{Any,Any}" href="#Base.LinAlg.eigs-Tuple{Any,Any}"><code>Base.LinAlg.eigs</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">eigs(A, B; nev=6, ncv=max(20,2*nev+1), which=:LM, tol=0.0, maxiter=300, sigma=nothing, ritzvec=true, v0=zeros((0,))) -&gt; (d,[v,],nconv,niter,nmult,resid)</code></pre><p>Computes generalized eigenvalues <code>d</code> of <code>A</code> and <code>B</code> using implicitly restarted Lanczos or Arnoldi iterations for real symmetric or general nonsymmetric matrices respectively.</p><p>The following keyword arguments are supported:</p><ul><li><p><code>nev</code>: Number of eigenvalues</p></li><li><p><code>ncv</code>: Number of Krylov vectors used in the computation; should satisfy <code>nev+1 &lt;= ncv &lt;= n</code> for real symmetric problems and <code>nev+2 &lt;= ncv &lt;= n</code> for other problems, where <code>n</code> is the size of the input matrices <code>A</code> and <code>B</code>. The default is <code>ncv = max(20,2*nev+1)</code>. Note that these restrictions limit the input matrix <code>A</code> to be of dimension at least 2.</p></li><li><p><code>which</code>: type of eigenvalues to compute. See the note below.</p></li></ul><table><tr><th><code>which</code></th><th>type of eigenvalues</th></tr><tr><td><code>:LM</code></td><td>eigenvalues of largest magnitude (default)</td></tr><tr><td><code>:SM</code></td><td>eigenvalues of smallest magnitude</td></tr><tr><td><code>:LR</code></td><td>eigenvalues of largest real part</td></tr><tr><td><code>:SR</code></td><td>eigenvalues of smallest real part</td></tr><tr><td><code>:LI</code></td><td>eigenvalues of largest imaginary part (nonsymmetric or complex <code>A</code> only)</td></tr><tr><td><code>:SI</code></td><td>eigenvalues of smallest imaginary part (nonsymmetric or complex <code>A</code> only)</td></tr><tr><td><code>:BE</code></td><td>compute half of the eigenvalues from each end of the spectrum, biased in favor of the high end. (real symmetric <code>A</code> only)</td></tr></table><ul><li><p><code>tol</code>: relative tolerance used in the convergence criterion for eigenvalues, similar to    <code>tol</code> in the <a href="#Base.LinAlg.eigs-Tuple{Any}"><code>eigs(A)</code></a> method for the ordinary eigenvalue    problem, but effectively for the eigenvalues of <span>$B^{-1} A$</span> instead of <span>$A$</span>.    See the documentation for the ordinary eigenvalue problem in    <a href="#Base.LinAlg.eigs-Tuple{Any}"><code>eigs(A)</code></a> and the accompanying note about <code>tol</code>.</p></li><li><p><code>maxiter</code>: Maximum number of iterations (default = 300)</p></li><li><p><code>sigma</code>: Specifies the level shift used in inverse iteration. If <code>nothing</code> (default), defaults to ordinary (forward) iterations. Otherwise, find eigenvalues close to <code>sigma</code> using shift and invert iterations.</p></li><li><p><code>ritzvec</code>: Returns the Ritz vectors <code>v</code> (eigenvectors) if <code>true</code></p></li><li><p><code>v0</code>: starting vector from which to start the iterations</p></li></ul><p><code>eigs</code> returns the <code>nev</code> requested eigenvalues in <code>d</code>, the corresponding Ritz vectors <code>v</code> (only if <code>ritzvec=true</code>), the number of converged eigenvalues <code>nconv</code>, the number of iterations <code>niter</code> and the number of matrix vector multiplications <code>nmult</code>, as well as the final residual vector <code>resid</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; A = speye(4, 4); B = spdiagm(1:4);

julia&gt; λ, ϕ = eigs(A, B, nev = 2);

julia&gt; λ
2-element Array{Float64,1}:
 1.0
 0.5</code></pre><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>The <code>sigma</code> and <code>which</code> keywords interact: the description of eigenvalues searched for by <code>which</code> do <em>not</em> necessarily refer to the eigenvalue problem <span>$Av = Bv\lambda$</span>, but rather the linear operator constructed by the specification of the iteration mode implied by <code>sigma</code>.</p><table><tr><th><code>sigma</code></th><th>iteration mode</th><th><code>which</code> refers to the problem</th></tr><tr><td><code>nothing</code></td><td>ordinary (forward)</td><td><span>$Av = Bv\lambda$</span></td></tr><tr><td>real or complex</td><td>inverse with level shift <code>sigma</code></td><td><span>$(A - \sigma B )^{-1}B = v\nu$</span></td></tr></table></div></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/arnoldi.jl#L105-L169">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.svds" href="#Base.LinAlg.svds"><code>Base.LinAlg.svds</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">svds(A; nsv=6, ritzvec=true, tol=0.0, maxiter=1000, ncv=2*nsv, u0=zeros((0,)), v0=zeros((0,))) -&gt; (SVD([left_sv,] s, [right_sv,]), nconv, niter, nmult, resid)</code></pre><p>Computes the largest singular values <code>s</code> of <code>A</code> using implicitly restarted Lanczos iterations derived from <a href="#Base.LinAlg.eigs-Tuple{Any}"><code>eigs</code></a>.</p><p><strong>Inputs</strong></p><ul><li><p><code>A</code>: Linear operator whose singular values are desired. <code>A</code> may be represented as a subtype of <code>AbstractArray</code>, e.g., a sparse matrix, or any other type supporting the four methods <code>size(A)</code>, <code>eltype(A)</code>, <code>A * vector</code>, and <code>A&#39; * vector</code>.</p></li><li><p><code>nsv</code>: Number of singular values. Default: 6.</p></li><li><p><code>ritzvec</code>: If <code>true</code>, return the left and right singular vectors <code>left_sv</code> and <code>right_sv</code>.  If <code>false</code>, omit the singular vectors. Default: <code>true</code>.</p></li><li><p><code>tol</code>: tolerance, see <a href="#Base.LinAlg.eigs-Tuple{Any}"><code>eigs</code></a>.</p></li><li><p><code>maxiter</code>: Maximum number of iterations, see <a href="#Base.LinAlg.eigs-Tuple{Any}"><code>eigs</code></a>. Default: 1000.</p></li><li><p><code>ncv</code>: Maximum size of the Krylov subspace, see <a href="#Base.LinAlg.eigs-Tuple{Any}"><code>eigs</code></a> (there called <code>nev</code>). Default: <code>2*nsv</code>.</p></li><li><p><code>u0</code>: Initial guess for the first left Krylov vector. It may have length <code>m</code> (the first dimension of <code>A</code>), or 0.</p></li><li><p><code>v0</code>: Initial guess for the first right Krylov vector. It may have length <code>n</code> (the second dimension of <code>A</code>), or 0.</p></li></ul><p><strong>Outputs</strong></p><ul><li><p><code>svd</code>: An <code>SVD</code> object containing the left singular vectors, the requested values, and the right singular vectors. If <code>ritzvec = false</code>, the left and right singular vectors will be empty.</p></li><li><p><code>nconv</code>: Number of converged singular values.</p></li><li><p><code>niter</code>: Number of iterations.</p></li><li><p><code>nmult</code>: Number of matrix–vector products used.</p></li><li><p><code>resid</code>: Final residual vector.</p></li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; A = spdiagm(1:4);

julia&gt; s = svds(A, nsv = 2)[1];

julia&gt; s[:S]
2-element Array{Float64,1}:
 4.0
 3.0</code></pre><div class="admonition note"><div class="admonition-title">Implementation</div><div class="admonition-text"><p><code>svds(A)</code> is formally equivalent to calling <a href="#Base.LinAlg.eigs-Tuple{Any}"><code>eigs</code></a> to perform implicitly restarted Lanczos tridiagonalization on the Hermitian matrix <span>$\begin{pmatrix} 0 &amp; A^\prime \\ A &amp; 0 \end{pmatrix}$</span>, whose eigenvalues are plus and minus the singular values of <span>$A$</span>.</p></div></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/arnoldi.jl#L333-L381">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.peakflops" href="#Base.LinAlg.peakflops"><code>Base.LinAlg.peakflops</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">peakflops(n::Integer=2000; parallel::Bool=false)</code></pre><p><code>peakflops</code> computes the peak flop rate of the computer by using double precision <a href="#Base.LinAlg.BLAS.gemm!"><code>gemm!</code></a>. By default, if no arguments are specified, it multiplies a matrix of size <code>n x n</code>, where <code>n = 2000</code>. If the underlying BLAS is using multiple threads, higher flop rates are realized. The number of BLAS threads can be set with <a href="#Base.LinAlg.BLAS.set_num_threads"><code>BLAS.set_num_threads(n)</code></a>.</p><p>If the keyword argument <code>parallel</code> is set to <code>true</code>, <code>peakflops</code> is run in parallel on all the worker processors. The flop rate of the entire parallel computer is returned. When running in parallel, only 1 BLAS thread is used. The argument <code>n</code> still refers to the size of the problem that is solved on each processor.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/generic.jl#L1103-L1116">source</a></section><h2><a class="nav-anchor" id="Low-level-matrix-operations-1" href="#Low-level-matrix-operations-1">Low-level matrix operations</a></h2><p>Matrix operations involving transpositions operations like <code>A&#39; \ B</code> are converted by the Julia parser into calls to specially named functions like <a href="#Base.Ac_ldiv_B"><code>Ac_ldiv_B</code></a>. If you want to overload these operations for your own types, then it is useful to know the names of these functions.</p><p>Also, in many cases there are in-place versions of matrix operations that allow you to supply a pre-allocated output vector or matrix.  This is useful when optimizing critical code in order to avoid the overhead of repeated allocations. These in-place operations are suffixed with <code>!</code> below (e.g. <a href="#Base.LinAlg.A_mul_B!"><code>A_mul_B!</code></a>) according to the usual Julia convention.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.A_ldiv_B!" href="#Base.LinAlg.A_ldiv_B!"><code>Base.LinAlg.A_ldiv_B!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">A_ldiv_B!([Y,] A, B) -&gt; Y</code></pre><p>Compute <code>A \ B</code> in-place and store the result in <code>Y</code>, returning the result. If only two arguments are passed, then <code>A_ldiv_B!(A, B)</code> overwrites <code>B</code> with the result.</p><p>The argument <code>A</code> should <em>not</em> be a matrix.  Rather, instead of matrices it should be a factorization object (e.g. produced by <a href="#Base.LinAlg.factorize"><code>factorize</code></a> or <a href="#Base.LinAlg.cholfact"><code>cholfact</code></a>). The reason for this is that factorization itself is both expensive and typically allocates memory (although it can also be done in-place via, e.g., <a href="#Base.LinAlg.lufact!"><code>lufact!</code></a>), and performance-critical situations requiring <code>A_ldiv_B!</code> usually also require fine-grained control over the factorization of <code>A</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/factorization.jl#L63-L76">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.A_ldiv_Bc" href="#Base.A_ldiv_Bc"><code>Base.A_ldiv_Bc</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">A_ldiv_Bc(A, B)</code></pre><p>For matrices or vectors <span>$A$</span> and <span>$B$</span>, calculates <span>$A$</span> \ <span>$Bᴴ$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/operators.jl#L806-L810">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.A_ldiv_Bt" href="#Base.A_ldiv_Bt"><code>Base.A_ldiv_Bt</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">A_ldiv_Bt(A, B)</code></pre><p>For matrices or vectors <span>$A$</span> and <span>$B$</span>, calculates <span>$A$</span> \ <span>$Bᵀ$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/operators.jl#L827-L831">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.A_mul_B!" href="#Base.LinAlg.A_mul_B!"><code>Base.LinAlg.A_mul_B!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">A_mul_B!(Y, A, B) -&gt; Y</code></pre><p>Calculates the matrix-matrix or matrix-vector product <span>$A⋅B$</span> and stores the result in <code>Y</code>, overwriting the existing value of <code>Y</code>. Note that <code>Y</code> must not be aliased with either <code>A</code> or <code>B</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; A=[1.0 2.0; 3.0 4.0]; B=[1.0 1.0; 1.0 1.0]; Y = similar(B); A_mul_B!(Y, A, B);

julia&gt; Y
2×2 Array{Float64,2}:
 3.0  3.0
 7.0  7.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/matmul.jl#L160-L177">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.A_mul_Bc" href="#Base.A_mul_Bc"><code>Base.A_mul_Bc</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">A_mul_Bc(A, B)</code></pre><p>For matrices or vectors <span>$A$</span> and <span>$B$</span>, calculates <span>$A⋅Bᴴ$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/operators.jl#L720-L724">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.A_mul_Bt" href="#Base.A_mul_Bt"><code>Base.A_mul_Bt</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">A_mul_Bt(A, B)</code></pre><p>For matrices or vectors <span>$A$</span> and <span>$B$</span>, calculates <span>$A⋅Bᵀ$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/operators.jl#L741-L745">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.A_rdiv_Bc" href="#Base.A_rdiv_Bc"><code>Base.A_rdiv_Bc</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">A_rdiv_Bc(A, B)</code></pre><p>For matrices or vectors <span>$A$</span> and <span>$B$</span>, calculates <span>$A / Bᴴ$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/operators.jl#L764-L768">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.A_rdiv_Bt" href="#Base.A_rdiv_Bt"><code>Base.A_rdiv_Bt</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">A_rdiv_Bt(A, B)</code></pre><p>For matrices or vectors <span>$A$</span> and <span>$B$</span>, calculates <span>$A / Bᵀ$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/operators.jl#L785-L789">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Ac_ldiv_B" href="#Base.Ac_ldiv_B"><code>Base.Ac_ldiv_B</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">Ac_ldiv_B(A, B)</code></pre><p>For matrices or vectors <span>$A$</span> and <span>$B$</span>, calculates <span>$Aᴴ$</span> \ <span>$B$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/operators.jl#L799-L803">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.Ac_ldiv_B!" href="#Base.LinAlg.Ac_ldiv_B!"><code>Base.LinAlg.Ac_ldiv_B!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">Ac_ldiv_B!([Y,] A, B) -&gt; Y</code></pre><p>Similar to <a href="#Base.LinAlg.A_ldiv_B!"><code>A_ldiv_B!</code></a>, but return <span>$Aᴴ$</span> \ <span>$B$</span>, computing the result in-place in <code>Y</code> (or overwriting <code>B</code> if <code>Y</code> is not supplied).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/factorization.jl#L79-L84">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Ac_ldiv_Bc" href="#Base.Ac_ldiv_Bc"><code>Base.Ac_ldiv_Bc</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">Ac_ldiv_Bc(A, B)</code></pre><p>For matrices or vectors <span>$A$</span> and <span>$B$</span>, calculates <span>$Aᴴ$</span> \ <span>$Bᴴ$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/operators.jl#L813-L817">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Ac_mul_B" href="#Base.Ac_mul_B"><code>Base.Ac_mul_B</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">Ac_mul_B(A, B)</code></pre><p>For matrices or vectors <span>$A$</span> and <span>$B$</span>, calculates <span>$Aᴴ⋅B$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/operators.jl#L713-L717">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Ac_mul_Bc" href="#Base.Ac_mul_Bc"><code>Base.Ac_mul_Bc</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">Ac_mul_Bc(A, B)</code></pre><p>For matrices or vectors <span>$A$</span> and <span>$B$</span>, calculates <span>$Aᴴ Bᴴ$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/operators.jl#L727-L731">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Ac_rdiv_B" href="#Base.Ac_rdiv_B"><code>Base.Ac_rdiv_B</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">Ac_rdiv_B(A, B)</code></pre><p>For matrices or vectors <span>$A$</span> and <span>$B$</span>, calculates <span>$Aᴴ / B$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/operators.jl#L757-L761">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Ac_rdiv_Bc" href="#Base.Ac_rdiv_Bc"><code>Base.Ac_rdiv_Bc</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">Ac_rdiv_Bc(A, B)</code></pre><p>For matrices or vectors <span>$A$</span> and <span>$B$</span>, calculates <span>$Aᴴ / Bᴴ$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/operators.jl#L771-L775">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.At_ldiv_B" href="#Base.At_ldiv_B"><code>Base.At_ldiv_B</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">At_ldiv_B(A, B)</code></pre><p>For matrices or vectors <span>$A$</span> and <span>$B$</span>, calculates <span>$Aᵀ$</span> \ <span>$B$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/operators.jl#L820-L824">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.At_ldiv_B!" href="#Base.LinAlg.At_ldiv_B!"><code>Base.LinAlg.At_ldiv_B!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">At_ldiv_B!([Y,] A, B) -&gt; Y</code></pre><p>Similar to <a href="#Base.LinAlg.A_ldiv_B!"><code>A_ldiv_B!</code></a>, but return <span>$Aᵀ$</span> \ <span>$B$</span>, computing the result in-place in <code>Y</code> (or overwriting <code>B</code> if <code>Y</code> is not supplied).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/factorization.jl#L87-L92">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.At_ldiv_Bt" href="#Base.At_ldiv_Bt"><code>Base.At_ldiv_Bt</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">At_ldiv_Bt(A, B)</code></pre><p>For matrices or vectors <span>$A$</span> and <span>$B$</span>, calculates <span>$Aᵀ$</span> \ <span>$Bᵀ$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/operators.jl#L834-L838">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.At_mul_B" href="#Base.At_mul_B"><code>Base.At_mul_B</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">At_mul_B(A, B)</code></pre><p>For matrices or vectors <span>$A$</span> and <span>$B$</span>, calculates <span>$Aᵀ⋅B$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/operators.jl#L734-L738">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.At_mul_Bt" href="#Base.At_mul_Bt"><code>Base.At_mul_Bt</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">At_mul_Bt(A, B)</code></pre><p>For matrices or vectors <span>$A$</span> and <span>$B$</span>, calculates <span>$Aᵀ⋅Bᵀ$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/operators.jl#L748-L752">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.At_rdiv_B" href="#Base.At_rdiv_B"><code>Base.At_rdiv_B</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">At_rdiv_B(A, B)</code></pre><p>For matrices or vectors <span>$A$</span> and <span>$B$</span>, calculates <span>$Aᵀ / B$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/operators.jl#L778-L782">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.At_rdiv_Bt" href="#Base.At_rdiv_Bt"><code>Base.At_rdiv_Bt</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">At_rdiv_Bt(A, B)</code></pre><p>For matrices or vectors <span>$A$</span> and <span>$B$</span>, calculates <span>$Aᵀ / Bᵀ$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/operators.jl#L792-L796">source</a></section><h2><a class="nav-anchor" id="BLAS-Functions-1" href="#BLAS-Functions-1">BLAS Functions</a></h2><p>In Julia (as in much of scientific computation), dense linear-algebra operations are based on the <a href="http://www.netlib.org/lapack/">LAPACK library</a>, which in turn is built on top of basic linear-algebra building-blocks known as the <a href="http://www.netlib.org/blas/">BLAS</a>. There are highly optimized implementations of BLAS available for every computer architecture, and sometimes in high-performance linear algebra routines it is useful to call the BLAS functions directly.</p><p><code>Base.LinAlg.BLAS</code> provides wrappers for some of the BLAS functions. Those BLAS functions that overwrite one of the input arrays have names ending in <code>&#39;!&#39;</code>.  Usually, a BLAS function has four methods defined, for <a href="../numbers/#Core.Float64"><code>Float64</code></a>, <a href="../numbers/#Core.Float32"><code>Float32</code></a>, <code>Complex128</code>, and <code>Complex64</code> arrays.</p><h3><a class="nav-anchor" id="stdlib-blas-chars-1" href="#stdlib-blas-chars-1">BLAS Character Arguments</a></h3><p>Many BLAS functions accept arguments that determine whether to transpose an argument (<code>trans</code>), which triangle of a matrix to reference (<code>uplo</code> or <code>ul</code>), whether the diagonal of a triangular matrix can be assumed to be all ones (<code>dA</code>) or which side of a matrix multiplication the input argument belongs on (<code>side</code>). The possiblities are:</p><h4><a class="nav-anchor" id="stdlib-blas-side-1" href="#stdlib-blas-side-1">Multplication Order</a></h4><table><tr><th><code>side</code></th><th>Meaning</th></tr><tr><td><code>&#39;L&#39;</code></td><td>The argument goes on the <em>left</em> side of a matrix-matrix operation.</td></tr><tr><td><code>&#39;R&#39;</code></td><td>The argument goes on the <em>right</em> side of a matrix-matrix operation.</td></tr></table><h4><a class="nav-anchor" id="stdlib-blas-uplo-1" href="#stdlib-blas-uplo-1">Triangle Referencing</a></h4><table><tr><th><code>uplo</code>/<code>ul</code></th><th>Meaning</th></tr><tr><td><code>&#39;U&#39;</code></td><td>Only the <em>upper</em> triangle of the matrix will be used.</td></tr><tr><td><code>&#39;L&#39;</code></td><td>Only the <em>lower</em> triangle of the matrix will be used.</td></tr></table><h4><a class="nav-anchor" id="stdlib-blas-trans-1" href="#stdlib-blas-trans-1">Transposition Operation</a></h4><table><tr><th><code>trans</code>/<code>tX</code></th><th>Meaning</th></tr><tr><td><code>&#39;N&#39;</code></td><td>The input matrix <code>X</code> is not transposed or conjugated.</td></tr><tr><td><code>&#39;T&#39;</code></td><td>The input matrix <code>X</code> will be transposed.</td></tr><tr><td><code>&#39;C&#39;</code></td><td>The input matrix <code>X</code> will be conjugated and transposed.</td></tr></table><h4><a class="nav-anchor" id="stdlib-blas-diag-1" href="#stdlib-blas-diag-1">Unit Diagonal</a></h4><table><tr><th><code>diag</code>/<code>dX</code></th><th>Meaning</th></tr><tr><td><code>&#39;N&#39;</code></td><td>The diagonal values of the matrix <code>X</code> will be read.</td></tr><tr><td><code>&#39;U&#39;</code></td><td>The diagonal of the matrix <code>X</code> is assumed to be all ones.</td></tr></table><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.BLAS.dotu" href="#Base.LinAlg.BLAS.dotu"><code>Base.LinAlg.BLAS.dotu</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">dotu(n, X, incx, Y, incy)</code></pre><p>Dot function for two complex vectors consisting of <code>n</code> elements of array <code>X</code> with stride <code>incx</code> and <code>n</code> elements of array <code>Y</code> with stride <code>incy</code>.</p><p><strong>Example:</strong></p><pre><code class="language-julia-repl">julia&gt; Base.BLAS.dotu(10, im*ones(10), 1, complex.(ones(20), ones(20)), 2)
-10.0 + 10.0im</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/blas.jl#L242-L253">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.BLAS.dotc" href="#Base.LinAlg.BLAS.dotc"><code>Base.LinAlg.BLAS.dotc</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">dotc(n, X, incx, U, incy)</code></pre><p>Dot function for two complex vectors, consisting of <code>n</code> elements of array <code>X</code> with stride <code>incx</code> and <code>n</code> elements of array <code>U</code> with stride <code>incy</code>, conjugating the first vector.</p><p><strong>Example:</strong></p><pre><code class="language-julia-repl">julia&gt; Base.BLAS.dotc(10, im*ones(10), 1, complex.(ones(20), ones(20)), 2)
10.0 - 10.0im</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/blas.jl#L227-L239">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.BLAS.blascopy!" href="#Base.LinAlg.BLAS.blascopy!"><code>Base.LinAlg.BLAS.blascopy!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">blascopy!(n, X, incx, Y, incy)</code></pre><p>Copy <code>n</code> elements of array <code>X</code> with stride <code>incx</code> to array <code>Y</code> with stride <code>incy</code>. Returns <code>Y</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/blas.jl#L157-L161">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.BLAS.nrm2" href="#Base.LinAlg.BLAS.nrm2"><code>Base.LinAlg.BLAS.nrm2</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">nrm2(n, X, incx)</code></pre><p>2-norm of a vector consisting of <code>n</code> elements of array <code>X</code> with stride <code>incx</code>.</p><p><strong>Example:</strong></p><pre><code class="language-julia-repl">julia&gt; Base.BLAS.nrm2(4, ones(8), 2)
2.0

julia&gt; Base.BLAS.nrm2(1, ones(8), 2)
1.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/blas.jl#L335-L348">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.BLAS.asum" href="#Base.LinAlg.BLAS.asum"><code>Base.LinAlg.BLAS.asum</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">asum(n, X, incx)</code></pre><p>Sum of the absolute values of the first <code>n</code> elements of array <code>X</code> with stride <code>incx</code>.</p><p><strong>Example:</strong></p><pre><code class="language-julia-repl">julia&gt; Base.BLAS.asum(5, im*ones(10), 2)
5.0

julia&gt; Base.BLAS.asum(2, im*ones(10), 5)
2.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/blas.jl#L368-L381">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.axpy!" href="#Base.LinAlg.axpy!"><code>Base.LinAlg.axpy!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">axpy!(a, X, Y)</code></pre><p>Overwrite <code>Y</code> with <code>a*X + Y</code>, where <code>a</code> is a scalar. Returns <code>Y</code>.</p><p><strong>Example:</strong></p><pre><code class="language-julia-repl">julia&gt; x = [1; 2; 3];

julia&gt; y = [4; 5; 6];

julia&gt; Base.BLAS.axpy!(2, x, y)
3-element Array{Int64,1}:
  6
  9
 12</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/blas.jl#L401-L418">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.BLAS.scal!" href="#Base.LinAlg.BLAS.scal!"><code>Base.LinAlg.BLAS.scal!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">scal!(n, a, X, incx)</code></pre><p>Overwrite <code>X</code> with <code>a*X</code> for the first <code>n</code> elements of array <code>X</code> with stride <code>incx</code>. Returns <code>X</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/blas.jl#L181-L185">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.BLAS.scal" href="#Base.LinAlg.BLAS.scal"><code>Base.LinAlg.BLAS.scal</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">scal(n, a, X, incx)</code></pre><p>Returns <code>X</code> scaled by <code>a</code> for the first <code>n</code> elements of array <code>X</code> with stride <code>incx</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/blas.jl#L188-L192">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.BLAS.ger!" href="#Base.LinAlg.BLAS.ger!"><code>Base.LinAlg.BLAS.ger!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">ger!(alpha, x, y, A)</code></pre><p>Rank-1 update of the matrix <code>A</code> with vectors <code>x</code> and <code>y</code> as <code>alpha*x*y&#39; + A</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/blas.jl#L904-L908">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.BLAS.syr!" href="#Base.LinAlg.BLAS.syr!"><code>Base.LinAlg.BLAS.syr!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">syr!(uplo, alpha, x, A)</code></pre><p>Rank-1 update of the symmetric matrix <code>A</code> with vector <code>x</code> as <code>alpha*x*x.&#39; + A</code>. <a href="#stdlib-blas-uplo-1"><code>uplo</code></a> controls which triangle of <code>A</code> is updated. Returns <code>A</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/blas.jl#L935-L940">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.BLAS.syrk!" href="#Base.LinAlg.BLAS.syrk!"><code>Base.LinAlg.BLAS.syrk!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">syrk!(uplo, trans, alpha, A, beta, C)</code></pre><p>Rank-k update of the symmetric matrix <code>C</code> as <code>alpha*A*A.&#39; + beta*C</code> or <code>alpha*A.&#39;*A + beta*C</code> according to <a href="#stdlib-blas-trans-1"><code>trans</code></a>. Only the <a href="#stdlib-blas-uplo-1"><code>uplo</code></a> triangle of <code>C</code> is used. Returns <code>C</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/blas.jl#L1169-L1175">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.BLAS.syrk" href="#Base.LinAlg.BLAS.syrk"><code>Base.LinAlg.BLAS.syrk</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">syrk(uplo, trans, alpha, A)</code></pre><p>Returns either the upper triangle or the lower triangle of <code>A</code>, according to <a href="#stdlib-blas-uplo-1"><code>uplo</code></a>, of <code>alpha*A*A.&#39;</code> or <code>alpha*A.&#39;*A</code>, according to <a href="#stdlib-blas-trans-1"><code>trans</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/blas.jl#L1178-L1185">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.BLAS.her!" href="#Base.LinAlg.BLAS.her!"><code>Base.LinAlg.BLAS.her!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">her!(uplo, alpha, x, A)</code></pre><p>Methods for complex arrays only. Rank-1 update of the Hermitian matrix <code>A</code> with vector <code>x</code> as <code>alpha*x*x&#39; + A</code>. <a href="#stdlib-blas-uplo-1"><code>uplo</code></a> controls which triangle of <code>A</code> is updated. Returns <code>A</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/blas.jl#L965-L971">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.BLAS.herk!" href="#Base.LinAlg.BLAS.herk!"><code>Base.LinAlg.BLAS.herk!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">herk!(uplo, trans, alpha, A, beta, C)</code></pre><p>Methods for complex arrays only. Rank-k update of the Hermitian matrix <code>C</code> as <code>alpha*A*A&#39; + beta*C</code> or <code>alpha*A&#39;*A + beta*C</code> according to <a href="#stdlib-blas-trans-1"><code>trans</code></a>. Only the <a href="#stdlib-blas-uplo-1"><code>uplo</code></a> triangle of <code>C</code> is updated. Returns <code>C</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/blas.jl#L1225-L1232">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.BLAS.herk" href="#Base.LinAlg.BLAS.herk"><code>Base.LinAlg.BLAS.herk</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">herk(uplo, trans, alpha, A)</code></pre><p>Methods for complex arrays only. Returns the <a href="#stdlib-blas-uplo-1"><code>uplo</code></a> triangle of <code>alpha*A*A&#39;</code> or <code>alpha*A&#39;*A</code>, according to <a href="#stdlib-blas-trans-1"><code>trans</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/blas.jl#L1235-L1241">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.BLAS.gbmv!" href="#Base.LinAlg.BLAS.gbmv!"><code>Base.LinAlg.BLAS.gbmv!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">gbmv!(trans, m, kl, ku, alpha, A, x, beta, y)</code></pre><p>Update vector <code>y</code> as <code>alpha*A*x + beta*y</code> or <code>alpha*A&#39;*x + beta*y</code> according to <a href="#stdlib-blas-trans-1"><code>trans</code></a>. The matrix <code>A</code> is a general band matrix of dimension <code>m</code> by <code>size(A,2)</code> with <code>kl</code> sub-diagonals and <code>ku</code> super-diagonals. <code>alpha</code> and <code>beta</code> are scalars. Returns the updated <code>y</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/blas.jl#L547-L553">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.BLAS.gbmv" href="#Base.LinAlg.BLAS.gbmv"><code>Base.LinAlg.BLAS.gbmv</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">gbmv(trans, m, kl, ku, alpha, A, x)</code></pre><p>Returns <code>alpha*A*x</code> or <code>alpha*A&#39;*x</code> according to <a href="#stdlib-blas-trans-1"><code>trans</code></a>. The matrix <code>A</code> is a general band matrix of dimension <code>m</code> by <code>size(A,2)</code> with <code>kl</code> sub-diagonals and <code>ku</code> super-diagonals, and <code>alpha</code> is a scalar.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/blas.jl#L556-L562">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.BLAS.sbmv!" href="#Base.LinAlg.BLAS.sbmv!"><code>Base.LinAlg.BLAS.sbmv!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">sbmv!(uplo, k, alpha, A, x, beta, y)</code></pre><p>Update vector <code>y</code> as <code>alpha*A*x + beta*y</code> where <code>A</code> is a a symmetric band matrix of order <code>size(A,2)</code> with <code>k</code> super-diagonals stored in the argument <code>A</code>. The storage layout for <code>A</code> is described the reference BLAS module, level-2 BLAS at <a href="http://www.netlib.org/lapack/explore-html/">http://www.netlib.org/lapack/explore-html/</a>. Only the <a href="#stdlib-blas-uplo-1"><code>uplo</code></a> triangle of <code>A</code> is used.</p><p>Returns the updated <code>y</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/blas.jl#L754-L764">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.BLAS.sbmv-NTuple{5,Any}" href="#Base.LinAlg.BLAS.sbmv-NTuple{5,Any}"><code>Base.LinAlg.BLAS.sbmv</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">sbmv(uplo, k, alpha, A, x)</code></pre><p>Returns <code>alpha*A*x</code> where <code>A</code> is a symmetric band matrix of order <code>size(A,2)</code> with <code>k</code> super-diagonals stored in the argument <code>A</code>. Only the <a href="#stdlib-blas-uplo-1"><code>uplo</code></a> triangle of <code>A</code> is used.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/blas.jl#L736-L742">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.BLAS.sbmv-NTuple{4,Any}" href="#Base.LinAlg.BLAS.sbmv-NTuple{4,Any}"><code>Base.LinAlg.BLAS.sbmv</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">sbmv(uplo, k, A, x)</code></pre><p>Returns <code>A*x</code> where <code>A</code> is a symmetric band matrix of order <code>size(A,2)</code> with <code>k</code> super-diagonals stored in the argument <code>A</code>. Only the <a href="#stdlib-blas-uplo-1"><code>uplo</code></a> triangle of <code>A</code> is used.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/blas.jl#L745-L751">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.BLAS.gemm!" href="#Base.LinAlg.BLAS.gemm!"><code>Base.LinAlg.BLAS.gemm!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">gemm!(tA, tB, alpha, A, B, beta, C)</code></pre><p>Update <code>C</code> as <code>alpha*A*B + beta*C</code> or the other three variants according to <a href="#stdlib-blas-trans-1"><code>tA</code></a> and <code>tB</code>. Returns the updated <code>C</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/blas.jl#L995-L1000">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.BLAS.gemm-NTuple{5,Any}" href="#Base.LinAlg.BLAS.gemm-NTuple{5,Any}"><code>Base.LinAlg.BLAS.gemm</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">gemm(tA, tB, alpha, A, B)</code></pre><p>Returns <code>alpha*A*B</code> or the other three variants according to <a href="#stdlib-blas-trans-1"><code>tA</code></a> and <code>tB</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/blas.jl#L1047-L1051">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.BLAS.gemm-NTuple{4,Any}" href="#Base.LinAlg.BLAS.gemm-NTuple{4,Any}"><code>Base.LinAlg.BLAS.gemm</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">gemm(tA, tB, A, B)</code></pre><p>Returns <code>A*B</code> or the other three variants according to <a href="#stdlib-blas-trans-1"><code>tA</code></a> and <code>tB</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/blas.jl#L1054-L1058">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.BLAS.gemv!" href="#Base.LinAlg.BLAS.gemv!"><code>Base.LinAlg.BLAS.gemv!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">gemv!(tA, alpha, A, x, beta, y)</code></pre><p>Update the vector <code>y</code> as <code>alpha*A*x + beta*y</code> or <code>alpha*A&#39;x + beta*y</code> according to <a href="#stdlib-blas-trans-1"><code>tA</code></a>. <code>alpha</code> and <code>beta</code> are scalars. Returns the updated <code>y</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/blas.jl#L521-L527">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.BLAS.gemv-NTuple{4,Any}" href="#Base.LinAlg.BLAS.gemv-NTuple{4,Any}"><code>Base.LinAlg.BLAS.gemv</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">gemv(tA, alpha, A, x)</code></pre><p>Returns <code>alpha*A*x</code> or <code>alpha*A&#39;x</code> according to <a href="#stdlib-blas-trans-1"><code>tA</code></a>. <code>alpha</code> is a scalar.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/blas.jl#L530-L535">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.BLAS.gemv-Tuple{Any,Any,Any}" href="#Base.LinAlg.BLAS.gemv-Tuple{Any,Any,Any}"><code>Base.LinAlg.BLAS.gemv</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">gemv(tA, A, x)</code></pre><p>Returns <code>A*x</code> or <code>A&#39;x</code> according to <a href="#stdlib-blas-trans-1"><code>tA</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/blas.jl#L538-L542">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.BLAS.symm!" href="#Base.LinAlg.BLAS.symm!"><code>Base.LinAlg.BLAS.symm!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">symm!(side, ul, alpha, A, B, beta, C)</code></pre><p>Update <code>C</code> as <code>alpha*A*B + beta*C</code> or <code>alpha*B*A + beta*C</code> according to <a href="#stdlib-blas-side-1"><code>side</code></a>. <code>A</code> is assumed to be symmetric. Only the <a href="#stdlib-blas-uplo-1"><code>ul</code></a> triangle of <code>A</code> is used. Returns the updated <code>C</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/blas.jl#L1120-L1126">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.BLAS.symm-NTuple{5,Any}" href="#Base.LinAlg.BLAS.symm-NTuple{5,Any}"><code>Base.LinAlg.BLAS.symm</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">symm(side, ul, alpha, A, B)</code></pre><p>Returns <code>alpha*A*B</code> or <code>alpha*B*A</code> according to <a href="#stdlib-blas-side-1"><code>side</code></a>. <code>A</code> is assumed to be symmetric. Only the <a href="#stdlib-blas-uplo-1"><code>ul</code></a> triangle of <code>A</code> is used.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/blas.jl#L1102-L1108">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.BLAS.symm-NTuple{4,Any}" href="#Base.LinAlg.BLAS.symm-NTuple{4,Any}"><code>Base.LinAlg.BLAS.symm</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">symm(side, ul, A, B)</code></pre><p>Returns <code>A*B</code> or <code>B*A</code> according to <a href="#stdlib-blas-side-1"><code>side</code></a>. <code>A</code> is assumed to be symmetric. Only the <a href="#stdlib-blas-uplo-1"><code>ul</code></a> triangle of <code>A</code> is used.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/blas.jl#L1111-L1117">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.BLAS.symv!" href="#Base.LinAlg.BLAS.symv!"><code>Base.LinAlg.BLAS.symv!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">symv!(ul, alpha, A, x, beta, y)</code></pre><p>Update the vector <code>y</code> as <code>alpha*A*x + beta*y</code>. <code>A</code> is assumed to be symmetric. Only the <a href="#stdlib-blas-uplo-1"><code>ul</code></a> triangle of <code>A</code> is used. <code>alpha</code> and <code>beta</code> are scalars. Returns the updated <code>y</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/blas.jl#L601-L607">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.BLAS.symv-NTuple{4,Any}" href="#Base.LinAlg.BLAS.symv-NTuple{4,Any}"><code>Base.LinAlg.BLAS.symv</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">symv(ul, alpha, A, x)</code></pre><p>Returns <code>alpha*A*x</code>. <code>A</code> is assumed to be symmetric. Only the <a href="#stdlib-blas-uplo-1"><code>ul</code></a> triangle of <code>A</code> is used. <code>alpha</code> is a scalar.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/blas.jl#L652-L658">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.BLAS.symv-Tuple{Any,Any,Any}" href="#Base.LinAlg.BLAS.symv-Tuple{Any,Any,Any}"><code>Base.LinAlg.BLAS.symv</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">symv(ul, A, x)</code></pre><p>Returns <code>A*x</code>. <code>A</code> is assumed to be symmetric. Only the <a href="#stdlib-blas-uplo-1"><code>ul</code></a> triangle of <code>A</code> is used.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/blas.jl#L661-L666">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.BLAS.trmm!" href="#Base.LinAlg.BLAS.trmm!"><code>Base.LinAlg.BLAS.trmm!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">trmm!(side, ul, tA, dA, alpha, A, B)</code></pre><p>Update <code>B</code> as <code>alpha*A*B</code> or one of the other three variants determined by <a href="#stdlib-blas-side-1"><code>side</code></a> and <a href="#stdlib-blas-trans-1"><code>tA</code></a>. Only the <a href="#stdlib-blas-uplo-1"><code>ul</code></a> triangle of <code>A</code> is used. <a href="#stdlib-blas-diag-1"><code>dA</code></a> determines if the diagonal values are read or are assumed to be all ones. Returns the updated <code>B</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/blas.jl#L1358-L1367">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.BLAS.trmm" href="#Base.LinAlg.BLAS.trmm"><code>Base.LinAlg.BLAS.trmm</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">trmm(side, ul, tA, dA, alpha, A, B)</code></pre><p>Returns <code>alpha*A*B</code> or one of the other three variants determined by <a href="#stdlib-blas-side-1"><code>side</code></a> and <a href="#stdlib-blas-trans-1"><code>tA</code></a>. Only the <a href="#stdlib-blas-uplo-1"><code>ul</code></a> triangle of <code>A</code> is used. <a href="#stdlib-blas-diag-1"><code>dA</code></a> determines if the diagonal values are read or are assumed to be all ones.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/blas.jl#L1370-L1378">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.BLAS.trsm!" href="#Base.LinAlg.BLAS.trsm!"><code>Base.LinAlg.BLAS.trsm!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">trsm!(side, ul, tA, dA, alpha, A, B)</code></pre><p>Overwrite <code>B</code> with the solution to <code>A*X = alpha*B</code> or one of the other three variants determined by <a href="#stdlib-blas-side-1"><code>side</code></a> and <a href="#stdlib-blas-trans-1"><code>tA</code></a>. Only the <a href="#stdlib-blas-uplo-1"><code>ul</code></a> triangle of <code>A</code> is used. <a href="#stdlib-blas-diag-1"><code>dA</code></a> determines if the diagonal values are read or are assumed to be all ones. Returns the updated <code>B</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/blas.jl#L1381-L1390">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.BLAS.trsm" href="#Base.LinAlg.BLAS.trsm"><code>Base.LinAlg.BLAS.trsm</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">trsm(side, ul, tA, dA, alpha, A, B)</code></pre><p>Returns the solution to <code>A*X = alpha*B</code> or one of the other three variants determined by determined by <a href="#stdlib-blas-side-1"><code>side</code></a> and <a href="#stdlib-blas-trans-1"><code>tA</code></a>. Only the <a href="#stdlib-blas-uplo-1"><code>ul</code></a> triangle of <code>A</code> is used. <a href="#stdlib-blas-diag-1"><code>dA</code></a> determines if the diagonal values are read or are assumed to be all ones.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/blas.jl#L1393-L1401">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.BLAS.trmv!" href="#Base.LinAlg.BLAS.trmv!"><code>Base.LinAlg.BLAS.trmv!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">trmv!(ul, tA, dA, A, b)</code></pre><p>Returns <code>op(A)*b</code>, where <code>op</code> is determined by <a href="#stdlib-blas-trans-1"><code>tA</code></a>. Only the <a href="#stdlib-blas-uplo-1"><code>ul</code></a> triangle of <code>A</code> is used. <a href="#stdlib-blas-diag-1"><code>dA</code></a> determines if the diagonal values are read or are assumed to be all ones. The multiplication occurs in-place on <code>b</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/blas.jl#L810-L818">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.BLAS.trmv" href="#Base.LinAlg.BLAS.trmv"><code>Base.LinAlg.BLAS.trmv</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">trmv(ul, tA, dA, A, b)</code></pre><p>Returns <code>op(A)*b</code>, where <code>op</code> is determined by <a href="#stdlib-blas-trans-1"><code>tA</code></a>. Only the <a href="#stdlib-blas-uplo-1"><code>ul</code></a> triangle of <code>A</code> is used. <a href="#stdlib-blas-diag-1"><code>dA</code></a> determines if the diagonal values are read or are assumed to be all ones.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/blas.jl#L800-L807">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.BLAS.trsv!" href="#Base.LinAlg.BLAS.trsv!"><code>Base.LinAlg.BLAS.trsv!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">trsv!(ul, tA, dA, A, b)</code></pre><p>Overwrite <code>b</code> with the solution to <code>A*x = b</code> or one of the other two variants determined by <a href="#stdlib-blas-trans-1"><code>tA</code></a> and <a href="#stdlib-blas-uplo-1"><code>ul</code></a>. <a href="#stdlib-blas-diag-1"><code>dA</code></a> determines if the diagonal values are read or are assumed to be all ones. Returns the updated <code>b</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/blas.jl#L852-L860">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.BLAS.trsv" href="#Base.LinAlg.BLAS.trsv"><code>Base.LinAlg.BLAS.trsv</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">trsv(ul, tA, dA, A, b)</code></pre><p>Returns the solution to <code>A*x = b</code> or one of the other two variants determined by <a href="#stdlib-blas-trans-1"><code>tA</code></a> and <a href="#stdlib-blas-uplo-1"><code>ul</code></a>. <a href="#stdlib-blas-diag-1"><code>dA</code></a> determines if the diagonal values are read or are assumed to be all ones.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/blas.jl#L863-L870">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.BLAS.set_num_threads" href="#Base.LinAlg.BLAS.set_num_threads"><code>Base.LinAlg.BLAS.set_num_threads</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">set_num_threads(n)</code></pre><p>Set the number of threads the BLAS library should use.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/blas.jl#L89-L93">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.I" href="#Base.LinAlg.I"><code>Base.LinAlg.I</code></a> — <span class="docstring-category">Constant</span>.</div><div><pre><code class="language-none">I</code></pre><p>An object of type <code>UniformScaling</code>, representing an identity matrix of any size.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; ones(5, 6) * I == ones(5, 6)
true

julia&gt; [1 2im 3; 1im 2 3] * I
2×3 Array{Complex{Int64},2}:
 1+0im  0+2im  3+0im
 0+1im  2+0im  3+0im</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/uniformscaling.jl#L11-L27">source</a></section><h2><a class="nav-anchor" id="LAPACK-Functions-1" href="#LAPACK-Functions-1">LAPACK Functions</a></h2><p><code>Base.LinAlg.LAPACK</code> provides wrappers for some of the LAPACK functions for linear algebra.  Those functions that overwrite one of the input arrays have names ending in <code>&#39;!&#39;</code>.</p><p>Usually a function has 4 methods defined, one each for <a href="../numbers/#Core.Float64"><code>Float64</code></a>, <a href="../numbers/#Core.Float32"><code>Float32</code></a>, <code>Complex128</code> and <code>Complex64</code> arrays.</p><p>Note that the LAPACK API provided by Julia can and will change in the future. Since this API is not user-facing, there is no commitment to support/deprecate this specific set of functions in future releases.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.gbtrf!" href="#Base.LinAlg.LAPACK.gbtrf!"><code>Base.LinAlg.LAPACK.gbtrf!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">gbtrf!(kl, ku, m, AB) -&gt; (AB, ipiv)</code></pre><p>Compute the LU factorization of a banded matrix <code>AB</code>. <code>kl</code> is the first subdiagonal containing a nonzero band, <code>ku</code> is the last superdiagonal containing one, and <code>m</code> is the first dimension of the matrix <code>AB</code>. Returns the LU factorization in-place and <code>ipiv</code>, the vector of pivots used.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lapack.jl#L161-L168">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.gbtrs!" href="#Base.LinAlg.LAPACK.gbtrs!"><code>Base.LinAlg.LAPACK.gbtrs!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">gbtrs!(trans, kl, ku, m, AB, ipiv, B)</code></pre><p>Solve the equation <code>AB * X = B</code>. <code>trans</code> determines the orientation of <code>AB</code>. It may be <code>N</code> (no transpose), <code>T</code> (transpose), or <code>C</code> (conjugate transpose). <code>kl</code> is the first subdiagonal containing a nonzero band, <code>ku</code> is the last superdiagonal containing one, and <code>m</code> is the first dimension of the matrix <code>AB</code>. <code>ipiv</code> is the vector of pivots returned from <code>gbtrf!</code>. Returns the vector or matrix <code>X</code>, overwriting <code>B</code> in-place.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lapack.jl#L171-L179">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.gebal!" href="#Base.LinAlg.LAPACK.gebal!"><code>Base.LinAlg.LAPACK.gebal!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">gebal!(job, A) -&gt; (ilo, ihi, scale)</code></pre><p>Balance the matrix <code>A</code> before computing its eigensystem or Schur factorization. <code>job</code> can be one of <code>N</code> (<code>A</code> will not be permuted or scaled), <code>P</code> (<code>A</code> will only be permuted), <code>S</code> (<code>A</code> will only be scaled), or <code>B</code> (<code>A</code> will be both permuted and scaled). Modifies <code>A</code> in-place and returns <code>ilo</code>, <code>ihi</code>, and <code>scale</code>. If permuting was turned on, <code>A[i,j] = 0</code> if <code>j &gt; i</code> and <code>1 &lt; j &lt; ilo</code> or <code>j &gt; ihi</code>. <code>scale</code> contains information about the scaling/permutations performed.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lapack.jl#L235-L244">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.gebak!" href="#Base.LinAlg.LAPACK.gebak!"><code>Base.LinAlg.LAPACK.gebak!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">gebak!(job, side, ilo, ihi, scale, V)</code></pre><p>Transform the eigenvectors <code>V</code> of a matrix balanced using <code>gebal!</code> to the unscaled/unpermuted eigenvectors of the original matrix. Modifies <code>V</code> in-place. <code>side</code> can be <code>L</code> (left eigenvectors are transformed) or <code>R</code> (right eigenvectors are transformed).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lapack.jl#L247-L254">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.gebrd!" href="#Base.LinAlg.LAPACK.gebrd!"><code>Base.LinAlg.LAPACK.gebrd!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">gebrd!(A) -&gt; (A, d, e, tauq, taup)</code></pre><p>Reduce <code>A</code> in-place to bidiagonal form <code>A = QBP&#39;</code>. Returns <code>A</code>, containing the bidiagonal matrix <code>B</code>; <code>d</code>, containing the diagonal elements of <code>B</code>; <code>e</code>, containing the off-diagonal elements of <code>B</code>; <code>tauq</code>, containing the elementary reflectors representing <code>Q</code>; and <code>taup</code>, containing the elementary reflectors representing <code>P</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lapack.jl#L544-L552">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.gelqf!" href="#Base.LinAlg.LAPACK.gelqf!"><code>Base.LinAlg.LAPACK.gelqf!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">gelqf!(A, tau)</code></pre><p>Compute the <code>LQ</code> factorization of <code>A</code>, <code>A = LQ</code>. <code>tau</code> contains scalars which parameterize the elementary reflectors of the factorization. <code>tau</code> must have length greater than or equal to the smallest dimension of <code>A</code>.</p><p>Returns <code>A</code> and <code>tau</code> modified in-place.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lapack.jl#L555-L564">source</a><div><pre><code class="language-none">gelqf!(A) -&gt; (A, tau)</code></pre><p>Compute the <code>LQ</code> factorization of <code>A</code>, <code>A = LQ</code>.</p><p>Returns <code>A</code>, modified in-place, and <code>tau</code>, which contains scalars which parameterize the elementary reflectors of the factorization.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lapack.jl#L650-L657">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.geqlf!" href="#Base.LinAlg.LAPACK.geqlf!"><code>Base.LinAlg.LAPACK.geqlf!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">geqlf!(A, tau)</code></pre><p>Compute the <code>QL</code> factorization of <code>A</code>, <code>A = QL</code>. <code>tau</code> contains scalars which parameterize the elementary reflectors of the factorization. <code>tau</code> must have length greater than or equal to the smallest dimension of <code>A</code>.</p><p>Returns <code>A</code> and <code>tau</code> modified in-place.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lapack.jl#L567-L575">source</a><div><pre><code class="language-none">geqlf!(A) -&gt; (A, tau)</code></pre><p>Compute the <code>QL</code> factorization of <code>A</code>, <code>A = QL</code>.</p><p>Returns <code>A</code>, modified in-place, and <code>tau</code>, which contains scalars which parameterize the elementary reflectors of the factorization.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lapack.jl#L660-L667">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.geqrf!" href="#Base.LinAlg.LAPACK.geqrf!"><code>Base.LinAlg.LAPACK.geqrf!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">geqrf!(A, tau)</code></pre><p>Compute the <code>QR</code> factorization of <code>A</code>, <code>A = QR</code>. <code>tau</code> contains scalars which parameterize the elementary reflectors of the factorization. <code>tau</code> must have length greater than or equal to the smallest dimension of <code>A</code>.</p><p>Returns <code>A</code> and <code>tau</code> modified in-place.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lapack.jl#L617-L625">source</a><div><pre><code class="language-none">geqrf!(A) -&gt; (A, tau)</code></pre><p>Compute the <code>QR</code> factorization of <code>A</code>, <code>A = QR</code>.</p><p>Returns <code>A</code>, modified in-place, and <code>tau</code>, which contains scalars which parameterize the elementary reflectors of the factorization.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lapack.jl#L692-L699">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.geqp3!" href="#Base.LinAlg.LAPACK.geqp3!"><code>Base.LinAlg.LAPACK.geqp3!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">geqp3!(A, jpvt, tau)</code></pre><p>Compute the pivoted <code>QR</code> factorization of <code>A</code>, <code>AP = QR</code> using BLAS level 3. <code>P</code> is a pivoting matrix, represented by <code>jpvt</code>. <code>tau</code> stores the elementary reflectors. <code>jpvt</code> must have length length greater than or equal to <code>n</code> if <code>A</code> is an <code>(m x n)</code> matrix. <code>tau</code> must have length greater than or equal to the smallest dimension of <code>A</code>.</p><p><code>A</code>, <code>jpvt</code>, and <code>tau</code> are modified in-place.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lapack.jl#L578-L588">source</a><div><pre><code class="language-none">geqp3!(A, jpvt) -&gt; (A, jpvt, tau)</code></pre><p>Compute the pivoted <code>QR</code> factorization of <code>A</code>, <code>AP = QR</code> using BLAS level 3. <code>P</code> is a pivoting matrix, represented by <code>jpvt</code>. <code>jpvt</code> must have length greater than or equal to <code>n</code> if <code>A</code> is an <code>(m x n)</code> matrix.</p><p>Returns <code>A</code> and <code>jpvt</code>, modified in-place, and <code>tau</code>, which stores the elementary reflectors.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lapack.jl#L712-L721">source</a><div><pre><code class="language-none">geqp3!(A) -&gt; (A, jpvt, tau)</code></pre><p>Compute the pivoted <code>QR</code> factorization of <code>A</code>, <code>AP = QR</code> using BLAS level 3.</p><p>Returns <code>A</code>, modified in-place, <code>jpvt</code>, which represents the pivoting matrix <code>P</code>, and <code>tau</code>, which stores the elementary reflectors.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lapack.jl#L727-L734">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.gerqf!" href="#Base.LinAlg.LAPACK.gerqf!"><code>Base.LinAlg.LAPACK.gerqf!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">gerqf!(A, tau)</code></pre><p>Compute the <code>RQ</code> factorization of <code>A</code>, <code>A = RQ</code>. <code>tau</code> contains scalars which parameterize the elementary reflectors of the factorization. <code>tau</code> must have length greater than or equal to the smallest dimension of <code>A</code>.</p><p>Returns <code>A</code> and <code>tau</code> modified in-place.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lapack.jl#L628-L636">source</a><div><pre><code class="language-none">gerqf!(A) -&gt; (A, tau)</code></pre><p>Compute the <code>RQ</code> factorization of <code>A</code>, <code>A = RQ</code>.</p><p>Returns <code>A</code>, modified in-place, and <code>tau</code>, which contains scalars which parameterize the elementary reflectors of the factorization.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lapack.jl#L702-L709">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.geqrt!" href="#Base.LinAlg.LAPACK.geqrt!"><code>Base.LinAlg.LAPACK.geqrt!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">geqrt!(A, T)</code></pre><p>Compute the blocked <code>QR</code> factorization of <code>A</code>, <code>A = QR</code>. <code>T</code> contains upper triangular block reflectors which parameterize the elementary reflectors of the factorization. The first dimension of <code>T</code> sets the block size and it must be between 1 and <code>n</code>. The second dimension of <code>T</code> must equal the smallest dimension of <code>A</code>.</p><p>Returns <code>A</code> and <code>T</code> modified in-place.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lapack.jl#L591-L601">source</a><div><pre><code class="language-none">geqrt!(A, nb) -&gt; (A, T)</code></pre><p>Compute the blocked <code>QR</code> factorization of <code>A</code>, <code>A = QR</code>. <code>nb</code> sets the block size and it must be between 1 and <code>n</code>, the second dimension of <code>A</code>.</p><p>Returns <code>A</code>, modified in-place, and <code>T</code>, which contains upper triangular block reflectors which parameterize the elementary reflectors of the factorization.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lapack.jl#L670-L679">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.geqrt3!" href="#Base.LinAlg.LAPACK.geqrt3!"><code>Base.LinAlg.LAPACK.geqrt3!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">geqrt3!(A, T)</code></pre><p>Recursively computes the blocked <code>QR</code> factorization of <code>A</code>, <code>A = QR</code>. <code>T</code> contains upper triangular block reflectors which parameterize the elementary reflectors of the factorization.  The first dimension of <code>T</code> sets the block size and it must be between 1 and <code>n</code>. The second dimension of <code>T</code> must equal the smallest dimension of <code>A</code>.</p><p>Returns <code>A</code> and <code>T</code> modified in-place.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lapack.jl#L604-L614">source</a><div><pre><code class="language-none">geqrt3!(A) -&gt; (A, T)</code></pre><p>Recursively computes the blocked <code>QR</code> factorization of <code>A</code>, <code>A = QR</code>.</p><p>Returns <code>A</code>, modified in-place, and <code>T</code>, which contains upper triangular block reflectors which parameterize the elementary reflectors of the factorization.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lapack.jl#L682-L689">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.getrf!" href="#Base.LinAlg.LAPACK.getrf!"><code>Base.LinAlg.LAPACK.getrf!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">getrf!(A) -&gt; (A, ipiv, info)</code></pre><p>Compute the pivoted <code>LU</code> factorization of <code>A</code>, <code>A = LU</code>.</p><p>Returns <code>A</code>, modified in-place, <code>ipiv</code>, the pivoting information, and an <code>info</code> code which indicates success (<code>info = 0</code>), a singular value in <code>U</code> (<code>info = i</code>, in which case <code>U[i,i]</code> is singular), or an error code (<code>info &lt; 0</code>).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lapack.jl#L639-L647">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.tzrzf!" href="#Base.LinAlg.LAPACK.tzrzf!"><code>Base.LinAlg.LAPACK.tzrzf!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">tzrzf!(A) -&gt; (A, tau)</code></pre><p>Transforms the upper trapezoidal matrix <code>A</code> to upper triangular form in-place. Returns <code>A</code> and <code>tau</code>, the scalar parameters for the elementary reflectors of the transformation.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lapack.jl#L834-L840">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.ormrz!" href="#Base.LinAlg.LAPACK.ormrz!"><code>Base.LinAlg.LAPACK.ormrz!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">ormrz!(side, trans, A, tau, C)</code></pre><p>Multiplies the matrix <code>C</code> by <code>Q</code> from the transformation supplied by <code>tzrzf!</code>. Depending on <code>side</code> or <code>trans</code> the multiplication can be left-sided (<code>side = L, Q*C</code>) or right-sided (<code>side = R, C*Q</code>) and <code>Q</code> can be unmodified (<code>trans = N</code>), transposed (<code>trans = T</code>), or conjugate transposed (<code>trans = C</code>). Returns matrix <code>C</code> which is modified in-place with the result of the multiplication.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lapack.jl#L822-L831">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.gels!" href="#Base.LinAlg.LAPACK.gels!"><code>Base.LinAlg.LAPACK.gels!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">gels!(trans, A, B) -&gt; (F, B, ssr)</code></pre><p>Solves the linear equation <code>A * X = B</code>, <code>A.&#39; * X =B</code>, or <code>A&#39; * X = B</code> using a QR or LQ factorization. Modifies the matrix/vector <code>B</code> in place with the solution. <code>A</code> is overwritten with its <code>QR</code> or <code>LQ</code> factorization. <code>trans</code> may be one of <code>N</code> (no modification), <code>T</code> (transpose), or <code>C</code> (conjugate transpose). <code>gels!</code> searches for the minimum norm/least squares solution. <code>A</code> may be under or over determined. The solution is returned in <code>B</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lapack.jl#L970-L979">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.gesv!" href="#Base.LinAlg.LAPACK.gesv!"><code>Base.LinAlg.LAPACK.gesv!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">gesv!(A, B) -&gt; (B, A, ipiv)</code></pre><p>Solves the linear equation <code>A * X = B</code> where <code>A</code> is a square matrix using the <code>LU</code> factorization of <code>A</code>. <code>A</code> is overwritten with its <code>LU</code> factorization and <code>B</code> is overwritten with the solution <code>X</code>. <code>ipiv</code> contains the pivoting information for the <code>LU</code> factorization of <code>A</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lapack.jl#L982-L989">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.getrs!" href="#Base.LinAlg.LAPACK.getrs!"><code>Base.LinAlg.LAPACK.getrs!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">getrs!(trans, A, ipiv, B)</code></pre><p>Solves the linear equation <code>A * X = B</code>, <code>A.&#39; * X =B</code>, or <code>A&#39; * X = B</code> for square <code>A</code>. Modifies the matrix/vector <code>B</code> in place with the solution. <code>A</code> is the <code>LU</code> factorization from <code>getrf!</code>, with <code>ipiv</code> the pivoting information. <code>trans</code> may be one of <code>N</code> (no modification), <code>T</code> (transpose), or <code>C</code> (conjugate transpose).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lapack.jl#L992-L1000">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.getri!" href="#Base.LinAlg.LAPACK.getri!"><code>Base.LinAlg.LAPACK.getri!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">getri!(A, ipiv)</code></pre><p>Computes the inverse of <code>A</code>, using its <code>LU</code> factorization found by <code>getrf!</code>. <code>ipiv</code> is the pivot information output and <code>A</code> contains the <code>LU</code> factorization of <code>getrf!</code>. <code>A</code> is overwritten with its inverse.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lapack.jl#L1003-L1010">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.gesvx!" href="#Base.LinAlg.LAPACK.gesvx!"><code>Base.LinAlg.LAPACK.gesvx!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">gesvx!(fact, trans, A, AF, ipiv, equed, R, C, B) -&gt; (X, equed, R, C, B, rcond, ferr, berr, work)</code></pre><p>Solves the linear equation <code>A * X = B</code> (<code>trans = N</code>), <code>A.&#39; * X =B</code> (<code>trans = T</code>), or <code>A&#39; * X = B</code> (<code>trans = C</code>) using the <code>LU</code> factorization of <code>A</code>. <code>fact</code> may be <code>E</code>, in which case <code>A</code> will be equilibrated and copied to <code>AF</code>; <code>F</code>, in which case <code>AF</code> and <code>ipiv</code> from a previous <code>LU</code> factorization are inputs; or <code>N</code>, in which case <code>A</code> will be copied to <code>AF</code> and then factored. If <code>fact = F</code>, <code>equed</code> may be <code>N</code>, meaning <code>A</code> has not been equilibrated; <code>R</code>, meaning <code>A</code> was multiplied by <code>diagm(R)</code> from the left; <code>C</code>, meaning <code>A</code> was multiplied by <code>diagm(C)</code> from the right; or <code>B</code>, meaning <code>A</code> was multiplied by <code>diagm(R)</code> from the left and <code>diagm(C)</code> from the right. If <code>fact = F</code> and <code>equed = R</code> or <code>B</code> the elements of <code>R</code> must all be positive. If <code>fact = F</code> and <code>equed = C</code> or <code>B</code> the elements of <code>C</code> must all be positive.</p><p>Returns the solution <code>X</code>; <code>equed</code>, which is an output if <code>fact</code> is not <code>N</code>, and describes the equilibration that was performed; <code>R</code>, the row equilibration diagonal; <code>C</code>, the column equilibration diagonal; <code>B</code>, which may be overwritten with its equilibrated form <code>diagm(R)*B</code> (if <code>trans = N</code> and <code>equed = R,B</code>) or <code>diagm(C)*B</code> (if <code>trans = T,C</code> and <code>equed = C,B</code>); <code>rcond</code>, the reciprocal condition number of <code>A</code> after equilbrating; <code>ferr</code>, the forward error bound for each solution vector in <code>X</code>; <code>berr</code>, the forward error bound for each solution vector in <code>X</code>; and <code>work</code>, the reciprocal pivot growth factor.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lapack.jl#L1153-L1176">source</a><div><pre><code class="language-none">gesvx!(A, B)</code></pre><p>The no-equilibration, no-transpose simplification of <code>gesvx!</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lapack.jl#L1180-L1184">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.gelsd!" href="#Base.LinAlg.LAPACK.gelsd!"><code>Base.LinAlg.LAPACK.gelsd!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">gelsd!(A, B, rcond) -&gt; (B, rnk)</code></pre><p>Computes the least norm solution of <code>A * X = B</code> by finding the <code>SVD</code> factorization of <code>A</code>, then dividing-and-conquering the problem. <code>B</code> is overwritten with the solution <code>X</code>. Singular values below <code>rcond</code> will be treated as zero. Returns the solution in <code>B</code> and the effective rank of <code>A</code> in <code>rnk</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lapack.jl#L1375-L1383">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.gelsy!" href="#Base.LinAlg.LAPACK.gelsy!"><code>Base.LinAlg.LAPACK.gelsy!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">gelsy!(A, B, rcond) -&gt; (B, rnk)</code></pre><p>Computes the least norm solution of <code>A * X = B</code> by finding the full <code>QR</code> factorization of <code>A</code>, then dividing-and-conquering the problem. <code>B</code> is overwritten with the solution <code>X</code>. Singular values below <code>rcond</code> will be treated as zero. Returns the solution in <code>B</code> and the effective rank of <code>A</code> in <code>rnk</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lapack.jl#L1386-L1394">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.gglse!" href="#Base.LinAlg.LAPACK.gglse!"><code>Base.LinAlg.LAPACK.gglse!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">gglse!(A, c, B, d) -&gt; (X,res)</code></pre><p>Solves the equation <code>A * x = c</code> where <code>x</code> is subject to the equality constraint <code>B * x = d</code>. Uses the formula <code>||c - A*x||^2 = 0</code> to solve. Returns <code>X</code> and the residual sum-of-squares.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lapack.jl#L1447-L1453">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.geev!" href="#Base.LinAlg.LAPACK.geev!"><code>Base.LinAlg.LAPACK.geev!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">geev!(jobvl, jobvr, A) -&gt; (W, VL, VR)</code></pre><p>Finds the eigensystem of <code>A</code>. If <code>jobvl = N</code>, the left eigenvectors of <code>A</code> aren&#39;t computed. If <code>jobvr = N</code>, the right eigenvectors of <code>A</code> aren&#39;t computed. If <code>jobvl = V</code> or <code>jobvr = V</code>, the corresponding eigenvectors are computed. Returns the eigenvalues in <code>W</code>, the right eigenvectors in <code>VR</code>, and the left eigenvectors in <code>VL</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lapack.jl#L1742-L1750">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.gesdd!" href="#Base.LinAlg.LAPACK.gesdd!"><code>Base.LinAlg.LAPACK.gesdd!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">gesdd!(job, A) -&gt; (U, S, VT)</code></pre><p>Finds the singular value decomposition of <code>A</code>, <code>A = U * S * V&#39;</code>, using a divide and conquer approach. If <code>job = A</code>, all the columns of <code>U</code> and the rows of <code>V&#39;</code> are computed. If <code>job = N</code>, no columns of <code>U</code> or rows of <code>V&#39;</code> are computed. If <code>job = O</code>, <code>A</code> is overwritten with the columns of (thin) <code>U</code> and the rows of (thin) <code>V&#39;</code>. If <code>job = S</code>, the columns of (thin) <code>U</code> and the rows of (thin) <code>V&#39;</code> are computed and returned separately.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lapack.jl#L1753-L1762">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.gesvd!" href="#Base.LinAlg.LAPACK.gesvd!"><code>Base.LinAlg.LAPACK.gesvd!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">gesvd!(jobu, jobvt, A) -&gt; (U, S, VT)</code></pre><p>Finds the singular value decomposition of <code>A</code>, <code>A = U * S * V&#39;</code>. If <code>jobu = A</code>, all the columns of <code>U</code> are computed. If <code>jobvt = A</code> all the rows of <code>V&#39;</code> are computed. If <code>jobu = N</code>, no columns of <code>U</code> are computed. If <code>jobvt = N</code> no rows of <code>V&#39;</code> are computed. If <code>jobu = O</code>, <code>A</code> is overwritten with the columns of (thin) <code>U</code>. If <code>jobvt = O</code>, <code>A</code> is overwritten with the rows of (thin) <code>V&#39;</code>. If <code>jobu = S</code>, the columns of (thin) <code>U</code> are computed and returned separately. If <code>jobvt = S</code> the rows of (thin) <code>V&#39;</code> are computed and returned separately. <code>jobu</code> and <code>jobvt</code> can&#39;t both be <code>O</code>.</p><p>Returns <code>U</code>, <code>S</code>, and <code>Vt</code>, where <code>S</code> are the singular values of <code>A</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lapack.jl#L1765-L1778">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.ggsvd!" href="#Base.LinAlg.LAPACK.ggsvd!"><code>Base.LinAlg.LAPACK.ggsvd!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">ggsvd!(jobu, jobv, jobq, A, B) -&gt; (U, V, Q, alpha, beta, k, l, R)</code></pre><p>Finds the generalized singular value decomposition of <code>A</code> and <code>B</code>, <code>U&#39;*A*Q = D1*R</code> and <code>V&#39;*B*Q = D2*R</code>. <code>D1</code> has <code>alpha</code> on its diagonal and <code>D2</code> has <code>beta</code> on its diagonal. If <code>jobu = U</code>, the orthogonal/unitary matrix <code>U</code> is computed. If <code>jobv = V</code> the orthogonal/unitary matrix <code>V</code> is computed. If <code>jobq = Q</code>, the orthogonal/unitary matrix <code>Q</code> is computed. If <code>jobu</code>, <code>jobv</code> or <code>jobq</code> is <code>N</code>, that matrix is not computed. This function is only available in LAPACK versions prior to 3.6.0.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lapack.jl#L1781-L1791">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.ggsvd3!" href="#Base.LinAlg.LAPACK.ggsvd3!"><code>Base.LinAlg.LAPACK.ggsvd3!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">ggsvd3!(jobu, jobv, jobq, A, B) -&gt; (U, V, Q, alpha, beta, k, l, R)</code></pre><p>Finds the generalized singular value decomposition of <code>A</code> and <code>B</code>, <code>U&#39;*A*Q = D1*R</code> and <code>V&#39;*B*Q = D2*R</code>. <code>D1</code> has <code>alpha</code> on its diagonal and <code>D2</code> has <code>beta</code> on its diagonal. If <code>jobu = U</code>, the orthogonal/unitary matrix <code>U</code> is computed. If <code>jobv = V</code> the orthogonal/unitary matrix <code>V</code> is computed. If <code>jobq = Q</code>, the orthogonal/unitary matrix <code>Q</code> is computed. If <code>jobu</code>, <code>jobv</code>, or <code>jobq</code> is <code>N</code>, that matrix is not computed. This function requires LAPACK 3.6.0.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lapack.jl#L1910-L1919">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.geevx!" href="#Base.LinAlg.LAPACK.geevx!"><code>Base.LinAlg.LAPACK.geevx!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">geevx!(balanc, jobvl, jobvr, sense, A) -&gt; (A, w, VL, VR, ilo, ihi, scale, abnrm, rconde, rcondv)</code></pre><p>Finds the eigensystem of <code>A</code> with matrix balancing. If <code>jobvl = N</code>, the left eigenvectors of <code>A</code> aren&#39;t computed. If <code>jobvr = N</code>, the right eigenvectors of <code>A</code> aren&#39;t computed. If <code>jobvl = V</code> or <code>jobvr = V</code>, the corresponding eigenvectors are computed. If <code>balanc = N</code>, no balancing is performed. If <code>balanc = P</code>, <code>A</code> is permuted but not scaled. If <code>balanc = S</code>, <code>A</code> is scaled but not permuted. If <code>balanc = B</code>, <code>A</code> is permuted and scaled. If <code>sense = N</code>, no reciprocal condition numbers are computed. If <code>sense = E</code>, reciprocal condition numbers are computed for the eigenvalues only. If <code>sense = V</code>, reciprocal condition numbers are computed for the right eigenvectors only. If <code>sense = B</code>, reciprocal condition numbers are computed for the right eigenvectors and the eigenvectors. If <code>sense = E,B</code>, the right and left eigenvectors must be computed.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lapack.jl#L2220-L2236">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.ggev!" href="#Base.LinAlg.LAPACK.ggev!"><code>Base.LinAlg.LAPACK.ggev!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">ggev!(jobvl, jobvr, A, B) -&gt; (alpha, beta, vl, vr)</code></pre><p>Finds the generalized eigendecomposition of <code>A</code> and <code>B</code>. If <code>jobvl = N</code>, the left eigenvectors aren&#39;t computed. If <code>jobvr = N</code>, the right eigenvectors aren&#39;t computed. If <code>jobvl = V</code> or <code>jobvr = V</code>, the corresponding eigenvectors are computed.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lapack.jl#L2239-L2246">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.gtsv!" href="#Base.LinAlg.LAPACK.gtsv!"><code>Base.LinAlg.LAPACK.gtsv!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">gtsv!(dl, d, du, B)</code></pre><p>Solves the equation <code>A * X = B</code> where <code>A</code> is a tridiagonal matrix with <code>dl</code> on the subdiagonal, <code>d</code> on the diagonal, and <code>du</code> on the superdiagonal.</p><p>Overwrites <code>B</code> with the solution <code>X</code> and returns it.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lapack.jl#L2413-L2421">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.gttrf!" href="#Base.LinAlg.LAPACK.gttrf!"><code>Base.LinAlg.LAPACK.gttrf!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">gttrf!(dl, d, du) -&gt; (dl, d, du, du2, ipiv)</code></pre><p>Finds the <code>LU</code> factorization of a tridiagonal matrix with <code>dl</code> on the subdiagonal, <code>d</code> on the diagonal, and <code>du</code> on the superdiagonal.</p><p>Modifies <code>dl</code>, <code>d</code>, and <code>du</code> in-place and returns them and the second superdiagonal <code>du2</code> and the pivoting vector <code>ipiv</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lapack.jl#L2424-L2432">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.gttrs!" href="#Base.LinAlg.LAPACK.gttrs!"><code>Base.LinAlg.LAPACK.gttrs!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">gttrs!(trans, dl, d, du, du2, ipiv, B)</code></pre><p>Solves the equation <code>A * X = B</code> (<code>trans = N</code>), <code>A.&#39; * X = B</code> (<code>trans = T</code>), or <code>A&#39; * X = B</code> (<code>trans = C</code>) using the <code>LU</code> factorization computed by <code>gttrf!</code>. <code>B</code> is overwritten with the solution <code>X</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lapack.jl#L2435-L2441">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.orglq!" href="#Base.LinAlg.LAPACK.orglq!"><code>Base.LinAlg.LAPACK.orglq!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">orglq!(A, tau, k = length(tau))</code></pre><p>Explicitly finds the matrix <code>Q</code> of a <code>LQ</code> factorization after calling <code>gelqf!</code> on <code>A</code>. Uses the output of <code>gelqf!</code>. <code>A</code> is overwritten by <code>Q</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lapack.jl#L2835-L2840">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.orgqr!" href="#Base.LinAlg.LAPACK.orgqr!"><code>Base.LinAlg.LAPACK.orgqr!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">orgqr!(A, tau, k = length(tau))</code></pre><p>Explicitly finds the matrix <code>Q</code> of a <code>QR</code> factorization after calling <code>geqrf!</code> on <code>A</code>. Uses the output of <code>geqrf!</code>. <code>A</code> is overwritten by <code>Q</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lapack.jl#L2843-L2848">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.orgql!" href="#Base.LinAlg.LAPACK.orgql!"><code>Base.LinAlg.LAPACK.orgql!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">orgql!(A, tau, k = length(tau))</code></pre><p>Explicitly finds the matrix <code>Q</code> of a <code>QL</code> factorization after calling <code>geqlf!</code> on <code>A</code>. Uses the output of <code>geqlf!</code>. <code>A</code> is overwritten by <code>Q</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lapack.jl#L2851-L2856">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.orgrq!" href="#Base.LinAlg.LAPACK.orgrq!"><code>Base.LinAlg.LAPACK.orgrq!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">orgrq!(A, tau, k = length(tau))</code></pre><p>Explicitly finds the matrix <code>Q</code> of a <code>RQ</code> factorization after calling <code>gerqf!</code> on <code>A</code>. Uses the output of <code>gerqf!</code>. <code>A</code> is overwritten by <code>Q</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lapack.jl#L2859-L2864">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.ormlq!" href="#Base.LinAlg.LAPACK.ormlq!"><code>Base.LinAlg.LAPACK.ormlq!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">ormlq!(side, trans, A, tau, C)</code></pre><p>Computes <code>Q * C</code> (<code>trans = N</code>), <code>Q.&#39; * C</code> (<code>trans = T</code>), <code>Q&#39; * C</code> (<code>trans = C</code>) for <code>side = L</code> or the equivalent right-sided multiplication for <code>side = R</code> using <code>Q</code> from a <code>LQ</code> factorization of <code>A</code> computed using <code>gelqf!</code>. <code>C</code> is overwritten.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lapack.jl#L2867-L2874">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.ormqr!" href="#Base.LinAlg.LAPACK.ormqr!"><code>Base.LinAlg.LAPACK.ormqr!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">ormqr!(side, trans, A, tau, C)</code></pre><p>Computes <code>Q * C</code> (<code>trans = N</code>), <code>Q.&#39; * C</code> (<code>trans = T</code>), <code>Q&#39; * C</code> (<code>trans = C</code>) for <code>side = L</code> or the equivalent right-sided multiplication for <code>side = R</code> using <code>Q</code> from a <code>QR</code> factorization of <code>A</code> computed using <code>geqrf!</code>. <code>C</code> is overwritten.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lapack.jl#L2877-L2884">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.ormql!" href="#Base.LinAlg.LAPACK.ormql!"><code>Base.LinAlg.LAPACK.ormql!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">ormql!(side, trans, A, tau, C)</code></pre><p>Computes <code>Q * C</code> (<code>trans = N</code>), <code>Q.&#39; * C</code> (<code>trans = T</code>), <code>Q&#39; * C</code> (<code>trans = C</code>) for <code>side = L</code> or the equivalent right-sided multiplication for <code>side = R</code> using <code>Q</code> from a <code>QL</code> factorization of <code>A</code> computed using <code>geqlf!</code>. <code>C</code> is overwritten.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lapack.jl#L2887-L2894">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.ormrq!" href="#Base.LinAlg.LAPACK.ormrq!"><code>Base.LinAlg.LAPACK.ormrq!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">ormrq!(side, trans, A, tau, C)</code></pre><p>Computes <code>Q * C</code> (<code>trans = N</code>), <code>Q.&#39; * C</code> (<code>trans = T</code>), <code>Q&#39; * C</code> (<code>trans = C</code>) for <code>side = L</code> or the equivalent right-sided multiplication for <code>side = R</code> using <code>Q</code> from a <code>RQ</code> factorization of <code>A</code> computed using <code>gerqf!</code>. <code>C</code> is overwritten.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lapack.jl#L2897-L2904">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.gemqrt!" href="#Base.LinAlg.LAPACK.gemqrt!"><code>Base.LinAlg.LAPACK.gemqrt!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">gemqrt!(side, trans, V, T, C)</code></pre><p>Computes <code>Q * C</code> (<code>trans = N</code>), <code>Q.&#39; * C</code> (<code>trans = T</code>), <code>Q&#39; * C</code> (<code>trans = C</code>) for <code>side = L</code> or the equivalent right-sided multiplication for <code>side = R</code> using <code>Q</code> from a <code>QR</code> factorization of <code>A</code> computed using <code>geqrt!</code>. <code>C</code> is overwritten.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lapack.jl#L2907-L2914">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.posv!" href="#Base.LinAlg.LAPACK.posv!"><code>Base.LinAlg.LAPACK.posv!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">posv!(uplo, A, B) -&gt; (A, B)</code></pre><p>Finds the solution to <code>A * X = B</code> where <code>A</code> is a symmetric or Hermitian positive definite matrix. If <code>uplo = U</code> the upper Cholesky decomposition of <code>A</code> is computed. If <code>uplo = L</code> the lower Cholesky decomposition of <code>A</code> is computed. <code>A</code> is overwritten by its Cholesky decomposition. <code>B</code> is overwritten with the solution <code>X</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lapack.jl#L3045-L3053">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.potrf!" href="#Base.LinAlg.LAPACK.potrf!"><code>Base.LinAlg.LAPACK.potrf!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">potrf!(uplo, A)</code></pre><p>Computes the Cholesky (upper if <code>uplo = U</code>, lower if <code>uplo = L</code>) decomposition of positive-definite matrix <code>A</code>. <code>A</code> is overwritten and returned with an info code.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lapack.jl#L3056-L3062">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.potri!" href="#Base.LinAlg.LAPACK.potri!"><code>Base.LinAlg.LAPACK.potri!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">potri!(uplo, A)</code></pre><p>Computes the inverse of positive-definite matrix <code>A</code> after calling <code>potrf!</code> to find its (upper if <code>uplo = U</code>, lower if <code>uplo = L</code>) Cholesky decomposition.</p><p><code>A</code> is overwritten by its inverse and returned.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lapack.jl#L3065-L3073">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.potrs!" href="#Base.LinAlg.LAPACK.potrs!"><code>Base.LinAlg.LAPACK.potrs!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">potrs!(uplo, A, B)</code></pre><p>Finds the solution to <code>A * X = B</code> where <code>A</code> is a symmetric or Hermitian positive definite matrix whose Cholesky decomposition was computed by <code>potrf!</code>. If <code>uplo = U</code> the upper Cholesky decomposition of <code>A</code> was computed. If <code>uplo = L</code> the lower Cholesky decomposition of <code>A</code> was computed. <code>B</code> is overwritten with the solution <code>X</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lapack.jl#L3076-L3084">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.pstrf!" href="#Base.LinAlg.LAPACK.pstrf!"><code>Base.LinAlg.LAPACK.pstrf!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">pstrf!(uplo, A, tol) -&gt; (A, piv, rank, info)</code></pre><p>Computes the (upper if <code>uplo = U</code>, lower if <code>uplo = L</code>) pivoted Cholesky decomposition of positive-definite matrix <code>A</code> with a user-set tolerance <code>tol</code>. <code>A</code> is overwritten by its Cholesky decomposition.</p><p>Returns <code>A</code>, the pivots <code>piv</code>, the rank of <code>A</code>, and an <code>info</code> code. If <code>info = 0</code>, the factorization succeeded. If <code>info = i &gt; 0</code>, then <code>A</code> is indefinite or rank-deficient.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lapack.jl#L3087-L3097">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.ptsv!" href="#Base.LinAlg.LAPACK.ptsv!"><code>Base.LinAlg.LAPACK.ptsv!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">ptsv!(D, E, B)</code></pre><p>Solves <code>A * X = B</code> for positive-definite tridiagonal <code>A</code>. <code>D</code> is the diagonal of <code>A</code> and <code>E</code> is the off-diagonal. <code>B</code> is overwritten with the solution <code>X</code> and returned.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lapack.jl#L3152-L3158">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.pttrf!" href="#Base.LinAlg.LAPACK.pttrf!"><code>Base.LinAlg.LAPACK.pttrf!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">pttrf!(D, E)</code></pre><p>Computes the LDLt factorization of a positive-definite tridiagonal matrix with <code>D</code> as diagonal and <code>E</code> as off-diagonal. <code>D</code> and <code>E</code> are overwritten and returned.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lapack.jl#L3161-L3167">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.pttrs!" href="#Base.LinAlg.LAPACK.pttrs!"><code>Base.LinAlg.LAPACK.pttrs!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">pttrs!(D, E, B)</code></pre><p>Solves <code>A * X = B</code> for positive-definite tridiagonal <code>A</code> with diagonal <code>D</code> and off-diagonal <code>E</code> after computing <code>A</code>&#39;s LDLt factorization using <code>pttrf!</code>. <code>B</code> is overwritten with the solution <code>X</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lapack.jl#L3232-L3238">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.trtri!" href="#Base.LinAlg.LAPACK.trtri!"><code>Base.LinAlg.LAPACK.trtri!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">trtri!(uplo, diag, A)</code></pre><p>Finds the inverse of (upper if <code>uplo = U</code>, lower if <code>uplo = L</code>) triangular matrix <code>A</code>. If <code>diag = N</code>, <code>A</code> has non-unit diagonal elements. If <code>diag = U</code>, all diagonal elements of <code>A</code> are one. <code>A</code> is overwritten with its inverse.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lapack.jl#L3297-L3304">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.trtrs!" href="#Base.LinAlg.LAPACK.trtrs!"><code>Base.LinAlg.LAPACK.trtrs!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">trtrs!(uplo, trans, diag, A, B)</code></pre><p>Solves <code>A * X = B</code> (<code>trans = N</code>), <code>A.&#39; * X = B</code> (<code>trans = T</code>), or <code>A&#39; * X = B</code> (<code>trans = C</code>) for (upper if <code>uplo = U</code>, lower if <code>uplo = L</code>) triangular matrix <code>A</code>. If <code>diag = N</code>, <code>A</code> has non-unit diagonal elements. If <code>diag = U</code>, all diagonal elements of <code>A</code> are one. <code>B</code> is overwritten with the solution <code>X</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lapack.jl#L3307-L3315">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.trcon!" href="#Base.LinAlg.LAPACK.trcon!"><code>Base.LinAlg.LAPACK.trcon!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">trcon!(norm, uplo, diag, A)</code></pre><p>Finds the reciprocal condition number of (upper if <code>uplo = U</code>, lower if <code>uplo = L</code>) triangular matrix <code>A</code>. If <code>diag = N</code>, <code>A</code> has non-unit diagonal elements. If <code>diag = U</code>, all diagonal elements of <code>A</code> are one. If <code>norm = I</code>, the condition number is found in the infinity norm. If <code>norm = O</code> or <code>1</code>, the condition number is found in the one norm.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lapack.jl#L3576-L3584">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.trevc!" href="#Base.LinAlg.LAPACK.trevc!"><code>Base.LinAlg.LAPACK.trevc!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">trevc!(side, howmny, select, T, VL = similar(T), VR = similar(T))</code></pre><p>Finds the eigensystem of an upper triangular matrix <code>T</code>. If <code>side = R</code>, the right eigenvectors are computed. If <code>side = L</code>, the left eigenvectors are computed. If <code>side = B</code>, both sets are computed. If <code>howmny = A</code>, all eigenvectors are found. If <code>howmny = B</code>, all eigenvectors are found and backtransformed using <code>VL</code> and <code>VR</code>. If <code>howmny = S</code>, only the eigenvectors corresponding to the values in <code>select</code> are computed.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lapack.jl#L3587-L3597">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.trrfs!" href="#Base.LinAlg.LAPACK.trrfs!"><code>Base.LinAlg.LAPACK.trrfs!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">trrfs!(uplo, trans, diag, A, B, X, Ferr, Berr) -&gt; (Ferr, Berr)</code></pre><p>Estimates the error in the solution to <code>A * X = B</code> (<code>trans = N</code>), <code>A.&#39; * X = B</code> (<code>trans = T</code>), <code>A&#39; * X = B</code> (<code>trans = C</code>) for <code>side = L</code>, or the equivalent equations a right-handed <code>side = R</code> <code>X * A</code> after computing <code>X</code> using <code>trtrs!</code>. If <code>uplo = U</code>, <code>A</code> is upper triangular. If <code>uplo = L</code>, <code>A</code> is lower triangular. If <code>diag = N</code>, <code>A</code> has non-unit diagonal elements. If <code>diag = U</code>, all diagonal elements of <code>A</code> are one. <code>Ferr</code> and <code>Berr</code> are optional inputs. <code>Ferr</code> is the forward error and <code>Berr</code> is the backward error, each component-wise.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lapack.jl#L3601-L3612">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.stev!" href="#Base.LinAlg.LAPACK.stev!"><code>Base.LinAlg.LAPACK.stev!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">stev!(job, dv, ev) -&gt; (dv, Zmat)</code></pre><p>Computes the eigensystem for a symmetric tridiagonal matrix with <code>dv</code> as diagonal and <code>ev</code> as off-diagonal. If <code>job = N</code> only the eigenvalues are found and returned in <code>dv</code>. If <code>job = V</code> then the eigenvectors are also found and returned in <code>Zmat</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lapack.jl#L3773-L3780">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.stebz!" href="#Base.LinAlg.LAPACK.stebz!"><code>Base.LinAlg.LAPACK.stebz!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">stebz!(range, order, vl, vu, il, iu, abstol, dv, ev) -&gt; (dv, iblock, isplit)</code></pre><p>Computes the eigenvalues for a symmetric tridiagonal matrix with <code>dv</code> as diagonal and <code>ev</code> as off-diagonal. If <code>range = A</code>, all the eigenvalues are found. If <code>range = V</code>, the eigenvalues in the half-open interval <code>(vl, vu]</code> are found. If <code>range = I</code>, the eigenvalues with indices between <code>il</code> and <code>iu</code> are found. If <code>order = B</code>, eigvalues are ordered within a block. If <code>order = E</code>, they are ordered across all the blocks. <code>abstol</code> can be set as a tolerance for convergence.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lapack.jl#L3783-L3793">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.stegr!" href="#Base.LinAlg.LAPACK.stegr!"><code>Base.LinAlg.LAPACK.stegr!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">stegr!(jobz, range, dv, ev, vl, vu, il, iu) -&gt; (w, Z)</code></pre><p>Computes the eigenvalues (<code>jobz = N</code>) or eigenvalues and eigenvectors (<code>jobz = V</code>) for a symmetric tridiagonal matrix with <code>dv</code> as diagonal and <code>ev</code> as off-diagonal. If <code>range = A</code>, all the eigenvalues are found. If <code>range = V</code>, the eigenvalues in the half-open interval <code>(vl, vu]</code> are found. If <code>range = I</code>, the eigenvalues with indices between <code>il</code> and <code>iu</code> are found. The eigenvalues are returned in <code>w</code> and the eigenvectors in <code>Z</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lapack.jl#L3796-L3806">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.stein!" href="#Base.LinAlg.LAPACK.stein!"><code>Base.LinAlg.LAPACK.stein!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">stein!(dv, ev_in, w_in, iblock_in, isplit_in)</code></pre><p>Computes the eigenvectors for a symmetric tridiagonal matrix with <code>dv</code> as diagonal and <code>ev_in</code> as off-diagonal. <code>w_in</code> specifies the input eigenvalues for which to find corresponding eigenvectors. <code>iblock_in</code> specifies the submatrices corresponding to the eigenvalues in <code>w_in</code>. <code>isplit_in</code> specifies the splitting points between the submatrix blocks.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lapack.jl#L3809-L3817">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.syconv!" href="#Base.LinAlg.LAPACK.syconv!"><code>Base.LinAlg.LAPACK.syconv!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">syconv!(uplo, A, ipiv) -&gt; (A, work)</code></pre><p>Converts a symmetric matrix <code>A</code> (which has been factorized into a triangular matrix) into two matrices <code>L</code> and <code>D</code>. If <code>uplo = U</code>, <code>A</code> is upper triangular. If <code>uplo = L</code>, it is lower triangular. <code>ipiv</code> is the pivot vector from the triangular factorization. <code>A</code> is overwritten by <code>L</code> and <code>D</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lapack.jl#L4673-L4681">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.sysv!" href="#Base.LinAlg.LAPACK.sysv!"><code>Base.LinAlg.LAPACK.sysv!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">sysv!(uplo, A, B) -&gt; (B, A, ipiv)</code></pre><p>Finds the solution to <code>A * X = B</code> for symmetric matrix <code>A</code>. If <code>uplo = U</code>, the upper half of <code>A</code> is stored. If <code>uplo = L</code>, the lower half is stored. <code>B</code> is overwritten by the solution <code>X</code>. <code>A</code> is overwritten by its Bunch-Kaufman factorization. <code>ipiv</code> contains pivoting information about the factorization.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lapack.jl#L4684-L4692">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.sytrf!" href="#Base.LinAlg.LAPACK.sytrf!"><code>Base.LinAlg.LAPACK.sytrf!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">sytrf!(uplo, A) -&gt; (A, ipiv, info)</code></pre><p>Computes the Bunch-Kaufman factorization of a symmetric matrix <code>A</code>. If <code>uplo = U</code>, the upper half of <code>A</code> is stored. If <code>uplo = L</code>, the lower half is stored.</p><p>Returns <code>A</code>, overwritten by the factorization, a pivot vector <code>ipiv</code>, and the error code <code>info</code> which is a non-negative integer. If <code>info</code> is positive the matrix is singular and the diagonal part of the factorization is exactly zero at position <code>info</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lapack.jl#L4695-L4706">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.sytri!" href="#Base.LinAlg.LAPACK.sytri!"><code>Base.LinAlg.LAPACK.sytri!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">sytri!(uplo, A, ipiv)</code></pre><p>Computes the inverse of a symmetric matrix <code>A</code> using the results of <code>sytrf!</code>. If <code>uplo = U</code>, the upper half of <code>A</code> is stored. If <code>uplo = L</code>, the lower half is stored. <code>A</code> is overwritten by its inverse.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lapack.jl#L4709-L4715">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.sytrs!" href="#Base.LinAlg.LAPACK.sytrs!"><code>Base.LinAlg.LAPACK.sytrs!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">sytrs!(uplo, A, ipiv, B)</code></pre><p>Solves the equation <code>A * X = B</code> for a symmetric matrix <code>A</code> using the results of <code>sytrf!</code>. If <code>uplo = U</code>, the upper half of <code>A</code> is stored. If <code>uplo = L</code>, the lower half is stored. <code>B</code> is overwritten by the solution <code>X</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lapack.jl#L4718-L4725">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.hesv!" href="#Base.LinAlg.LAPACK.hesv!"><code>Base.LinAlg.LAPACK.hesv!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">hesv!(uplo, A, B) -&gt; (B, A, ipiv)</code></pre><p>Finds the solution to <code>A * X = B</code> for Hermitian matrix <code>A</code>. If <code>uplo = U</code>, the upper half of <code>A</code> is stored. If <code>uplo = L</code>, the lower half is stored. <code>B</code> is overwritten by the solution <code>X</code>. <code>A</code> is overwritten by its Bunch-Kaufman factorization. <code>ipiv</code> contains pivoting information about the factorization.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lapack.jl#L4729-L4737">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.hetrf!" href="#Base.LinAlg.LAPACK.hetrf!"><code>Base.LinAlg.LAPACK.hetrf!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">hetrf!(uplo, A) -&gt; (A, ipiv, info)</code></pre><p>Computes the Bunch-Kaufman factorization of a Hermitian matrix <code>A</code>. If <code>uplo = U</code>, the upper half of <code>A</code> is stored. If <code>uplo = L</code>, the lower half is stored.</p><p>Returns <code>A</code>, overwritten by the factorization, a pivot vector <code>ipiv</code>, and the error code <code>info</code> which is a non-negative integer. If <code>info</code> is positive the matrix is singular and the diagonal part of the factorization is exactly zero at position <code>info</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lapack.jl#L4740-L4751">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.hetri!" href="#Base.LinAlg.LAPACK.hetri!"><code>Base.LinAlg.LAPACK.hetri!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">hetri!(uplo, A, ipiv)</code></pre><p>Computes the inverse of a Hermitian matrix <code>A</code> using the results of <code>sytrf!</code>. If <code>uplo = U</code>, the upper half of <code>A</code> is stored. If <code>uplo = L</code>, the lower half is stored. <code>A</code> is overwritten by its inverse.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lapack.jl#L4754-L4760">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.hetrs!" href="#Base.LinAlg.LAPACK.hetrs!"><code>Base.LinAlg.LAPACK.hetrs!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">hetrs!(uplo, A, ipiv, B)</code></pre><p>Solves the equation <code>A * X = B</code> for a Hermitian matrix <code>A</code> using the results of <code>sytrf!</code>. If <code>uplo = U</code>, the upper half of <code>A</code> is stored. If <code>uplo = L</code>, the lower half is stored. <code>B</code> is overwritten by the solution <code>X</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lapack.jl#L4763-L4770">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.syev!" href="#Base.LinAlg.LAPACK.syev!"><code>Base.LinAlg.LAPACK.syev!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">syev!(jobz, uplo, A)</code></pre><p>Finds the eigenvalues (<code>jobz = N</code>) or eigenvalues and eigenvectors (<code>jobz = V</code>) of a symmetric matrix <code>A</code>. If <code>uplo = U</code>, the upper triangle of <code>A</code> is used. If <code>uplo = L</code>, the lower triangle of <code>A</code> is used.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lapack.jl#L5072-L5078">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.syevr!" href="#Base.LinAlg.LAPACK.syevr!"><code>Base.LinAlg.LAPACK.syevr!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">syevr!(jobz, range, uplo, A, vl, vu, il, iu, abstol) -&gt; (W, Z)</code></pre><p>Finds the eigenvalues (<code>jobz = N</code>) or eigenvalues and eigenvectors (<code>jobz = V</code>) of a symmetric matrix <code>A</code>. If <code>uplo = U</code>, the upper triangle of <code>A</code> is used. If <code>uplo = L</code>, the lower triangle of <code>A</code> is used. If <code>range = A</code>, all the eigenvalues are found. If <code>range = V</code>, the eigenvalues in the half-open interval <code>(vl, vu]</code> are found. If <code>range = I</code>, the eigenvalues with indices between <code>il</code> and <code>iu</code> are found. <code>abstol</code> can be set as a tolerance for convergence.</p><p>The eigenvalues are returned in <code>W</code> and the eigenvectors in <code>Z</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lapack.jl#L5081-L5093">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.sygvd!" href="#Base.LinAlg.LAPACK.sygvd!"><code>Base.LinAlg.LAPACK.sygvd!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">sygvd!(itype, jobz, uplo, A, B) -&gt; (w, A, B)</code></pre><p>Finds the generalized eigenvalues (<code>jobz = N</code>) or eigenvalues and eigenvectors (<code>jobz = V</code>) of a symmetric matrix <code>A</code> and symmetric positive-definite matrix <code>B</code>. If <code>uplo = U</code>, the upper triangles of <code>A</code> and <code>B</code> are used. If <code>uplo = L</code>, the lower triangles of <code>A</code> and <code>B</code> are used. If <code>itype = 1</code>, the problem to solve is <code>A * x = lambda * B * x</code>. If <code>itype = 2</code>, the problem to solve is <code>A * B * x = lambda * x</code>. If <code>itype = 3</code>, the problem to solve is <code>B * A * x = lambda * x</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lapack.jl#L5097-L5108">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.bdsqr!" href="#Base.LinAlg.LAPACK.bdsqr!"><code>Base.LinAlg.LAPACK.bdsqr!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">bdsqr!(uplo, d, e_, Vt, U, C) -&gt; (d, Vt, U, C)</code></pre><p>Computes the singular value decomposition of a bidiagonal matrix with <code>d</code> on the diagonal and <code>e_</code> on the off-diagonal. If <code>uplo = U</code>, <code>e_</code> is the superdiagonal. If <code>uplo = L</code>, <code>e_</code> is the subdiagonal. Can optionally also compute the product <code>Q&#39; * C</code>.</p><p>Returns the singular values in <code>d</code>, and the matrix <code>C</code> overwritten with <code>Q&#39; * C</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lapack.jl#L5160-L5169">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.bdsdc!" href="#Base.LinAlg.LAPACK.bdsdc!"><code>Base.LinAlg.LAPACK.bdsdc!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">bdsdc!(uplo, compq, d, e_) -&gt; (d, e, u, vt, q, iq)</code></pre><p>Computes the singular value decomposition of a bidiagonal matrix with <code>d</code> on the diagonal and <code>e_</code> on the off-diagonal using a divide and conqueq method. If <code>uplo = U</code>, <code>e_</code> is the superdiagonal. If <code>uplo = L</code>, <code>e_</code> is the subdiagonal. If <code>compq = N</code>, only the singular values are found. If <code>compq = I</code>, the singular values and vectors are found. If <code>compq = P</code>, the singular values and vectors are found in compact form. Only works for real types.</p><p>Returns the singular values in <code>d</code>, and if <code>compq = P</code>, the compact singular vectors in <code>iq</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lapack.jl#L5228-L5240">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.gecon!" href="#Base.LinAlg.LAPACK.gecon!"><code>Base.LinAlg.LAPACK.gecon!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">gecon!(normtype, A, anorm)</code></pre><p>Finds the reciprocal condition number of matrix <code>A</code>. If <code>normtype = I</code>, the condition number is found in the infinity norm. If <code>normtype = O</code> or <code>1</code>, the condition number is found in the one norm. <code>A</code> must be the result of <code>getrf!</code> and <code>anorm</code> is the norm of <code>A</code> in the relevant norm.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lapack.jl#L5311-L5318">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.gehrd!" href="#Base.LinAlg.LAPACK.gehrd!"><code>Base.LinAlg.LAPACK.gehrd!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">gehrd!(ilo, ihi, A) -&gt; (A, tau)</code></pre><p>Converts a matrix <code>A</code> to Hessenberg form. If <code>A</code> is balanced with <code>gebal!</code> then <code>ilo</code> and <code>ihi</code> are the outputs of <code>gebal!</code>. Otherwise they should be <code>ilo = 1</code> and <code>ihi = size(A,2)</code>. <code>tau</code> contains the elementary reflectors of the factorization.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lapack.jl#L5361-L5368">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.orghr!" href="#Base.LinAlg.LAPACK.orghr!"><code>Base.LinAlg.LAPACK.orghr!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">orghr!(ilo, ihi, A, tau)</code></pre><p>Explicitly finds <code>Q</code>, the orthogonal/unitary matrix from <code>gehrd!</code>. <code>ilo</code>, <code>ihi</code>, <code>A</code>, and <code>tau</code> must correspond to the input/output to <code>gehrd!</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lapack.jl#L5410-L5415">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.gees!" href="#Base.LinAlg.LAPACK.gees!"><code>Base.LinAlg.LAPACK.gees!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">gees!(jobvs, A) -&gt; (A, vs, w)</code></pre><p>Computes the eigenvalues (<code>jobvs = N</code>) or the eigenvalues and Schur vectors (<code>jobvs = V</code>) of matrix <code>A</code>. <code>A</code> is overwritten by its Schur form.</p><p>Returns <code>A</code>, <code>vs</code> containing the Schur vectors, and <code>w</code>, containing the eigenvalues.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lapack.jl#L5656-L5664">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.gges!" href="#Base.LinAlg.LAPACK.gges!"><code>Base.LinAlg.LAPACK.gges!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">gges!(jobvsl, jobvsr, A, B) -&gt; (A, B, alpha, beta, vsl, vsr)</code></pre><p>Computes the generalized eigenvalues, generalized Schur form, left Schur vectors (<code>jobsvl = V</code>), or right Schur vectors (<code>jobvsr = V</code>) of <code>A</code> and <code>B</code>.</p><p>The generalized eigenvalues are returned in <code>alpha</code> and <code>beta</code>. The left Schur vectors are returned in <code>vsl</code> and the right Schur vectors are returned in <code>vsr</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lapack.jl#L5668-L5677">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.trexc!" href="#Base.LinAlg.LAPACK.trexc!"><code>Base.LinAlg.LAPACK.trexc!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">trexc!(compq, ifst, ilst, T, Q) -&gt; (T, Q)</code></pre><p>Reorder the Schur factorization of a matrix. If <code>compq = V</code>, the Schur vectors <code>Q</code> are reordered. If <code>compq = N</code> they are not modified. <code>ifst</code> and <code>ilst</code> specify the reordering of the vectors.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lapack.jl#L5972-L5978">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.trsen!" href="#Base.LinAlg.LAPACK.trsen!"><code>Base.LinAlg.LAPACK.trsen!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">trsen!(compq, job, select, T, Q) -&gt; (T, Q, w)</code></pre><p>Reorder the Schur factorization of a matrix and optionally finds reciprocal condition numbers. If <code>job = N</code>, no condition numbers are found. If <code>job = E</code>, only the condition number for this cluster of eigenvalues is found. If <code>job = V</code>, only the condition number for the invariant subspace is found. If <code>job = B</code> then the condition numbers for the cluster and subspace are found. If <code>compq = V</code> the Schur vectors <code>Q</code> are updated. If <code>compq = N</code> the Schur vectors are not modified. <code>select</code> determines which eigenvalues are in the cluster.</p><p>Returns <code>T</code>, <code>Q</code>, and reordered eigenvalues in <code>w</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lapack.jl#L5981-L5994">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.tgsen!" href="#Base.LinAlg.LAPACK.tgsen!"><code>Base.LinAlg.LAPACK.tgsen!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">tgsen!(select, S, T, Q, Z) -&gt; (S, T, alpha, beta, Q, Z)</code></pre><p>Reorders the vectors of a generalized Schur decomposition. <code>select</code> specifices the eigenvalues in each cluster.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lapack.jl#L5997-L6002">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.trsyl!" href="#Base.LinAlg.LAPACK.trsyl!"><code>Base.LinAlg.LAPACK.trsyl!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">trsyl!(transa, transb, A, B, C, isgn=1) -&gt; (C, scale)</code></pre><p>Solves the Sylvester matrix equation <code>A * X +/- X * B = scale*C</code> where <code>A</code> and <code>B</code> are both quasi-upper triangular. If <code>transa = N</code>, <code>A</code> is not modified. If <code>transa = T</code>, <code>A</code> is transposed. If <code>transa = C</code>, <code>A</code> is conjugate transposed. Similarly for <code>transb</code> and <code>B</code>. If <code>isgn = 1</code>, the equation <code>A * X + X * B = scale * C</code> is solved. If <code>isgn = -1</code>, the equation <code>A * X - X * B = scale * C</code> is solved.</p><p>Returns <code>X</code> (overwriting <code>C</code>) and <code>scale</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/linalg/lapack.jl#L6036-L6047">source</a></section><footer><hr/><a class="previous" href="../parallel/"><span class="direction">Previous</span><span class="title">Tasks and Parallel Computing</span></a><a class="next" href="../constants/"><span class="direction">Next</span><span class="title">Constants</span></a></footer></article></body></html>
