<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Strings · The Julia Language</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-28835595-6', 'auto');
ga('send', 'pageview');
</script><link rel="canonical" href="https://docs.julialang.org/en/stable/base/strings/index.html"/><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../../assets/julia-manual.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../../index.html"><img class="logo" src="../../assets/logo.png" alt="The Julia Language logo"/></a><h1>The Julia Language</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../../manual/getting-started/">Getting Started</a></li><li><a class="toctext" href="../../manual/variables/">Variables</a></li><li><a class="toctext" href="../../manual/integers-and-floating-point-numbers/">Integers and Floating-Point Numbers</a></li><li><a class="toctext" href="../../manual/mathematical-operations/">Mathematical Operations and Elementary Functions</a></li><li><a class="toctext" href="../../manual/complex-and-rational-numbers/">Complex and Rational Numbers</a></li><li><a class="toctext" href="../../manual/strings/">Strings</a></li><li><a class="toctext" href="../../manual/functions/">Functions</a></li><li><a class="toctext" href="../../manual/control-flow/">Control Flow</a></li><li><a class="toctext" href="../../manual/variables-and-scoping/">Scope of Variables</a></li><li><a class="toctext" href="../../manual/types/">Types</a></li><li><a class="toctext" href="../../manual/methods/">Methods</a></li><li><a class="toctext" href="../../manual/constructors/">Constructors</a></li><li><a class="toctext" href="../../manual/conversion-and-promotion/">Conversion and Promotion</a></li><li><a class="toctext" href="../../manual/interfaces/">Interfaces</a></li><li><a class="toctext" href="../../manual/modules/">Modules</a></li><li><a class="toctext" href="../../manual/documentation/">Documentation</a></li><li><a class="toctext" href="../../manual/metaprogramming/">Metaprogramming</a></li><li><a class="toctext" href="../../manual/arrays/">Multi-dimensional Arrays</a></li><li><a class="toctext" href="../../manual/missing/">Missing Values</a></li><li><a class="toctext" href="../../manual/networking-and-streams/">Networking and Streams</a></li><li><a class="toctext" href="../../manual/parallel-computing/">Parallel Computing</a></li><li><a class="toctext" href="../../manual/running-external-programs/">Running External Programs</a></li><li><a class="toctext" href="../../manual/calling-c-and-fortran-code/">Calling C and Fortran Code</a></li><li><a class="toctext" href="../../manual/handling-operating-system-variation/">Handling Operating System Variation</a></li><li><a class="toctext" href="../../manual/environment-variables/">Environment Variables</a></li><li><a class="toctext" href="../../manual/embedding/">Embedding Julia</a></li><li><a class="toctext" href="../../manual/code-loading/">Code Loading</a></li><li><a class="toctext" href="../../manual/profile/">Profiling</a></li><li><a class="toctext" href="../../manual/stacktraces/">Stack Traces</a></li><li><a class="toctext" href="../../manual/performance-tips/">Performance Tips</a></li><li><a class="toctext" href="../../manual/workflow-tips/">Workflow Tips</a></li><li><a class="toctext" href="../../manual/style-guide/">Style Guide</a></li><li><a class="toctext" href="../../manual/faq/">Frequently Asked Questions</a></li><li><a class="toctext" href="../../manual/noteworthy-differences/">Noteworthy Differences from other Languages</a></li><li><a class="toctext" href="../../manual/unicode-input/">Unicode Input</a></li></ul></li><li><span class="toctext">Base</span><ul><li><a class="toctext" href="../base/">Essentials</a></li><li><a class="toctext" href="../collections/">Collections and Data Structures</a></li><li><a class="toctext" href="../math/">Mathematics</a></li><li><a class="toctext" href="../numbers/">Numbers</a></li><li class="current"><a class="toctext" href>Strings</a><ul class="internal"></ul></li><li><a class="toctext" href="../arrays/">Arrays</a></li><li><a class="toctext" href="../parallel/">Tasks</a></li><li><a class="toctext" href="../multi-threading/">Multi-Threading</a></li><li><a class="toctext" href="../constants/">Constants</a></li><li><a class="toctext" href="../file/">Filesystem</a></li><li><a class="toctext" href="../io-network/">I/O and Network</a></li><li><a class="toctext" href="../punctuation/">Punctuation</a></li><li><a class="toctext" href="../sort/">Sorting and Related Functions</a></li><li><a class="toctext" href="../iterators/">Iteration utilities</a></li><li><a class="toctext" href="../c/">C Interface</a></li><li><a class="toctext" href="../libc/">C Standard Library</a></li><li><a class="toctext" href="../stacktraces/">StackTraces</a></li><li><a class="toctext" href="../simd-types/">SIMD Support</a></li></ul></li><li><span class="toctext">Standard Library</span><ul><li><a class="toctext" href="../../stdlib/Base64/">Base64</a></li><li><a class="toctext" href="../../stdlib/CRC32c/">CRC32c</a></li><li><a class="toctext" href="../../stdlib/Dates/">Dates</a></li><li><a class="toctext" href="../../stdlib/DelimitedFiles/">Delimited Files</a></li><li><a class="toctext" href="../../stdlib/Distributed/">Distributed Computing</a></li><li><a class="toctext" href="../../stdlib/FileWatching/">File Events</a></li><li><a class="toctext" href="../../stdlib/InteractiveUtils/">Interactive Utilities</a></li><li><a class="toctext" href="../../stdlib/LibGit2/">LibGit2</a></li><li><a class="toctext" href="../../stdlib/Libdl/">Dynamic Linker</a></li><li><a class="toctext" href="../../stdlib/LinearAlgebra/">Linear Algebra</a></li><li><a class="toctext" href="../../stdlib/Logging/">Logging</a></li><li><a class="toctext" href="../../stdlib/Markdown/">Markdown</a></li><li><a class="toctext" href="../../stdlib/Mmap/">Memory-mapped I/O</a></li><li><a class="toctext" href="../../stdlib/Pkg/">Pkg</a></li><li><a class="toctext" href="../../stdlib/Printf/">Printf</a></li><li><a class="toctext" href="../../stdlib/Profile/">Profiling</a></li><li><a class="toctext" href="../../stdlib/REPL/">The Julia REPL</a></li><li><a class="toctext" href="../../stdlib/Random/">Random Numbers</a></li><li><a class="toctext" href="../../stdlib/SHA/">SHA</a></li><li><a class="toctext" href="../../stdlib/Serialization/">Serialization</a></li><li><a class="toctext" href="../../stdlib/SharedArrays/">Shared Arrays</a></li><li><a class="toctext" href="../../stdlib/Sockets/">Sockets</a></li><li><a class="toctext" href="../../stdlib/SparseArrays/">Sparse Arrays</a></li><li><a class="toctext" href="../../stdlib/Statistics/">Statistics</a></li><li><a class="toctext" href="../../stdlib/Test/">Unit Testing</a></li><li><a class="toctext" href="../../stdlib/UUIDs/">UUIDs</a></li><li><a class="toctext" href="../../stdlib/Unicode/">Unicode</a></li></ul></li><li><span class="toctext">Developer Documentation</span><ul><li><a class="toctext" href="../../devdocs/reflection/">Reflection and introspection</a></li><li><span class="toctext">Documentation of Julia&#39;s Internals</span><ul><li><a class="toctext" href="../../devdocs/init/">Initialization of the Julia runtime</a></li><li><a class="toctext" href="../../devdocs/ast/">Julia ASTs</a></li><li><a class="toctext" href="../../devdocs/types/">More about types</a></li><li><a class="toctext" href="../../devdocs/object/">Memory layout of Julia Objects</a></li><li><a class="toctext" href="../../devdocs/eval/">Eval of Julia code</a></li><li><a class="toctext" href="../../devdocs/callconv/">Calling Conventions</a></li><li><a class="toctext" href="../../devdocs/compiler/">High-level Overview of the Native-Code Generation Process</a></li><li><a class="toctext" href="../../devdocs/functions/">Julia Functions</a></li><li><a class="toctext" href="../../devdocs/cartesian/">Base.Cartesian</a></li><li><a class="toctext" href="../../devdocs/meta/">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="../../devdocs/subarrays/">SubArrays</a></li><li><a class="toctext" href="../../devdocs/sysimg/">System Image Building</a></li><li><a class="toctext" href="../../devdocs/llvm/">Working with LLVM</a></li><li><a class="toctext" href="../../devdocs/stdio/">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="../../devdocs/boundscheck/">Bounds checking</a></li><li><a class="toctext" href="../../devdocs/locks/">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="../../devdocs/offset-arrays/">Arrays with custom indices</a></li><li><a class="toctext" href="../../devdocs/require/">Module loading</a></li><li><a class="toctext" href="../../devdocs/inference/">Inference</a></li></ul></li><li><span class="toctext">Developing/debugging Julia&#39;s C code</span><ul><li><a class="toctext" href="../../devdocs/backtraces/">Reporting and analyzing crashes (segfaults)</a></li><li><a class="toctext" href="../../devdocs/debuggingtips/">gdb debugging tips</a></li><li><a class="toctext" href="../../devdocs/valgrind/">Using Valgrind with Julia</a></li><li><a class="toctext" href="../../devdocs/sanitizers/">Sanitizer support</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Base</li><li><a href>Strings</a></li></ul><a class="edit-page" href="https://github.com/JuliaLang/julia/blob/master/doc/src/base/strings.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Strings</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="lib-strings-1" href="#lib-strings-1">Strings</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Core.AbstractChar" href="#Core.AbstractChar"><code>Core.AbstractChar</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>The <code>AbstractChar</code> type is the supertype of all character implementations in Julia.   A character represents a Unicode code point, and can be converted to an integer via the <a href="#Base.codepoint"><code>codepoint</code></a> function in order to obtain the numerical value of the code point, or constructed from the same integer. These numerical values determine how characters are compared with <code>&lt;</code> and <code>==</code>, for example.  New <code>T &lt;: AbstractChar</code> types should define a <code>codepoint(::T)</code> method and a <code>T(::UInt32)</code> constructor, at minimum.</p><p>A given <code>AbstractChar</code> subtype may be capable of representing only a subset of Unicode, in which case conversion from an unsupported <code>UInt32</code> value may throw an error.  Conversely, the built-in <a href="#Core.Char"><code>Char</code></a> type represents a <em>superset</em> of Unicode (in order to losslessly encode invalid byte streams), in which case conversion of a non-Unicode value <em>to</em> <code>UInt32</code> throws an error. The <a href="#Base.isvalid-Tuple{Any}"><code>isvalid</code></a> function can be used to check which codepoints are representable in a given <code>AbstractChar</code> type.</p><p>Internally, an <code>AbstractChar</code> type may use a variety of encodings.  Conversion via <code>codepoint(char)</code> will not reveal this encoding because it always returns the Unicode value of the character. <code>print(io, c)</code> of any <code>c::AbstractChar</code> produces an encoding determined by <code>io</code> (UTF-8 for all built-in <code>IO</code> types), via conversion to <code>Char</code> if necessary.</p><p><code>write(io, c)</code>, in contrast, may emit an encoding depending on <code>typeof(c)</code>, and <code>read(io, typeof(c))</code> should read the same encoding as <code>write</code>. New <code>AbstractChar</code> types must provide their own implementations of <code>write</code> and <code>read</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/f94ce50398176ec3dae0bb794d6b4de6a4ed834a/base/char.jl#L3-L30">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Core.Char" href="#Core.Char"><code>Core.Char</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Char(c::Union{Number,AbstractChar})</code></pre><p><code>Char</code> is a 32-bit <a href="#Core.AbstractChar"><code>AbstractChar</code></a> type that is the default representation of characters in Julia.  <code>Char</code> is the type used for character literals like <code>&#39;x&#39;</code> and it is also the element type of <a href="#Core.String-Tuple{AbstractString}"><code>String</code></a>.</p><p>In order to losslessly represent arbitrary byte streams stored in a <code>String</code>, a <code>Char</code> value may store information that cannot be converted to a Unicode codepoint — converting such a <code>Char</code> to <code>UInt32</code> will throw an error. The <a href="#Base.isvalid-Tuple{Any}"><code>isvalid(c::Char)</code></a> function can be used to query whether <code>c</code> represents a valid Unicode character.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/f94ce50398176ec3dae0bb794d6b4de6a4ed834a/base/char.jl#L33-L45">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.codepoint" href="#Base.codepoint"><code>Base.codepoint</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">codepoint(c::AbstractChar)</code></pre><p>Return the Unicode codepoint (an unsigned integer) corresponding to the character <code>c</code> (or throw an exception if <code>c</code> does not represent a valid character).   For <code>Char</code>, this is a <code>UInt32</code> value, but <code>AbstractChar</code> types that represent only a subset of Unicode may return a different-sized integer (e.g. <code>UInt8</code>).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/f94ce50398176ec3dae0bb794d6b4de6a4ed834a/base/char.jl#L55-L63">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.length-Tuple{AbstractString}" href="#Base.length-Tuple{AbstractString}"><code>Base.length</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">length(s::AbstractString) -&gt; Int
length(s::AbstractString, i::Integer, j::Integer) -&gt; Int</code></pre><p>The number of characters in string <code>s</code> from indices <code>i</code> through <code>j</code>. This is computed as the number of code unit indices from <code>i</code> to <code>j</code> which are valid character indices. Without only a single string argument, this computes the number of characters in the entire string. With <code>i</code> and <code>j</code> arguments it computes the number of indices between <code>i</code> and <code>j</code> inclusive that are valid indices in the string <code>s</code>. In addition to in-bounds values, <code>i</code> may take the out-of-bounds value <code>ncodeunits(s) + 1</code> and <code>j</code> may take the out-of-bounds value <code>0</code>.</p><p>See also: <a href="#Base.isvalid-Tuple{Any}"><code>isvalid</code></a>, <a href="#Base.ncodeunits-Tuple{AbstractString}"><code>ncodeunits</code></a>, <a href="../collections/#Base.lastindex"><code>lastindex</code></a>, <a href="#Base.thisind"><code>thisind</code></a>, <a href="#Base.nextind"><code>nextind</code></a>, <a href="#Base.prevind"><code>prevind</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; length(&quot;jμΛIα&quot;)
5</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/f94ce50398176ec3dae0bb794d6b4de6a4ed834a/base/strings/basic.jl#L323-L344">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.sizeof-Tuple{AbstractString}" href="#Base.sizeof-Tuple{AbstractString}"><code>Base.sizeof</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">sizeof(str::AbstractString)</code></pre><p>Size, in bytes, of the string <code>s</code>. Equal to the number of code units in <code>s</code> multiplied by the size, in bytes, of one code unit in <code>s</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; sizeof(&quot;&quot;)
0

julia&gt; sizeof(&quot;∀&quot;)
3</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/f94ce50398176ec3dae0bb794d6b4de6a4ed834a/base/strings/basic.jl#L142-L156">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:*-Tuple{Union{AbstractChar, AbstractString},Vararg{Union{AbstractChar, AbstractString},N} where N}" href="#Base.:*-Tuple{Union{AbstractChar, AbstractString},Vararg{Union{AbstractChar, AbstractString},N} where N}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">*(s::Union{AbstractString, AbstractChar}, t::Union{AbstractString, AbstractChar}...) -&gt; AbstractString</code></pre><p>Concatenate strings and/or characters, producing a <a href="#Core.String-Tuple{AbstractString}"><code>String</code></a>. This is equivalent to calling the <a href="#Base.string"><code>string</code></a> function on the arguments. Concatenation of built-in string types always produces a value of type <code>String</code> but other string types may choose to return a string of a different type as appropriate.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; &quot;Hello &quot; * &quot;world&quot;
&quot;Hello world&quot;

julia&gt; &#39;j&#39; * &quot;ulia&quot;
&quot;julia&quot;</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/f94ce50398176ec3dae0bb794d6b4de6a4ed834a/base/strings/basic.jl#L212-L228">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:^-Tuple{AbstractString,Integer}" href="#Base.:^-Tuple{AbstractString,Integer}"><code>Base.:^</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">^(s::Union{AbstractString,AbstractChar}, n::Integer)</code></pre><p>Repeat a string or character <code>n</code> times. This can also be written as <code>repeat(s, n)</code>.</p><p>See also: <a href="../arrays/#Base.repeat"><code>repeat</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; &quot;Test &quot;^3
&quot;Test Test Test &quot;</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/f94ce50398176ec3dae0bb794d6b4de6a4ed834a/base/strings/basic.jl#L661-L673">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.string" href="#Base.string"><code>Base.string</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">string(n::Integer; base::Integer = 10, pad::Integer = 1)</code></pre><p>Convert an integer <code>n</code> to a string in the given <code>base</code>, optionally specifying a number of digits to pad to.</p><pre><code class="language-julia-repl">julia&gt; string(5, base = 13, pad = 4)
&quot;0005&quot;

julia&gt; string(13, base = 5, pad = 4)
&quot;0023&quot;</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/f94ce50398176ec3dae0bb794d6b4de6a4ed834a/base/intfuncs.jl#L644-L657">source</a><div><div><pre><code class="language-none">string(xs...)</code></pre><p>Create a string from any values using the <a href="../io-network/#Base.print"><code>print</code></a> function.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; string(&quot;a&quot;, 1, true)
&quot;a1true&quot;</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/f94ce50398176ec3dae0bb794d6b4de6a4ed834a/base/strings/io.jl#L130-L140">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.repeat-Tuple{AbstractString,Integer}" href="#Base.repeat-Tuple{AbstractString,Integer}"><code>Base.repeat</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">repeat(s::AbstractString, r::Integer)</code></pre><p>Repeat a string <code>r</code> times. This can be written as <code>s^r</code>.</p><p>See also: <a href="#Base.:^-Tuple{AbstractString,Integer}"><code>^</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; repeat(&quot;ha&quot;, 3)
&quot;hahaha&quot;</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/f94ce50398176ec3dae0bb794d6b4de6a4ed834a/base/strings/basic.jl#L646-L658">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.repeat-Tuple{AbstractChar,Integer}" href="#Base.repeat-Tuple{AbstractChar,Integer}"><code>Base.repeat</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">repeat(c::AbstractChar, r::Integer) -&gt; String</code></pre><p>Repeat a character <code>r</code> times. This can equivalently be accomplished by calling <a href="#Base.:^-Tuple{AbstractString,Integer}"><code>c^r</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; repeat(&#39;A&#39;, 3)
&quot;AAA&quot;</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/f94ce50398176ec3dae0bb794d6b4de6a4ed834a/base/strings/string.jl#L348-L358">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.repr-Tuple{Any}" href="#Base.repr-Tuple{Any}"><code>Base.repr</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">repr(x; context=nothing)</code></pre><p>Create a string from any value using the <a href="../io-network/#Base.show-Tuple{Any}"><code>show</code></a> function.</p><p>The optional keyword argument <code>context</code> can be set to an <code>IO</code> or <a href="../io-network/#Base.IOContext"><code>IOContext</code></a> object whose attributes are used for the I/O stream passed to <code>show</code>.</p><p>Note that <code>repr(x)</code> is usually similar to how the value of <code>x</code> would be entered in Julia.  See also <a href="#Base.repr-Tuple{Any}"><code>repr(MIME(&quot;text/plain&quot;), x)</code></a> to instead return a &quot;pretty-printed&quot; version of <code>x</code> designed more for human consumption, equivalent to the REPL display of <code>x</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; repr(1)
&quot;1&quot;

julia&gt; repr(zeros(3))
&quot;[0.0, 0.0, 0.0]&quot;

julia&gt; repr(big(1/3))
&quot;3.33333333333333314829616256247390992939472198486328125e-01&quot;

julia&gt; repr(big(1/3), context=:compact =&gt; true)
&quot;3.33333e-01&quot;
</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/f94ce50398176ec3dae0bb794d6b4de6a4ed834a/base/strings/io.jl#L164-L192">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Core.String-Tuple{AbstractString}" href="#Core.String-Tuple{AbstractString}"><code>Core.String</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">String(s::AbstractString)</code></pre><p>Convert a string to a contiguous byte array representation encoded as UTF-8 bytes. This representation is often appropriate for passing strings to C.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/f94ce50398176ec3dae0bb794d6b4de6a4ed834a/base/strings/string.jl#L62-L67">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.SubString" href="#Base.SubString"><code>Base.SubString</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">SubString(s::AbstractString, i::Integer, j::Integer=lastindex(s))
SubString(s::AbstractString, r::UnitRange{&lt;:Integer})</code></pre><p>Like <a href="../collections/#Base.getindex"><code>getindex</code></a>, but returns a view into the parent string <code>s</code> within range <code>i:j</code> or <code>r</code> respectively instead of making a copy.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; SubString(&quot;abc&quot;, 1, 2)
&quot;ab&quot;

julia&gt; SubString(&quot;abc&quot;, 1:2)
&quot;ab&quot;

julia&gt; SubString(&quot;abc&quot;, 2)
&quot;bc&quot;</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/f94ce50398176ec3dae0bb794d6b4de6a4ed834a/base/strings/substring.jl#L3-L21">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.transcode" href="#Base.transcode"><code>Base.transcode</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">transcode(T, src)</code></pre><p>Convert string data between Unicode encodings. <code>src</code> is either a <code>String</code> or a <code>Vector{UIntXX}</code> of UTF-XX code units, where <code>XX</code> is 8, 16, or 32. <code>T</code> indicates the encoding of the return value: <code>String</code> to return a (UTF-8 encoded) <code>String</code> or <code>UIntXX</code> to return a <code>Vector{UIntXX}</code> of UTF-<code>XX</code> data.   (The alias <code>Cwchar_t</code> can also be used as the integer type, for converting <code>wchar_t*</code> strings used by external C libraries.)</p><p>The <code>transcode</code> function succeeds as long as the input data can be reasonably represented in the target encoding; it always succeeds for conversions between UTF-XX encodings, even for invalid Unicode data.</p><p>Only conversion to/from UTF-8 is currently supported.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/f94ce50398176ec3dae0bb794d6b4de6a4ed834a/base/c.jl#L232-L248">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.unsafe_string" href="#Base.unsafe_string"><code>Base.unsafe_string</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">unsafe_string(p::Ptr{UInt8}, [length::Integer])</code></pre><p>Copy a string from the address of a C-style (NUL-terminated) string encoded as UTF-8. (The pointer can be safely freed afterwards.) If <code>length</code> is specified (the length of the data in bytes), the string does not have to be NUL-terminated.</p><p>This function is labeled &quot;unsafe&quot; because it will crash if <code>p</code> is not a valid memory address to data of the requested length.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/f94ce50398176ec3dae0bb794d6b4de6a4ed834a/base/strings/string.jl#L41-L50">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.ncodeunits-Tuple{AbstractString}" href="#Base.ncodeunits-Tuple{AbstractString}"><code>Base.ncodeunits</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">ncodeunits(s::AbstractString) -&gt; Int</code></pre><p>Return the number of code units in a string. Indices that are in bounds to access this string must satisfy <code>1 ≤ i ≤ ncodeunits(s)</code>. Not all such indices are valid – they may not be the start of a character, but they will return a code unit value when calling <code>codeunit(s,i)</code>.</p><p>See also: <a href="#Base.codeunit"><code>codeunit</code></a>, <a href="../arrays/#Base.checkbounds"><code>checkbounds</code></a>, <a href="#Base.sizeof-Tuple{AbstractString}"><code>sizeof</code></a>, <a href="../collections/#Base.length"><code>length</code></a>, <a href="../collections/#Base.lastindex"><code>lastindex</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/f94ce50398176ec3dae0bb794d6b4de6a4ed834a/base/strings/basic.jl#L45-L55">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.codeunit" href="#Base.codeunit"><code>Base.codeunit</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">codeunit(s::AbstractString) -&gt; Type{&lt;:Union{UInt8, UInt16, UInt32}}</code></pre><p>Return the code unit type of the given string object. For ASCII, Latin-1, or UTF-8 encoded strings, this would be <code>UInt8</code>; for UCS-2 and UTF-16 it would be <code>UInt16</code>; for UTF-32 it would be <code>UInt32</code>. The unit code type need not be limited to these three types, but it&#39;s hard to think of widely used string encodings that don&#39;t use one of these units. <code>codeunit(s)</code> is the same as <code>typeof(codeunit(s,1))</code> when <code>s</code> is a non-empty string.</p><p>See also: <a href="#Base.ncodeunits-Tuple{AbstractString}"><code>ncodeunits</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/f94ce50398176ec3dae0bb794d6b4de6a4ed834a/base/strings/basic.jl#L58-L69">source</a><div><div><pre><code class="language-none">codeunit(s::AbstractString, i::Integer) -&gt; Union{UInt8, UInt16, UInt32}</code></pre><p>Return the code unit value in the string <code>s</code> at index <code>i</code>. Note that</p><pre><code class="language-none">codeunit(s, i) :: codeunit(s)</code></pre><p>I.e. the value returned by <code>codeunit(s, i)</code> is of the type returned by <code>codeunit(s)</code>.</p><p>See also: <a href="#Base.ncodeunits-Tuple{AbstractString}"><code>ncodeunits</code></a>, <a href="../arrays/#Base.checkbounds"><code>checkbounds</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/f94ce50398176ec3dae0bb794d6b4de6a4ed834a/base/strings/basic.jl#L72-L83">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.codeunits" href="#Base.codeunits"><code>Base.codeunits</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">codeunits(s::AbstractString)</code></pre><p>Obtain a vector-like object containing the code units of a string. Returns a <code>CodeUnits</code> wrapper by default, but <code>codeunits</code> may optionally be defined for new string types if necessary.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/f94ce50398176ec3dae0bb794d6b4de6a4ed834a/base/strings/basic.jl#L707-L713">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.ascii" href="#Base.ascii"><code>Base.ascii</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ascii(s::AbstractString)</code></pre><p>Convert a string to <code>String</code> type and check that it contains only ASCII data, otherwise throwing an <code>ArgumentError</code> indicating the position of the first non-ASCII byte.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; ascii(&quot;abcdeγfgh&quot;)
ERROR: ArgumentError: invalid ASCII at index 6 in &quot;abcdeγfgh&quot;
Stacktrace:
[...]

julia&gt; ascii(&quot;abcdefgh&quot;)
&quot;abcdefgh&quot;</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/f94ce50398176ec3dae0bb794d6b4de6a4ed834a/base/strings/util.jl#L636-L652">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.@r_str" href="#Base.@r_str"><code>Base.@r_str</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@r_str -&gt; Regex</code></pre><p>Construct a regex, such as <code>r&quot;^[a-z]*$&quot;</code>, without interpolation and unescaping (except for quotation mark <code>&quot;</code> which still has to be escaped). The regex also accepts one or more flags, listed after the ending quote, to change its behaviour:</p><ul><li><code>i</code> enables case-insensitive matching</li><li><code>m</code> treats the <code>^</code> and <code>$</code> tokens as matching the start and end of individual lines, as opposed to the whole string.</li><li><code>s</code> allows the <code>.</code> modifier to match newlines.</li><li><code>x</code> enables &quot;comment mode&quot;: whitespace is enabled except when escaped with <code>\</code>, and <code>#</code> is treated as starting a comment.</li><li><code>a</code> disables <code>UCP</code> mode (enables ASCII mode). By default <code>\B</code>, <code>\b</code>, <code>\D</code>, <code>\d</code>, <code>\S</code>, <code>\s</code>, <code>\W</code>, <code>\w</code>, etc. match based on Unicode character properties. With this option, these sequences only match ASCII characters.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; match(r&quot;a+.*b+.*?d$&quot;ism, &quot;Goodbye,\nOh, angry,\nBad world\n&quot;)
RegexMatch(&quot;angry,\nBad world&quot;)</code></pre><p>This regex has the first three flags enabled.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/f94ce50398176ec3dae0bb794d6b4de6a4ed834a/base/regex.jl#L67-L90">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.SubstitutionString" href="#Base.SubstitutionString"><code>Base.SubstitutionString</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">SubstitutionString(substr)</code></pre><p>Stores the given string <code>substr</code> as a <code>SubstitutionString</code>, for use in regular expression substitutions. Most commonly constructed using the <a href="#Base.@s_str"><code>@s_str</code></a> macro.</p><pre><code class="language-julia-repl">julia&gt; SubstitutionString(&quot;Hello \\g&lt;name&gt;, it&#39;s \\1&quot;)
s&quot;Hello \\g&lt;name&gt;, it&#39;s \\1&quot;

julia&gt; subst = s&quot;Hello \g&lt;name&gt;, it&#39;s \1&quot;
s&quot;Hello \\g&lt;name&gt;, it&#39;s \\1&quot;

julia&gt; typeof(subst)
SubstitutionString{String}
</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/f94ce50398176ec3dae0bb794d6b4de6a4ed834a/base/regex.jl#L233-L251">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.@s_str" href="#Base.@s_str"><code>Base.@s_str</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@s_str -&gt; SubstitutionString</code></pre><p>Construct a substitution string, used for regular expression substitutions.  Within the string, sequences of the form <code>\N</code> refer to the Nth capture group in the regex, and <code>\g&lt;groupname&gt;</code> refers to a named capture group with name <code>groupname</code>.</p><pre><code class="language-julia-repl">julia&gt; msg = &quot;#Hello# from Julia&quot;;

julia&gt; replace(msg, r&quot;#(.+)# from (?&lt;from&gt;\w+)&quot; =&gt; s&quot;FROM: \g&lt;from&gt;; MESSAGE: \1&quot;)
&quot;FROM: Julia; MESSAGE: Hello&quot;</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/f94ce50398176ec3dae0bb794d6b4de6a4ed834a/base/regex.jl#L267-L280">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.@raw_str" href="#Base.@raw_str"><code>Base.@raw_str</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@raw_str -&gt; String</code></pre><p>Create a raw string without interpolation and unescaping. The exception is that quotation marks still must be escaped. Backslashes escape both quotation marks and other backslashes, but only when a sequence of backslashes precedes a quote character. Thus, 2n backslashes followed by a quote encodes n backslashes and the end of the literal while 2n+1 backslashes followed by a quote encodes n backslashes followed by a quote character.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; println(raw&quot;\ $x&quot;)
\ $x

julia&gt; println(raw&quot;\&quot;&quot;)
&quot;

julia&gt; println(raw&quot;\\\&quot;&quot;)
\&quot;

julia&gt; println(raw&quot;\\x \\\&quot;&quot;)
\\x \&quot;</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/f94ce50398176ec3dae0bb794d6b4de6a4ed834a/base/strings/io.jl#L429-L453">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Docs.@html_str" href="#Base.Docs.@html_str"><code>Base.Docs.@html_str</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@html_str -&gt; Docs.HTML</code></pre><p>Create an <code>HTML</code> object from a literal string.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/f94ce50398176ec3dae0bb794d6b4de6a4ed834a/base/docs/utils.jl#L37-L41">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Docs.@text_str" href="#Base.Docs.@text_str"><code>Base.Docs.@text_str</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@text_str -&gt; Docs.Text</code></pre><p>Create a <code>Text</code> object from a literal string.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/f94ce50398176ec3dae0bb794d6b4de6a4ed834a/base/docs/utils.jl#L78-L82">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isvalid-Tuple{Any}" href="#Base.isvalid-Tuple{Any}"><code>Base.isvalid</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">isvalid(value) -&gt; Bool</code></pre><p>Returns <code>true</code> if the given value is valid for its type, which currently can be either <code>AbstractChar</code> or <code>String</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; isvalid(Char(0xd800))
false

julia&gt; isvalid(Char(0xd799))
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/f94ce50398176ec3dae0bb794d6b4de6a4ed834a/base/strings/unicode.jl#L11-L25">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isvalid-Tuple{Any,Any}" href="#Base.isvalid-Tuple{Any,Any}"><code>Base.isvalid</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">isvalid(T, value) -&gt; Bool</code></pre><p>Returns <code>true</code> if the given value is valid for that type. Types currently can be either <code>AbstractChar</code> or <code>String</code>. Values for <code>AbstractChar</code> can be of type <code>AbstractChar</code> or <a href="../numbers/#Core.UInt32"><code>UInt32</code></a>. Values for <code>String</code> can be of that type, or <code>Vector{UInt8}</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; isvalid(Char, 0xd800)
false

julia&gt; isvalid(Char, 0xd799)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/f94ce50398176ec3dae0bb794d6b4de6a4ed834a/base/strings/unicode.jl#L28-L43">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isvalid-Tuple{AbstractString,Integer}" href="#Base.isvalid-Tuple{AbstractString,Integer}"><code>Base.isvalid</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">isvalid(s::AbstractString, i::Integer) -&gt; Bool</code></pre><p>Predicate indicating whether the given index is the start of the encoding of a character in <code>s</code> or not. If <code>isvalid(s, i)</code> is true then <code>s[i]</code> will return the character whose encoding starts at that index, if it&#39;s false, then <code>s[i]</code> will raise an invalid index error or a bounds error depending on if <code>i</code> is in bounds. In order for <code>isvalid(s, i)</code> to be an O(1) function, the encoding of <code>s</code> must be <a href="https://en.wikipedia.org/wiki/Self-synchronizing_code">self-synchronizing</a> this is a basic assumption of Julia&#39;s generic string support.</p><p>See also: <a href="../collections/#Base.getindex"><code>getindex</code></a>, <a href="../collections/#Base.iterate"><code>iterate</code></a>, <a href="#Base.thisind"><code>thisind</code></a>, <a href="#Base.nextind"><code>nextind</code></a>, <a href="#Base.prevind"><code>prevind</code></a>, <a href="../collections/#Base.length"><code>length</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; str = &quot;αβγdef&quot;;

julia&gt; isvalid(str, 1)
true

julia&gt; str[1]
&#39;α&#39;: Unicode U+03b1 (category Ll: Letter, lowercase)

julia&gt; isvalid(str, 2)
false

julia&gt; str[2]
ERROR: StringIndexError(&quot;αβγdef&quot;, 2)
Stacktrace:
[...]</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/f94ce50398176ec3dae0bb794d6b4de6a4ed834a/base/strings/basic.jl#L87-L120">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.match" href="#Base.match"><code>Base.match</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">match(r::Regex, s::AbstractString[, idx::Integer[, addopts]])</code></pre><p>Search for the first match of the regular expression <code>r</code> in <code>s</code> and return a <code>RegexMatch</code> object containing the match, or nothing if the match failed. The matching substring can be retrieved by accessing <code>m.match</code> and the captured sequences can be retrieved by accessing <code>m.captures</code> The optional <code>idx</code> argument specifies an index at which to start the search.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; rx = r&quot;a(.)a&quot;
r&quot;a(.)a&quot;

julia&gt; m = match(rx, &quot;cabac&quot;)
RegexMatch(&quot;aba&quot;, 1=&quot;b&quot;)

julia&gt; m.captures
1-element Array{Union{Nothing, SubString{String}},1}:
 &quot;b&quot;

julia&gt; m.match
&quot;aba&quot;

julia&gt; match(rx, &quot;cabac&quot;, 3) === nothing
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/f94ce50398176ec3dae0bb794d6b4de6a4ed834a/base/regex.jl#L165-L191">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.eachmatch" href="#Base.eachmatch"><code>Base.eachmatch</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">eachmatch(r::Regex, s::AbstractString; overlap::Bool=false])</code></pre><p>Search for all matches of a the regular expression <code>r</code> in <code>s</code> and return a iterator over the matches. If overlap is <code>true</code>, the matching sequences are allowed to overlap indices in the original string, otherwise they must be from distinct character ranges.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; rx = r&quot;a.a&quot;
r&quot;a.a&quot;

julia&gt; m = eachmatch(rx, &quot;a1a2a3a&quot;)
Base.RegexMatchIterator(r&quot;a.a&quot;, &quot;a1a2a3a&quot;, false)

julia&gt; collect(m)
2-element Array{RegexMatch,1}:
 RegexMatch(&quot;a1a&quot;)
 RegexMatch(&quot;a3a&quot;)

julia&gt; collect(eachmatch(rx, &quot;a1a2a3a&quot;, overlap = true))
3-element Array{RegexMatch,1}:
 RegexMatch(&quot;a1a&quot;)
 RegexMatch(&quot;a2a&quot;)
 RegexMatch(&quot;a3a&quot;)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/f94ce50398176ec3dae0bb794d6b4de6a4ed834a/base/regex.jl#L396-L422">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isless-Tuple{AbstractString,AbstractString}" href="#Base.isless-Tuple{AbstractString,AbstractString}"><code>Base.isless</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">isless(a::AbstractString, b::AbstractString) -&gt; Bool</code></pre><p>Test whether string <code>a</code> comes before string <code>b</code> in alphabetical order (technically, in lexicographical order by Unicode code points).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; isless(&quot;a&quot;, &quot;b&quot;)
true

julia&gt; isless(&quot;β&quot;, &quot;α&quot;)
false

julia&gt; isless(&quot;a&quot;, &quot;a&quot;)
false</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/f94ce50398176ec3dae0bb794d6b4de6a4ed834a/base/strings/basic.jl#L295-L312">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:==-Tuple{AbstractString,AbstractString}" href="#Base.:==-Tuple{AbstractString,AbstractString}"><code>Base.:==</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">==(a::AbstractString, b::AbstractString) -&gt; Bool</code></pre><p>Test whether two strings are equal character by character (technically, Unicode code point by code point).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; &quot;abc&quot; == &quot;abc&quot;
true

julia&gt; &quot;abc&quot; == &quot;αβγ&quot;
false</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/f94ce50398176ec3dae0bb794d6b4de6a4ed834a/base/strings/basic.jl#L278-L292">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.cmp-Tuple{AbstractString,AbstractString}" href="#Base.cmp-Tuple{AbstractString,AbstractString}"><code>Base.cmp</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">cmp(a::AbstractString, b::AbstractString) -&gt; Int</code></pre><p>Compare two strings. Return <code>0</code> if both strings have the same length and the character at each index is the same in both strings. Return <code>-1</code> if <code>a</code> is a prefix of <code>b</code>, or if <code>a</code> comes before <code>b</code> in alphabetical order. Return <code>1</code> if <code>b</code> is a prefix of <code>a</code>, or if <code>b</code> comes before <code>a</code> in alphabetical order (technically, lexicographical order by Unicode code points).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; cmp(&quot;abc&quot;, &quot;abc&quot;)
0

julia&gt; cmp(&quot;ab&quot;, &quot;abc&quot;)
-1

julia&gt; cmp(&quot;abc&quot;, &quot;ab&quot;)
1

julia&gt; cmp(&quot;ab&quot;, &quot;ac&quot;)
-1

julia&gt; cmp(&quot;ac&quot;, &quot;ab&quot;)
1

julia&gt; cmp(&quot;α&quot;, &quot;a&quot;)
1

julia&gt; cmp(&quot;b&quot;, &quot;β&quot;)
-1</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/f94ce50398176ec3dae0bb794d6b4de6a4ed834a/base/strings/basic.jl#L235-L267">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.lpad" href="#Base.lpad"><code>Base.lpad</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">lpad(s, n::Integer, p::Union{AbstractChar,AbstractString}=&#39; &#39;) -&gt; String</code></pre><p>Stringify <code>s</code> and pad the resulting string on the left with <code>p</code> to make it <code>n</code> characters (code points) long. If <code>s</code> is already <code>n</code> characters long, an equal string is returned. Pad with spaces by default.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; lpad(&quot;March&quot;, 10)
&quot;     March&quot;</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/f94ce50398176ec3dae0bb794d6b4de6a4ed834a/base/strings/util.jl#L222-L234">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.rpad" href="#Base.rpad"><code>Base.rpad</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">rpad(s, n::Integer, p::Union{AbstractChar,AbstractString}=&#39; &#39;) -&gt; String</code></pre><p>Stringify <code>s</code> and pad the resulting string on the right with <code>p</code> to make it <code>n</code> characters (code points) long. If <code>s</code> is already <code>n</code> characters long, an equal string is returned. Pad with spaces by default.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; rpad(&quot;March&quot;, 20)
&quot;March               &quot;</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/f94ce50398176ec3dae0bb794d6b4de6a4ed834a/base/strings/util.jl#L249-L261">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.findfirst-Tuple{AbstractString,AbstractString}" href="#Base.findfirst-Tuple{AbstractString,AbstractString}"><code>Base.findfirst</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">findfirst(pattern::AbstractString, string::AbstractString)
findfirst(pattern::Regex, string::String)</code></pre><p>Find the first occurrence of <code>pattern</code> in <code>string</code>. Equivalent to <a href="#Base.findnext-Tuple{AbstractString,AbstractString,Integer}"><code>findnext(pattern, string, firstindex(s))</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; findfirst(&quot;z&quot;, &quot;Hello to the world&quot;) # returns nothing, but not printed in the REPL

julia&gt; findfirst(&quot;Julia&quot;, &quot;JuliaLang&quot;)
1:5</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/f94ce50398176ec3dae0bb794d6b4de6a4ed834a/base/strings/search.jl#L89-L103">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.findnext-Tuple{AbstractString,AbstractString,Integer}" href="#Base.findnext-Tuple{AbstractString,AbstractString,Integer}"><code>Base.findnext</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">findnext(pattern::AbstractString, string::AbstractString, start::Integer)
findnext(pattern::Regex, string::String, start::Integer)</code></pre><p>Find the next occurrence of <code>pattern</code> in <code>string</code> starting at position <code>start</code>. <code>pattern</code> can be either a string, or a regular expression, in which case <code>string</code> must be of type <code>String</code>.</p><p>The return value is a range of indices where the matching sequence is found, such that <code>s[findnext(x, s, i)] == x</code>:</p><p><code>findnext(&quot;substring&quot;, string, i)</code> = <code>start:end</code> such that <code>string[start:end] == &quot;substring&quot;</code>, or <code>nothing</code> if unmatched.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; findnext(&quot;z&quot;, &quot;Hello to the world&quot;, 1) === nothing
true

julia&gt; findnext(&quot;o&quot;, &quot;Hello to the world&quot;, 6)
8:8

julia&gt; findnext(&quot;Lang&quot;, &quot;JuliaLang&quot;, 2)
6:9</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/f94ce50398176ec3dae0bb794d6b4de6a4ed834a/base/strings/search.jl#L230-L255">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.findlast-Tuple{AbstractString,AbstractString}" href="#Base.findlast-Tuple{AbstractString,AbstractString}"><code>Base.findlast</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">findlast(pattern::AbstractString, string::AbstractString)
findlast(pattern::Regex, string::String)</code></pre><p>Find the last occurrence of <code>pattern</code> in <code>string</code>. Equivalent to <a href="#Base.findlast-Tuple{AbstractString,AbstractString}"><code>findlast(pattern, string, lastindex(s))</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; findlast(&quot;o&quot;, &quot;Hello to the world&quot;)
15:15

julia&gt; findfirst(&quot;Julia&quot;, &quot;JuliaLang&quot;)
1:5</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/f94ce50398176ec3dae0bb794d6b4de6a4ed834a/base/strings/search.jl#L258-L273">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.findprev-Tuple{AbstractString,AbstractString,Integer}" href="#Base.findprev-Tuple{AbstractString,AbstractString,Integer}"><code>Base.findprev</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">findprev(pattern::AbstractString, string::AbstractString, start::Integer)
findprev(pattern::Regex, string::String, start::Integer)</code></pre><p>Find the previous occurrence of <code>pattern</code> in <code>string</code> starting at position <code>start</code>. <code>pattern</code> can be either a string, or a regular expression, in which case <code>string</code> must be of type <code>String</code>.</p><p>The return value is a range of indices where the matching sequence is found, such that <code>s[findprev(x, s, i)] == x</code>:</p><p><code>findprev(&quot;substring&quot;, string, i)</code> = <code>start:end</code> such that <code>string[start:end] == &quot;substring&quot;</code>, or <code>nothing</code> if unmatched.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; findprev(&quot;z&quot;, &quot;Hello to the world&quot;, 18) === nothing
true

julia&gt; findprev(&quot;o&quot;, &quot;Hello to the world&quot;, 18)
15:15

julia&gt; findprev(&quot;Julia&quot;, &quot;JuliaLang&quot;, 6)
1:5</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/f94ce50398176ec3dae0bb794d6b4de6a4ed834a/base/strings/search.jl#L407-L432">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.occursin" href="#Base.occursin"><code>Base.occursin</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">occursin(needle::Union{AbstractString,Regex,AbstractChar}, haystack::AbstractString)</code></pre><p>Determine whether the first argument is a substring of the second. If <code>needle</code> is a regular expression, checks whether <code>haystack</code> contains a match.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; occursin(&quot;Julia&quot;, &quot;JuliaLang is pretty cool!&quot;)
true

julia&gt; occursin(&#39;a&#39;, &quot;JuliaLang is pretty cool!&quot;)
true

julia&gt; occursin(r&quot;a.a&quot;, &quot;aba&quot;)
true

julia&gt; occursin(r&quot;a.a&quot;, &quot;abba&quot;)
false</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/f94ce50398176ec3dae0bb794d6b4de6a4ed834a/base/strings/search.jl#L435-L455">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.reverse-Tuple{Union{SubString{String}, String}}" href="#Base.reverse-Tuple{Union{SubString{String}, String}}"><code>Base.reverse</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">reverse(s::AbstractString) -&gt; AbstractString</code></pre><p>Reverses a string. Technically, this function reverses the codepoints in a string and its main utility is for reversed-order string processing, especially for reversed regular-expression searches. See also <a href="../arrays/#Base.reverseind"><code>reverseind</code></a> to convert indices in <code>s</code> to indices in <code>reverse(s)</code> and vice-versa, and <code>graphemes</code> from module <code>Unicode</code> to operate on user-visible &quot;characters&quot; (graphemes) rather than codepoints. See also <a href="../iterators/#Base.Iterators.reverse"><code>Iterators.reverse</code></a> for reverse-order iteration without making a copy. Custom string types must implement the <code>reverse</code> function themselves and should typically return a string with the same type and encoding. If they return a string with a different encoding, they must also override <code>reverseind</code> for that string type to satisfy <code>s[reverseind(s,i)] == reverse(s)[i]</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; reverse(&quot;JuliaLang&quot;)
&quot;gnaLailuJ&quot;

julia&gt; reverse(&quot;ax̂e&quot;) # combining characters can lead to surprising results
&quot;êxa&quot;

julia&gt; using Unicode

julia&gt; join(reverse(collect(graphemes(&quot;ax̂e&quot;)))) # reverses graphemes
&quot;ex̂a&quot;</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/f94ce50398176ec3dae0bb794d6b4de6a4ed834a/base/strings/substring.jl#L107-L134">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.replace-Tuple{AbstractString,Pair}" href="#Base.replace-Tuple{AbstractString,Pair}"><code>Base.replace</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">replace(s::AbstractString, pat=&gt;r; [count::Integer])</code></pre><p>Search for the given pattern <code>pat</code> in <code>s</code>, and replace each occurrence with <code>r</code>. If <code>count</code> is provided, replace at most <code>count</code> occurrences. <code>pat</code> may be a single character, a vector or a set of characters, a string, or a regular expression. If <code>r</code> is a function, each occurrence is replaced with <code>r(s)</code> where <code>s</code> is the matched substring (when <code>pat</code>is a <code>Regex</code> or <code>AbstractString</code>) or character (when <code>pat</code> is an <code>AbstractChar</code> or a collection of <code>AbstractChar</code>). If <code>pat</code> is a regular expression and <code>r</code> is a <a href="#Base.SubstitutionString"><code>SubstitutionString</code></a>, then capture group references in <code>r</code> are replaced with the corresponding matched text. To remove instances of <code>pat</code> from <code>string</code>, set <code>r</code> to the empty <code>String</code> (<code>&quot;&quot;</code>).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; replace(&quot;Python is a programming language.&quot;, &quot;Python&quot; =&gt; &quot;Julia&quot;)
&quot;Julia is a programming language.&quot;

julia&gt; replace(&quot;The quick foxes run quickly.&quot;, &quot;quick&quot; =&gt; &quot;slow&quot;, count=1)
&quot;The slow foxes run quickly.&quot;

julia&gt; replace(&quot;The quick foxes run quickly.&quot;, &quot;quick&quot; =&gt; &quot;&quot;, count=1)
&quot;The  foxes run quickly.&quot;

julia&gt; replace(&quot;The quick foxes run quickly.&quot;, r&quot;fox(es)?&quot; =&gt; s&quot;bus\1&quot;)
&quot;The quick buses run quickly.&quot;</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/f94ce50398176ec3dae0bb794d6b4de6a4ed834a/base/strings/util.jl#L480-L508">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.split" href="#Base.split"><code>Base.split</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">split(str::AbstractString, dlm; limit::Integer=0, keepempty::Bool=true)
split(str::AbstractString; limit::Integer=0, keepempty::Bool=false)</code></pre><p>Split <code>str</code> into an array of substrings on occurrences of the delimiter(s) <code>dlm</code>.  <code>dlm</code> can be any of the formats allowed by <a href="#Base.findnext-Tuple{AbstractString,AbstractString,Integer}"><code>findnext</code></a>&#39;s first argument (i.e. as a string, regular expression or a function), or as a single character or collection of characters.</p><p>If <code>dlm</code> is omitted, it defaults to <a href="#Base.Unicode.isspace"><code>isspace</code></a>.</p><p>The optional keyword arguments are:</p><ul><li><code>limit</code>: the maximum size of the result. <code>limit=0</code> implies no maximum (default)</li><li><code>keepempty</code>: whether empty fields should be kept in the result. Default is <code>false</code> without a <code>dlm</code> argument, <code>true</code> with a <code>dlm</code> argument.</li></ul><p>See also <a href="#Base.rsplit"><code>rsplit</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = &quot;Ma.rch&quot;
&quot;Ma.rch&quot;

julia&gt; split(a,&quot;.&quot;)
2-element Array{SubString{String},1}:
 &quot;Ma&quot;
 &quot;rch&quot;</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/f94ce50398176ec3dae0bb794d6b4de6a4ed834a/base/strings/util.jl#L276-L304">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.rsplit" href="#Base.rsplit"><code>Base.rsplit</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">rsplit(s::AbstractString; limit::Integer=0, keepempty::Bool=false)
rsplit(s::AbstractString, chars; limit::Integer=0, keepempty::Bool=true)</code></pre><p>Similar to <a href="#Base.split"><code>split</code></a>, but starting from the end of the string.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = &quot;M.a.r.c.h&quot;
&quot;M.a.r.c.h&quot;

julia&gt; rsplit(a,&quot;.&quot;)
5-element Array{SubString{String},1}:
 &quot;M&quot;
 &quot;a&quot;
 &quot;r&quot;
 &quot;c&quot;
 &quot;h&quot;

julia&gt; rsplit(a,&quot;.&quot;;limit=1)
1-element Array{SubString{String},1}:
 &quot;M.a.r.c.h&quot;

julia&gt; rsplit(a,&quot;.&quot;;limit=2)
2-element Array{SubString{String},1}:
 &quot;M.a.r.c&quot;
 &quot;h&quot;</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/f94ce50398176ec3dae0bb794d6b4de6a4ed834a/base/strings/util.jl#L362-L390">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.strip" href="#Base.strip"><code>Base.strip</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">strip(str::AbstractString, [chars])</code></pre><p>Remove leading and trailing characters from <code>str</code>.</p><p>The default behaviour is to remove leading whitespace and delimiters: see <a href="#Base.Unicode.isspace"><code>isspace</code></a> for precise details.</p><p>The optional <code>chars</code> argument specifies which characters to remove: it can be a single character, vector or set of characters, or a predicate function.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; strip(&quot;{3, 5}\n&quot;, [&#39;{&#39;, &#39;}&#39;, &#39;\n&#39;])
&quot;3, 5&quot;</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/f94ce50398176ec3dae0bb794d6b4de6a4ed834a/base/strings/util.jl#L200-L216">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.lstrip" href="#Base.lstrip"><code>Base.lstrip</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">lstrip([pred=isspace,] str::AbstractString)
lstrip(str::AbstractString, chars)</code></pre><p>Remove leading characters from <code>str</code>, either those specified by <code>chars</code> or those for which the function <code>pred</code> returns <code>true</code>.</p><p>The default behaviour is to remove leading whitespace and delimiters: see <a href="#Base.Unicode.isspace"><code>isspace</code></a> for precise details.</p><p>The optional <code>chars</code> argument specifies which characters to remove: it can be a single character, or a vector or set of characters.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = lpad(&quot;March&quot;, 20)
&quot;               March&quot;

julia&gt; lstrip(a)
&quot;March&quot;</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/f94ce50398176ec3dae0bb794d6b4de6a4ed834a/base/strings/util.jl#L137-L158">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.rstrip" href="#Base.rstrip"><code>Base.rstrip</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">rstrip([pred=isspace,] str::AbstractString)
rstrip(str::AbstractString, chars)</code></pre><p>Remove trailing characters from <code>str</code>, either those specified by <code>chars</code> or those for which the function <code>pred</code> returns <code>true</code>.</p><p>The default behaviour is to remove leading whitespace and delimiters: see <a href="#Base.Unicode.isspace"><code>isspace</code></a> for precise details.</p><p>The optional <code>chars</code> argument specifies which characters to remove: it can be a single character, or a vector or set of characters.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = rpad(&quot;March&quot;, 20)
&quot;March               &quot;

julia&gt; rstrip(a)
&quot;March&quot;</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/f94ce50398176ec3dae0bb794d6b4de6a4ed834a/base/strings/util.jl#L169-L190">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.startswith" href="#Base.startswith"><code>Base.startswith</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">startswith(s::AbstractString, prefix::AbstractString)</code></pre><p>Returns <code>true</code> if <code>s</code> starts with <code>prefix</code>. If <code>prefix</code> is a vector or set of characters, tests whether the first character of <code>s</code> belongs to that set.</p><p>See also <a href="#Base.endswith"><code>endswith</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; startswith(&quot;JuliaLang&quot;, &quot;Julia&quot;)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/f94ce50398176ec3dae0bb794d6b4de6a4ed834a/base/strings/util.jl#L7-L20">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.endswith" href="#Base.endswith"><code>Base.endswith</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">endswith(s::AbstractString, suffix::AbstractString)</code></pre><p>Returns <code>true</code> if <code>s</code> ends with <code>suffix</code>. If <code>suffix</code> is a vector or set of characters, tests whether the last character of <code>s</code> belongs to that set.</p><p>See also <a href="#Base.startswith"><code>startswith</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; endswith(&quot;Sunday&quot;, &quot;day&quot;)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/f94ce50398176ec3dae0bb794d6b4de6a4ed834a/base/strings/util.jl#L27-L40">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.first-Tuple{AbstractString,Integer}" href="#Base.first-Tuple{AbstractString,Integer}"><code>Base.first</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">first(s::AbstractString, n::Integer)</code></pre><p>Get a string consisting of the first <code>n</code> characters of <code>s</code>.</p><pre><code class="language-julia-repl">julia&gt; first(&quot;∀ϵ≠0: ϵ²&gt;0&quot;, 0)
&quot;&quot;

julia&gt; first(&quot;∀ϵ≠0: ϵ²&gt;0&quot;, 1)
&quot;∀&quot;

julia&gt; first(&quot;∀ϵ≠0: ϵ²&gt;0&quot;, 3)
&quot;∀ϵ≠&quot;</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/f94ce50398176ec3dae0bb794d6b4de6a4ed834a/base/strings/basic.jl#L590-L605">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.last-Tuple{AbstractString,Integer}" href="#Base.last-Tuple{AbstractString,Integer}"><code>Base.last</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">last(s::AbstractString, n::Integer)</code></pre><p>Get a string consisting of the last <code>n</code> characters of <code>s</code>.</p><pre><code class="language-julia-repl">julia&gt; last(&quot;∀ϵ≠0: ϵ²&gt;0&quot;, 0)
&quot;&quot;

julia&gt; last(&quot;∀ϵ≠0: ϵ²&gt;0&quot;, 1)
&quot;0&quot;

julia&gt; last(&quot;∀ϵ≠0: ϵ²&gt;0&quot;, 3)
&quot;²&gt;0&quot;</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/f94ce50398176ec3dae0bb794d6b4de6a4ed834a/base/strings/basic.jl#L608-L623">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Unicode.uppercase" href="#Base.Unicode.uppercase"><code>Base.Unicode.uppercase</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">uppercase(s::AbstractString)</code></pre><p>Return <code>s</code> with all characters converted to uppercase.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; uppercase(&quot;Julia&quot;)
&quot;JULIA&quot;</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/f94ce50398176ec3dae0bb794d6b4de6a4ed834a/base/strings/unicode.jl#L501-L511">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Unicode.lowercase" href="#Base.Unicode.lowercase"><code>Base.Unicode.lowercase</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">lowercase(s::AbstractString)</code></pre><p>Return <code>s</code> with all characters converted to lowercase.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; lowercase(&quot;STRINGS AND THINGS&quot;)
&quot;strings and things&quot;</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/f94ce50398176ec3dae0bb794d6b4de6a4ed834a/base/strings/unicode.jl#L514-L524">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Unicode.titlecase" href="#Base.Unicode.titlecase"><code>Base.Unicode.titlecase</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">titlecase(s::AbstractString; [wordsep::Function], strict::Bool=true) -&gt; String</code></pre><p>Capitalize the first character of each word in <code>s</code>; if <code>strict</code> is true, every other character is converted to lowercase, otherwise they are left unchanged. By default, all non-letters are considered as word separators; a predicate can be passed as the <code>wordsep</code> keyword to determine which characters should be considered as word separators. See also <a href="#Base.Unicode.uppercasefirst"><code>uppercasefirst</code></a> to capitalize only the first character in <code>s</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; titlecase(&quot;the JULIA programming language&quot;)
&quot;The Julia Programming Language&quot;

julia&gt; titlecase(&quot;ISS - international space station&quot;, strict=false)
&quot;ISS - International Space Station&quot;

julia&gt; titlecase(&quot;a-a b-b&quot;, wordsep = c-&gt;c==&#39; &#39;)
&quot;A-a B-b&quot;</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/f94ce50398176ec3dae0bb794d6b4de6a4ed834a/base/strings/unicode.jl#L527-L550">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Unicode.uppercasefirst" href="#Base.Unicode.uppercasefirst"><code>Base.Unicode.uppercasefirst</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">uppercasefirst(s::AbstractString) -&gt; String</code></pre><p>Return <code>s</code> with the first character converted to uppercase (technically &quot;title case&quot; for Unicode). See also <a href="#Base.Unicode.titlecase"><code>titlecase</code></a> to capitalize the first character of every word in <code>s</code>.</p><p>See also: <a href="#Base.Unicode.lowercasefirst"><code>lowercasefirst</code></a>, <a href="#Base.Unicode.uppercase"><code>uppercase</code></a>, <a href="#Base.Unicode.lowercase"><code>lowercase</code></a>, <a href="#Base.Unicode.titlecase"><code>titlecase</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; uppercasefirst(&quot;python&quot;)
&quot;Python&quot;</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/f94ce50398176ec3dae0bb794d6b4de6a4ed834a/base/strings/unicode.jl#L566-L581">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Unicode.lowercasefirst" href="#Base.Unicode.lowercasefirst"><code>Base.Unicode.lowercasefirst</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">lowercasefirst(s::AbstractString)</code></pre><p>Return <code>s</code> with the first character converted to lowercase.</p><p>See also: <a href="#Base.Unicode.uppercasefirst"><code>uppercasefirst</code></a>, <a href="#Base.Unicode.uppercase"><code>uppercase</code></a>, <a href="#Base.Unicode.lowercase"><code>lowercase</code></a>, <a href="#Base.Unicode.titlecase"><code>titlecase</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; lowercasefirst(&quot;Julia&quot;)
&quot;julia&quot;</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/f94ce50398176ec3dae0bb794d6b4de6a4ed834a/base/strings/unicode.jl#L590-L603">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.join" href="#Base.join"><code>Base.join</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">join([io::IO,] strings, delim, [last])</code></pre><p>Join an array of <code>strings</code> into a single string, inserting the given delimiter between adjacent strings. If <code>last</code> is given, it will be used instead of <code>delim</code> between the last two strings. If <code>io</code> is given, the result is written to <code>io</code> rather than returned as as a <code>String</code>.  For example,</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; join([&quot;apples&quot;, &quot;bananas&quot;, &quot;pineapples&quot;], &quot;, &quot;, &quot; and &quot;)
&quot;apples, bananas and pineapples&quot;</code></pre><p><code>strings</code> can be any iterable over elements <code>x</code> which are convertible to strings via <code>print(io::IOBuffer, x)</code>. <code>strings</code> will be printed to <code>io</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/f94ce50398176ec3dae0bb794d6b4de6a4ed834a/base/strings/io.jl#L218-L234">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.chop" href="#Base.chop"><code>Base.chop</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">chop(s::AbstractString; head::Integer = 0, tail::Integer = 1)</code></pre><p>Remove the first <code>head</code> and the last <code>tail</code> characters from <code>s</code>. The call <code>chop(s)</code> removes the last character from <code>s</code>. If it is requested to remove more characters than <code>length(s)</code> then an empty string is returned.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = &quot;March&quot;
&quot;March&quot;

julia&gt; chop(a)
&quot;Marc&quot;

julia&gt; chop(a, head = 1, tail = 2)
&quot;ar&quot;

julia&gt; chop(a, head = 5, tail = 5)
&quot;&quot;</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/f94ce50398176ec3dae0bb794d6b4de6a4ed834a/base/strings/util.jl#L78-L100">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.chomp" href="#Base.chomp"><code>Base.chomp</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">chomp(s::AbstractString)</code></pre><p>Remove a single trailing newline from a string.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; chomp(&quot;Hello\n&quot;)
&quot;Hello&quot;</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/f94ce50398176ec3dae0bb794d6b4de6a4ed834a/base/strings/util.jl#L108-L118">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.thisind" href="#Base.thisind"><code>Base.thisind</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">thisind(s::AbstractString, i::Integer) -&gt; Int</code></pre><p>If <code>i</code> is in bounds in <code>s</code> return the index of the start of the character whose encoding code unit <code>i</code> is part of. In other words, if <code>i</code> is the start of a character, return <code>i</code>; if <code>i</code> is not the start of a character, rewind until the start of a character and return that index. If <code>i</code> is equal to 0 or <code>ncodeunits(s)+1</code> return <code>i</code>. In all other cases throw <code>BoundsError</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; thisind(&quot;α&quot;, 0)
0

julia&gt; thisind(&quot;α&quot;, 1)
1

julia&gt; thisind(&quot;α&quot;, 2)
1

julia&gt; thisind(&quot;α&quot;, 3)
3

julia&gt; thisind(&quot;α&quot;, 4)
ERROR: BoundsError: attempt to access &quot;α&quot;
  at index [4]
[...]

julia&gt; thisind(&quot;α&quot;, -1)
ERROR: BoundsError: attempt to access &quot;α&quot;
  at index [-1]
[...]</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/f94ce50398176ec3dae0bb794d6b4de6a4ed834a/base/strings/basic.jl#L362-L395">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.nextind" href="#Base.nextind"><code>Base.nextind</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">nextind(str::AbstractString, i::Integer, n::Integer=1) -&gt; Int</code></pre><ul><li><p>Case <code>n == 1</code></p><p>If <code>i</code> is in bounds in <code>s</code> return the index of the start of the character whose encoding starts after index <code>i</code>. In other words, if <code>i</code> is the start of a character, return the start of the next character; if <code>i</code> is not the start of a character, move forward until the start of a character and return that index. If <code>i</code> is equal to <code>0</code> return <code>1</code>. If <code>i</code> is in bounds but greater or equal to <code>lastindex(str)</code> return <code>ncodeunits(str)+1</code>. Otherwise throw <code>BoundsError</code>.</p></li><li><p>Case <code>n &gt; 1</code></p><p>Behaves like applying <code>n</code> times <code>nextind</code> for <code>n==1</code>. The only difference is that if <code>n</code> is so large that applying <code>nextind</code> would reach <code>ncodeunits(str)+1</code> then each remaining iteration increases the returned value by <code>1</code>. This means that in this case <code>nextind</code> can return a value greater than <code>ncodeunits(str)+1</code>.</p></li><li><p>Case <code>n == 0</code></p><p>Return <code>i</code> only if <code>i</code> is a valid index in <code>s</code> or is equal to <code>0</code>. Otherwise <code>StringIndexError</code> or <code>BoundsError</code> is thrown.</p></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; nextind(&quot;α&quot;, 0)
1

julia&gt; nextind(&quot;α&quot;, 1)
3

julia&gt; nextind(&quot;α&quot;, 3)
ERROR: BoundsError: attempt to access &quot;α&quot;
  at index [3]
[...]

julia&gt; nextind(&quot;α&quot;, 0, 2)
3

julia&gt; nextind(&quot;α&quot;, 1, 2)
4</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/f94ce50398176ec3dae0bb794d6b4de6a4ed834a/base/strings/basic.jl#L468-L512">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.prevind" href="#Base.prevind"><code>Base.prevind</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">prevind(str::AbstractString, i::Integer, n::Integer=1) -&gt; Int</code></pre><ul><li><p>Case <code>n == 1</code></p><p>If <code>i</code> is in bounds in <code>s</code> return the index of the start of the character whose encoding starts before index <code>i</code>. In other words, if <code>i</code> is the start of a character, return the start of the previous character; if <code>i</code> is not the start of a character, rewind until the start of a character and return that index. If <code>i</code> is equal to <code>1</code> return <code>0</code>. If <code>i</code> is equal to <code>ncodeunits(str)+1</code> return <code>lastindex(str)</code>. Otherwise throw <code>BoundsError</code>.</p></li><li><p>Case <code>n &gt; 1</code></p><p>Behaves like applying <code>n</code> times <code>prevind</code> for <code>n==1</code>. The only difference is that if <code>n</code> is so large that applying <code>prevind</code> would reach <code>0</code> then each remaining iteration decreases the returned value by <code>1</code>. This means that in this case <code>prevind</code> can return a negative value.</p></li><li><p>Case <code>n == 0</code></p><p>Return <code>i</code> only if <code>i</code> is a valid index in <code>str</code> or is equal to <code>ncodeunits(str)+1</code>. Otherwise <code>StringIndexError</code> or <code>BoundsError</code> is thrown.</p></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; prevind(&quot;α&quot;, 3)
1

julia&gt; prevind(&quot;α&quot;, 1)
0

julia&gt; prevind(&quot;α&quot;, 0)
ERROR: BoundsError: attempt to access &quot;α&quot;
  at index [0]
[...]

julia&gt; prevind(&quot;α&quot;, 2, 2)
0

julia&gt; prevind(&quot;α&quot;, 2, 3)
-1</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/f94ce50398176ec3dae0bb794d6b4de6a4ed834a/base/strings/basic.jl#L408-L452">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Unicode.textwidth" href="#Base.Unicode.textwidth"><code>Base.Unicode.textwidth</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">textwidth(c)</code></pre><p>Give the number of columns needed to print a character.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; textwidth(&#39;α&#39;)
1

julia&gt; textwidth(&#39;❤&#39;)
2</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/f94ce50398176ec3dae0bb794d6b4de6a4ed834a/base/strings/unicode.jl#L207-L220">source</a><div><div><pre><code class="language-none">textwidth(s::AbstractString)</code></pre><p>Give the number of columns needed to print a string.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; textwidth(&quot;March&quot;)
5</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/f94ce50398176ec3dae0bb794d6b4de6a4ed834a/base/strings/unicode.jl#L226-L236">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isascii" href="#Base.isascii"><code>Base.isascii</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">isascii(c::Union{AbstractChar,AbstractString}) -&gt; Bool</code></pre><p>Test whether a character belongs to the ASCII character set, or whether this is true for all elements of a string.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; isascii(&#39;a&#39;)
true

julia&gt; isascii(&#39;α&#39;)
false

julia&gt; isascii(&quot;abc&quot;)
true

julia&gt; isascii(&quot;αβγ&quot;)
false</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/f94ce50398176ec3dae0bb794d6b4de6a4ed834a/base/strings/basic.jl#L541-L561">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Unicode.iscntrl" href="#Base.Unicode.iscntrl"><code>Base.Unicode.iscntrl</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">iscntrl(c::AbstractChar) -&gt; Bool</code></pre><p>Tests whether a character is a control character. Control characters are the non-printing characters of the Latin-1 subset of Unicode.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; iscntrl(&#39;\x01&#39;)
true

julia&gt; iscntrl(&#39;a&#39;)
false</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/f94ce50398176ec3dae0bb794d6b4de6a4ed834a/base/strings/unicode.jl#L399-L413">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Unicode.isdigit" href="#Base.Unicode.isdigit"><code>Base.Unicode.isdigit</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">isdigit(c::AbstractChar) -&gt; Bool</code></pre><p>Tests whether a character is a decimal digit (0-9).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; isdigit(&#39;❤&#39;)
false

julia&gt; isdigit(&#39;9&#39;)
true

julia&gt; isdigit(&#39;α&#39;)
false</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/f94ce50398176ec3dae0bb794d6b4de6a4ed834a/base/strings/unicode.jl#L330-L346">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Unicode.isletter" href="#Base.Unicode.isletter"><code>Base.Unicode.isletter</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">isletter(c::AbstractChar) -&gt; Bool</code></pre><p>Test whether a character is a letter. A character is classified as a letter if it belongs to the Unicode general category Letter, i.e. a character whose category code begins with &#39;L&#39;.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; isletter(&#39;❤&#39;)
false

julia&gt; isletter(&#39;α&#39;)
true

julia&gt; isletter(&#39;9&#39;)
false</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/f94ce50398176ec3dae0bb794d6b4de6a4ed834a/base/strings/unicode.jl#L349-L367">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Unicode.islowercase" href="#Base.Unicode.islowercase"><code>Base.Unicode.islowercase</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">islowercase(c::AbstractChar) -&gt; Bool</code></pre><p>Tests whether a character is a lowercase letter. A character is classified as lowercase if it belongs to Unicode category Ll, Letter: Lowercase.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; islowercase(&#39;α&#39;)
true

julia&gt; islowercase(&#39;Γ&#39;)
false

julia&gt; islowercase(&#39;❤&#39;)
false</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/f94ce50398176ec3dae0bb794d6b4de6a4ed834a/base/strings/unicode.jl#L270-L288">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Unicode.isnumeric" href="#Base.Unicode.isnumeric"><code>Base.Unicode.isnumeric</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">isnumeric(c::AbstractChar) -&gt; Bool</code></pre><p>Tests whether a character is numeric. A character is classified as numeric if it belongs to the Unicode general category Number, i.e. a character whose category code begins with &#39;N&#39;.</p><p>Note that this broad category includes characters such as ¾ and ௰. Use <a href="#Base.Unicode.isdigit"><code>isdigit</code></a> to check whether a character a decimal digit between 0 and 9.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; isnumeric(&#39;௰&#39;)
true

julia&gt; isnumeric(&#39;9&#39;)
true

julia&gt; isnumeric(&#39;α&#39;)
false

julia&gt; isnumeric(&#39;❤&#39;)
false</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/f94ce50398176ec3dae0bb794d6b4de6a4ed834a/base/strings/unicode.jl#L370-L394">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Unicode.isprint" href="#Base.Unicode.isprint"><code>Base.Unicode.isprint</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">isprint(c::AbstractChar) -&gt; Bool</code></pre><p>Tests whether a character is printable, including spaces, but not a control character.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; isprint(&#39;\x01&#39;)
false

julia&gt; isprint(&#39;A&#39;)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/f94ce50398176ec3dae0bb794d6b4de6a4ed834a/base/strings/unicode.jl#L464-L477">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Unicode.ispunct" href="#Base.Unicode.ispunct"><code>Base.Unicode.ispunct</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ispunct(c::AbstractChar) -&gt; Bool</code></pre><p>Tests whether a character belongs to the Unicode general category Punctuation, i.e. a character whose category code begins with &#39;P&#39;.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; ispunct(&#39;α&#39;)
false

julia&gt; ispunct(&#39;/&#39;)
true

julia&gt; ispunct(&#39;;&#39;)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/f94ce50398176ec3dae0bb794d6b4de6a4ed834a/base/strings/unicode.jl#L416-L433">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Unicode.isspace" href="#Base.Unicode.isspace"><code>Base.Unicode.isspace</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">isspace(c::AbstractChar) -&gt; Bool</code></pre><p>Tests whether a character is any whitespace character. Includes ASCII characters &#39;\t&#39;, &#39;\n&#39;, &#39;\v&#39;, &#39;\f&#39;, &#39;\r&#39;, and &#39; &#39;, Latin-1 character U+0085, and characters in Unicode category Zs.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; isspace(&#39;\n&#39;)
true

julia&gt; isspace(&#39;\r&#39;)
true

julia&gt; isspace(&#39; &#39;)
true

julia&gt; isspace(&#39;\x20&#39;)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/f94ce50398176ec3dae0bb794d6b4de6a4ed834a/base/strings/unicode.jl#L438-L459">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Unicode.isuppercase" href="#Base.Unicode.isuppercase"><code>Base.Unicode.isuppercase</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">isuppercase(c::AbstractChar) -&gt; Bool</code></pre><p>Tests whether a character is an uppercase letter. A character is classified as uppercase if it belongs to Unicode category Lu, Letter: Uppercase, or Lt, Letter: Titlecase.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; isuppercase(&#39;γ&#39;)
false

julia&gt; isuppercase(&#39;Γ&#39;)
true

julia&gt; isuppercase(&#39;❤&#39;)
false</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/f94ce50398176ec3dae0bb794d6b4de6a4ed834a/base/strings/unicode.jl#L293-L311">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Unicode.isxdigit" href="#Base.Unicode.isxdigit"><code>Base.Unicode.isxdigit</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">isxdigit(c::AbstractChar) -&gt; Bool</code></pre><p>Test whether a character is a valid hexadecimal digit. Note that this does not include <code>x</code> (as in the standard <code>0x</code> prefix).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; isxdigit(&#39;a&#39;)
true

julia&gt; isxdigit(&#39;x&#39;)
false</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/f94ce50398176ec3dae0bb794d6b4de6a4ed834a/base/strings/unicode.jl#L482-L496">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Core.Symbol" href="#Core.Symbol"><code>Core.Symbol</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Symbol(x...) -&gt; Symbol</code></pre><p>Create a <code>Symbol</code> by concatenating the string representations of the arguments together.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Symbol(&quot;my&quot;, &quot;name&quot;)
:myname

julia&gt; Symbol(&quot;day&quot;, 4)
:day4</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/f94ce50398176ec3dae0bb794d6b4de6a4ed834a/base/docs/basedocs.jl#L1260-L1273">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.escape_string" href="#Base.escape_string"><code>Base.escape_string</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">escape_string(str::AbstractString[, esc])::AbstractString
escape_string(io, str::AbstractString[, esc::])::Nothing</code></pre><p>General escaping of traditional C and Unicode escape sequences. The first form returns the escaped string, the second prints the result to <code>io</code>.</p><p>Backslashes (<code>\</code>) are escaped with a double-backslash (<code>&quot;\\&quot;</code>). Non-printable characters are escaped either with their standard C escape codes, <code>&quot;\0&quot;</code> for NUL (if unambiguous), unicode code point (<code>&quot;\u&quot;</code> prefix) or hex (<code>&quot;\x&quot;</code> prefix).</p><p>The optional <code>esc</code> argument specifies any additional characters that should also be escaped by a prepending backslash (<code>&quot;</code> is also escaped by default in the first form).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; escape_string(&quot;aaa\nbbb&quot;)
&quot;aaa\\nbbb&quot;

julia&gt; escape_string(&quot;\xfe\xff&quot;) # invalid utf-8
&quot;\\xfe\\xff&quot;

julia&gt; escape_string(string(&#39;\u2135&#39;,&#39;\0&#39;)) # unambiguous
&quot;ℵ\\0&quot;

julia&gt; escape_string(string(&#39;\u2135&#39;,&#39;\0&#39;,&#39;0&#39;)) # \0 would be ambiguous
&quot;ℵ\\x000&quot;</code></pre><p><strong>See also</strong></p><p><a href="#Base.unescape_string"><code>unescape_string</code></a> for the reverse operation.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/f94ce50398176ec3dae0bb794d6b4de6a4ed834a/base/strings/io.jl#L266-L297">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.unescape_string" href="#Base.unescape_string"><code>Base.unescape_string</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">unescape_string(str::AbstractString)::AbstractString
unescape_string(io, str::AbstractString)::Nothing</code></pre><p>General unescaping of traditional C and Unicode escape sequences. The first form returns the escaped string, the second prints the result to <code>io</code>.</p><p>The following escape sequences are recognised:</p><ul><li>Escaped backslash (<code>\\</code>)</li><li>Escaped double-quote (<code>\&quot;</code>)</li><li>Standard C escape sequences (<code>\a</code>, <code>\b</code>, <code>\t</code>, <code>\n</code>, <code>\v</code>, <code>\f</code>, <code>\r</code>, <code>\e</code>)</li><li>Unicode code points (<code>\u</code> or <code>\U</code> prefixes with 1-4 trailing hex digits)</li><li>Hex bytes (<code>\x</code> with 1-2 trailing hex digits)</li><li>Octal bytes (<code>\</code> with 1-3 trailing octal digits)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; unescape_string(&quot;aaa\\nbbb&quot;) # C escape sequence
&quot;aaa\nbbb&quot;

julia&gt; unescape_string(&quot;\\u03c0&quot;) # unicode
&quot;π&quot;

julia&gt; unescape_string(&quot;\\101&quot;) # octal
&quot;A&quot;</code></pre><p><strong>See also</strong></p><p><a href="#Base.escape_string"><code>escape_string</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/f94ce50398176ec3dae0bb794d6b4de6a4ed834a/base/strings/io.jl#L336-L365">source</a></section><footer><hr/><a class="previous" href="../numbers/"><span class="direction">Previous</span><span class="title">Numbers</span></a><a class="next" href="../arrays/"><span class="direction">Next</span><span class="title">Arrays</span></a></footer></article></body></html>
