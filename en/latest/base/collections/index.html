<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Collections and Data Structures · The Julia Language</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-28835595-6', 'auto');
ga('send', 'pageview');
</script><link rel="canonical" href="https://docs.julialang.org/en/stable/base/collections/index.html"/><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../../index.html"><img class="logo" src="../../assets/logo.png" alt="The Julia Language logo"/></a><h1>The Julia Language</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../../manual/introduction/">Introduction</a></li><li><a class="toctext" href="../../manual/getting-started/">Getting Started</a></li><li><a class="toctext" href="../../manual/variables/">Variables</a></li><li><a class="toctext" href="../../manual/integers-and-floating-point-numbers/">Integers and Floating-Point Numbers</a></li><li><a class="toctext" href="../../manual/mathematical-operations/">Mathematical Operations and Elementary Functions</a></li><li><a class="toctext" href="../../manual/complex-and-rational-numbers/">Complex and Rational Numbers</a></li><li><a class="toctext" href="../../manual/strings/">Strings</a></li><li><a class="toctext" href="../../manual/functions/">Functions</a></li><li><a class="toctext" href="../../manual/control-flow/">Control Flow</a></li><li><a class="toctext" href="../../manual/variables-and-scoping/">Scope of Variables</a></li><li><a class="toctext" href="../../manual/types/">Types</a></li><li><a class="toctext" href="../../manual/methods/">Methods</a></li><li><a class="toctext" href="../../manual/constructors/">Constructors</a></li><li><a class="toctext" href="../../manual/conversion-and-promotion/">Conversion and Promotion</a></li><li><a class="toctext" href="../../manual/interfaces/">Interfaces</a></li><li><a class="toctext" href="../../manual/modules/">Modules</a></li><li><a class="toctext" href="../../manual/documentation/">Documentation</a></li><li><a class="toctext" href="../../manual/metaprogramming/">Metaprogramming</a></li><li><a class="toctext" href="../../manual/arrays/">Multi-dimensional Arrays</a></li><li><a class="toctext" href="../../manual/missing/">Missing Values</a></li><li><a class="toctext" href="../../manual/networking-and-streams/">Networking and Streams</a></li><li><a class="toctext" href="../../manual/parallel-computing/">Parallel Computing</a></li><li><a class="toctext" href="../../manual/running-external-programs/">Running External Programs</a></li><li><a class="toctext" href="../../manual/calling-c-and-fortran-code/">Calling C and Fortran Code</a></li><li><a class="toctext" href="../../manual/handling-operating-system-variation/">Handling Operating System Variation</a></li><li><a class="toctext" href="../../manual/environment-variables/">Environment Variables</a></li><li><a class="toctext" href="../../manual/embedding/">Embedding Julia</a></li><li><a class="toctext" href="../../manual/packages/">Packages</a></li><li><a class="toctext" href="../../manual/profile/">Profiling</a></li><li><a class="toctext" href="../../manual/stacktraces/">Stack Traces</a></li><li><a class="toctext" href="../../manual/performance-tips/">Performance Tips</a></li><li><a class="toctext" href="../../manual/workflow-tips/">Workflow Tips</a></li><li><a class="toctext" href="../../manual/style-guide/">Style Guide</a></li><li><a class="toctext" href="../../manual/faq/">Frequently Asked Questions</a></li><li><a class="toctext" href="../../manual/noteworthy-differences/">Noteworthy Differences from other Languages</a></li><li><a class="toctext" href="../../manual/unicode-input/">Unicode Input</a></li></ul></li><li><span class="toctext">Base</span><ul><li><a class="toctext" href="../base/">Essentials</a></li><li class="current"><a class="toctext" href>Collections and Data Structures</a><ul class="internal"><li><a class="toctext" href="#lib-collections-iteration-1">Iteration</a></li><li><a class="toctext" href="#General-Collections-1">General Collections</a></li><li><a class="toctext" href="#Iterable-Collections-1">Iterable Collections</a></li><li><a class="toctext" href="#Indexable-Collections-1">Indexable Collections</a></li><li><a class="toctext" href="#Dictionaries-1">Dictionaries</a></li><li><a class="toctext" href="#Set-Like-Collections-1">Set-Like Collections</a></li><li><a class="toctext" href="#Dequeues-1">Dequeues</a></li><li><a class="toctext" href="#Utility-Collections-1">Utility Collections</a></li></ul></li><li><a class="toctext" href="../math/">Mathematics</a></li><li><a class="toctext" href="../numbers/">Numbers</a></li><li><a class="toctext" href="../strings/">Strings</a></li><li><a class="toctext" href="../arrays/">Arrays</a></li><li><a class="toctext" href="../parallel/">Tasks</a></li><li><a class="toctext" href="../multi-threading/">Multi-Threading</a></li><li><a class="toctext" href="../constants/">Constants</a></li><li><a class="toctext" href="../file/">Filesystem</a></li><li><a class="toctext" href="../io-network/">I/O and Network</a></li><li><a class="toctext" href="../punctuation/">Punctuation</a></li><li><a class="toctext" href="../sort/">Sorting and Related Functions</a></li><li><a class="toctext" href="../iterators/">Iteration utilities</a></li><li><a class="toctext" href="../c/">C Interface</a></li><li><a class="toctext" href="../libc/">C Standard Library</a></li><li><a class="toctext" href="../stacktraces/">StackTraces</a></li><li><a class="toctext" href="../simd-types/">SIMD Support</a></li></ul></li><li><span class="toctext">Standard Library</span><ul><li><a class="toctext" href="../../stdlib/Base64/">Base64</a></li><li><a class="toctext" href="../../stdlib/CRC32c/">CRC32c</a></li><li><a class="toctext" href="../../stdlib/Dates/">Dates</a></li><li><a class="toctext" href="../../stdlib/DelimitedFiles/">Delimited Files</a></li><li><a class="toctext" href="../../stdlib/Distributed/">Distributed Computing</a></li><li><a class="toctext" href="../../stdlib/FileWatching/">File Events</a></li><li><a class="toctext" href="../../stdlib/InteractiveUtils/">Interactive Utilities</a></li><li><a class="toctext" href="../../stdlib/IterativeEigensolvers/">Iterative Eigensolvers</a></li><li><a class="toctext" href="../../stdlib/Libdl/">Dynamic Linker</a></li><li><a class="toctext" href="../../stdlib/LinearAlgebra/">Linear Algebra</a></li><li><a class="toctext" href="../../stdlib/Markdown/">Markdown</a></li><li><a class="toctext" href="../../stdlib/Mmap/">Memory-mapped I/O</a></li><li><a class="toctext" href="../../stdlib/Pkg/">Package Manager Functions</a></li><li><a class="toctext" href="../../stdlib/Printf/">Printf</a></li><li><a class="toctext" href="../../stdlib/Profile/">Profiling</a></li><li><a class="toctext" href="../../stdlib/REPL/">The Julia REPL</a></li><li><a class="toctext" href="../../stdlib/Random/">Random Numbers</a></li><li><a class="toctext" href="../../stdlib/SHA/">SHA</a></li><li><a class="toctext" href="../../stdlib/Serialization/">Serialization</a></li><li><a class="toctext" href="../../stdlib/SharedArrays/">Shared Arrays</a></li><li><a class="toctext" href="../../stdlib/Sockets/">-</a></li><li><a class="toctext" href="../../stdlib/SparseArrays/">Sparse Arrays</a></li><li><a class="toctext" href="../../stdlib/Test/">Unit Testing</a></li><li><a class="toctext" href="../../stdlib/UUIDs/">UUIDs</a></li><li><a class="toctext" href="../../stdlib/Unicode/">Unicode</a></li></ul></li><li><span class="toctext">Developer Documentation</span><ul><li><a class="toctext" href="../../devdocs/reflection/">Reflection and introspection</a></li><li><span class="toctext">Documentation of Julia&#39;s Internals</span><ul><li><a class="toctext" href="../../devdocs/init/">Initialization of the Julia runtime</a></li><li><a class="toctext" href="../../devdocs/ast/">Julia ASTs</a></li><li><a class="toctext" href="../../devdocs/types/">More about types</a></li><li><a class="toctext" href="../../devdocs/object/">Memory layout of Julia Objects</a></li><li><a class="toctext" href="../../devdocs/eval/">Eval of Julia code</a></li><li><a class="toctext" href="../../devdocs/callconv/">Calling Conventions</a></li><li><a class="toctext" href="../../devdocs/compiler/">High-level Overview of the Native-Code Generation Process</a></li><li><a class="toctext" href="../../devdocs/functions/">Julia Functions</a></li><li><a class="toctext" href="../../devdocs/cartesian/">Base.Cartesian</a></li><li><a class="toctext" href="../../devdocs/meta/">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="../../devdocs/subarrays/">SubArrays</a></li><li><a class="toctext" href="../../devdocs/sysimg/">System Image Building</a></li><li><a class="toctext" href="../../devdocs/llvm/">Working with LLVM</a></li><li><a class="toctext" href="../../devdocs/stdio/">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="../../devdocs/boundscheck/">Bounds checking</a></li><li><a class="toctext" href="../../devdocs/locks/">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="../../devdocs/offset-arrays/">Arrays with custom indices</a></li><li><a class="toctext" href="../../devdocs/require/">Module loading</a></li><li><a class="toctext" href="../../devdocs/inference/">Inference</a></li></ul></li><li><span class="toctext">Developing/debugging Julia&#39;s C code</span><ul><li><a class="toctext" href="../../devdocs/backtraces/">Reporting and analyzing crashes (segfaults)</a></li><li><a class="toctext" href="../../devdocs/debuggingtips/">gdb debugging tips</a></li><li><a class="toctext" href="../../devdocs/valgrind/">Using Valgrind with Julia</a></li><li><a class="toctext" href="../../devdocs/sanitizers/">Sanitizer support</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Base</li><li><a href>Collections and Data Structures</a></li></ul><a class="edit-page" href="https://github.com/JuliaLang/julia/blob/master/doc/src/base/collections.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Collections and Data Structures</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Collections-and-Data-Structures-1" href="#Collections-and-Data-Structures-1">Collections and Data Structures</a></h1><h2><a class="nav-anchor" id="lib-collections-iteration-1" href="#lib-collections-iteration-1">Iteration</a></h2><p>Sequential iteration is implemented by the methods <a href="#Base.start"><code>start</code></a>, <a href="#Base.done"><code>done</code></a>, and <a href="#Base.next"><code>next</code></a>. The general <code>for</code> loop:</p><pre><code class="language-julia">for i = I   # or  &quot;for i in I&quot;
    # body
end</code></pre><p>is translated into:</p><pre><code class="language-julia">state = start(I)
while !done(I, state)
    (i, state) = next(I, state)
    # body
end</code></pre><p>The <code>state</code> object may be anything, and should be chosen appropriately for each iterable type. See the <a href="../../manual/interfaces/#man-interface-iteration-1">manual section on the iteration interface</a> for more details about defining a custom iterable type.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.start" href="#Base.start"><code>Base.start</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">start(iter) -&gt; state</code></pre><p>Get initial iteration state for an iterable object.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; start(1:5)
1

julia&gt; start([1;2;3])
1

julia&gt; start([4;2;3])
1</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/8dc4fc13a65ede21b7a31456a27d4af4a006fa2a/base/essentials.jl#L661-L677">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.done" href="#Base.done"><code>Base.done</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">done(iter, state) -&gt; Bool</code></pre><p>Test whether we are done iterating.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; done(1:5, 3)
false

julia&gt; done(1:5, 5)
false

julia&gt; done(1:5, 6)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/8dc4fc13a65ede21b7a31456a27d4af4a006fa2a/base/essentials.jl#L680-L696">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.next" href="#Base.next"><code>Base.next</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">next(iter, state) -&gt; item, state</code></pre><p>For a given iterable object and iteration state, return the current item and the next iteration state.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; next(1:5, 3)
(3, 4)

julia&gt; next(1:5, 5)
(5, 6)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/8dc4fc13a65ede21b7a31456a27d4af4a006fa2a/base/essentials.jl#L645-L658">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.IteratorSize" href="#Base.IteratorSize"><code>Base.IteratorSize</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">IteratorSize(itertype::Type) -&gt; IteratorSize</code></pre><p>Given the type of an iterator, return one of the following values:</p><ul><li><p><code>SizeUnknown()</code> if the length (number of elements) cannot be determined in advance.</p></li><li><p><code>HasLength()</code> if there is a fixed, finite length.</p></li><li><p><code>HasShape{N}()</code> if there is a known length plus a notion of multidimensional shape (as for an array).  In this case <code>N</code> should give the number of dimensions, and the <a href="../arrays/#Base.axes-Tuple{Any}"><code>axes</code></a> function is valid  for the iterator.</p></li><li><p><code>IsInfinite()</code> if the iterator yields values forever.</p></li></ul><p>The default value (for iterators that do not define this function) is <code>HasLength()</code>. This means that most iterators are assumed to implement <a href="#Base.length"><code>length</code></a>.</p><p>This trait is generally used to select between algorithms that pre-allocate space for their result, and algorithms that resize their result incrementally.</p><pre><code class="language-julia-repl">julia&gt; Base.IteratorSize(1:5)
Base.HasShape{1}()

julia&gt; Base.IteratorSize((2,3))
Base.HasLength()</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/8dc4fc13a65ede21b7a31456a27d4af4a006fa2a/base/generator.jl#L59-L84">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.IteratorEltype" href="#Base.IteratorEltype"><code>Base.IteratorEltype</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">IteratorEltype(itertype::Type) -&gt; IteratorEltype</code></pre><p>Given the type of an iterator, return one of the following values:</p><ul><li><p><code>EltypeUnknown()</code> if the type of elements yielded by the iterator is not known in advance.</p></li><li><p><code>HasEltype()</code> if the element type is known, and <a href="#Base.eltype"><code>eltype</code></a> would return a meaningful value.</p></li></ul><p><code>HasEltype()</code> is the default, since iterators are assumed to implement <a href="#Base.eltype"><code>eltype</code></a>.</p><p>This trait is generally used to select between algorithms that pre-allocate a specific type of result, and algorithms that pick a result type based on the types of yielded values.</p><pre><code class="language-julia-repl">julia&gt; Base.IteratorEltype(1:5)
Base.HasEltype()</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/8dc4fc13a65ede21b7a31456a27d4af4a006fa2a/base/generator.jl#L92-L110">source</a></section><p>Fully implemented by:</p><ul><li><p><code>AbstractRange</code></p></li><li><p><code>UnitRange</code></p></li><li><p><code>Tuple</code></p></li><li><p><code>Number</code></p></li><li><p><a href="../arrays/#Core.AbstractArray"><code>AbstractArray</code></a></p></li><li><p><a href="#Base.BitSet"><code>BitSet</code></a></p></li><li><p><a href="#Base.IdDict"><code>IdDict</code></a></p></li><li><p><a href="#Base.Dict"><code>Dict</code></a></p></li><li><p><a href="#Base.WeakKeyDict"><code>WeakKeyDict</code></a></p></li><li><p><code>EachLine</code></p></li><li><p><code>AbstractString</code></p></li><li><p><a href="#Base.Set"><code>Set</code></a></p></li><li><p><a href="#Base.Pair"><code>Pair</code></a></p></li><li><p><a href="../base/#Core.NamedTuple"><code>NamedTuple</code></a></p></li></ul><h2><a class="nav-anchor" id="General-Collections-1" href="#General-Collections-1">General Collections</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isempty" href="#Base.isempty"><code>Base.isempty</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">isempty(collection) -&gt; Bool</code></pre><p>Determine whether a collection is empty (has no elements).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; isempty([])
true

julia&gt; isempty([1 2 3])
false</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/8dc4fc13a65ede21b7a31456a27d4af4a006fa2a/base/essentials.jl#L699-L712">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.empty!" href="#Base.empty!"><code>Base.empty!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">empty!(collection) -&gt; collection</code></pre><p>Remove all elements from a <code>collection</code>.</p><pre><code class="language-julia-repl">julia&gt; A = Dict(&quot;a&quot; =&gt; 1, &quot;b&quot; =&gt; 2)
Dict{String,Int64} with 2 entries:
  &quot;b&quot; =&gt; 2
  &quot;a&quot; =&gt; 1

julia&gt; empty!(A);

julia&gt; A
Dict{String,Int64} with 0 entries</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/8dc4fc13a65ede21b7a31456a27d4af4a006fa2a/base/dict.jl#L247-L263">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.length" href="#Base.length"><code>Base.length</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">length(collection) -&gt; Integer</code></pre><p>Return the number of elements in the collection.</p><p>Use <a href="#Base.lastindex"><code>lastindex</code></a> to get the last valid index of an indexable collection.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; length(1:5)
5

julia&gt; length([1, 2, 3, 4])
4

julia&gt; length([1 2; 3 4])
4</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/8dc4fc13a65ede21b7a31456a27d4af4a006fa2a/base/abstractarray.jl#L148-L166">source</a><div><div><pre><code class="language-none">length(s::AbstractString) -&gt; Int
length(s::AbstractString, i::Integer, j::Integer) -&gt; Int</code></pre><p>The number of characters in string <code>s</code> from indices <code>i</code> through <code>j</code>. This is computed as the number of code unit indices from <code>i</code> to <code>j</code> which are valid character indices. Without only a single string argument, this computes the number of characters in the entire string. With <code>i</code> and <code>j</code> arguments it computes the number of indices between <code>i</code> and <code>j</code> inclusive that are valid indices in the string <code>s</code>. In addition to in-bounds values, <code>i</code> may take the out-of-bounds value <code>ncodeunits(s) + 1</code> and <code>j</code> may take the out-of-bounds value <code>0</code>.</p><p>See also: <a href="../strings/#Base.isvalid-Tuple{Any}"><code>isvalid</code></a>, <a href="../strings/#Base.ncodeunits-Tuple{AbstractString}"><code>ncodeunits</code></a>, <a href="#Base.lastindex"><code>lastindex</code></a>, <a href="../strings/#Base.thisind"><code>thisind</code></a>, <a href="../strings/#Base.nextind"><code>nextind</code></a>, <a href="../strings/#Base.prevind"><code>prevind</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; length(&quot;jμΛIα&quot;)
5</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/8dc4fc13a65ede21b7a31456a27d4af4a006fa2a/base/strings/basic.jl#L312-L333">source</a></section><p>Fully implemented by:</p><ul><li><p><code>AbstractRange</code></p></li><li><p><code>UnitRange</code></p></li><li><p><code>Tuple</code></p></li><li><p><code>Number</code></p></li><li><p><a href="../arrays/#Core.AbstractArray"><code>AbstractArray</code></a></p></li><li><p><a href="#Base.BitSet"><code>BitSet</code></a></p></li><li><p><a href="#Base.IdDict"><code>IdDict</code></a></p></li><li><p><a href="#Base.Dict"><code>Dict</code></a></p></li><li><p><a href="#Base.WeakKeyDict"><code>WeakKeyDict</code></a></p></li><li><p><code>AbstractString</code></p></li><li><p><a href="#Base.Set"><code>Set</code></a></p></li><li><p><a href="../base/#Core.NamedTuple"><code>NamedTuple</code></a></p></li></ul><h2><a class="nav-anchor" id="Iterable-Collections-1" href="#Iterable-Collections-1">Iterable Collections</a></h2><pre><code class="language-none">Base.in
Base.eltype
Base.indexin
Base.unique
Base.unique!
Base.allunique
Base.reduce(::Any, ::Any, ::Any)
Base.reduce(::Any, ::Any)
Base.foldl(::Any, ::Any, ::Any)
Base.foldl(::Any, ::Any)
Base.foldr(::Any, ::Any, ::Any)
Base.foldr(::Any, ::Any)
Base.maximum(::Any)
Base.maximum(::Any, ::Any)
Base.maximum!
Base.minimum(::Any)
Base.minimum(::Any, ::Any)
Base.minimum!
Base.extrema(::Any)
Base.extrema(::AbstractArray, ::Any)
Base.argmax
Base.argmin
Base.findmax(::Any)
Base.findmax(::AbstractArray, ::Any)
Base.findmin(::Any)
Base.findmin(::AbstractArray, ::Any)
Base.findmax!
Base.findmin!
Base.sum
Base.sum!
Base.prod
Base.prod!
Base.any(::Any)
Base.any(::AbstractArray, ::Any)
Base.any!
Base.all(::Any)
Base.all(::AbstractArray, ::Any)
Base.all!
Base.count
Base.any(::Any, ::Any)
Base.all(::Any, ::Any)
Base.foreach
Base.map
Base.map!
Base.mapreduce(::Any, ::Any, ::Any, ::Any)
Base.mapreduce(::Any, ::Any, ::Any)
Base.mapfoldl(::Any, ::Any, ::Any, ::Any)
Base.mapfoldl(::Any, ::Any, ::Any)
Base.mapfoldr(::Any, ::Any, ::Any, ::Any)
Base.mapfoldr(::Any, ::Any, ::Any)
Base.first
Base.last
Base.step
Base.collect(::Any)
Base.collect(::Type, ::Any)
Base.issubset(::Any, ::Any)
Base.filter
Base.filter!
Base.replace(::Any, ::Pair...)
Base.replace(::Base.Callable, ::Any, ::Any)
Base.replace(::Base.Callable, ::Any)
Base.replace!</code></pre><h2><a class="nav-anchor" id="Indexable-Collections-1" href="#Indexable-Collections-1">Indexable Collections</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.getindex" href="#Base.getindex"><code>Base.getindex</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">getindex(collection, key...)</code></pre><p>Retrieve the value(s) stored at the given key or index within a collection. The syntax <code>a[i,j,...]</code> is converted by the compiler to <code>getindex(a, i, j, ...)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = Dict(&quot;a&quot; =&gt; 1, &quot;b&quot; =&gt; 2)
Dict{String,Int64} with 2 entries:
  &quot;b&quot; =&gt; 2
  &quot;a&quot; =&gt; 1

julia&gt; getindex(A, &quot;a&quot;)
1</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/8dc4fc13a65ede21b7a31456a27d4af4a006fa2a/base/array.jl#L640-L656">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.setindex!" href="#Base.setindex!"><code>Base.setindex!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">setindex!(collection, value, key...)</code></pre><p>Store the given value at the given key or index within a collection. The syntax <code>a[i,j,...] = x</code> is converted by the compiler to <code>(setindex!(a, x, i, j, ...); x)</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/8dc4fc13a65ede21b7a31456a27d4af4a006fa2a/base/array.jl#L690-L695">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.firstindex" href="#Base.firstindex"><code>Base.firstindex</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">firstindex(collection) -&gt; Integer</code></pre><p>Return the first index of the collection.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; firstindex([1,2,4])
1</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/8dc4fc13a65ede21b7a31456a27d4af4a006fa2a/base/abstractarray.jl#L185-L195">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.lastindex" href="#Base.lastindex"><code>Base.lastindex</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">lastindex(collection) -&gt; Integer</code></pre><p>Return the last index of the collection.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; lastindex([1,2,4])
3</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/8dc4fc13a65ede21b7a31456a27d4af4a006fa2a/base/abstractarray.jl#L171-L181">source</a></section><p>Fully implemented by:</p><ul><li><p><a href="../arrays/#Core.Array"><code>Array</code></a></p></li><li><p><a href="../arrays/#Base.BitArray"><code>BitArray</code></a></p></li><li><p><a href="../arrays/#Core.AbstractArray"><code>AbstractArray</code></a></p></li><li><p><code>SubArray</code></p></li></ul><p>Partially implemented by:</p><ul><li><p><code>AbstractRange</code></p></li><li><p><code>UnitRange</code></p></li><li><p><code>Tuple</code></p></li><li><p><code>AbstractString</code></p></li><li><p><a href="#Base.Dict"><code>Dict</code></a></p></li><li><p><a href="#Base.IdDict"><code>IdDict</code></a></p></li><li><p><a href="#Base.WeakKeyDict"><code>WeakKeyDict</code></a></p></li><li><p><a href="../base/#Core.NamedTuple"><code>NamedTuple</code></a></p></li></ul><h2><a class="nav-anchor" id="Dictionaries-1" href="#Dictionaries-1">Dictionaries</a></h2><p><a href="#Base.Dict"><code>Dict</code></a> is the standard dictionary. Its implementation uses <a href="../base/#Base.hash"><code>hash</code></a> as the hashing function for the key, and <a href="../base/#Base.isequal"><code>isequal</code></a> to determine equality. Define these two functions for custom types to override how they are stored in a hash table.</p><p><a href="#Base.IdDict"><code>IdDict</code></a> is a special hash table where the keys are always object identities.</p><p><a href="#Base.WeakKeyDict"><code>WeakKeyDict</code></a> is a hash table implementation where the keys are weak references to objects, and thus may be garbage collected even when referenced in a hash table.</p><p><a href="#Base.Dict"><code>Dict</code></a>s can be created by passing pair objects constructed with <code>=&gt;</code> to a <a href="#Base.Dict"><code>Dict</code></a> constructor: <code>Dict(&quot;A&quot;=&gt;1, &quot;B&quot;=&gt;2)</code>. This call will attempt to infer type information from the keys and values (i.e. this example creates a <code>Dict{String, Int64}</code>). To explicitly specify types use the syntax <code>Dict{KeyType,ValueType}(...)</code>. For example, <code>Dict{String,Int32}(&quot;A&quot;=&gt;1, &quot;B&quot;=&gt;2)</code>.</p><p>Dictionaries may also be created with generators. For example, <code>Dict(i =&gt; f(i) for i = 1:10)</code>.</p><p>Given a dictionary <code>D</code>, the syntax <code>D[x]</code> returns the value of key <code>x</code> (if it exists) or throws an error, and <code>D[x] = y</code> stores the key-value pair <code>x =&gt; y</code> in <code>D</code> (replacing any existing value for the key <code>x</code>).  Multiple arguments to <code>D[...]</code> are converted to tuples; for example, the syntax <code>D[x,y]</code>  is equivalent to <code>D[(x,y)]</code>, i.e. it refers to the value keyed by the tuple <code>(x,y)</code>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Dict" href="#Base.Dict"><code>Base.Dict</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Dict([itr])</code></pre><p><code>Dict{K,V}()</code> constructs a hash table with keys of type <code>K</code> and values of type <code>V</code>.</p><p>Given a single iterable argument, constructs a <a href="#Base.Dict"><code>Dict</code></a> whose key-value pairs are taken from 2-tuples <code>(key,value)</code> generated by the argument.</p><pre><code class="language-julia-repl">julia&gt; Dict([(&quot;A&quot;, 1), (&quot;B&quot;, 2)])
Dict{String,Int64} with 2 entries:
  &quot;B&quot; =&gt; 2
  &quot;A&quot; =&gt; 1</code></pre><p>Alternatively, a sequence of pair arguments may be passed.</p><pre><code class="language-julia-repl">julia&gt; Dict(&quot;A&quot;=&gt;1, &quot;B&quot;=&gt;2)
Dict{String,Int64} with 2 entries:
  &quot;B&quot; =&gt; 2
  &quot;A&quot; =&gt; 1</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/8dc4fc13a65ede21b7a31456a27d4af4a006fa2a/base/dict.jl#L62-L85">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.IdDict" href="#Base.IdDict"><code>Base.IdDict</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">IdDict([itr])</code></pre><p><code>IdDict{K,V}()</code> constructs a hash table using object-id as hash and <code>===</code> as equality with keys of type <code>K</code> and values of type <code>V</code>.</p><p>See <a href="#Base.Dict"><code>Dict</code></a> for further help.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/8dc4fc13a65ede21b7a31456a27d4af4a006fa2a/base/abstractdict.jl#L534-L541">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.WeakKeyDict" href="#Base.WeakKeyDict"><code>Base.WeakKeyDict</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">WeakKeyDict([itr])</code></pre><p><code>WeakKeyDict()</code> constructs a hash table where the keys are weak references to objects, and thus may be garbage collected even when referenced in a hash table.</p><p>See <a href="#Base.Dict"><code>Dict</code></a> for further help.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/8dc4fc13a65ede21b7a31456a27d4af4a006fa2a/base/weakkeydict.jl#L5-L13">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.ImmutableDict" href="#Base.ImmutableDict"><code>Base.ImmutableDict</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ImmutableDict</code></pre><p>ImmutableDict is a Dictionary implemented as an immutable linked list, which is optimal for small dictionaries that are constructed over many individual insertions Note that it is not possible to remove a value, although it can be partially overridden and hidden by inserting a new value with the same key</p><pre><code class="language-none">ImmutableDict(KV::Pair)</code></pre><p>Create a new entry in the Immutable Dictionary for the key =&gt; value pair</p><ul><li><p>use <code>(key =&gt; value) in dict</code> to see if this particular combination is in the properties set</p></li><li><p>use <code>get(dict, key, default)</code> to retrieve the most recent value for a particular key</p></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/8dc4fc13a65ede21b7a31456a27d4af4a006fa2a/base/dict.jl#L696-L711">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.haskey" href="#Base.haskey"><code>Base.haskey</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">haskey(collection, key) -&gt; Bool</code></pre><p>Determine whether a collection has a mapping for a given key.</p><pre><code class="language-julia-repl">julia&gt; a = Dict(&#39;a&#39;=&gt;2, &#39;b&#39;=&gt;3)
Dict{Char,Int64} with 2 entries:
  &#39;b&#39; =&gt; 3
  &#39;a&#39; =&gt; 2

julia&gt; haskey(a,&#39;a&#39;)
true

julia&gt; haskey(a,&#39;c&#39;)
false</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/8dc4fc13a65ede21b7a31456a27d4af4a006fa2a/base/dict.jl#L527-L544">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.get-Tuple{Any,Any,Any}" href="#Base.get-Tuple{Any,Any,Any}"><code>Base.get</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">get(collection, key, default)</code></pre><p>Return the value stored for the given key, or the given default value if no mapping for the key is present.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; d = Dict(&quot;a&quot;=&gt;1, &quot;b&quot;=&gt;2);

julia&gt; get(d, &quot;a&quot;, 3)
1

julia&gt; get(d, &quot;c&quot;, 3)
3</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/8dc4fc13a65ede21b7a31456a27d4af4a006fa2a/base/dict.jl#L481-L497">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.get" href="#Base.get"><code>Base.get</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">get(collection, key, default)</code></pre><p>Return the value stored for the given key, or the given default value if no mapping for the key is present.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; d = Dict(&quot;a&quot;=&gt;1, &quot;b&quot;=&gt;2);

julia&gt; get(d, &quot;a&quot;, 3)
1

julia&gt; get(d, &quot;c&quot;, 3)
3</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/8dc4fc13a65ede21b7a31456a27d4af4a006fa2a/base/dict.jl#L481-L497">source</a><div><div><pre><code class="language-none">get(f::Function, collection, key)</code></pre><p>Return the value stored for the given key, or if no mapping for the key is present, return <code>f()</code>.  Use <a href="#Base.get!-Tuple{Any,Any,Any}"><code>get!</code></a> to also store the default value in the dictionary.</p><p>This is intended to be called using <code>do</code> block syntax</p><pre><code class="language-julia">get(dict, key) do
    # default value calculated here
    time()
end</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/8dc4fc13a65ede21b7a31456a27d4af4a006fa2a/base/dict.jl#L505-L519">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.get!-Tuple{Any,Any,Any}" href="#Base.get!-Tuple{Any,Any,Any}"><code>Base.get!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">get!(collection, key, default)</code></pre><p>Return the value stored for the given key, or if no mapping for the key is present, store <code>key =&gt; default</code>, and return <code>default</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; d = Dict(&quot;a&quot;=&gt;1, &quot;b&quot;=&gt;2, &quot;c&quot;=&gt;3);

julia&gt; get!(d, &quot;a&quot;, 5)
1

julia&gt; get!(d, &quot;d&quot;, 4)
4

julia&gt; d
Dict{String,Int64} with 4 entries:
  &quot;c&quot; =&gt; 3
  &quot;b&quot; =&gt; 2
  &quot;a&quot; =&gt; 1
  &quot;d&quot; =&gt; 4</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/8dc4fc13a65ede21b7a31456a27d4af4a006fa2a/base/dict.jl#L395-L418">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.get!-Tuple{Function,Any,Any}" href="#Base.get!-Tuple{Function,Any,Any}"><code>Base.get!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">get!(f::Function, collection, key)</code></pre><p>Return the value stored for the given key, or if no mapping for the key is present, store <code>key =&gt; f()</code>, and return <code>f()</code>.</p><p>This is intended to be called using <code>do</code> block syntax:</p><pre><code class="language-julia">get!(dict, key) do
    # default value calculated here
    time()
end</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/8dc4fc13a65ede21b7a31456a27d4af4a006fa2a/base/dict.jl#L423-L436">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.getkey" href="#Base.getkey"><code>Base.getkey</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">getkey(collection, key, default)</code></pre><p>Return the key matching argument <code>key</code> if one exists in <code>collection</code>, otherwise return <code>default</code>.</p><pre><code class="language-julia-repl">julia&gt; a = Dict(&#39;a&#39;=&gt;2, &#39;b&#39;=&gt;3)
Dict{Char,Int64} with 2 entries:
  &#39;b&#39; =&gt; 3
  &#39;a&#39; =&gt; 2

julia&gt; getkey(a,&#39;a&#39;,1)
&#39;a&#39;: ASCII/Unicode U+0061 (category Ll: Letter, lowercase)

julia&gt; getkey(a,&#39;d&#39;,&#39;a&#39;)
&#39;a&#39;: ASCII/Unicode U+0061 (category Ll: Letter, lowercase)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/8dc4fc13a65ede21b7a31456a27d4af4a006fa2a/base/dict.jl#L548-L565">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.delete!" href="#Base.delete!"><code>Base.delete!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">delete!(collection, key)</code></pre><p>Delete the mapping for the given key in a collection, and return the collection.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; d = Dict(&quot;a&quot;=&gt;1, &quot;b&quot;=&gt;2)
Dict{String,Int64} with 2 entries:
  &quot;b&quot; =&gt; 2
  &quot;a&quot; =&gt; 1

julia&gt; delete!(d, &quot;b&quot;)
Dict{String,Int64} with 1 entry:
  &quot;a&quot; =&gt; 1</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/8dc4fc13a65ede21b7a31456a27d4af4a006fa2a/base/dict.jl#L630-L646">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.pop!-Tuple{Any,Any,Any}" href="#Base.pop!-Tuple{Any,Any,Any}"><code>Base.pop!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">pop!(collection, key[, default])</code></pre><p>Delete and return the mapping for <code>key</code> if it exists in <code>collection</code>, otherwise return <code>default</code>, or throw an error if <code>default</code> is not specified.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; d = Dict(&quot;a&quot;=&gt;1, &quot;b&quot;=&gt;2, &quot;c&quot;=&gt;3);

julia&gt; pop!(d, &quot;a&quot;)
1

julia&gt; pop!(d, &quot;d&quot;)
ERROR: KeyError: key &quot;d&quot; not found
Stacktrace:
[...]

julia&gt; pop!(d, &quot;e&quot;, 4)
4</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/8dc4fc13a65ede21b7a31456a27d4af4a006fa2a/base/dict.jl#L582-L603">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.keys" href="#Base.keys"><code>Base.keys</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">keys(iterator)</code></pre><p>For an iterator or collection that has keys and values (e.g. arrays and dictionaries), return an iterator over the keys.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/8dc4fc13a65ede21b7a31456a27d4af4a006fa2a/base/abstractdict.jl#L73-L78">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.values" href="#Base.values"><code>Base.values</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">values(iterator)</code></pre><p>For an iterator or collection that has keys and values, return an iterator over the values. This function simply returns its argument by default, since the elements of a general iterator are normally considered its &quot;values&quot;.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; d = Dict(&quot;a&quot;=&gt;1, &quot;b&quot;=&gt;2);

julia&gt; values(d)
Base.ValueIterator for a Dict{String,Int64} with 2 entries. Values:
  2
  1

julia&gt; values([2])
1-element Array{Int64,1}:
 2</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/8dc4fc13a65ede21b7a31456a27d4af4a006fa2a/base/essentials.jl#L715-L736">source</a><div><div><pre><code class="language-none">values(a::AbstractDict)</code></pre><p>Return an iterator over all values in a collection. <code>collect(values(a))</code> returns an array of values. Since the values are stored internally in a hash table, the order in which they are returned may vary. But <code>keys(a)</code> and <code>values(a)</code> both iterate <code>a</code> and return the elements in the same order.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = Dict(&#39;a&#39;=&gt;2, &#39;b&#39;=&gt;3)
Dict{Char,Int64} with 2 entries:
  &#39;b&#39; =&gt; 3
  &#39;a&#39; =&gt; 2

julia&gt; collect(values(a))
2-element Array{Int64,1}:
 3
 2</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/8dc4fc13a65ede21b7a31456a27d4af4a006fa2a/base/abstractdict.jl#L106-L128">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.pairs" href="#Base.pairs"><code>Base.pairs</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">pairs(IndexLinear(), A)
pairs(IndexCartesian(), A)
pairs(IndexStyle(A), A)</code></pre><p>An iterator that accesses each element of the array <code>A</code>, returning <code>i =&gt; x</code>, where <code>i</code> is the index for the element and <code>x = A[i]</code>. Identical to <code>pairs(A)</code>, except that the style of index can be selected. Also similar to <code>enumerate(A)</code>, except <code>i</code> will be a valid index for <code>A</code>, while <code>enumerate</code> always counts from 1 regardless of the indices of <code>A</code>.</p><p>Specifying <code>IndexLinear()</code> ensures that <code>i</code> will be an integer; specifying <code>IndexCartesian()</code> ensures that <code>i</code> will be a <code>CartesianIndex</code>; specifying <code>IndexStyle(A)</code> chooses whichever has been defined as the native indexing style for array <code>A</code>.</p><p>Mutation of the bounds of the underlying array will invalidate this iterator.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [&quot;a&quot; &quot;d&quot;; &quot;b&quot; &quot;e&quot;; &quot;c&quot; &quot;f&quot;];

julia&gt; for (index, value) in pairs(IndexStyle(A), A)
           println(&quot;$index $value&quot;)
       end
1 a
2 b
3 c
4 d
5 e
6 f

julia&gt; S = view(A, 1:2, :);

julia&gt; for (index, value) in pairs(IndexStyle(S), S)
           println(&quot;$index $value&quot;)
       end
CartesianIndex(1, 1) a
CartesianIndex(2, 1) b
CartesianIndex(1, 2) d
CartesianIndex(2, 2) e</code></pre><p>See also: <a href="../arrays/#Base.IndexStyle"><code>IndexStyle</code></a>, <a href="../arrays/#Base.axes-Tuple{Any}"><code>axes</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/8dc4fc13a65ede21b7a31456a27d4af4a006fa2a/base/iterators.jl#L168-L213">source</a><div><div><pre><code class="language-none">pairs(collection)</code></pre><p>Return an iterator over <code>key =&gt; value</code> pairs for any collection that maps a set of keys to a set of values. This includes arrays, where the keys are the array indices.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/8dc4fc13a65ede21b7a31456a27d4af4a006fa2a/base/abstractdict.jl#L131-L137">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.merge" href="#Base.merge"><code>Base.merge</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">merge(d::AbstractDict, others::AbstractDict...)</code></pre><p>Construct a merged collection from the given collections. If necessary, the types of the resulting collection will be promoted to accommodate the types of the merged collections. If the same key is present in another collection, the value for that key will be the value it has in the last collection listed.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = Dict(&quot;foo&quot; =&gt; 0.0, &quot;bar&quot; =&gt; 42.0)
Dict{String,Float64} with 2 entries:
  &quot;bar&quot; =&gt; 42.0
  &quot;foo&quot; =&gt; 0.0

julia&gt; b = Dict(&quot;baz&quot; =&gt; 17, &quot;bar&quot; =&gt; 4711)
Dict{String,Int64} with 2 entries:
  &quot;bar&quot; =&gt; 4711
  &quot;baz&quot; =&gt; 17

julia&gt; merge(a, b)
Dict{String,Float64} with 3 entries:
  &quot;bar&quot; =&gt; 4711.0
  &quot;baz&quot; =&gt; 17.0
  &quot;foo&quot; =&gt; 0.0

julia&gt; merge(b, a)
Dict{String,Float64} with 3 entries:
  &quot;bar&quot; =&gt; 42.0
  &quot;baz&quot; =&gt; 17.0
  &quot;foo&quot; =&gt; 0.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/8dc4fc13a65ede21b7a31456a27d4af4a006fa2a/base/abstractdict.jl#L262-L294">source</a><div><div><pre><code class="language-none">merge(combine, d::AbstractDict, others::AbstractDict...)</code></pre><p>Construct a merged collection from the given collections. If necessary, the types of the resulting collection will be promoted to accommodate the types of the merged collections. Values with the same key will be combined using the combiner function.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = Dict(&quot;foo&quot; =&gt; 0.0, &quot;bar&quot; =&gt; 42.0)
Dict{String,Float64} with 2 entries:
  &quot;bar&quot; =&gt; 42.0
  &quot;foo&quot; =&gt; 0.0

julia&gt; b = Dict(&quot;baz&quot; =&gt; 17, &quot;bar&quot; =&gt; 4711)
Dict{String,Int64} with 2 entries:
  &quot;bar&quot; =&gt; 4711
  &quot;baz&quot; =&gt; 17

julia&gt; merge(+, a, b)
Dict{String,Float64} with 3 entries:
  &quot;bar&quot; =&gt; 4753.0
  &quot;baz&quot; =&gt; 17.0
  &quot;foo&quot; =&gt; 0.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/8dc4fc13a65ede21b7a31456a27d4af4a006fa2a/base/abstractdict.jl#L298-L324">source</a><div><div><pre><code class="language-none">merge(a::NamedTuple, b::NamedTuple)</code></pre><p>Construct a new named tuple by merging two existing ones. The order of fields in <code>a</code> is preserved, but values are taken from matching fields in <code>b</code>. Fields present only in <code>b</code> are appended at the end.</p><pre><code class="language-julia-repl">julia&gt; merge((a=1, b=2, c=3), (b=4, d=5))
(a = 1, b = 4, c = 3, d = 5)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/8dc4fc13a65ede21b7a31456a27d4af4a006fa2a/base/namedtuple.jl#L210-L221">source</a><div><div><pre><code class="language-none">merge(a::NamedTuple, iterable)</code></pre><p>Interpret an iterable of key-value pairs as a named tuple, and perform a merge.</p><pre><code class="language-julia-repl">julia&gt; merge((a=1, b=2, c=3), [:b=&gt;4, :d=&gt;5])
(a = 1, b = 4, c = 3, d = 5)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/8dc4fc13a65ede21b7a31456a27d4af4a006fa2a/base/namedtuple.jl#L239-L248">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.merge!-Tuple{AbstractDict,Vararg{AbstractDict,N} where N}" href="#Base.merge!-Tuple{AbstractDict,Vararg{AbstractDict,N} where N}"><code>Base.merge!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">merge!(d::AbstractDict, others::AbstractDict...)</code></pre><p>Update collection with pairs from the other collections. See also <a href="#Base.merge"><code>merge</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; d1 = Dict(1 =&gt; 2, 3 =&gt; 4);

julia&gt; d2 = Dict(1 =&gt; 4, 4 =&gt; 5);

julia&gt; merge!(d1, d2);

julia&gt; d1
Dict{Int64,Int64} with 3 entries:
  4 =&gt; 5
  3 =&gt; 4
  1 =&gt; 4</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/8dc4fc13a65ede21b7a31456a27d4af4a006fa2a/base/abstractdict.jl#L165-L185">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.merge!-Tuple{Function,AbstractDict,Vararg{AbstractDict,N} where N}" href="#Base.merge!-Tuple{Function,AbstractDict,Vararg{AbstractDict,N} where N}"><code>Base.merge!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">merge!(combine, d::AbstractDict, others::AbstractDict...)</code></pre><p>Update collection with pairs from the other collections. Values with the same key will be combined using the combiner function.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; d1 = Dict(1 =&gt; 2, 3 =&gt; 4);

julia&gt; d2 = Dict(1 =&gt; 4, 4 =&gt; 5);

julia&gt; merge!(+, d1, d2);

julia&gt; d1
Dict{Int64,Int64} with 3 entries:
  4 =&gt; 5
  3 =&gt; 4
  1 =&gt; 6

julia&gt; merge!(-, d1, d1);

julia&gt; d1
Dict{Int64,Int64} with 3 entries:
  4 =&gt; 0
  3 =&gt; 0
  1 =&gt; 0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/8dc4fc13a65ede21b7a31456a27d4af4a006fa2a/base/abstractdict.jl#L195-L224">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.sizehint!" href="#Base.sizehint!"><code>Base.sizehint!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">sizehint!(s, n)</code></pre><p>Suggest that collection <code>s</code> reserve capacity for at least <code>n</code> elements. This can improve performance.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/8dc4fc13a65ede21b7a31456a27d4af4a006fa2a/base/array.jl#L953-L957">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.keytype" href="#Base.keytype"><code>Base.keytype</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">keytype(type)</code></pre><p>Get the key type of an dictionary type. Behaves similarly to <a href="#Base.eltype"><code>eltype</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; keytype(Dict(Int32(1) =&gt; &quot;foo&quot;))
Int32</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/8dc4fc13a65ede21b7a31456a27d4af4a006fa2a/base/abstractdict.jl#L234-L244">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.valtype" href="#Base.valtype"><code>Base.valtype</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">valtype(type)</code></pre><p>Get the value type of an dictionary type. Behaves similarly to <a href="#Base.eltype"><code>eltype</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; valtype(Dict(Int32(1) =&gt; &quot;foo&quot;))
String</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/8dc4fc13a65ede21b7a31456a27d4af4a006fa2a/base/abstractdict.jl#L248-L258">source</a></section><p>Fully implemented by:</p><ul><li><p><a href="#Base.IdDict"><code>IdDict</code></a></p></li><li><p><a href="#Base.Dict"><code>Dict</code></a></p></li><li><p><a href="#Base.WeakKeyDict"><code>WeakKeyDict</code></a></p></li></ul><p>Partially implemented by:</p><ul><li><p><a href="#Base.BitSet"><code>BitSet</code></a></p></li><li><p><a href="#Base.Set"><code>Set</code></a></p></li><li><p><a href="../base/#Base.EnvDict"><code>EnvDict</code></a></p></li><li><p><a href="../arrays/#Core.Array"><code>Array</code></a></p></li><li><p><a href="../arrays/#Base.BitArray"><code>BitArray</code></a></p></li><li><p><a href="#Base.ImmutableDict"><code>ImmutableDict</code></a></p></li><li><p><a href="#Base.Iterators.Pairs"><code>Iterators.Pairs</code></a></p></li></ul><h2><a class="nav-anchor" id="Set-Like-Collections-1" href="#Set-Like-Collections-1">Set-Like Collections</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Set" href="#Base.Set"><code>Base.Set</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Set([itr])</code></pre><p>Construct a <a href="#Base.Set"><code>Set</code></a> of the values generated by the given iterable object, or an empty set. Should be used instead of <a href="#Base.BitSet"><code>BitSet</code></a> for sparse integer sets, or for sets of arbitrary objects.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/8dc4fc13a65ede21b7a31456a27d4af4a006fa2a/base/set.jl#L14-L20">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.BitSet" href="#Base.BitSet"><code>Base.BitSet</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">BitSet([itr])</code></pre><p>Construct a sorted set of <code>Int</code>s generated by the given iterable object, or an empty set. Implemented as a bit string, and therefore designed for dense integer sets. If the set will be sparse (for example, holding a few very large integers), use <a href="#Base.Set"><code>Set</code></a> instead.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/8dc4fc13a65ede21b7a31456a27d4af4a006fa2a/base/bitset.jl#L21-L28">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.union" href="#Base.union"><code>Base.union</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">union(s, itrs...)
∪(s, itrs...)</code></pre><p>Construct the union of sets. Maintain order with arrays.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; union([1, 2], [3, 4])
4-element Array{Int64,1}:
 1
 2
 3
 4

julia&gt; union([1, 2], [2, 4])
3-element Array{Int64,1}:
 1
 2
 4

julia&gt; union([4, 2], 1:2)
3-element Array{Int64,1}:
 4
 2
 1

julia&gt; union(Set([1, 2]), 2:3)
Set([2, 3, 1])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/8dc4fc13a65ede21b7a31456a27d4af4a006fa2a/base/abstractset.jl#L4-L34">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.union!" href="#Base.union!"><code>Base.union!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">union!(s::Union{AbstractSet,AbstractVector}, itrs...)</code></pre><p>Construct the union of passed in sets and overwrite <code>s</code> with the result. Maintain order with arrays.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = Set([1, 3, 4, 5]);

julia&gt; union!(a, 1:2:8);

julia&gt; a
Set([7, 4, 3, 5, 1])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/8dc4fc13a65ede21b7a31456a27d4af4a006fa2a/base/abstractset.jl#L44-L59">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.intersect" href="#Base.intersect"><code>Base.intersect</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">intersect(s, itrs...)
∩(s, itrs...)</code></pre><p>Construct the intersection of sets. Maintain order with arrays.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; intersect([1, 2, 3], [3, 4, 5])
1-element Array{Int64,1}:
 3

julia&gt; intersect([1, 4, 4, 5, 6], [4, 6, 6, 7, 8])
2-element Array{Int64,1}:
 4
 6

julia&gt; intersect(Set([1, 2]), BitSet([2, 3]))
Set([2])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/8dc4fc13a65ede21b7a31456a27d4af4a006fa2a/base/abstractset.jl#L76-L97">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.setdiff" href="#Base.setdiff"><code>Base.setdiff</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">setdiff(s, itrs...)</code></pre><p>Construct the set of elements in <code>s</code> but not in any of the iterables in <code>itrs</code>. Maintain order with arrays.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; setdiff([1,2,3], [3,4,5])
2-element Array{Int64,1}:
 1
 2</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/8dc4fc13a65ede21b7a31456a27d4af4a006fa2a/base/abstractset.jl#L114-L127">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.setdiff!" href="#Base.setdiff!"><code>Base.setdiff!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">setdiff!(s, itrs...)</code></pre><p>Remove from set <code>s</code> (in-place) each element of each iterable from <code>itrs</code>. Maintain order with arrays.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = Set([1, 3, 4, 5]);

julia&gt; setdiff!(a, 1:2:6);

julia&gt; a
Set([4])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/8dc4fc13a65ede21b7a31456a27d4af4a006fa2a/base/abstractset.jl#L131-L146">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.symdiff" href="#Base.symdiff"><code>Base.symdiff</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">symdiff(s, itrs...)</code></pre><p>Construct the symmetric difference of elements in the passed in sets. When <code>s</code> is not an <code>AbstractSet</code>, the order is maintained. Note that in this case the multiplicity of elements matters.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; symdiff([1,2,3], [3,4,5], [4,5,6])
3-element Array{Int64,1}:
 1
 2
 6

julia&gt; symdiff([1,2,1], [2, 1, 2])
2-element Array{Int64,1}:
 1
 2

julia&gt; symdiff(unique([1,2,1]), unique([2, 1, 2]))
0-element Array{Int64,1}</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/8dc4fc13a65ede21b7a31456a27d4af4a006fa2a/base/abstractset.jl#L151-L174">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.symdiff!" href="#Base.symdiff!"><code>Base.symdiff!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">symdiff!(s::Union{AbstractSet,AbstractVector}, itrs...)</code></pre><p>Construct the symmetric difference of the passed in sets, and overwrite <code>s</code> with the result. When <code>s</code> is an array, the order is maintained. Note that in this case the multiplicity of elements matters.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/8dc4fc13a65ede21b7a31456a27d4af4a006fa2a/base/abstractset.jl#L178-L184">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.intersect!" href="#Base.intersect!"><code>Base.intersect!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">intersect!(s::Union{AbstractSet,AbstractVector}, itrs...)</code></pre><p>Intersect all passed in sets and overwrite <code>s</code> with the result. Maintain order with arrays.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/8dc4fc13a65ede21b7a31456a27d4af4a006fa2a/base/abstractset.jl#L104-L109">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.issubset" href="#Base.issubset"><code>Base.issubset</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">issubset(a, b)
⊆(a,b) -&gt; Bool
⊈(a,b) -&gt; Bool
⊊(a,b) -&gt; Bool</code></pre><p>Determine whether every element of <code>a</code> is also in <code>b</code>, using <a href="#Base.in"><code>in</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; issubset([1, 2], [1, 2, 3])
true

julia&gt; issubset([1, 2, 3], [1, 2])
false</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/8dc4fc13a65ede21b7a31456a27d4af4a006fa2a/base/abstractset.jl#L200-L216">source</a></section><p>Fully implemented by:</p><ul><li><p><a href="#Base.BitSet"><code>BitSet</code></a></p></li><li><p><a href="#Base.Set"><code>Set</code></a></p></li></ul><p>Partially implemented by:</p><ul><li><p><a href="../arrays/#Core.Array"><code>Array</code></a></p></li></ul><h2><a class="nav-anchor" id="Dequeues-1" href="#Dequeues-1">Dequeues</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.push!" href="#Base.push!"><code>Base.push!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">push!(collection, items...) -&gt; collection</code></pre><p>Insert one or more <code>items</code> at the end of <code>collection</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; push!([1, 2, 3], 4, 5, 6)
6-element Array{Int64,1}:
 1
 2
 3
 4
 5
 6</code></pre><p>Use <a href="#Base.append!"><code>append!</code></a> to add all the elements of another collection to <code>collection</code>. The result of the preceding example is equivalent to <code>append!([1, 2, 3], [4, 5, 6])</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/8dc4fc13a65ede21b7a31456a27d4af4a006fa2a/base/array.jl#L769-L789">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.pop!" href="#Base.pop!"><code>Base.pop!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">pop!(collection) -&gt; item</code></pre><p>Remove an item in <code>collection</code> and return it. If <code>collection</code> is an ordered container, the last item is returned.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A=[1, 2, 3]
3-element Array{Int64,1}:
 1
 2
 3

julia&gt; pop!(A)
3

julia&gt; A
2-element Array{Int64,1}:
 1
 2

julia&gt; S = Set([1, 2])
Set([2, 1])

julia&gt; pop!(S)
2

julia&gt; S
Set([1])

julia&gt; pop!(Dict(1=&gt;2))
1 =&gt; 2</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/8dc4fc13a65ede21b7a31456a27d4af4a006fa2a/base/array.jl#L965-L999">source</a><div><div><pre><code class="language-none">pop!(collection, key[, default])</code></pre><p>Delete and return the mapping for <code>key</code> if it exists in <code>collection</code>, otherwise return <code>default</code>, or throw an error if <code>default</code> is not specified.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; d = Dict(&quot;a&quot;=&gt;1, &quot;b&quot;=&gt;2, &quot;c&quot;=&gt;3);

julia&gt; pop!(d, &quot;a&quot;)
1

julia&gt; pop!(d, &quot;d&quot;)
ERROR: KeyError: key &quot;d&quot; not found
Stacktrace:
[...]

julia&gt; pop!(d, &quot;e&quot;, 4)
4</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/8dc4fc13a65ede21b7a31456a27d4af4a006fa2a/base/dict.jl#L582-L603">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.pushfirst!" href="#Base.pushfirst!"><code>Base.pushfirst!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">pushfirst!(collection, items...) -&gt; collection</code></pre><p>Insert one or more <code>items</code> at the beginning of <code>collection</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; pushfirst!([1, 2, 3, 4], 5, 6)
6-element Array{Int64,1}:
 5
 6
 1
 2
 3
 4</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/8dc4fc13a65ede21b7a31456a27d4af4a006fa2a/base/array.jl#L1009-L1025">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.popfirst!" href="#Base.popfirst!"><code>Base.popfirst!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">popfirst!(collection) -&gt; item</code></pre><p>Remove the first <code>item</code> from <code>collection</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1, 2, 3, 4, 5, 6]
6-element Array{Int64,1}:
 1
 2
 3
 4
 5
 6

julia&gt; popfirst!(A)
1

julia&gt; A
5-element Array{Int64,1}:
 2
 3
 4
 5
 6</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/8dc4fc13a65ede21b7a31456a27d4af4a006fa2a/base/array.jl#L1033-L1060">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.insert!" href="#Base.insert!"><code>Base.insert!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">insert!(a::Vector, index::Integer, item)</code></pre><p>Insert an <code>item</code> into <code>a</code> at the given <code>index</code>. <code>index</code> is the index of <code>item</code> in the resulting <code>a</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; insert!([6, 5, 4, 2, 1], 4, 3)
6-element Array{Int64,1}:
 6
 5
 4
 3
 2
 1</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/8dc4fc13a65ede21b7a31456a27d4af4a006fa2a/base/array.jl#L1070-L1087">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.deleteat!" href="#Base.deleteat!"><code>Base.deleteat!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">deleteat!(a::Vector, i::Integer)</code></pre><p>Remove the item at the given <code>i</code> and return the modified <code>a</code>. Subsequent items are shifted to fill the resulting gap.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; deleteat!([6, 5, 4, 3, 2, 1], 2)
5-element Array{Int64,1}:
 6
 4
 3
 2
 1</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/8dc4fc13a65ede21b7a31456a27d4af4a006fa2a/base/array.jl#L1097-L1113">source</a><div><div><pre><code class="language-none">deleteat!(a::Vector, inds)</code></pre><p>Remove the items at the indices given by <code>inds</code>, and return the modified <code>a</code>. Subsequent items are shifted to fill the resulting gap.</p><p><code>inds</code> can be either an iterator or a collection of sorted and unique integer indices, or a boolean vector of the same length as <code>a</code> with <code>true</code> indicating entries to delete.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; deleteat!([6, 5, 4, 3, 2, 1], 1:2:5)
3-element Array{Int64,1}:
 5
 3
 1

julia&gt; deleteat!([6, 5, 4, 3, 2, 1], [true, false, true, false, true, false])
3-element Array{Int64,1}:
 5
 3
 1

julia&gt; deleteat!([6, 5, 4, 3, 2, 1], (2, 2))
ERROR: ArgumentError: indices must be unique and sorted
Stacktrace:
[...]</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/8dc4fc13a65ede21b7a31456a27d4af4a006fa2a/base/array.jl#L1122-L1150">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.splice!" href="#Base.splice!"><code>Base.splice!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">splice!(a::Vector, index::Integer, [replacement]) -&gt; item</code></pre><p>Remove the item at the given index, and return the removed item. Subsequent items are shifted left to fill the resulting gap. If specified, replacement values from an ordered collection will be spliced in place of the removed item.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [6, 5, 4, 3, 2, 1]; splice!(A, 5)
2

julia&gt; A
5-element Array{Int64,1}:
 6
 5
 4
 3
 1

julia&gt; splice!(A, 5, -1)
1

julia&gt; A
5-element Array{Int64,1}:
  6
  5
  4
  3
 -1

julia&gt; splice!(A, 1, [-1, -2, -3])
6

julia&gt; A
7-element Array{Int64,1}:
 -1
 -2
 -3
  5
  4
  3
 -1</code></pre><p>To insert <code>replacement</code> before an index <code>n</code> without removing any items, use <code>splice!(collection, n:n-1, replacement)</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/8dc4fc13a65ede21b7a31456a27d4af4a006fa2a/base/array.jl#L1198-L1246">source</a><div><div><pre><code class="language-none">splice!(a::Vector, range, [replacement]) -&gt; items</code></pre><p>Remove items in the specified index range, and return a collection containing the removed items. Subsequent items are shifted left to fill the resulting gap. If specified, replacement values from an ordered collection will be spliced in place of the removed items.</p><p>To insert <code>replacement</code> before an index <code>n</code> without removing any items, use <code>splice!(collection, n:n-1, replacement)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; splice!(A, 4:3, 2)
0-element Array{Int64,1}

julia&gt; A
8-element Array{Int64,1}:
 -1
 -2
 -3
  2
  5
  4
  3
 -1</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/8dc4fc13a65ede21b7a31456a27d4af4a006fa2a/base/array.jl#L1265-L1293">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.resize!" href="#Base.resize!"><code>Base.resize!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">resize!(a::Vector, n::Integer) -&gt; Vector</code></pre><p>Resize <code>a</code> to contain <code>n</code> elements. If <code>n</code> is smaller than the current collection length, the first <code>n</code> elements will be retained. If <code>n</code> is larger, the new elements are not guaranteed to be initialized.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; resize!([6, 5, 4, 3, 2, 1], 3)
3-element Array{Int64,1}:
 6
 5
 4

julia&gt; a = resize!([6, 5, 4, 3, 2, 1], 8);

julia&gt; length(a)
8

julia&gt; a[1:6]
6-element Array{Int64,1}:
 6
 5
 4
 3
 2
 1</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/8dc4fc13a65ede21b7a31456a27d4af4a006fa2a/base/array.jl#L910-L939">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.append!" href="#Base.append!"><code>Base.append!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">append!(collection, collection2) -&gt; collection.</code></pre><p>Add the elements of <code>collection2</code> to the end of <code>collection</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; append!([1],[2,3])
3-element Array{Int64,1}:
 1
 2
 3

julia&gt; append!([1, 2, 3], [4, 5, 6])
6-element Array{Int64,1}:
 1
 2
 3
 4
 5
 6</code></pre><p>Use <a href="#Base.push!"><code>push!</code></a> to add individual items to <code>collection</code> which are not already themselves in another collection. The result is of the preceding example is equivalent to <code>push!([1, 2, 3], 4, 5, 6)</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/8dc4fc13a65ede21b7a31456a27d4af4a006fa2a/base/array.jl#L806-L832">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.prepend!" href="#Base.prepend!"><code>Base.prepend!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">prepend!(a::Vector, items) -&gt; collection</code></pre><p>Insert the elements of <code>items</code> to the beginning of <code>a</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; prepend!([3],[1,2])
3-element Array{Int64,1}:
 1
 2
 3</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/8dc4fc13a65ede21b7a31456a27d4af4a006fa2a/base/array.jl#L860-L873">source</a></section><p>Fully implemented by:</p><ul><li><p><code>Vector</code> (a.k.a. 1-dimensional <a href="../arrays/#Core.Array"><code>Array</code></a>)</p></li><li><p><code>BitVector</code> (a.k.a. 1-dimensional <a href="../arrays/#Base.BitArray"><code>BitArray</code></a>)</p></li></ul><h2><a class="nav-anchor" id="Utility-Collections-1" href="#Utility-Collections-1">Utility Collections</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Pair" href="#Base.Pair"><code>Base.Pair</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Pair(x, y)
x =&gt; y</code></pre><p>Construct a <code>Pair</code> object with type <code>Pair{typeof(x), typeof(y)}</code>. The elements are stored in the fields <code>first</code> and <code>second</code>. They can also be accessed via iteration.</p><p>See also: <a href="#Base.Dict"><code>Dict</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; p = &quot;foo&quot; =&gt; 7
&quot;foo&quot; =&gt; 7

julia&gt; typeof(p)
Pair{String,Int64}

julia&gt; p.first
&quot;foo&quot;

julia&gt; for x in p
           println(x)
       end
foo
7</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/8dc4fc13a65ede21b7a31456a27d4af4a006fa2a/base/pair.jl#L3-L30">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Iterators.Pairs" href="#Base.Iterators.Pairs"><code>Base.Iterators.Pairs</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Iterators.Pairs(values, keys) &lt;: AbstractDict{eltype(keys), eltype(values)}</code></pre><p>Transforms an indexable container into an Dictionary-view of the same data. Modifying the key-space of the underlying data may invalidate this object.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/8dc4fc13a65ede21b7a31456a27d4af4a006fa2a/base/iterators.jl#L156-L161">source</a></section><footer><hr/><a class="previous" href="../base/"><span class="direction">Previous</span><span class="title">Essentials</span></a><a class="next" href="../math/"><span class="direction">Next</span><span class="title">Mathematics</span></a></footer></article></body></html>
