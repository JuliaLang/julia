<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Mathematics · The Julia Language</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-28835595-6', 'auto');
ga('send', 'pageview');
</script><link rel="canonical" href="https://docs.julialang.org/en/stable/base/math/index.html"/><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../../index.html"><img class="logo" src="../../assets/logo.png" alt="The Julia Language logo"/></a><h1>The Julia Language</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../../manual/introduction/">Introduction</a></li><li><a class="toctext" href="../../manual/getting-started/">Getting Started</a></li><li><a class="toctext" href="../../manual/variables/">Variables</a></li><li><a class="toctext" href="../../manual/integers-and-floating-point-numbers/">Integers and Floating-Point Numbers</a></li><li><a class="toctext" href="../../manual/mathematical-operations/">Mathematical Operations and Elementary Functions</a></li><li><a class="toctext" href="../../manual/complex-and-rational-numbers/">Complex and Rational Numbers</a></li><li><a class="toctext" href="../../manual/strings/">Strings</a></li><li><a class="toctext" href="../../manual/functions/">Functions</a></li><li><a class="toctext" href="../../manual/control-flow/">Control Flow</a></li><li><a class="toctext" href="../../manual/variables-and-scoping/">Scope of Variables</a></li><li><a class="toctext" href="../../manual/types/">Types</a></li><li><a class="toctext" href="../../manual/methods/">Methods</a></li><li><a class="toctext" href="../../manual/constructors/">Constructors</a></li><li><a class="toctext" href="../../manual/conversion-and-promotion/">Conversion and Promotion</a></li><li><a class="toctext" href="../../manual/interfaces/">Interfaces</a></li><li><a class="toctext" href="../../manual/modules/">Modules</a></li><li><a class="toctext" href="../../manual/documentation/">Documentation</a></li><li><a class="toctext" href="../../manual/metaprogramming/">Metaprogramming</a></li><li><a class="toctext" href="../../manual/arrays/">Multi-dimensional Arrays</a></li><li><a class="toctext" href="../../manual/missing/">Missing Values</a></li><li><a class="toctext" href="../../manual/networking-and-streams/">Networking and Streams</a></li><li><a class="toctext" href="../../manual/parallel-computing/">Parallel Computing</a></li><li><a class="toctext" href="../../manual/running-external-programs/">Running External Programs</a></li><li><a class="toctext" href="../../manual/calling-c-and-fortran-code/">Calling C and Fortran Code</a></li><li><a class="toctext" href="../../manual/handling-operating-system-variation/">Handling Operating System Variation</a></li><li><a class="toctext" href="../../manual/environment-variables/">Environment Variables</a></li><li><a class="toctext" href="../../manual/embedding/">Embedding Julia</a></li><li><a class="toctext" href="../../manual/packages/">Packages</a></li><li><a class="toctext" href="../../manual/profile/">Profiling</a></li><li><a class="toctext" href="../../manual/stacktraces/">Stack Traces</a></li><li><a class="toctext" href="../../manual/performance-tips/">Performance Tips</a></li><li><a class="toctext" href="../../manual/workflow-tips/">Workflow Tips</a></li><li><a class="toctext" href="../../manual/style-guide/">Style Guide</a></li><li><a class="toctext" href="../../manual/faq/">Frequently Asked Questions</a></li><li><a class="toctext" href="../../manual/noteworthy-differences/">Noteworthy Differences from other Languages</a></li><li><a class="toctext" href="../../manual/unicode-input/">Unicode Input</a></li></ul></li><li><span class="toctext">Base</span><ul><li><a class="toctext" href="../base/">Essentials</a></li><li><a class="toctext" href="../collections/">Collections and Data Structures</a></li><li class="current"><a class="toctext" href>Mathematics</a><ul class="internal"><li><a class="toctext" href="#math-ops-1">Mathematical Operators</a></li><li><a class="toctext" href="#Mathematical-Functions-1">Mathematical Functions</a></li><li><a class="toctext" href="#Statistics-1">Statistics</a></li></ul></li><li><a class="toctext" href="../numbers/">Numbers</a></li><li><a class="toctext" href="../strings/">Strings</a></li><li><a class="toctext" href="../arrays/">Arrays</a></li><li><a class="toctext" href="../parallel/">Tasks</a></li><li><a class="toctext" href="../multi-threading/">Multi-Threading</a></li><li><a class="toctext" href="../constants/">Constants</a></li><li><a class="toctext" href="../file/">Filesystem</a></li><li><a class="toctext" href="../io-network/">I/O and Network</a></li><li><a class="toctext" href="../punctuation/">Punctuation</a></li><li><a class="toctext" href="../sort/">Sorting and Related Functions</a></li><li><a class="toctext" href="../iterators/">Iteration utilities</a></li><li><a class="toctext" href="../c/">C Interface</a></li><li><a class="toctext" href="../libc/">C Standard Library</a></li><li><a class="toctext" href="../stacktraces/">StackTraces</a></li><li><a class="toctext" href="../simd-types/">SIMD Support</a></li></ul></li><li><span class="toctext">Standard Library</span><ul><li><a class="toctext" href="../../stdlib/Base64/">Base64</a></li><li><a class="toctext" href="../../stdlib/CRC32c/">CRC32c</a></li><li><a class="toctext" href="../../stdlib/Dates/">Dates</a></li><li><a class="toctext" href="../../stdlib/DelimitedFiles/">Delimited Files</a></li><li><a class="toctext" href="../../stdlib/Distributed/">Distributed Computing</a></li><li><a class="toctext" href="../../stdlib/FileWatching/">File Events</a></li><li><a class="toctext" href="../../stdlib/InteractiveUtils/">Interactive Utilities</a></li><li><a class="toctext" href="../../stdlib/IterativeEigensolvers/">Iterative Eigensolvers</a></li><li><a class="toctext" href="../../stdlib/LibGit2/">LibGit2</a></li><li><a class="toctext" href="../../stdlib/Libdl/">Dynamic Linker</a></li><li><a class="toctext" href="../../stdlib/LinearAlgebra/">Linear Algebra</a></li><li><a class="toctext" href="../../stdlib/Logging/">Logging</a></li><li><a class="toctext" href="../../stdlib/Markdown/">Markdown</a></li><li><a class="toctext" href="../../stdlib/Mmap/">Memory-mapped I/O</a></li><li><a class="toctext" href="../../stdlib/Pkg/">Package Manager Functions</a></li><li><a class="toctext" href="../../stdlib/Pkg3/">Pkg3.jl</a></li><li><a class="toctext" href="../../stdlib/Printf/">Printf</a></li><li><a class="toctext" href="../../stdlib/Profile/">Profiling</a></li><li><a class="toctext" href="../../stdlib/REPL/">The Julia REPL</a></li><li><a class="toctext" href="../../stdlib/Random/">Random Numbers</a></li><li><a class="toctext" href="../../stdlib/SHA/">SHA</a></li><li><a class="toctext" href="../../stdlib/Serialization/">Serialization</a></li><li><a class="toctext" href="../../stdlib/SharedArrays/">Shared Arrays</a></li><li><a class="toctext" href="../../stdlib/Sockets/">Sockets</a></li><li><a class="toctext" href="../../stdlib/SparseArrays/">Sparse Arrays</a></li><li><a class="toctext" href="../../stdlib/Test/">Unit Testing</a></li><li><a class="toctext" href="../../stdlib/UUIDs/">UUIDs</a></li><li><a class="toctext" href="../../stdlib/Unicode/">Unicode</a></li></ul></li><li><span class="toctext">Developer Documentation</span><ul><li><a class="toctext" href="../../devdocs/reflection/">Reflection and introspection</a></li><li><span class="toctext">Documentation of Julia&#39;s Internals</span><ul><li><a class="toctext" href="../../devdocs/init/">Initialization of the Julia runtime</a></li><li><a class="toctext" href="../../devdocs/ast/">Julia ASTs</a></li><li><a class="toctext" href="../../devdocs/types/">More about types</a></li><li><a class="toctext" href="../../devdocs/object/">Memory layout of Julia Objects</a></li><li><a class="toctext" href="../../devdocs/eval/">Eval of Julia code</a></li><li><a class="toctext" href="../../devdocs/callconv/">Calling Conventions</a></li><li><a class="toctext" href="../../devdocs/compiler/">High-level Overview of the Native-Code Generation Process</a></li><li><a class="toctext" href="../../devdocs/functions/">Julia Functions</a></li><li><a class="toctext" href="../../devdocs/cartesian/">Base.Cartesian</a></li><li><a class="toctext" href="../../devdocs/meta/">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="../../devdocs/subarrays/">SubArrays</a></li><li><a class="toctext" href="../../devdocs/sysimg/">System Image Building</a></li><li><a class="toctext" href="../../devdocs/llvm/">Working with LLVM</a></li><li><a class="toctext" href="../../devdocs/stdio/">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="../../devdocs/boundscheck/">Bounds checking</a></li><li><a class="toctext" href="../../devdocs/locks/">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="../../devdocs/offset-arrays/">Arrays with custom indices</a></li><li><a class="toctext" href="../../devdocs/require/">Module loading</a></li><li><a class="toctext" href="../../devdocs/inference/">Inference</a></li></ul></li><li><span class="toctext">Developing/debugging Julia&#39;s C code</span><ul><li><a class="toctext" href="../../devdocs/backtraces/">Reporting and analyzing crashes (segfaults)</a></li><li><a class="toctext" href="../../devdocs/debuggingtips/">gdb debugging tips</a></li><li><a class="toctext" href="../../devdocs/valgrind/">Using Valgrind with Julia</a></li><li><a class="toctext" href="../../devdocs/sanitizers/">Sanitizer support</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Base</li><li><a href>Mathematics</a></li></ul><a class="edit-page" href="https://github.com/JuliaLang/julia/blob/master/doc/src/base/math.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Mathematics</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Mathematics-1" href="#Mathematics-1">Mathematics</a></h1><h2><a class="nav-anchor" id="math-ops-1" href="#math-ops-1">Mathematical Operators</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:--Tuple{Any}" href="#Base.:--Tuple{Any}"><code>Base.:-</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">-(x)</code></pre><p>Unary minus operator.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; -1
-1

julia&gt; -(2)
-2

julia&gt; -[1 2; 3 4]
2×2 Array{Int64,2}:
 -1  -2
 -3  -4</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/3666ffad817cfca8539afc589d4a8daa8c6db7cf/base/docs/basedocs.jl#L1536-L1554">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:+" href="#Base.:+"><code>Base.:+</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">+(x, y...)</code></pre><p>Addition operator. <code>x+y+z+...</code> calls this function with all arguments, i.e. <code>+(x, y, z, ...)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; 1 + 20 + 4
25

julia&gt; +(1, 20, 4)
25</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/3666ffad817cfca8539afc589d4a8daa8c6db7cf/base/docs/basedocs.jl#L1520-L1533">source</a><div><div><pre><code class="language-none">dt::Date + t::Time -&gt; DateTime</code></pre><p>The addition of a <code>Date</code> with a <code>Time</code> produces a <code>DateTime</code>. The hour, minute, second, and millisecond parts of the <code>Time</code> are used along with the year, month, and day of the <code>Date</code> to create the new <code>DateTime</code>. Non-zero microseconds or nanoseconds in the <code>Time</code> type will result in an <code>InexactError</code> being thrown.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/3666ffad817cfca8539afc589d4a8daa8c6db7cf/stdlib/Dates/src/arithmetic.jl#L12-L18">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:--Tuple{Any,Any}" href="#Base.:--Tuple{Any,Any}"><code>Base.:-</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">-(x, y)</code></pre><p>Subtraction operator.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; 2 - 3
-1

julia&gt; -(2, 4.5)
-2.5</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/3666ffad817cfca8539afc589d4a8daa8c6db7cf/base/docs/basedocs.jl#L1557-L1570">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:*-Tuple{Any,Vararg{Any,N} where N}" href="#Base.:*-Tuple{Any,Vararg{Any,N} where N}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">*(x, y...)</code></pre><p>Multiplication operator. <code>x*y*z*...</code> calls this function with all arguments, i.e. <code>*(x, y, z, ...)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; 2 * 7 * 8
112

julia&gt; *(2, 7, 8)
112</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/3666ffad817cfca8539afc589d4a8daa8c6db7cf/base/docs/basedocs.jl#L1573-L1586">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:/" href="#Base.:/"><code>Base.:/</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">/(x, y)</code></pre><p>Right division operator: multiplication of <code>x</code> by the inverse of <code>y</code> on the right. Gives floating-point results for integer arguments.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; 1/2
0.5

julia&gt; 4/2
2.0

julia&gt; 4.5/2
2.25</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/3666ffad817cfca8539afc589d4a8daa8c6db7cf/base/docs/basedocs.jl#L1589-L1606">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:\\-Tuple{Any,Any}" href="#Base.:\\-Tuple{Any,Any}"><code>Base.:\</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">\(x, y)</code></pre><p>Left division operator: multiplication of <code>y</code> by the inverse of <code>x</code> on the left. Gives floating-point results for integer arguments.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; 3 \ 6
2.0

julia&gt; inv(3) * 6
2.0

julia&gt; A = [1 2; 3 4]; x = [5, 6];

julia&gt; A \ x
2-element Array{Float64,1}:
 -4.0
  4.5

julia&gt; inv(A) * x
2-element Array{Float64,1}:
 -4.0
  4.5</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/3666ffad817cfca8539afc589d4a8daa8c6db7cf/base/operators.jl#L473-L499">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:^-Tuple{Number,Number}" href="#Base.:^-Tuple{Number,Number}"><code>Base.:^</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">^(x, y)</code></pre><p>Exponentiation operator. If <code>x</code> is a matrix, computes matrix exponentiation.</p><p>If <code>y</code> is an <code>Int</code> literal (e.g. <code>2</code> in <code>x^2</code> or <code>-3</code> in <code>x^-3</code>), the Julia code <code>x^y</code> is transformed by the compiler to <code>Base.literal_pow(^, x, Val(y))</code>, to enable compile-time specialization on the value of the exponent. (As a default fallback we have <code>Base.literal_pow(^, x, Val(y)) = ^(x,y)</code>, where usually <code>^ == Base.^</code> unless <code>^</code> has been defined in the calling namespace.)</p><pre><code class="language-julia-repl">julia&gt; 3^5
243

julia&gt; A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; A^3
2×2 Array{Int64,2}:
 37   54
 81  118</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/3666ffad817cfca8539afc589d4a8daa8c6db7cf/base/promotion.jl#L336-L362">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.fma" href="#Base.fma"><code>Base.fma</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">fma(x, y, z)</code></pre><p>Computes <code>x*y+z</code> without rounding the intermediate result <code>x*y</code>. On some systems this is significantly more expensive than <code>x*y+z</code>. <code>fma</code> is used to improve accuracy in certain algorithms. See <a href="#Base.muladd"><code>muladd</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/3666ffad817cfca8539afc589d4a8daa8c6db7cf/base/floatfuncs.jl#L281-L287">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.muladd" href="#Base.muladd"><code>Base.muladd</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">muladd(x, y, z)</code></pre><p>Combined multiply-add: computes <code>x*y+z</code>, but allowing the add and multiply to be merged with each other or with surrounding operations for performance. For example, this may be implemented as an <a href="#Base.fma"><code>fma</code></a> if the hardware supports it efficiently. The result can be different on different machines and can also be different on the same machine due to constant propagation or other optimizations. See <a href="#Base.fma"><code>fma</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; muladd(3, 2, 1)
7

julia&gt; 3 * 2 + 1
7</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/3666ffad817cfca8539afc589d4a8daa8c6db7cf/base/math.jl#L929-L948">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.inv-Tuple{Number}" href="#Base.inv-Tuple{Number}"><code>Base.inv</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">inv(x)</code></pre><p>Return the multiplicative inverse of <code>x</code>, such that <code>x*inv(x)</code> or <code>inv(x)*x</code> yields <a href="../numbers/#Base.one"><code>one(x)</code></a> (the multiplicative identity) up to roundoff errors.</p><p>If <code>x</code> is a number, this is essentially the same as <code>one(x)/x</code>, but for some types <code>inv(x)</code> may be slightly more efficient.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; inv(2)
0.5

julia&gt; inv(1 + 2im)
0.2 - 0.4im

julia&gt; inv(1 + 2im) * (1 + 2im)
1.0 + 0.0im

julia&gt; inv(2//3)
3//2</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/3666ffad817cfca8539afc589d4a8daa8c6db7cf/base/number.jl#L178-L201">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.div" href="#Base.div"><code>Base.div</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">div(x, y)
÷(x, y)</code></pre><p>The quotient from Euclidean division. Computes <code>x/y</code>, truncated to an integer.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; 9 ÷ 4
2

julia&gt; -5 ÷ 3
-1</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/3666ffad817cfca8539afc589d4a8daa8c6db7cf/base/operators.jl#L665-L679">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.fld" href="#Base.fld"><code>Base.fld</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">fld(x, y)</code></pre><p>Largest integer less than or equal to <code>x/y</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; fld(7.3,5.5)
1.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/3666ffad817cfca8539afc589d4a8daa8c6db7cf/base/operators.jl#L613-L623">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.cld" href="#Base.cld"><code>Base.cld</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">cld(x, y)</code></pre><p>Smallest integer larger than or equal to <code>x/y</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; cld(5.5,2.2)
3.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/3666ffad817cfca8539afc589d4a8daa8c6db7cf/base/operators.jl#L626-L636">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.mod" href="#Base.mod"><code>Base.mod</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">mod(x, y)
rem(x, y, RoundDown)</code></pre><p>The reduction of <code>x</code> modulo <code>y</code>, or equivalently, the remainder of <code>x</code> after floored division by <code>y</code>, i.e.</p><pre><code class="language-julia">x - y*fld(x,y)</code></pre><p>if computed without intermediate rounding.</p><p>The result will have the same sign as <code>y</code>, and magnitude less than <code>abs(y)</code> (with some exceptions, see note below).</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>When used with floating point values, the exact result may not be representable by the type, and so rounding error may occur. In particular, if the exact result is very close to <code>y</code>, then it may be rounded to <code>y</code>.</p></div></div><pre><code class="language-julia-repl">julia&gt; mod(8, 3)
2

julia&gt; mod(9, 3)
0

julia&gt; mod(8.9, 3)
2.9000000000000004

julia&gt; mod(eps(), 3)
2.220446049250313e-16

julia&gt; mod(-eps(), 3)
3.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/3666ffad817cfca8539afc589d4a8daa8c6db7cf/base/int.jl#L179-L215">source</a><div><div><pre><code class="language-none">rem(x::Integer, T::Type{&lt;:Integer}) -&gt; T
mod(x::Integer, T::Type{&lt;:Integer}) -&gt; T
%(x::Integer, T::Type{&lt;:Integer}) -&gt; T</code></pre><p>Find <code>y::T</code> such that <code>x</code> ≡ <code>y</code> (mod n), where n is the number of integers representable in <code>T</code>, and <code>y</code> is an integer in <code>[typemin(T),typemax(T)]</code>. If <code>T</code> can represent any integer (e.g. <code>T == BigInt</code>), then this operation corresponds to a conversion to <code>T</code>.</p><pre><code class="language-julia-repl">julia&gt; 129 % Int8
-127</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/3666ffad817cfca8539afc589d4a8daa8c6db7cf/base/int.jl#L469-L483">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.rem" href="#Base.rem"><code>Base.rem</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">rem(x, y)
%(x, y)</code></pre><p>Remainder from Euclidean division, returning a value of the same sign as <code>x</code>, and smaller in magnitude than <code>y</code>. This value is always exact.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; x = 15; y = 4;

julia&gt; x % y
3

julia&gt; x == div(x, y) * y + rem(x, y)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/3666ffad817cfca8539afc589d4a8daa8c6db7cf/base/operators.jl#L644-L661">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Math.rem2pi" href="#Base.Math.rem2pi"><code>Base.Math.rem2pi</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">rem2pi(x, r::RoundingMode)</code></pre><p>Compute the remainder of <code>x</code> after integer division by <code>2π</code>, with the quotient rounded according to the rounding mode <code>r</code>. In other words, the quantity</p><pre><code class="language-none">x - 2π*round(x/(2π),r)</code></pre><p>without any intermediate rounding. This internally uses a high precision approximation of 2π, and so will give a more accurate result than <code>rem(x,2π,r)</code></p><ul><li><p>if <code>r == RoundNearest</code>, then the result is in the interval <span>$[-π, π]$</span>. This will generally be the most accurate result.</p></li><li><p>if <code>r == RoundToZero</code>, then the result is in the interval <span>$[0, 2π]$</span> if <code>x</code> is positive,. or <span>$[-2π, 0]$</span> otherwise.</p></li><li><p>if <code>r == RoundDown</code>, then the result is in the interval <span>$[0, 2π]$</span>.</p></li><li><p>if <code>r == RoundUp</code>, then the result is in the interval <span>$[-2π, 0]$</span>.</p></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; rem2pi(7pi/4, RoundNearest)
-0.7853981633974485

julia&gt; rem2pi(7pi/4, RoundDown)
5.497787143782138</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/3666ffad817cfca8539afc589d4a8daa8c6db7cf/base/math.jl#L763-L792">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Math.mod2pi" href="#Base.Math.mod2pi"><code>Base.Math.mod2pi</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">mod2pi(x)</code></pre><p>Modulus after division by <code>2π</code>, returning in the range <span>$[0,2π)$</span>.</p><p>This function computes a floating point representation of the modulus after division by numerically exact <code>2π</code>, and is therefore not exactly the same as <code>mod(x,2π)</code>, which would compute the modulus of <code>x</code> relative to division by the floating-point number <code>2π</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; mod2pi(9*pi/4)
0.7853981633974481</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/3666ffad817cfca8539afc589d4a8daa8c6db7cf/base/math.jl#L910-L924">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.divrem" href="#Base.divrem"><code>Base.divrem</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">divrem(x, y)</code></pre><p>The quotient and remainder from Euclidean division. Equivalent to <code>(div(x,y), rem(x,y))</code> or <code>(x÷y, x%y)</code>.</p><pre><code class="language-julia-repl">julia&gt; divrem(3,7)
(0, 3)

julia&gt; divrem(7,3)
(2, 1)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/3666ffad817cfca8539afc589d4a8daa8c6db7cf/base/number.jl#L75-L88">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.fldmod" href="#Base.fldmod"><code>Base.fldmod</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">fldmod(x, y)</code></pre><p>The floored quotient and modulus after division. Equivalent to <code>(fld(x,y), mod(x,y))</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/3666ffad817cfca8539afc589d4a8daa8c6db7cf/base/number.jl#L91-L95">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.fld1" href="#Base.fld1"><code>Base.fld1</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">fld1(x, y)</code></pre><p>Flooring division, returning a value consistent with <code>mod1(x,y)</code></p><p>See also: <a href="#Base.mod1"><code>mod1</code></a>, <a href="#Base.fldmod1"><code>fldmod1</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; x = 15; y = 4;

julia&gt; fld1(x, y)
4

julia&gt; x == fld(x, y) * y + mod(x, y)
true

julia&gt; x == (fld1(x, y) - 1) * y + mod1(x, y)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/3666ffad817cfca8539afc589d4a8daa8c6db7cf/base/operators.jl#L703-L723">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.mod1" href="#Base.mod1"><code>Base.mod1</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">mod1(x, y)</code></pre><p>Modulus after flooring division, returning a value <code>r</code> such that <code>mod(r, y) == mod(x, y)</code> in the range <span>$(0, y]$</span> for positive <code>y</code> and in the range <span>$[y,0)$</span> for negative <code>y</code>.</p><p>See also: <a href="#Base.fld1"><code>fld1</code></a>, <a href="#Base.fldmod1"><code>fldmod1</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; mod1(4, 2)
2

julia&gt; mod1(4, 3)
1</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/3666ffad817cfca8539afc589d4a8daa8c6db7cf/base/operators.jl#L683-L699">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.fldmod1" href="#Base.fldmod1"><code>Base.fldmod1</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">fldmod1(x, y)</code></pre><p>Return <code>(fld1(x,y), mod1(x,y))</code>.</p><p>See also: <a href="#Base.fld1"><code>fld1</code></a>, <a href="#Base.mod1"><code>mod1</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/3666ffad817cfca8539afc589d4a8daa8c6db7cf/base/operators.jl#L730-L736">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.://" href="#Base.://"><code>Base.://</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">//(num, den)</code></pre><p>Divide two integers or rational numbers, giving a <a href="../numbers/#Base.Rational"><code>Rational</code></a> result.</p><pre><code class="language-julia-repl">julia&gt; 3 // 5
3//5

julia&gt; (3 // 5) // (2 // 1)
3//10</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/3666ffad817cfca8539afc589d4a8daa8c6db7cf/base/rational.jl#L27-L39">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.rationalize" href="#Base.rationalize"><code>Base.rationalize</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">rationalize([T&lt;:Integer=Int,] x; tol::Real=eps(x))</code></pre><p>Approximate floating point number <code>x</code> as a <a href="../numbers/#Base.Rational"><code>Rational</code></a> number with components of the given integer type. The result will differ from <code>x</code> by no more than <code>tol</code>.</p><pre><code class="language-julia-repl">julia&gt; rationalize(5.6)
28//5

julia&gt; a = rationalize(BigInt, 10.3)
103//10

julia&gt; typeof(numerator(a))
BigInt</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/3666ffad817cfca8539afc589d4a8daa8c6db7cf/base/rational.jl#L109-L125">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.numerator" href="#Base.numerator"><code>Base.numerator</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">numerator(x)</code></pre><p>Numerator of the rational representation of <code>x</code>.</p><pre><code class="language-julia-repl">julia&gt; numerator(2//3)
2

julia&gt; numerator(4)
4</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/3666ffad817cfca8539afc589d4a8daa8c6db7cf/base/rational.jl#L188-L200">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.denominator" href="#Base.denominator"><code>Base.denominator</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">denominator(x)</code></pre><p>Denominator of the rational representation of <code>x</code>.</p><pre><code class="language-julia-repl">julia&gt; denominator(2//3)
3

julia&gt; denominator(4)
1</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/3666ffad817cfca8539afc589d4a8daa8c6db7cf/base/rational.jl#L204-L216">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:&lt;&lt;" href="#Base.:&lt;&lt;"><code>Base.:&lt;&lt;</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">&lt;&lt;(x, n)</code></pre><p>Left bit shift operator, <code>x &lt;&lt; n</code>. For <code>n &gt;= 0</code>, the result is <code>x</code> shifted left by <code>n</code> bits, filling with <code>0</code>s. This is equivalent to <code>x * 2^n</code>. For <code>n &lt; 0</code>, this is equivalent to <code>x &gt;&gt; -n</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Int8(3) &lt;&lt; 2
12

julia&gt; bitstring(Int8(3))
&quot;00000011&quot;

julia&gt; bitstring(Int8(12))
&quot;00001100&quot;</code></pre><p>See also <a href="#Base.:&gt;&gt;"><code>&gt;&gt;</code></a>, <a href="#Base.:&gt;&gt;&gt;"><code>&gt;&gt;&gt;</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/3666ffad817cfca8539afc589d4a8daa8c6db7cf/base/operators.jl#L506-L525">source</a><div><div><pre><code class="language-none">&lt;&lt;(B::BitVector, n) -&gt; BitVector</code></pre><p>Left bit shift operator, <code>B &lt;&lt; n</code>. For <code>n &gt;= 0</code>, the result is <code>B</code> with elements shifted <code>n</code> positions backwards, filling with <code>false</code> values. If <code>n &lt; 0</code>, elements are shifted forwards. Equivalent to <code>B &gt;&gt; -n</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; B = BitVector([true, false, true, false, false])
5-element BitArray{1}:
  true
 false
  true
 false
 false

julia&gt; B &lt;&lt; 1
5-element BitArray{1}:
 false
  true
 false
 false
 false

julia&gt; B &lt;&lt; -1
5-element BitArray{1}:
 false
  true
 false
  true
 false</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/3666ffad817cfca8539afc589d4a8daa8c6db7cf/base/bitarray.jl#L1375-L1409">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:&gt;&gt;" href="#Base.:&gt;&gt;"><code>Base.:&gt;&gt;</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">&gt;&gt;(x, n)</code></pre><p>Right bit shift operator, <code>x &gt;&gt; n</code>. For <code>n &gt;= 0</code>, the result is <code>x</code> shifted right by <code>n</code> bits, where <code>n &gt;= 0</code>, filling with <code>0</code>s if <code>x &gt;= 0</code>, <code>1</code>s if <code>x &lt; 0</code>, preserving the sign of <code>x</code>. This is equivalent to <code>fld(x, 2^n)</code>. For <code>n &lt; 0</code>, this is equivalent to <code>x &lt;&lt; -n</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Int8(13) &gt;&gt; 2
3

julia&gt; bitstring(Int8(13))
&quot;00001101&quot;

julia&gt; bitstring(Int8(3))
&quot;00000011&quot;

julia&gt; Int8(-14) &gt;&gt; 2
-4

julia&gt; bitstring(Int8(-14))
&quot;11110010&quot;

julia&gt; bitstring(Int8(-4))
&quot;11111100&quot;</code></pre><p>See also <a href="#Base.:&gt;&gt;&gt;"><code>&gt;&gt;&gt;</code></a>, <a href="#Base.:&lt;&lt;"><code>&lt;&lt;</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/3666ffad817cfca8539afc589d4a8daa8c6db7cf/base/operators.jl#L535-L564">source</a><div><div><pre><code class="language-none">&gt;&gt;(B::BitVector, n) -&gt; BitVector</code></pre><p>Right bit shift operator, <code>B &gt;&gt; n</code>. For <code>n &gt;= 0</code>, the result is <code>B</code> with elements shifted <code>n</code> positions forward, filling with <code>false</code> values. If <code>n &lt; 0</code>, elements are shifted backwards. Equivalent to <code>B &lt;&lt; -n</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; B = BitVector([true, false, true, false, false])
5-element BitArray{1}:
  true
 false
  true
 false
 false

julia&gt; B &gt;&gt; 1
5-element BitArray{1}:
 false
  true
 false
  true
 false

julia&gt; B &gt;&gt; -1
5-element BitArray{1}:
 false
  true
 false
 false
 false</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/3666ffad817cfca8539afc589d4a8daa8c6db7cf/base/bitarray.jl#L1337-L1371">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:&gt;&gt;&gt;" href="#Base.:&gt;&gt;&gt;"><code>Base.:&gt;&gt;&gt;</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">&gt;&gt;&gt;(x, n)</code></pre><p>Unsigned right bit shift operator, <code>x &gt;&gt;&gt; n</code>. For <code>n &gt;= 0</code>, the result is <code>x</code> shifted right by <code>n</code> bits, where <code>n &gt;= 0</code>, filling with <code>0</code>s. For <code>n &lt; 0</code>, this is equivalent to <code>x &lt;&lt; -n</code>.</p><p>For <a href="../numbers/#Core.Unsigned"><code>Unsigned</code></a> integer types, this is equivalent to <a href="#Base.:&gt;&gt;"><code>&gt;&gt;</code></a>. For <a href="../numbers/#Core.Signed"><code>Signed</code></a> integer types, this is equivalent to <code>signed(unsigned(x) &gt;&gt; n)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Int8(-14) &gt;&gt;&gt; 2
60

julia&gt; bitstring(Int8(-14))
&quot;11110010&quot;

julia&gt; bitstring(Int8(60))
&quot;00111100&quot;</code></pre><p><a href="../numbers/#Base.GMP.BigInt"><code>BigInt</code></a>s are treated as if having infinite size, so no filling is required and this is equivalent to <a href="#Base.:&gt;&gt;"><code>&gt;&gt;</code></a>.</p><p>See also <a href="#Base.:&gt;&gt;"><code>&gt;&gt;</code></a>, <a href="#Base.:&lt;&lt;"><code>&lt;&lt;</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/3666ffad817cfca8539afc589d4a8daa8c6db7cf/base/operators.jl#L574-L600">source</a><div><div><pre><code class="language-none">&gt;&gt;&gt;(B::BitVector, n) -&gt; BitVector</code></pre><p>Unsigned right bitshift operator, <code>B &gt;&gt;&gt; n</code>. Equivalent to <code>B &gt;&gt; n</code>. See <a href="#Base.:&gt;&gt;"><code>&gt;&gt;</code></a> for details and examples.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/3666ffad817cfca8539afc589d4a8daa8c6db7cf/base/bitarray.jl#L1412-L1417">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.::" href="#Base.::"><code>Base.::</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(:)(start, [step], stop)</code></pre><p>Range operator. <code>a:b</code> constructs a range from <code>a</code> to <code>b</code> with a step size of 1, and <code>a:s:b</code> is similar but uses a step size of <code>s</code>.</p><p><code>:</code> is also used in indexing to select whole dimensions.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/3666ffad817cfca8539afc589d4a8daa8c6db7cf/base/range.jl#L32-L39">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.range" href="#Base.range"><code>Base.range</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">range(start; length, stop, step=1)</code></pre><p>Given a starting value, construct a range either by length or from <code>start</code> to <code>stop</code>, optionally with a given step (defaults to 1). One of <code>length</code> or <code>step</code> is required. If <code>length</code>, <code>stop</code>, and <code>step</code> are all specified, they must agree.</p><p>If <code>length</code> and <code>stop</code> are provided and <code>step</code> is not, the step size will be computed automatically such that there are <code>length</code> linearly spaced elements in the range.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/3666ffad817cfca8539afc589d4a8daa8c6db7cf/base/range.jl#L49-L58">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.OneTo" href="#Base.OneTo"><code>Base.OneTo</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Base.OneTo(n)</code></pre><p>Define an <code>AbstractUnitRange</code> that behaves like <code>1:n</code>, with the added distinction that the lower limit is guaranteed (by the type system) to be 1.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/3666ffad817cfca8539afc589d4a8daa8c6db7cf/base/range.jl#L186-L192">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.StepRangeLen" href="#Base.StepRangeLen"><code>Base.StepRangeLen</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">StepRangeLen{T,R,S}(ref::R, step::S, len, [offset=1]) where {T,R,S}
StepRangeLen(       ref::R, step::S, len, [offset=1]) where {  R,S}</code></pre><p>A range <code>r</code> where <code>r[i]</code> produces values of type <code>T</code> (in the second form, <code>T</code> is deduced automatically), parameterized by a <code>ref</code>erence value, a <code>step</code>, and the <code>len</code>gth. By default <code>ref</code> is the starting value <code>r[1]</code>, but alternatively you can supply it as the value of <code>r[offset]</code> for some other index <code>1 &lt;= offset &lt;= len</code>. In conjunction with <code>TwicePrecision</code> this can be used to implement ranges that are free of roundoff error.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/3666ffad817cfca8539afc589d4a8daa8c6db7cf/base/range.jl#L201-L212">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:==" href="#Base.:=="><code>Base.:==</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">==(x, y)</code></pre><p>Generic equality operator. Falls back to <a href="../base/#Core.:==="><code>===</code></a>. Should be implemented for all types with a notion of equality, based on the abstract value that an instance represents. For example, all numeric types are compared by numeric value, ignoring type. Strings are compared as sequences of characters, ignoring encoding. For collections, <code>==</code> is generally called recursively on all contents, though other properties (like the shape for arrays) may also be taken into account.</p><p>This operator follows IEEE semantics for floating-point numbers: <code>0.0 == -0.0</code> and <code>NaN != NaN</code>.</p><p>The result is of type <code>Bool</code>, except when one of the operands is <a href="../base/#Base.missing"><code>missing</code></a>, in which case <code>missing</code> is returned (<a href="https://en.wikipedia.org/wiki/Three-valued_logic">three-valued logic</a>). For collections, <code>missing</code> is returned if at least one of the operands contains a <code>missing</code> value and all non-missing values are equal. Use <a href="../base/#Base.isequal"><code>isequal</code></a> or <a href="../base/#Core.:==="><code>===</code></a> to always get a <code>Bool</code> result.</p><p><strong>Implementation</strong></p><p>New numeric types should implement this function for two arguments of the new type, and handle comparison to other types via promotion rules where possible.</p><p><a href="../base/#Base.isequal"><code>isequal</code></a> falls back to <code>==</code>, so new methods of <code>==</code> will be used by the <a href="../collections/#Base.Dict"><code>Dict</code></a> type to compare keys. If your type will be used as a dictionary key, it should therefore also implement <a href="../base/#Base.hash"><code>hash</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/3666ffad817cfca8539afc589d4a8daa8c6db7cf/base/operators.jl#L53-L80">source</a><div><div><pre><code class="language-none">==(x)</code></pre><p>Create a function that compares its argument to <code>x</code> using <a href="#Base.:=="><code>==</code></a>, i.e. a function equivalent to <code>y -&gt; y == x</code>.</p><p>The returned function is of type <code>Base.Fix2{typeof(==)}</code>, which can be used to implement specialized methods.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/3666ffad817cfca8539afc589d4a8daa8c6db7cf/base/operators.jl#L861-L869">source</a><div><div><pre><code class="language-none">==(a::AbstractString, b::AbstractString) -&gt; Bool</code></pre><p>Test whether two strings are equal character by character (technically, Unicode code point by code point).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; &quot;abc&quot; == &quot;abc&quot;
true

julia&gt; &quot;abc&quot; == &quot;αβγ&quot;
false</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/3666ffad817cfca8539afc589d4a8daa8c6db7cf/base/strings/basic.jl#L265-L279">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:!=" href="#Base.:!="><code>Base.:!=</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">!=(x, y)
≠(x,y)</code></pre><p>Not-equals comparison operator. Always gives the opposite answer as <a href="#Base.:=="><code>==</code></a>.</p><p><strong>Implementation</strong></p><p>New types should generally not implement this, and rely on the fallback definition <code>!=(x,y) = !(x==y)</code> instead.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; 3 != 2
true

julia&gt; &quot;foo&quot; ≠ &quot;foo&quot;
false</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/3666ffad817cfca8539afc589d4a8daa8c6db7cf/base/operators.jl#L164-L182">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:!==" href="#Base.:!=="><code>Base.:!==</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">!==(x, y)
≢(x,y)</code></pre><p>Always gives the opposite answer as <a href="../base/#Core.:==="><code>===</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = [1, 2]; b = [1, 2];

julia&gt; a ≢ b
true

julia&gt; a ≢ a
false</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/3666ffad817cfca8539afc589d4a8daa8c6db7cf/base/operators.jl#L213-L229">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:&lt;" href="#Base.:&lt;"><code>Base.:&lt;</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">&lt;(x, y)</code></pre><p>Less-than comparison operator. Falls back to <a href="../base/#Base.isless"><code>isless</code></a>. Because of the behavior of floating-point NaN values, this operator implements a partial order.</p><p><strong>Implementation</strong></p><p>New numeric types with a canonical partial order should implement this function for two arguments of the new type. Types with a canonical total order should implement <a href="../base/#Base.isless"><code>isless</code></a> instead. (x &lt; y) | (x == y)</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; &#39;a&#39; &lt; &#39;b&#39;
true

julia&gt; &quot;abc&quot; &lt; &quot;abd&quot;
true

julia&gt; 5 &lt; 3
false</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/3666ffad817cfca8539afc589d4a8daa8c6db7cf/base/operators.jl#L233-L256">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:&lt;=" href="#Base.:&lt;="><code>Base.:&lt;=</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">&lt;=(x, y)
≤(x,y)</code></pre><p>Less-than-or-equals comparison operator. Falls back to <code>(x &lt; y) | (x == y)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; &#39;a&#39; &lt;= &#39;b&#39;
true

julia&gt; 7 ≤ 7 ≤ 9
true

julia&gt; &quot;abc&quot; ≤ &quot;abc&quot;
true

julia&gt; 5 &lt;= 3
false</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/3666ffad817cfca8539afc589d4a8daa8c6db7cf/base/operators.jl#L285-L305">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:&gt;" href="#Base.:&gt;"><code>Base.:&gt;</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">&gt;(x, y)</code></pre><p>Greater-than comparison operator. Falls back to <code>y &lt; x</code>.</p><p><strong>Implementation</strong></p><p>Generally, new types should implement <a href="#Base.:&lt;"><code>&lt;</code></a> instead of this function, and rely on the fallback definition <code>&gt;(x, y) = y &lt; x</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; &#39;a&#39; &gt; &#39;b&#39;
false

julia&gt; 7 &gt; 3 &gt; 1
true

julia&gt; &quot;abc&quot; &gt; &quot;abd&quot;
false

julia&gt; 5 &gt; 3
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/3666ffad817cfca8539afc589d4a8daa8c6db7cf/base/operators.jl#L259-L282">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:&gt;=" href="#Base.:&gt;="><code>Base.:&gt;=</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">&gt;=(x, y)
≥(x,y)</code></pre><p>Greater-than-or-equals comparison operator. Falls back to <code>y &lt;= x</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; &#39;a&#39; &gt;= &#39;b&#39;
false

julia&gt; 7 ≥ 7 ≥ 3
true

julia&gt; &quot;abc&quot; ≥ &quot;abc&quot;
true

julia&gt; 5 &gt;= 3
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/3666ffad817cfca8539afc589d4a8daa8c6db7cf/base/operators.jl#L309-L329">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.cmp" href="#Base.cmp"><code>Base.cmp</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">cmp(x,y)</code></pre><p>Return -1, 0, or 1 depending on whether <code>x</code> is less than, equal to, or greater than <code>y</code>, respectively. Uses the total order implemented by <code>isless</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; cmp(1, 2)
-1

julia&gt; cmp(2, 1)
1

julia&gt; cmp(2+im, 3-im)
ERROR: MethodError: no method matching isless(::Complex{Int64}, ::Complex{Int64})
[...]</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/3666ffad817cfca8539afc589d4a8daa8c6db7cf/base/operators.jl#L353-L371">source</a><div><div><pre><code class="language-none">cmp(&lt;, x, y)</code></pre><p>Return -1, 0, or 1 depending on whether <code>x</code> is less than, equal to, or greater than <code>y</code>, respectively. The first argument specifies a less-than comparison function to use.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/3666ffad817cfca8539afc589d4a8daa8c6db7cf/base/operators.jl#L374-L379">source</a><div><div><pre><code class="language-none">cmp(a::AbstractString, b::AbstractString) -&gt; Int</code></pre><p>Compare two strings. Return <code>0</code> if both strings have the same length and the character at each index is the same in both strings. Return <code>-1</code> if <code>a</code> is a prefix of <code>b</code>, or if <code>a</code> comes before <code>b</code> in alphabetical order. Return <code>1</code> if <code>b</code> is a prefix of <code>a</code>, or if <code>b</code> comes before <code>a</code> in alphabetical order (technically, lexicographical order by Unicode code points).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; cmp(&quot;abc&quot;, &quot;abc&quot;)
0

julia&gt; cmp(&quot;ab&quot;, &quot;abc&quot;)
-1

julia&gt; cmp(&quot;abc&quot;, &quot;ab&quot;)
1

julia&gt; cmp(&quot;ab&quot;, &quot;ac&quot;)
-1

julia&gt; cmp(&quot;ac&quot;, &quot;ab&quot;)
1

julia&gt; cmp(&quot;α&quot;, &quot;a&quot;)
1

julia&gt; cmp(&quot;b&quot;, &quot;β&quot;)
-1</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/3666ffad817cfca8539afc589d4a8daa8c6db7cf/base/strings/basic.jl#L222-L254">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:~" href="#Base.:~"><code>Base.:~</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">~(x)</code></pre><p>Bitwise not.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; ~4
-5

julia&gt; ~10
-11

julia&gt; ~true
false</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/3666ffad817cfca8539afc589d4a8daa8c6db7cf/base/int.jl#L254-L270">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:&amp;" href="#Base.:&amp;"><code>Base.:&amp;</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">&amp;(x, y)</code></pre><p>Bitwise and. Implements <a href="https://en.wikipedia.org/wiki/Three-valued_logic">three-valued logic</a>, returning <a href="../base/#Base.missing"><code>missing</code></a> if one operand is <code>missing</code> and the other is <code>true</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; 4 &amp; 10
0

julia&gt; 4 &amp; 12
4

julia&gt; true &amp; missing
missing

julia&gt; false &amp; missing
false</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/3666ffad817cfca8539afc589d4a8daa8c6db7cf/base/int.jl#L273-L293">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:|" href="#Base.:|"><code>Base.:|</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">|(x, y)</code></pre><p>Bitwise or. Implements <a href="https://en.wikipedia.org/wiki/Three-valued_logic">three-valued logic</a>, returning <a href="../base/#Base.missing"><code>missing</code></a> if one operand is <code>missing</code> and the other is <code>false</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; 4 | 10
14

julia&gt; 4 | 1
5

julia&gt; true | missing
true

julia&gt; false | missing
missing</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/3666ffad817cfca8539afc589d4a8daa8c6db7cf/base/int.jl#L296-L316">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.xor" href="#Base.xor"><code>Base.xor</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">xor(x, y)
⊻(x, y)</code></pre><p>Bitwise exclusive or of <code>x</code> and <code>y</code>. Implements <a href="https://en.wikipedia.org/wiki/Three-valued_logic">three-valued logic</a>, returning <a href="../base/#Base.missing"><code>missing</code></a> if one of the arguments is <code>missing</code>.</p><p>The infix operation <code>a ⊻ b</code> is a synonym for <code>xor(a,b)</code>, and <code>⊻</code> can be typed by tab-completing <code>\xor</code> or <code>\veebar</code> in the Julia REPL.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; xor(true, false)
true

julia&gt; xor(true, true)
false

julia&gt; xor(true, missing)
missing

julia&gt; false ⊻ false
false

julia&gt; [true; true; false] .⊻ [true; false; false]
3-element BitArray{1}:
 false
  true
 false</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/3666ffad817cfca8539afc589d4a8daa8c6db7cf/base/bool.jl#L43-L74">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:!" href="#Base.:!"><code>Base.:!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">!(x)</code></pre><p>Boolean not. Implements <a href="https://en.wikipedia.org/wiki/Three-valued_logic">three-valued logic</a>, returning <a href="../base/#Base.missing"><code>missing</code></a> if <code>x</code> is <code>missing</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; !true
false

julia&gt; !false
true

julia&gt; !missing
missing

julia&gt; .![true false true]
1×3 BitArray{2}:
 false  true  false</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/3666ffad817cfca8539afc589d4a8daa8c6db7cf/base/bool.jl#L11-L32">source</a><div><div><pre><code class="language-none">!f::Function</code></pre><p>Predicate function negation: when the argument of <code>!</code> is a function, it returns a function which computes the boolean negation of <code>f</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; str = &quot;∀ ε &gt; 0, ∃ δ &gt; 0: |x-y| &lt; δ ⇒ |f(x)-f(y)| &lt; ε&quot;
&quot;∀ ε &gt; 0, ∃ δ &gt; 0: |x-y| &lt; δ ⇒ |f(x)-f(y)| &lt; ε&quot;

julia&gt; filter(isalpha, str)
&quot;εδxyδfxfyε&quot;

julia&gt; filter(!isalpha, str)
&quot;∀  &gt; 0, ∃  &gt; 0: |-| &lt;  ⇒ |()-()| &lt; &quot;</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/3666ffad817cfca8539afc589d4a8daa8c6db7cf/base/operators.jl#L796-L813">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="&amp;&amp;" href="#&amp;&amp;"><code>&amp;&amp;</code></a> — <span class="docstring-category">Keyword</span>.</div><div><div><pre><code class="language-none">x &amp;&amp; y</code></pre><p>Short-circuiting boolean AND.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/3666ffad817cfca8539afc589d4a8daa8c6db7cf/base/docs/basedocs.jl#L616-L620">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="||" href="#||"><code>||</code></a> — <span class="docstring-category">Keyword</span>.</div><div><div><pre><code class="language-none">x || y</code></pre><p>Short-circuiting boolean OR.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/3666ffad817cfca8539afc589d4a8daa8c6db7cf/base/docs/basedocs.jl#L623-L627">source</a></section><h2><a class="nav-anchor" id="Mathematical-Functions-1" href="#Mathematical-Functions-1">Mathematical Functions</a></h2><pre><code class="language-none">Base.isapprox
Base.sin(::Number)
Base.cos(::Number)
Base.sincos(::Float64)
Base.tan(::Number)
Base.Math.sind
Base.Math.cosd
Base.Math.tand
Base.Math.sinpi
Base.Math.cospi
Base.sinh(::Number)
Base.cosh(::Number)
Base.tanh(::Number)
Base.asin(::Number)
Base.acos(::Number)
Base.atan(::Number)
Base.Math.atan2
Base.Math.asind
Base.Math.acosd
Base.Math.atand
Base.Math.sec(::Number)
Base.Math.csc(::Number)
Base.Math.cot(::Number)
Base.Math.secd
Base.Math.cscd
Base.Math.cotd
Base.Math.asec(::Number)
Base.Math.acsc(::Number)
Base.Math.acot(::Number)
Base.Math.asecd
Base.Math.acscd
Base.Math.acotd
Base.Math.sech(::Number)
Base.Math.csch(::Number)
Base.Math.coth(::Number)
Base.asinh(::Number)
Base.acosh(::Number)
Base.atanh(::Number)
Base.Math.asech(::Number)
Base.Math.acsch(::Number)
Base.Math.acoth(::Number)
Base.Math.sinc
Base.Math.cosc
Base.Math.deg2rad
Base.Math.rad2deg
Base.Math.hypot
Base.log(::Number)
Base.log(::Number, ::Number)
Base.log2
Base.log10
Base.log1p
Base.Math.frexp
Base.exp(::Float64)
Base.exp2
Base.exp10
Base.Math.ldexp
Base.Math.modf
Base.expm1
Base.round(::Type, ::Any)
Base.Rounding.RoundingMode
Base.Rounding.RoundNearest
Base.Rounding.RoundNearestTiesAway
Base.Rounding.RoundNearestTiesUp
Base.Rounding.RoundToZero
Base.Rounding.RoundUp
Base.Rounding.RoundDown
Base.round{T &lt;: AbstractFloat, MR, MI}(::Complex{T}, ::RoundingMode{MR}, ::RoundingMode{MI})
Base.ceil
Base.floor
Base.trunc
Base.unsafe_trunc
Base.signif
Base.min
Base.max
Base.minmax
Base.Math.clamp
Base.Math.clamp!
Base.abs
Base.Checked.checked_abs
Base.Checked.checked_neg
Base.Checked.checked_add
Base.Checked.checked_sub
Base.Checked.checked_mul
Base.Checked.checked_div
Base.Checked.checked_rem
Base.Checked.checked_fld
Base.Checked.checked_mod
Base.Checked.checked_cld
Base.Checked.add_with_overflow
Base.Checked.sub_with_overflow
Base.Checked.mul_with_overflow
Base.abs2
Base.copysign
Base.sign
Base.signbit
Base.flipsign
Base.sqrt(::Real)
Base.isqrt
Base.Math.cbrt
Base.real(::Complex)
Base.imag
Base.reim
Base.conj
Base.angle
Base.cis
Base.binomial
Base.factorial
Base.gcd
Base.lcm
Base.gcdx
Base.ispow2
Base.nextpow2
Base.prevpow2
Base.nextpow
Base.prevpow
Base.nextprod
Base.invmod
Base.powermod
Base.Math.gamma
Base.Math.lgamma
Base.Math.lfact
Base.Math.beta
Base.Math.lbeta
Base.ndigits
Base.widemul
Base.Math.@evalpoly
Base.FastMath.@fastmath</code></pre><h2><a class="nav-anchor" id="Statistics-1" href="#Statistics-1">Statistics</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.mean" href="#Base.mean"><code>Base.mean</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">mean(f::Function, v)</code></pre><p>Apply the function <code>f</code> to each element of <code>v</code> and take the mean.</p><pre><code class="language-julia-repl">julia&gt; mean(√, [1, 2, 3])
1.3820881233139908

julia&gt; mean([√1, √2, √3])
1.3820881233139908</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/3666ffad817cfca8539afc589d4a8daa8c6db7cf/base/statistics.jl#L5-L17">source</a><div><div><pre><code class="language-none">mean(v; dims)</code></pre><p>Compute the mean of whole array <code>v</code>, or optionally along the given dimensions.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Julia does not ignore <code>NaN</code> values in the computation. Use the <a href="../base/#Base.missing"><code>missing</code></a> type to represent missing values, and the <a href="../base/#Base.skipmissing"><code>skipmissing</code></a> function to omit them.</p></div></div></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/3666ffad817cfca8539afc589d4a8daa8c6db7cf/base/statistics.jl#L66-L74">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.mean!" href="#Base.mean!"><code>Base.mean!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">mean!(r, v)</code></pre><p>Compute the mean of <code>v</code> over the singleton dimensions of <code>r</code>, and write results to <code>r</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; v = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; mean!([1., 1.], v)
2-element Array{Float64,1}:
 1.5
 3.5

julia&gt; mean!([1. 1.], v)
1×2 Array{Float64,2}:
 2.0  3.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/3666ffad817cfca8539afc589d4a8daa8c6db7cf/base/statistics.jl#L37-L58">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.std" href="#Base.std"><code>Base.std</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">std(v; corrected::Bool=true, mean=nothing, dims)</code></pre><p>Compute the sample standard deviation of a vector or array <code>v</code>, optionally along the given dimensions. The algorithm returns an estimator of the generative distribution&#39;s standard deviation under the assumption that each entry of <code>v</code> is an IID drawn from that generative distribution. This computation is equivalent to calculating <code>sqrt(sum((v - mean(v)).^2) / (length(v) - 1))</code>. A pre-computed <code>mean</code> may be provided. If <code>corrected</code> is <code>true</code>, then the sum is scaled with <code>n-1</code>, whereas the sum is scaled with <code>n</code> if <code>corrected</code> is <code>false</code> where <code>n = length(x)</code>.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Julia does not ignore <code>NaN</code> values in the computation. Use the <a href="../base/#Base.missing"><code>missing</code></a> type to represent missing values, and the <a href="../base/#Base.skipmissing"><code>skipmissing</code></a> function to omit them.</p></div></div></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/3666ffad817cfca8539afc589d4a8daa8c6db7cf/base/statistics.jl#L272-L286">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.stdm" href="#Base.stdm"><code>Base.stdm</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">stdm(v, m; corrected::Bool=true)</code></pre><p>Compute the sample standard deviation of a vector <code>v</code> with known mean <code>m</code>. If <code>corrected</code> is <code>true</code>, then the sum is scaled with <code>n-1</code>, whereas the sum is scaled with <code>n</code> if <code>corrected</code> is <code>false</code> where <code>n = length(x)</code>.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Julia does not ignore <code>NaN</code> values in the computation. Use the <a href="../base/#Base.missing"><code>missing</code></a> type to represent missing values, and the <a href="../base/#Base.skipmissing"><code>skipmissing</code></a> function to omit them.</p></div></div></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/3666ffad817cfca8539afc589d4a8daa8c6db7cf/base/statistics.jl#L304-L315">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.var" href="#Base.var"><code>Base.var</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">var(v; dims, corrected::Bool=true, mean=nothing)</code></pre><p>Compute the sample variance of a vector or array <code>v</code>, optionally along the given dimensions. The algorithm will return an estimator of the generative distribution&#39;s variance under the assumption that each entry of <code>v</code> is an IID drawn from that generative distribution. This computation is equivalent to calculating <code>sum(abs2, v - mean(v)) / (length(v) - 1)</code>. If <code>corrected</code> is <code>true</code>, then the sum is scaled with <code>n-1</code>, whereas the sum is scaled with <code>n</code> if <code>corrected</code> is <code>false</code> where <code>n = length(x)</code>. The mean <code>mean</code> over the region may be provided.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Julia does not ignore <code>NaN</code> values in the computation. Use the <a href="../base/#Base.missing"><code>missing</code></a> type to represent missing values, and the <a href="../base/#Base.skipmissing"><code>skipmissing</code></a> function to omit them.</p></div></div></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/3666ffad817cfca8539afc589d4a8daa8c6db7cf/base/statistics.jl#L208-L222">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.varm" href="#Base.varm"><code>Base.varm</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">varm(v, m; dims, corrected::Bool=true)</code></pre><p>Compute the sample variance of a collection <code>v</code> with known mean(s) <code>m</code>, optionally over the given dimensions. <code>m</code> may contain means for each dimension of <code>v</code>. If <code>corrected</code> is <code>true</code>, then the sum is scaled with <code>n-1</code>, whereas the sum is scaled with <code>n</code> if <code>corrected</code> is <code>false</code> where <code>n = length(x)</code>.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Julia does not ignore <code>NaN</code> values in the computation. Use the <a href="../base/#Base.missing"><code>missing</code></a> type to represent missing values, and the <a href="../base/#Base.skipmissing"><code>skipmissing</code></a> function to omit them.</p></div></div></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/3666ffad817cfca8539afc589d4a8daa8c6db7cf/base/statistics.jl#L182-L193">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.middle" href="#Base.middle"><code>Base.middle</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">middle(x)</code></pre><p>Compute the middle of a scalar value, which is equivalent to <code>x</code> itself, but of the type of <code>middle(x, x)</code> for consistency.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/3666ffad817cfca8539afc589d4a8daa8c6db7cf/base/statistics.jl#L560-L564">source</a><div><div><pre><code class="language-none">middle(x, y)</code></pre><p>Compute the middle of two reals <code>x</code> and <code>y</code>, which is equivalent in both value and type to computing their mean (<code>(x + y) / 2</code>).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/3666ffad817cfca8539afc589d4a8daa8c6db7cf/base/statistics.jl#L570-L575">source</a><div><div><pre><code class="language-none">middle(range)</code></pre><p>Compute the middle of a range, which consists of computing the mean of its extrema. Since a range is sorted, the mean is performed with the first and last element.</p><pre><code class="language-julia-repl">julia&gt; middle(1:10)
5.5</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/3666ffad817cfca8539afc589d4a8daa8c6db7cf/base/statistics.jl#L578-L588">source</a><div><div><pre><code class="language-none">middle(a)</code></pre><p>Compute the middle of an array <code>a</code>, which consists of finding its extrema and then computing their mean.</p><pre><code class="language-julia-repl">julia&gt; a = [1,2,3.6,10.9]
4-element Array{Float64,1}:
  1.0
  2.0
  3.6
 10.9

julia&gt; middle(a)
5.95</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/3666ffad817cfca8539afc589d4a8daa8c6db7cf/base/statistics.jl#L591-L608">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.median" href="#Base.median"><code>Base.median</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">median(v; dims)</code></pre><p>Compute the median of an entire array <code>v</code>, or, optionally, along the given dimensions. For an even number of elements no exact median element exists, so the result is equivalent to calculating mean of two median elements.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Julia does not ignore <code>NaN</code> values in the computation. Use the <a href="../base/#Base.missing"><code>missing</code></a> type to represent missing values, and the <a href="../base/#Base.skipmissing"><code>skipmissing</code></a> function to omit them.</p></div></div></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/3666ffad817cfca8539afc589d4a8daa8c6db7cf/base/statistics.jl#L635-L646">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.median!" href="#Base.median!"><code>Base.median!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">median!(v)</code></pre><p>Like <a href="#Base.median"><code>median</code></a>, but may overwrite the input vector.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/3666ffad817cfca8539afc589d4a8daa8c6db7cf/base/statistics.jl#L611-L615">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.quantile" href="#Base.quantile"><code>Base.quantile</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">quantile(v, p; sorted=false)</code></pre><p>Compute the quantile(s) of a vector <code>v</code> at a specified probability or vector or tuple of probabilities <code>p</code>. The keyword argument <code>sorted</code> indicates whether <code>v</code> can be assumed to be sorted.</p><p>The <code>p</code> should be on the interval [0,1], and <code>v</code> should not have any <code>NaN</code> values.</p><p>Quantiles are computed via linear interpolation between the points <code>((k-1)/(n-1), v[k])</code>, for <code>k = 1:n</code> where <code>n = length(v)</code>. This corresponds to Definition 7 of Hyndman and Fan (1996), and is the same as the R default.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Julia does not ignore <code>NaN</code> values in the computation: <code>quantile</code> will throw an <code>ArgumentError</code> in the presence of <code>NaN</code> values in the data array. Use the <a href="../base/#Base.missing"><code>missing</code></a> type to represent missing values, and the <a href="../base/#Base.skipmissing"><code>skipmissing</code></a> function to omit them.</p></div></div><ul><li>Hyndman, R.J and Fan, Y. (1996) &quot;Sample Quantiles in Statistical Packages&quot;, <em>The American Statistician</em>, Vol. 50, No. 4, pp. 361-365</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/3666ffad817cfca8539afc589d4a8daa8c6db7cf/base/statistics.jl#L751-L772">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.quantile!" href="#Base.quantile!"><code>Base.quantile!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">quantile!([q, ] v, p; sorted=false)</code></pre><p>Compute the quantile(s) of a vector <code>v</code> at the probability or probabilities <code>p</code>, which can be given as a single value, a vector, or a tuple. If <code>p</code> is a vector, an optional output array <code>q</code> may also be specified. (If not provided, a new output array is created.) The keyword argument <code>sorted</code> indicates whether <code>v</code> can be assumed to be sorted; if <code>false</code> (the default), then the elements of <code>v</code> may be partially sorted.</p><p>The elements of <code>p</code> should be on the interval [0,1], and <code>v</code> should not have any <code>NaN</code> values.</p><p>Quantiles are computed via linear interpolation between the points <code>((k-1)/(n-1), v[k])</code>, for <code>k = 1:n</code> where <code>n = length(v)</code>. This corresponds to Definition 7 of Hyndman and Fan (1996), and is the same as the R default.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Julia does not ignore <code>NaN</code> values in the computation: <code>quantile!</code> will throw an <code>ArgumentError</code> in the presence of <code>NaN</code> values in the data array. Use the <a href="../base/#Base.missing"><code>missing</code></a> type to represent missing values, and the <a href="../base/#Base.skipmissing"><code>skipmissing</code></a> function to omit them.</p></div></div><ul><li>Hyndman, R.J and Fan, Y. (1996) &quot;Sample Quantiles in Statistical Packages&quot;, <em>The American Statistician</em>, Vol. 50, No. 4, pp. 361-365</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/3666ffad817cfca8539afc589d4a8daa8c6db7cf/base/statistics.jl#L655-L679">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.cov" href="#Base.cov"><code>Base.cov</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">cov(x::AbstractVector; corrected::Bool=true)</code></pre><p>Compute the variance of the vector <code>x</code>. If <code>corrected</code> is <code>true</code> (the default) then the sum is scaled with <code>n-1</code>, whereas the sum is scaled with <code>n</code> if <code>corrected</code> is <code>false</code> where <code>n = length(x)</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/3666ffad817cfca8539afc589d4a8daa8c6db7cf/base/statistics.jl#L388-L393">source</a><div><div><pre><code class="language-none">cov(X::AbstractMatrix; dims::Int=1, corrected::Bool=true)</code></pre><p>Compute the covariance matrix of the matrix <code>X</code> along the dimension <code>dims</code>. If <code>corrected</code> is <code>true</code> (the default) then the sum is scaled with <code>n-1</code>, whereas the sum is scaled with <code>n</code> if <code>corrected</code> is <code>false</code> where <code>n = size(X, dims)</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/3666ffad817cfca8539afc589d4a8daa8c6db7cf/base/statistics.jl#L396-L402">source</a><div><div><pre><code class="language-none">cov(x::AbstractVector, y::AbstractVector; corrected::Bool=true)</code></pre><p>Compute the covariance between the vectors <code>x</code> and <code>y</code>. If <code>corrected</code> is <code>true</code> (the default), computes <span>$\frac{1}{n-1}\sum_{i=1}^n (x_i-\bar x) (y_i-\bar y)^*$</span> where <span>$*$</span> denotes the complex conjugate and <code>n = length(x) = length(y)</code>. If <code>corrected</code> is <code>false</code>, computes <span>$\frac{1}{n}\sum_{i=1}^n (x_i-\bar x) (y_i-\bar y)^*$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/3666ffad817cfca8539afc589d4a8daa8c6db7cf/base/statistics.jl#L406-L413">source</a><div><div><pre><code class="language-none">cov(X::AbstractVecOrMat, Y::AbstractVecOrMat; dims::Int=1, corrected::Bool=true)</code></pre><p>Compute the covariance between the vectors or matrices <code>X</code> and <code>Y</code> along the dimension <code>dims</code>. If <code>corrected</code> is <code>true</code> (the default) then the sum is scaled with <code>n-1</code>, whereas the sum is scaled with <code>n</code> if <code>corrected</code> is <code>false</code> where <code>n = size(X, dims) = size(Y, dims)</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/3666ffad817cfca8539afc589d4a8daa8c6db7cf/base/statistics.jl#L417-L423">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.cor" href="#Base.cor"><code>Base.cor</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">cor(x::AbstractVector)</code></pre><p>Return the number one.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/3666ffad817cfca8539afc589d4a8daa8c6db7cf/base/statistics.jl#L529-L533">source</a><div><div><pre><code class="language-none">cor(X::AbstractMatrix; dims::Int=1)</code></pre><p>Compute the Pearson correlation matrix of the matrix <code>X</code> along the dimension <code>dims</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/3666ffad817cfca8539afc589d4a8daa8c6db7cf/base/statistics.jl#L536-L540">source</a><div><div><pre><code class="language-none">cor(x::AbstractVector, y::AbstractVector)</code></pre><p>Compute the Pearson correlation between the vectors <code>x</code> and <code>y</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/3666ffad817cfca8539afc589d4a8daa8c6db7cf/base/statistics.jl#L543-L547">source</a><div><div><pre><code class="language-none">cor(X::AbstractVecOrMat, Y::AbstractVecOrMat; dims=1)</code></pre><p>Compute the Pearson correlation between the vectors or matrices <code>X</code> and <code>Y</code> along the dimension <code>dims</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/3666ffad817cfca8539afc589d4a8daa8c6db7cf/base/statistics.jl#L550-L554">source</a></section><footer><hr/><a class="previous" href="../collections/"><span class="direction">Previous</span><span class="title">Collections and Data Structures</span></a><a class="next" href="../numbers/"><span class="direction">Next</span><span class="title">Numbers</span></a></footer></article></body></html>
