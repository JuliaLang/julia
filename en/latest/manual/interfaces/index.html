<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Interfaces · The Julia Language</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-28835595-6', 'auto');
ga('send', 'pageview');
</script><link rel="canonical" href="https://docs.julialang.org/en/stable/manual/interfaces/index.html"/><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../../index.html"><img class="logo" src="../../assets/logo.png" alt="The Julia Language logo"/></a><h1>The Julia Language</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../introduction/">Introduction</a></li><li><a class="toctext" href="../getting-started/">Getting Started</a></li><li><a class="toctext" href="../variables/">Variables</a></li><li><a class="toctext" href="../integers-and-floating-point-numbers/">Integers and Floating-Point Numbers</a></li><li><a class="toctext" href="../mathematical-operations/">Mathematical Operations and Elementary Functions</a></li><li><a class="toctext" href="../complex-and-rational-numbers/">Complex and Rational Numbers</a></li><li><a class="toctext" href="../strings/">Strings</a></li><li><a class="toctext" href="../functions/">Functions</a></li><li><a class="toctext" href="../control-flow/">Control Flow</a></li><li><a class="toctext" href="../variables-and-scoping/">Scope of Variables</a></li><li><a class="toctext" href="../types/">Types</a></li><li><a class="toctext" href="../methods/">Methods</a></li><li><a class="toctext" href="../constructors/">Constructors</a></li><li><a class="toctext" href="../conversion-and-promotion/">Conversion and Promotion</a></li><li class="current"><a class="toctext" href>Interfaces</a><ul class="internal"><li><a class="toctext" href="#man-interface-iteration-1">Iteration</a></li><li><a class="toctext" href="#Indexing-1">Indexing</a></li><li><a class="toctext" href="#man-interface-array-1">Abstract Arrays</a></li><li><a class="toctext" href="#man-interface-strided-arrays-1">Strided Arrays</a></li><li><a class="toctext" href="#man-interfaces-broadcasting-1">Broadcasting</a></li></ul></li><li><a class="toctext" href="../modules/">Modules</a></li><li><a class="toctext" href="../documentation/">Documentation</a></li><li><a class="toctext" href="../metaprogramming/">Metaprogramming</a></li><li><a class="toctext" href="../arrays/">Multi-dimensional Arrays</a></li><li><a class="toctext" href="../missing/">Missing Values</a></li><li><a class="toctext" href="../networking-and-streams/">Networking and Streams</a></li><li><a class="toctext" href="../parallel-computing/">Parallel Computing</a></li><li><a class="toctext" href="../running-external-programs/">Running External Programs</a></li><li><a class="toctext" href="../calling-c-and-fortran-code/">Calling C and Fortran Code</a></li><li><a class="toctext" href="../handling-operating-system-variation/">Handling Operating System Variation</a></li><li><a class="toctext" href="../environment-variables/">Environment Variables</a></li><li><a class="toctext" href="../embedding/">Embedding Julia</a></li><li><a class="toctext" href="../packages/">Packages</a></li><li><a class="toctext" href="../profile/">Profiling</a></li><li><a class="toctext" href="../stacktraces/">Stack Traces</a></li><li><a class="toctext" href="../performance-tips/">Performance Tips</a></li><li><a class="toctext" href="../workflow-tips/">Workflow Tips</a></li><li><a class="toctext" href="../style-guide/">Style Guide</a></li><li><a class="toctext" href="../faq/">Frequently Asked Questions</a></li><li><a class="toctext" href="../noteworthy-differences/">Noteworthy Differences from other Languages</a></li><li><a class="toctext" href="../unicode-input/">Unicode Input</a></li></ul></li><li><span class="toctext">Base</span><ul><li><a class="toctext" href="../../base/base/">Essentials</a></li><li><a class="toctext" href="../../base/collections/">Collections and Data Structures</a></li><li><a class="toctext" href="../../base/math/">Mathematics</a></li><li><a class="toctext" href="../../base/numbers/">Numbers</a></li><li><a class="toctext" href="../../base/strings/">Strings</a></li><li><a class="toctext" href="../../base/arrays/">Arrays</a></li><li><a class="toctext" href="../../base/parallel/">Tasks</a></li><li><a class="toctext" href="../../base/multi-threading/">Multi-Threading</a></li><li><a class="toctext" href="../../base/constants/">Constants</a></li><li><a class="toctext" href="../../base/file/">Filesystem</a></li><li><a class="toctext" href="../../base/io-network/">I/O and Network</a></li><li><a class="toctext" href="../../base/punctuation/">Punctuation</a></li><li><a class="toctext" href="../../base/sort/">Sorting and Related Functions</a></li><li><a class="toctext" href="../../base/iterators/">Iteration utilities</a></li><li><a class="toctext" href="../../base/c/">C Interface</a></li><li><a class="toctext" href="../../base/libc/">C Standard Library</a></li><li><a class="toctext" href="../../base/stacktraces/">StackTraces</a></li><li><a class="toctext" href="../../base/simd-types/">SIMD Support</a></li></ul></li><li><span class="toctext">Standard Library</span><ul><li><a class="toctext" href="../../stdlib/Base64/">Base64</a></li><li><a class="toctext" href="../../stdlib/CRC32c/">CRC32c</a></li><li><a class="toctext" href="../../stdlib/Dates/">Dates</a></li><li><a class="toctext" href="../../stdlib/DelimitedFiles/">Delimited Files</a></li><li><a class="toctext" href="../../stdlib/Distributed/">Distributed Computing</a></li><li><a class="toctext" href="../../stdlib/FileWatching/">File Events</a></li><li><a class="toctext" href="../../stdlib/InteractiveUtils/">Interactive Utilities</a></li><li><a class="toctext" href="../../stdlib/IterativeEigensolvers/">Iterative Eigensolvers</a></li><li><a class="toctext" href="../../stdlib/Libdl/">Dynamic Linker</a></li><li><a class="toctext" href="../../stdlib/LinearAlgebra/">Linear Algebra</a></li><li><a class="toctext" href="../../stdlib/Logging/">Logging</a></li><li><a class="toctext" href="../../stdlib/Markdown/">Markdown</a></li><li><a class="toctext" href="../../stdlib/Mmap/">Memory-mapped I/O</a></li><li><a class="toctext" href="../../stdlib/Pkg/">Package Manager Functions</a></li><li><a class="toctext" href="../../stdlib/Pkg3/">Pkg3.jl</a></li><li><a class="toctext" href="../../stdlib/Printf/">Printf</a></li><li><a class="toctext" href="../../stdlib/Profile/">Profiling</a></li><li><a class="toctext" href="../../stdlib/REPL/">The Julia REPL</a></li><li><a class="toctext" href="../../stdlib/Random/">Random Numbers</a></li><li><a class="toctext" href="../../stdlib/SHA/">SHA</a></li><li><a class="toctext" href="../../stdlib/Serialization/">Serialization</a></li><li><a class="toctext" href="../../stdlib/SharedArrays/">Shared Arrays</a></li><li><a class="toctext" href="../../stdlib/Sockets/">Sockets</a></li><li><a class="toctext" href="../../stdlib/SparseArrays/">Sparse Arrays</a></li><li><a class="toctext" href="../../stdlib/Test/">Unit Testing</a></li><li><a class="toctext" href="../../stdlib/UUIDs/">UUIDs</a></li><li><a class="toctext" href="../../stdlib/Unicode/">Unicode</a></li></ul></li><li><span class="toctext">Developer Documentation</span><ul><li><a class="toctext" href="../../devdocs/reflection/">Reflection and introspection</a></li><li><span class="toctext">Documentation of Julia&#39;s Internals</span><ul><li><a class="toctext" href="../../devdocs/init/">Initialization of the Julia runtime</a></li><li><a class="toctext" href="../../devdocs/ast/">Julia ASTs</a></li><li><a class="toctext" href="../../devdocs/types/">More about types</a></li><li><a class="toctext" href="../../devdocs/object/">Memory layout of Julia Objects</a></li><li><a class="toctext" href="../../devdocs/eval/">Eval of Julia code</a></li><li><a class="toctext" href="../../devdocs/callconv/">Calling Conventions</a></li><li><a class="toctext" href="../../devdocs/compiler/">High-level Overview of the Native-Code Generation Process</a></li><li><a class="toctext" href="../../devdocs/functions/">Julia Functions</a></li><li><a class="toctext" href="../../devdocs/cartesian/">Base.Cartesian</a></li><li><a class="toctext" href="../../devdocs/meta/">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="../../devdocs/subarrays/">SubArrays</a></li><li><a class="toctext" href="../../devdocs/sysimg/">System Image Building</a></li><li><a class="toctext" href="../../devdocs/llvm/">Working with LLVM</a></li><li><a class="toctext" href="../../devdocs/stdio/">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="../../devdocs/boundscheck/">Bounds checking</a></li><li><a class="toctext" href="../../devdocs/locks/">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="../../devdocs/offset-arrays/">Arrays with custom indices</a></li><li><a class="toctext" href="../../devdocs/require/">Module loading</a></li><li><a class="toctext" href="../../devdocs/inference/">Inference</a></li></ul></li><li><span class="toctext">Developing/debugging Julia&#39;s C code</span><ul><li><a class="toctext" href="../../devdocs/backtraces/">Reporting and analyzing crashes (segfaults)</a></li><li><a class="toctext" href="../../devdocs/debuggingtips/">gdb debugging tips</a></li><li><a class="toctext" href="../../devdocs/valgrind/">Using Valgrind with Julia</a></li><li><a class="toctext" href="../../devdocs/sanitizers/">Sanitizer support</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href>Interfaces</a></li></ul><a class="edit-page" href="https://github.com/JuliaLang/julia/blob/master/doc/src/manual/interfaces.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Interfaces</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Interfaces-1" href="#Interfaces-1">Interfaces</a></h1><p>A lot of the power and extensibility in Julia comes from a collection of informal interfaces.  By extending a few specific methods to work for a custom type, objects of that type not only receive those functionalities, but they are also able to be used in other methods that are written to generically build upon those behaviors.</p><h2><a class="nav-anchor" id="man-interface-iteration-1" href="#man-interface-iteration-1">Iteration</a></h2><table><tr><th>Required methods</th><th> </th><th>Brief description</th></tr><tr><td><code>start(iter)</code></td><td> </td><td>Returns the initial iteration state</td></tr><tr><td><code>next(iter, state)</code></td><td> </td><td>Returns the current item and the next state</td></tr><tr><td><code>done(iter, state)</code></td><td> </td><td>Tests if there are any items remaining</td></tr><tr><td><strong>Important optional methods</strong></td><td><strong>Default definition</strong></td><td><strong>Brief description</strong></td></tr><tr><td><code>IteratorSize(IterType)</code></td><td><code>HasLength()</code></td><td>One of <code>HasLength()</code>, <code>HasShape{N}()</code>, <code>IsInfinite()</code>, or <code>SizeUnknown()</code> as appropriate</td></tr><tr><td><code>IteratorEltype(IterType)</code></td><td><code>HasEltype()</code></td><td>Either <code>EltypeUnknown()</code> or <code>HasEltype()</code> as appropriate</td></tr><tr><td><code>eltype(IterType)</code></td><td><code>Any</code></td><td>The type of the items returned by <code>next()</code></td></tr><tr><td><code>length(iter)</code></td><td>(<em>undefined</em>)</td><td>The number of items, if known</td></tr><tr><td><code>size(iter, [dim...])</code></td><td>(<em>undefined</em>)</td><td>The number of items in each dimension, if known</td></tr></table><table><tr><th>Value returned by <code>IteratorSize(IterType)</code></th><th>Required Methods</th></tr><tr><td><code>HasLength()</code></td><td><code>length(iter)</code></td></tr><tr><td><code>HasShape{N}()</code></td><td><code>length(iter)</code>  and <code>size(iter, [dim...])</code></td></tr><tr><td><code>IsInfinite()</code></td><td>(<em>none</em>)</td></tr><tr><td><code>SizeUnknown()</code></td><td>(<em>none</em>)</td></tr></table><table><tr><th>Value returned by <code>IteratorEltype(IterType)</code></th><th>Required Methods</th></tr><tr><td><code>HasEltype()</code></td><td><code>eltype(IterType)</code></td></tr><tr><td><code>EltypeUnknown()</code></td><td>(<em>none</em>)</td></tr></table><p>Sequential iteration is implemented by the methods <a href="../../base/collections/#Base.start"><code>start</code></a>, <a href="../../base/collections/#Base.done"><code>done</code></a>, and <a href="../../base/collections/#Base.next"><code>next</code></a>. Instead of mutating objects as they are iterated over, Julia provides these three methods to keep track of the iteration state externally from the object. The <code>start(iter)</code> method returns the initial state for the iterable object <code>iter</code>. That state gets passed along to <code>done(iter, state)</code>, which tests if there are any elements remaining, and <code>next(iter, state)</code>, which returns a tuple containing the current element and an updated <code>state</code>. The <code>state</code> object can be anything, and is generally considered to be an implementation detail private to the iterable object.</p><p>Any object that defines these three methods is iterable and can be used in the <a href="../../base/collections/#lib-collections-iteration-1">many functions that rely upon iteration</a>. It can also be used directly in a <code>for</code> loop since the syntax:</p><pre><code class="language-julia">for i in iter   # or  &quot;for i = iter&quot;
    # body
end</code></pre><p>is translated into:</p><pre><code class="language-julia">state = start(iter)
while !done(iter, state)
    (i, state) = next(iter, state)
    # body
end</code></pre><p>A simple example is an iterable sequence of square numbers with a defined length:</p><pre><code class="language-julia-repl">julia&gt; struct Squares
           count::Int
       end

julia&gt; Base.start(::Squares) = 1

julia&gt; Base.next(S::Squares, state) = (state*state, state+1)

julia&gt; Base.done(S::Squares, state) = state &gt; S.count

julia&gt; Base.eltype(::Type{Squares}) = Int # Note that this is defined for the type

julia&gt; Base.length(S::Squares) = S.count</code></pre><p>With only <a href="../../base/collections/#Base.start"><code>start</code></a>, <a href="../../base/collections/#Base.next"><code>next</code></a>, and <a href="../../base/collections/#Base.done"><code>done</code></a> definitions, the <code>Squares</code> type is already pretty powerful. We can iterate over all the elements:</p><pre><code class="language-julia-repl">julia&gt; for i in Squares(7)
           println(i)
       end
1
4
9
16
25
36
49</code></pre><p>We can use many of the builtin methods that work with iterables, like <a href="../../base/collections/#Base.in"><code>in</code></a>, <a href="../../base/math/#Base.mean"><code>mean</code></a> and <a href="../../base/math/#Base.std"><code>std</code></a>:</p><pre><code class="language-julia-repl">julia&gt; 25 in Squares(10)
true

julia&gt; mean(Squares(100))
3383.5

julia&gt; std(Squares(100))
3024.355854282583</code></pre><p>There are a few more methods we can extend to give Julia more information about this iterable collection.  We know that the elements in a <code>Squares</code> sequence will always be <code>Int</code>. By extending the <a href="../../base/collections/#Base.eltype"><code>eltype</code></a> method, we can give that information to Julia and help it make more specialized code in the more complicated methods. We also know the number of elements in our sequence, so we can extend <a href="../../base/collections/#Base.length"><code>length</code></a>, too.</p><p>Now, when we ask Julia to <a href="../../base/collections/#Base.collect-Tuple{Any}"><code>collect</code></a> all the elements into an array it can preallocate a <code>Vector{Int}</code> of the right size instead of blindly <a href="../../base/collections/#Base.push!"><code>push!</code></a>ing each element into a <code>Vector{Any}</code>:</p><pre><code class="language-julia-repl">julia&gt; collect(Squares(4))
4-element Array{Int64,1}:
  1
  4
  9
 16</code></pre><p>While we can rely upon generic implementations, we can also extend specific methods where we know there is a simpler algorithm. For example, there&#39;s a formula to compute the sum of squares, so we can override the generic iterative version with a more performant solution:</p><pre><code class="language-julia-repl">julia&gt; Base.sum(S::Squares) = (n = S.count; return n*(n+1)*(2n+1)÷6)

julia&gt; sum(Squares(1803))
1955361914</code></pre><p>This is a very common pattern throughout Julia Base: a small set of required methods define an informal interface that enable many fancier behaviors. In some cases, types will want to additionally specialize those extra behaviors when they know a more efficient algorithm can be used in their specific case.</p><p>It is also often useful to allow iteration over a collection in <em>reverse order</em> by iterating over <a href="../../base/iterators/#Base.Iterators.reverse"><code>Iterators.reverse(iterator)</code></a>.  To actually support reverse-order iteration, however, an iterator type <code>T</code> needs to implement <code>start</code>, <code>next</code>, and <code>done</code> methods for <code>Iterators.Reverse{T}</code>. (Given <code>r::Iterators.Reverse{T}</code>, the underling iterator of type <code>T</code> is <code>r.itr</code>.) In our <code>Squares</code> example, we would implement <code>Iterators.Reverse{Squares}</code> methods:</p><pre><code class="language-julia-repl">julia&gt; Base.start(rS::Iterators.Reverse{Squares}) = rS.itr.count

julia&gt; Base.next(::Iterators.Reverse{Squares}, state) = (state*state, state-1)

julia&gt; Base.done(::Iterators.Reverse{Squares}, state) = state &lt; 1

julia&gt; collect(Iterators.reverse(Squares(4)))
4-element Array{Int64,1}:
 16
  9
  4
  1</code></pre><h2><a class="nav-anchor" id="Indexing-1" href="#Indexing-1">Indexing</a></h2><table><tr><th>Methods to implement</th><th>Brief description</th></tr><tr><td><code>getindex(X, i)</code></td><td><code>X[i]</code>, indexed element access</td></tr><tr><td><code>setindex!(X, v, i)</code></td><td><code>X[i] = v</code>, indexed assignment</td></tr><tr><td><code>firstindex(X)</code></td><td>The first index</td></tr><tr><td><code>lastindex(X)</code></td><td>The last index, used in <code>X[end]</code></td></tr></table><p>For the <code>Squares</code> iterable above, we can easily compute the <code>i</code>th element of the sequence by squaring it.  We can expose this as an indexing expression <code>S[i]</code>. To opt into this behavior, <code>Squares</code> simply needs to define <a href="../../base/collections/#Base.getindex"><code>getindex</code></a>:</p><pre><code class="language-julia-repl">julia&gt; function Base.getindex(S::Squares, i::Int)
           1 &lt;= i &lt;= S.count || throw(BoundsError(S, i))
           return i*i
       end

julia&gt; Squares(100)[23]
529</code></pre><p>Additionally, to support the syntax <code>S[end]</code>, we must define <a href="../../base/collections/#Base.lastindex"><code>lastindex</code></a> to specify the last valid index. It is recommended to also define <a href="../../base/collections/#Base.firstindex"><code>firstindex</code></a> to specify the first valid index:</p><pre><code class="language-julia-repl">julia&gt; Base.firstindex(S::Squares) = 1

julia&gt; Base.lastindex(S::Squares) = length(S)

julia&gt; Squares(23)[end]
529</code></pre><p>Note, though, that the above <em>only</em> defines <a href="../../base/collections/#Base.getindex"><code>getindex</code></a> with one integer index. Indexing with anything other than an <code>Int</code> will throw a <a href="../../base/base/#Core.MethodError"><code>MethodError</code></a> saying that there was no matching method. In order to support indexing with ranges or vectors of <code>Int</code>s, separate methods must be written:</p><pre><code class="language-julia-repl">julia&gt; Base.getindex(S::Squares, i::Number) = S[convert(Int, i)]

julia&gt; Base.getindex(S::Squares, I) = [S[i] for i in I]

julia&gt; Squares(10)[[3,4.,5]]
3-element Array{Int64,1}:
  9
 16
 25</code></pre><p>While this is starting to support more of the <a href="../arrays/#man-array-indexing-1">indexing operations supported by some of the builtin types</a>, there&#39;s still quite a number of behaviors missing. This <code>Squares</code> sequence is starting to look more and more like a vector as we&#39;ve added behaviors to it. Instead of defining all these behaviors ourselves, we can officially define it as a subtype of an <a href="../../base/arrays/#Core.AbstractArray"><code>AbstractArray</code></a>.</p><h2><a class="nav-anchor" id="man-interface-array-1" href="#man-interface-array-1">Abstract Arrays</a></h2><table><tr><th>Methods to implement</th><th> </th><th>Brief description</th></tr><tr><td><code>size(A)</code></td><td> </td><td>Returns a tuple containing the dimensions of <code>A</code></td></tr><tr><td><code>getindex(A, i::Int)</code></td><td> </td><td>(if <code>IndexLinear</code>) Linear scalar indexing</td></tr><tr><td><code>getindex(A, I::Vararg{Int, N})</code></td><td> </td><td>(if <code>IndexCartesian</code>, where <code>N = ndims(A)</code>) N-dimensional scalar indexing</td></tr><tr><td><code>setindex!(A, v, i::Int)</code></td><td> </td><td>(if <code>IndexLinear</code>) Scalar indexed assignment</td></tr><tr><td><code>setindex!(A, v, I::Vararg{Int, N})</code></td><td> </td><td>(if <code>IndexCartesian</code>, where <code>N = ndims(A)</code>) N-dimensional scalar indexed assignment</td></tr><tr><td><strong>Optional methods</strong></td><td><strong>Default definition</strong></td><td><strong>Brief description</strong></td></tr><tr><td><code>IndexStyle(::Type)</code></td><td><code>IndexCartesian()</code></td><td>Returns either <code>IndexLinear()</code> or <code>IndexCartesian()</code>. See the description below.</td></tr><tr><td><code>getindex(A, I...)</code></td><td>defined in terms of scalar <code>getindex</code></td><td><a href="../arrays/#man-array-indexing-1">Multidimensional and nonscalar indexing</a></td></tr><tr><td><code>setindex!(A, I...)</code></td><td>defined in terms of scalar <code>setindex!</code></td><td><a href="../arrays/#man-array-indexing-1">Multidimensional and nonscalar indexed assignment</a></td></tr><tr><td><code>start</code>/<code>next</code>/<code>done</code></td><td>defined in terms of scalar <code>getindex</code></td><td>Iteration</td></tr><tr><td><code>length(A)</code></td><td><code>prod(size(A))</code></td><td>Number of elements</td></tr><tr><td><code>similar(A)</code></td><td><code>similar(A, eltype(A), size(A))</code></td><td>Return a mutable array with the same shape and element type</td></tr><tr><td><code>similar(A, ::Type{S})</code></td><td><code>similar(A, S, size(A))</code></td><td>Return a mutable array with the same shape and the specified element type</td></tr><tr><td><code>similar(A, dims::NTuple{Int})</code></td><td><code>similar(A, eltype(A), dims)</code></td><td>Return a mutable array with the same element type and size <em>dims</em></td></tr><tr><td><code>similar(A, ::Type{S}, dims::NTuple{Int})</code></td><td><code>Array{S}(undef, dims)</code></td><td>Return a mutable array with the specified element type and size</td></tr><tr><td><strong>Non-traditional indices</strong></td><td><strong>Default definition</strong></td><td><strong>Brief description</strong></td></tr><tr><td><code>axes(A)</code></td><td><code>map(OneTo, size(A))</code></td><td>Return the <code>AbstractUnitRange</code> of valid indices</td></tr><tr><td><code>Base.similar(A, ::Type{S}, inds::NTuple{Ind})</code></td><td><code>similar(A, S, Base.to_shape(inds))</code></td><td>Return a mutable array with the specified indices <code>inds</code> (see below)</td></tr><tr><td><code>Base.similar(T::Union{Type,Function}, inds)</code></td><td><code>T(Base.to_shape(inds))</code></td><td>Return an array similar to <code>T</code> with the specified indices <code>inds</code> (see below)</td></tr></table><p>If a type is defined as a subtype of <code>AbstractArray</code>, it inherits a very large set of rich behaviors including iteration and multidimensional indexing built on top of single-element access.  See the <a href="../arrays/#man-multi-dim-arrays-1">arrays manual page</a> and the <a href="../../base/arrays/#lib-arrays-1">Julia Base section</a> for more supported methods.</p><p>A key part in defining an <code>AbstractArray</code> subtype is <a href="../../base/arrays/#Base.IndexStyle"><code>IndexStyle</code></a>. Since indexing is such an important part of an array and often occurs in hot loops, it&#39;s important to make both indexing and indexed assignment as efficient as possible.  Array data structures are typically defined in one of two ways: either it most efficiently accesses its elements using just one index (linear indexing) or it intrinsically accesses the elements with indices specified for every dimension.  These two modalities are identified by Julia as <code>IndexLinear()</code> and <code>IndexCartesian()</code>.  Converting a linear index to multiple indexing subscripts is typically very expensive, so this provides a traits-based mechanism to enable efficient generic code for all array types.</p><p>This distinction determines which scalar indexing methods the type must define. <code>IndexLinear()</code> arrays are simple: just define <code>getindex(A::ArrayType, i::Int)</code>.  When the array is subsequently indexed with a multidimensional set of indices, the fallback <code>getindex(A::AbstractArray, I...)()</code> efficiently converts the indices into one linear index and then calls the above method. <code>IndexCartesian()</code> arrays, on the other hand, require methods to be defined for each supported dimensionality with <code>ndims(A)</code> <code>Int</code> indices. For example, <a href="../../stdlib/SparseArrays/#SparseArrays.SparseMatrixCSC"><code>SparseMatrixCSC</code></a> from the <code>SparseArrays</code> standard library module, only supports two dimensions, so it just defines <code>getindex(A::SparseMatrixCSC, i::Int, j::Int)</code>. The same holds for <code>setindex!</code>.</p><p>Returning to the sequence of squares from above, we could instead define it as a subtype of an <code>AbstractArray{Int, 1}</code>:</p><pre><code class="language-julia-repl">julia&gt; struct SquaresVector &lt;: AbstractArray{Int, 1}
           count::Int
       end

julia&gt; Base.size(S::SquaresVector) = (S.count,)

julia&gt; Base.IndexStyle(::Type{&lt;:SquaresVector}) = IndexLinear()

julia&gt; Base.getindex(S::SquaresVector, i::Int) = i*i</code></pre><p>Note that it&#39;s very important to specify the two parameters of the <code>AbstractArray</code>; the first defines the <a href="../../base/collections/#Base.eltype"><code>eltype</code></a>, and the second defines the <a href="../../base/arrays/#Base.ndims"><code>ndims</code></a>. That supertype and those three methods are all it takes for <code>SquaresVector</code> to be an iterable, indexable, and completely functional array:</p><pre><code class="language-julia-repl">julia&gt; s = SquaresVector(4)
4-element SquaresVector:
  1
  4
  9
 16

julia&gt; s[s .&gt; 8]
2-element Array{Int64,1}:
  9
 16

julia&gt; s + s
4-element Array{Int64,1}:
  2
  8
 18
 32

julia&gt; sin.(s)
4-element Array{Float64,1}:
  0.8414709848078965
 -0.7568024953079282
  0.4121184852417566
 -0.2879033166650653</code></pre><p>As a more complicated example, let&#39;s define our own toy N-dimensional sparse-like array type built on top of <a href="../../base/collections/#Base.Dict"><code>Dict</code></a>:</p><pre><code class="language-julia-repl">julia&gt; struct SparseArray{T,N} &lt;: AbstractArray{T,N}
           data::Dict{NTuple{N,Int}, T}
           dims::NTuple{N,Int}
       end

julia&gt; SparseArray(::Type{T}, dims::Int...) where {T} = SparseArray(T, dims);

julia&gt; SparseArray(::Type{T}, dims::NTuple{N,Int}) where {T,N} = SparseArray{T,N}(Dict{NTuple{N,Int}, T}(), dims);

julia&gt; Base.size(A::SparseArray) = A.dims

julia&gt; Base.similar(A::SparseArray, ::Type{T}, dims::Dims) where {T} = SparseArray(T, dims)

julia&gt; Base.getindex(A::SparseArray{T,N}, I::Vararg{Int,N}) where {T,N} = get(A.data, I, zero(T))

julia&gt; Base.setindex!(A::SparseArray{T,N}, v, I::Vararg{Int,N}) where {T,N} = (A.data[I] = v)</code></pre><p>Notice that this is an <code>IndexCartesian</code> array, so we must manually define <a href="../../base/collections/#Base.getindex"><code>getindex</code></a> and <a href="../../base/collections/#Base.setindex!"><code>setindex!</code></a> at the dimensionality of the array. Unlike the <code>SquaresVector</code>, we are able to define <a href="../../base/collections/#Base.setindex!"><code>setindex!</code></a>, and so we can mutate the array:</p><pre><code class="language-julia-repl">julia&gt; A = SparseArray(Float64, 3, 3)
3×3 SparseArray{Float64,2}:
 0.0  0.0  0.0
 0.0  0.0  0.0
 0.0  0.0  0.0

julia&gt; fill!(A, 2)
3×3 SparseArray{Float64,2}:
 2.0  2.0  2.0
 2.0  2.0  2.0
 2.0  2.0  2.0

julia&gt; A[:] = 1:length(A); A
3×3 SparseArray{Float64,2}:
 1.0  4.0  7.0
 2.0  5.0  8.0
 3.0  6.0  9.0</code></pre><p>The result of indexing an <code>AbstractArray</code> can itself be an array (for instance when indexing by an <code>AbstractRange</code>). The <code>AbstractArray</code> fallback methods use <a href="../../base/arrays/#Base.similar-Tuple{AbstractArray}"><code>similar</code></a> to allocate an <code>Array</code> of the appropriate size and element type, which is filled in using the basic indexing method described above. However, when implementing an array wrapper you often want the result to be wrapped as well:</p><pre><code class="language-julia-repl">julia&gt; A[1:2,:]
2×3 SparseArray{Float64,2}:
 1.0  4.0  7.0
 2.0  5.0  8.0</code></pre><p>In this example it is accomplished by defining <code>Base.similar{T}(A::SparseArray, ::Type{T}, dims::Dims)</code> to create the appropriate wrapped array. (Note that while <code>similar</code> supports 1- and 2-argument forms, in most case you only need to specialize the 3-argument form.) For this to work it&#39;s important that <code>SparseArray</code> is mutable (supports <code>setindex!</code>). Defining <code>similar</code>, <code>getindex</code> and <code>setindex!</code> for <code>SparseArray</code> also makes it possible to <a href="../../base/base/#Base.copy"><code>copy</code></a> the array:</p><pre><code class="language-julia-repl">julia&gt; copy(A)
3×3 SparseArray{Float64,2}:
 1.0  4.0  7.0
 2.0  5.0  8.0
 3.0  6.0  9.0</code></pre><p>In addition to all the iterable and indexable methods from above, these types can also interact with each other and use most of the methods defined in Julia Base for <code>AbstractArrays</code>:</p><pre><code class="language-julia-repl">julia&gt; A[SquaresVector(3)]
3-element SparseArray{Float64,1}:
 1.0
 4.0
 9.0

julia&gt; mean(A)
5.0</code></pre><p>If you are defining an array type that allows non-traditional indexing (indices that start at something other than 1), you should specialize <code>axes</code>. You should also specialize <a href="../../base/arrays/#Base.similar-Tuple{AbstractArray}"><code>similar</code></a> so that the <code>dims</code> argument (ordinarily a <code>Dims</code> size-tuple) can accept <code>AbstractUnitRange</code> objects, perhaps range-types <code>Ind</code> of your own design. For more information, see <a href="../../devdocs/offset-arrays/#man-custom-indices-1">Arrays with custom indices</a>.</p><h2><a class="nav-anchor" id="man-interface-strided-arrays-1" href="#man-interface-strided-arrays-1">Strided Arrays</a></h2><table><tr><th>Methods to implement</th><th> </th><th>Brief description</th></tr><tr><td><code>strides(A)</code></td><td> </td><td>Return the distance in memory (in number of elements) between adjacent elements in each dimension as a tuple. If <code>A</code> is an <code>AbstractArray{T,0}</code>, this should return an empty tuple.</td></tr><tr><td><code>Base.unsafe_convert(::Type{Ptr{T}}, A)</code></td><td> </td><td>Return the native address of an array.</td></tr><tr><td><strong>Optional methods</strong></td><td><strong>Default definition</strong></td><td><strong>Brief description</strong></td></tr><tr><td><code>stride(A, i::Int)</code></td><td>    <code>strides(A)[i]</code></td><td>Return the distance in memory (in number of elements) between adjacent elements in dimension k.</td></tr></table><p>A strided array is a subtype of <code>AbstractArray</code> whose entries are stored in memory with fixed strides. Provided the element type of the array is compatible with BLAS, a strided array can utilize BLAS and LAPACK routines for more efficient linear algebra routines.  A typical example of a user-defined strided array is one that wraps a standard <code>Array</code> with additional structure.</p><p>Warning: do not implement these methods if the underlying storage is not actually strided, as it may lead to incorrect results or segmentation faults.</p><p>Here are some examples to demonstrate which type of arrays are strided and which are not:</p><pre><code class="language-julia">1:5   # not strided (there is no storage associated with this array.)
Vector(1:5)  # is strided with strides (1,)
A = [1 5; 2 6; 3 7; 4 8]  # is strided with strides (1,4)
V = view(A, 1:2, :)   # is strided with strides (1,4)
V = view(A, 1:2:3, 1:2)   # is strided with strides (2,4)
V = view(A, [1,2,4], :)   # is not strided, as the spacing between rows is not fixed.</code></pre><h2><a class="nav-anchor" id="man-interfaces-broadcasting-1" href="#man-interfaces-broadcasting-1">Broadcasting</a></h2><table><tr><th>Methods to implement</th><th>Brief description</th></tr><tr><td><code>Base.BroadcastStyle(::Type{SrcType}) = SrcStyle()</code></td><td>Broadcasting behavior of <code>SrcType</code></td></tr><tr><td><code>Base.broadcast_similar(f, ::DestStyle, ::Type{ElType}, inds, As...)</code></td><td>Allocation of output container</td></tr><tr><td><strong>Optional methods</strong></td><td></td></tr><tr><td><code>Base.BroadcastStyle(::Style1, ::Style2) = Style12()</code></td><td>Precedence rules for mixing styles</td></tr><tr><td><code>Base.broadcast_indices(::StyleA, A)</code></td><td>Declaration of the indices of <code>A</code> for broadcasting purposes (defaults to <a href="../../base/arrays/#Base.axes-Tuple{Any}"><code>axes(A)</code></a>)</td></tr><tr><td><code>Base.broadcastable(x)</code></td><td>Convert <code>x</code> to an object that has <code>axes</code> and supports indexing</td></tr><tr><td><strong>Bypassing default machinery</strong></td><td></td></tr><tr><td><code>broadcast(f, As...)</code></td><td>Complete bypass of broadcasting machinery</td></tr><tr><td><code>broadcast(f, ::DestStyle, ::Nothing, ::Nothing, As...)</code></td><td>Bypass after container type is computed</td></tr><tr><td><code>broadcast(f, ::DestStyle, ::Type{ElType}, inds::Tuple, As...)</code></td><td>Bypass after container type, eltype, and indices are computed</td></tr><tr><td><code>broadcast!(f, dest::DestType, ::Nothing, As...)</code></td><td>Bypass in-place broadcast, specialization on destination type</td></tr><tr><td><code>broadcast!(f, dest, ::BroadcastStyle, As...)</code></td><td>Bypass in-place broadcast, specialization on <code>BroadcastStyle</code></td></tr></table><p><a href="../arrays/#Broadcasting-1">Broadcasting</a> is triggered by an explicit call to <code>broadcast</code> or <code>broadcast!</code>, or implicitly by &quot;dot&quot; operations like <code>A .+ b</code> or <code>f.(x, y)</code>. Any object that has <a href="../../base/arrays/#Base.axes-Tuple{Any}"><code>axes</code></a> and supports indexing can participate as an argument in broadcasting, and by default the result is stored in an <code>Array</code>. This basic framework is extensible in three major ways:</p><ul><li>Ensuring that all arguments support broadcast</li><li>Selecting an appropriate output array for the given set of arguments</li><li>Selecting an efficient implementation for the given set of arguments</li></ul><p>Not all types support <code>axes</code> and indexing, but many are convenient to allow in broadcast. The <a href="../../base/arrays/#Base.Broadcast.broadcastable"><code>Base.broadcastable</code></a> function is called on each argument to broadcast, allowing it to return something different that supports <code>axes</code> and indexing if it does not. By default, this is the identity function for all <code>AbstractArray</code>s and <code>Number</code>s — they already support <code>axes</code> and indexing. For a handful of other types (including but not limited to types themselves, functions, special singletons like <code>missing</code> and <code>nothing</code>, and dates), <code>Base.broadcastable</code> returns the argument wrapped in a <code>Ref</code> to act as a 0-dimensional &quot;scalar&quot; for the purposes of broadcasting. Custom types can similarly specialize <code>Base.broadcastable</code> to define their shape, but they should follow the convention that <code>collect(Base.broadcastable(x)) == collect(x)</code>. A notable exception are <code>AbstractString</code>s; they are special-cased to behave as scalars for the purposes of broadcast even though they are iterable collections of their characters.</p><p>The next two steps (selecting the output array and implementation) are dependent upon determining a single answer for a given set of arguments. Broadcast must take all the varied types of its arguments and collapse them down to just one output array and one implementation. Broadcast calls this single answer a &quot;style.&quot; Every broadcastable object each has its own preferred style, and a promotion-like system is used to combine these styles into a single answer — the &quot;destination style&quot;.</p><h3><a class="nav-anchor" id="Broadcast-Styles-1" href="#Broadcast-Styles-1">Broadcast Styles</a></h3><p><code>Base.BroadcastStyle</code> is the abstract type from which all styles are derived. When used as a function it has two possible forms, unary (single-argument) and binary. The unary variant states that you intend to implement specific broadcasting behavior and/or output type, and do not wish to rely on the default fallback (<a href="../../base/arrays/#Base.Broadcast.DefaultArrayStyle"><code>Broadcast.DefaultArrayStyle</code></a>). To override these defaults, you can define a custom <code>BroadcastStyle</code> for your object:</p><pre><code class="language-julia">struct MyStyle &lt;: Broadcast.BroadcastStyle end
Base.BroadcastStyle(::Type{&lt;:MyType}) = MyStyle()</code></pre><p>In some cases it might be convenient not to have to define <code>MyStyle</code>, in which case you can leverage one of the general broadcast wrappers:</p><ul><li><code>Base.BroadcastStyle(::Type{&lt;:MyType}) = Broadcast.Style{MyType}()</code> can be used for arbitrary types.</li><li><code>Base.BroadcastStyle(::Type{&lt;:MyType}) = Broadcast.ArrayStyle{MyType}()</code> is preferred if <code>MyType</code> is an <code>AbstractArray</code>.</li><li>For <code>AbstractArrays</code> that only support a certain dimensionality, create a subtype of <code>Broadcast.AbstractArrayStyle{N}</code> (see below).</li></ul><p>When your broadcast operation involves several arguments, individual argument styles get combined to determine a single <code>DestStyle</code> that controls the type of the output container. For more detail, see <a href="#writing-binary-broadcasting-rules-1">below</a>.</p><h3><a class="nav-anchor" id="Selecting-an-appropriate-output-array-1" href="#Selecting-an-appropriate-output-array-1">Selecting an appropriate output array</a></h3><p>The actual allocation of the result array is handled by <code>Base.broadcast_similar</code>:</p><pre><code class="language-julia">Base.broadcast_similar(f, ::DestStyle, ::Type{ElType}, inds, As...)</code></pre><p><code>f</code> is the operation being performed and <code>DestStyle</code> signals the final result from combining the input styles. <code>As...</code> is the list of input objects. You may not need to use <code>f</code> or <code>As...</code> unless they help you build the appropriate object; the fallback definition is</p><pre><code class="language-julia">broadcast_similar(f, ::DefaultArrayStyle{N}, ::Type{ElType}, inds::Indices{N}, As...) where {N,ElType} =
    similar(Array{ElType}, inds)</code></pre><p>However, if needed you can specialize on any or all of these arguments.</p><p>For a complete example, let&#39;s say you have created a type, <code>ArrayAndChar</code>, that stores an array and a single character:</p><pre><code class="language-julia">struct ArrayAndChar{T,N} &lt;: AbstractArray{T,N}
    data::Array{T,N}
    char::Char
end
Base.size(A::ArrayAndChar) = size(A.data)
Base.getindex(A::ArrayAndChar{T,N}, inds::Vararg{Int,N}) where {T,N} = A.data[inds...]
Base.setindex!(A::ArrayAndChar{T,N}, val, inds::Vararg{Int,N}) where {T,N} = A.data[inds...] = val
Base.showarg(io::IO, A::ArrayAndChar, toplevel) = print(io, typeof(A), &quot; with char &#39;&quot;, A.char, &quot;&#39;&quot;)
# output
</code></pre><p>You might want broadcasting to preserve the <code>char</code> &quot;metadata.&quot; First we define</p><pre><code class="language-julia">Base.BroadcastStyle(::Type{&lt;:ArrayAndChar}) = Broadcast.ArrayStyle{ArrayAndChar}()
# output
</code></pre><p>This forces us to also define a <code>broadcast_similar</code> method:</p><pre><code class="language-julia">function Base.broadcast_similar(f, ::Broadcast.ArrayStyle{ArrayAndChar}, ::Type{ElType}, inds, As...) where ElType
    # Scan the inputs for the ArrayAndChar:
    A = find_aac(As...)
    # Use the char field of A to create the output
    ArrayAndChar(similar(Array{ElType}, inds), A.char)
end

&quot;`A = find_aac(As...)` returns the first ArrayAndChar among the arguments.&quot;
find_aac(A::ArrayAndChar, B...) = A
find_aac(A, B...) = find_aac(B...);
# output
</code></pre><p>From these definitions, one obtains the following behavior:</p><pre><code class="language-julia-repl">julia&gt; a = ArrayAndChar([1 2; 3 4], &#39;x&#39;)
2×2 ArrayAndChar{Int64,2} with char &#39;x&#39;:
 1  2
 3  4

julia&gt; a .+ 1
2×2 ArrayAndChar{Int64,2} with char &#39;x&#39;:
 2  3
 4  5

julia&gt; a .+ [5,10]
2×2 ArrayAndChar{Int64,2} with char &#39;x&#39;:
  6   7
 13  14</code></pre><h3><a class="nav-anchor" id="extending-in-place-broadcast-1" href="#extending-in-place-broadcast-1">Extending broadcast with custom implementations</a></h3><p>Finally, it&#39;s worth noting that sometimes it&#39;s easier simply to bypass the machinery for computing result types and container sizes, and just do everything manually. For example, you can convert a <code>UnitRange{Int}</code> <code>r</code> to a <code>UnitRange{BigInt}</code> with <code>big.(r)</code>; the definition of this method is approximately</p><pre><code class="language-julia">Broadcast.broadcast(::typeof(big), r::UnitRange) = big(first(r)):big(last(r))</code></pre><p>This exploits Julia&#39;s ability to dispatch on a particular function type. (This kind of explicit definition can indeed be necessary if the output container does not support <code>setindex!</code>.) You can optionally choose to implement the actual broadcasting yourself, but allow the internal machinery to compute the container type, element type, and indices by specializing</p><pre><code class="language-julia">Broadcast.broadcast(::typeof(somefunction), ::MyStyle, ::Type{ElType}, inds, As...)</code></pre><p>Extending <code>broadcast!</code> (in-place broadcast) should be done with care, as it is easy to introduce ambiguities between packages. To avoid these ambiguities, we adhere to the following conventions.</p><p>First, if you want to specialize on the destination type, say <code>DestType</code>, then you should define a method with the following signature:</p><pre><code class="language-julia">broadcast!(f, dest::DestType, ::Nothing, As...)</code></pre><p>Note that no bounds should be placed on the types of <code>f</code> and <code>As...</code>.</p><p>Second, if specialized <code>broadcast!</code> behavior is desired depending on the input types, you should write <a href="#writing-binary-broadcasting-rules-1">binary broadcasting rules</a> to determine a custom <code>BroadcastStyle</code> given the input types, say <code>MyBroadcastStyle</code>, and you should define a method with the following signature:</p><pre><code class="language-julia">broadcast!(f, dest, ::MyBroadcastStyle, As...)</code></pre><p>Note the lack of bounds on <code>f</code>, <code>dest</code>, and <code>As...</code>.</p><p>Third, simultaneously specializing on both the type of <code>dest</code> and the <code>BroadcastStyle</code> is fine. In this case, it is also allowed to specialize on the types of the source arguments (<code>As...</code>). For example, these method signatures are OK:</p><pre><code class="language-julia">broadcast!(f, dest::DestType, ::MyBroadcastStyle, As...)
broadcast!(f, dest::DestType, ::MyBroadcastStyle, As::AbstractArray...)
broadcast!(f, dest::DestType, ::Broadcast.DefaultArrayStyle{0}, As::Number...)</code></pre><h4><a class="nav-anchor" id="writing-binary-broadcasting-rules-1" href="#writing-binary-broadcasting-rules-1">Writing binary broadcasting rules</a></h4><p>The precedence rules are defined by binary <code>BroadcastStyle</code> calls:</p><pre><code class="language-julia">Base.BroadcastStyle(::Style1, ::Style2) = Style12()</code></pre><p>where <code>Style12</code> is the <code>BroadcastStyle</code> you want to choose for outputs involving arguments of <code>Style1</code> and <code>Style2</code>. For example,</p><pre><code class="language-julia">Base.BroadcastStyle(::Broadcast.Style{Tuple}, ::Broadcast.AbstractArrayStyle{0}) = Broadcast.Style{Tuple}()</code></pre><p>indicates that <code>Tuple</code> &quot;wins&quot; over zero-dimensional arrays (the output container will be a tuple). It is worth noting that you do not need to (and should not) define both argument orders of this call; defining one is sufficient no matter what order the user supplies the arguments in.</p><p>For <code>AbstractArray</code> types, defining a <code>BroadcastStyle</code> supersedes the fallback choice, <a href="../../base/arrays/#Base.Broadcast.DefaultArrayStyle"><code>Broadcast.DefaultArrayStyle</code></a>. <code>DefaultArrayStyle</code> and the abstract supertype, <code>AbstractArrayStyle</code>, store the dimensionality as a type parameter to support specialized array types that have fixed dimensionality requirements.</p><p><code>DefaultArrayStyle</code> &quot;loses&quot; to any other <code>AbstractArrayStyle</code> that has been defined because of the following methods:</p><pre><code class="language-julia">BroadcastStyle(a::AbstractArrayStyle{Any}, ::DefaultArrayStyle) = a
BroadcastStyle(a::AbstractArrayStyle{N}, ::DefaultArrayStyle{N}) where N = a
BroadcastStyle(a::AbstractArrayStyle{M}, ::DefaultArrayStyle{N}) where {M,N} =
    typeof(a)(_max(Val(M),Val(N)))</code></pre><p>You do not need to write binary <code>BroadcastStyle</code> rules unless you want to establish precedence for two or more non-<code>DefaultArrayStyle</code> types.</p><p>If your array type does have fixed dimensionality requirements, then you should subtype <code>AbstractArrayStyle</code>. For example, the sparse array code has the following definitions:</p><pre><code class="language-julia">struct SparseVecStyle &lt;: Broadcast.AbstractArrayStyle{1} end
struct SparseMatStyle &lt;: Broadcast.AbstractArrayStyle{2} end
Base.BroadcastStyle(::Type{&lt;:SparseVector}) = SparseVecStyle()
Base.BroadcastStyle(::Type{&lt;:SparseMatrixCSC}) = SparseMatStyle()</code></pre><p>Whenever you subtype <code>AbstractArrayStyle</code>, you also need to define rules for combining dimensionalities, by creating a constructor for your style that takes a <code>Val(N)</code> argument. For example:</p><pre><code class="language-julia">SparseVecStyle(::Val{0}) = SparseVecStyle()
SparseVecStyle(::Val{1}) = SparseVecStyle()
SparseVecStyle(::Val{2}) = SparseMatStyle()
SparseVecStyle(::Val{N}) where N = Broadcast.DefaultArrayStyle{N}()</code></pre><p>These rules indicate that the combination of a <code>SparseVecStyle</code> with 0- or 1-dimensional arrays yields another <code>SparseVecStyle</code>, that its combination with a 2-dimensional array yields a <code>SparseMatStyle</code>, and anything of higher dimensionality falls back to the dense arbitrary-dimensional framework. These rules allow broadcasting to keep the sparse representation for operations that result in one or two dimensional outputs, but produce an <code>Array</code> for any other dimensionality.</p><footer><hr/><a class="previous" href="../conversion-and-promotion/"><span class="direction">Previous</span><span class="title">Conversion and Promotion</span></a><a class="next" href="../modules/"><span class="direction">Next</span><span class="title">Modules</span></a></footer></article></body></html>
