<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Packages · The Julia Language</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-28835595-6', 'auto');
ga('send', 'pageview');
</script><link rel="canonical" href="https://docs.julialang.org/en/stable/manual/packages/index.html"/><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../../assets/julia-manual.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../../index.html"><img class="logo" src="../../assets/logo.png" alt="The Julia Language logo"/></a><h1>The Julia Language</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../getting-started/">Getting Started</a></li><li><a class="toctext" href="../variables/">Variables</a></li><li><a class="toctext" href="../integers-and-floating-point-numbers/">Integers and Floating-Point Numbers</a></li><li><a class="toctext" href="../mathematical-operations/">Mathematical Operations and Elementary Functions</a></li><li><a class="toctext" href="../complex-and-rational-numbers/">Complex and Rational Numbers</a></li><li><a class="toctext" href="../strings/">Strings</a></li><li><a class="toctext" href="../functions/">Functions</a></li><li><a class="toctext" href="../control-flow/">Control Flow</a></li><li><a class="toctext" href="../variables-and-scoping/">Scope of Variables</a></li><li><a class="toctext" href="../types/">Types</a></li><li><a class="toctext" href="../methods/">Methods</a></li><li><a class="toctext" href="../constructors/">Constructors</a></li><li><a class="toctext" href="../conversion-and-promotion/">Conversion and Promotion</a></li><li><a class="toctext" href="../interfaces/">Interfaces</a></li><li><a class="toctext" href="../modules/">Modules</a></li><li><a class="toctext" href="../documentation/">Documentation</a></li><li><a class="toctext" href="../metaprogramming/">Metaprogramming</a></li><li><a class="toctext" href="../arrays/">Multi-dimensional Arrays</a></li><li><a class="toctext" href="../missing/">Missing Values</a></li><li><a class="toctext" href="../networking-and-streams/">Networking and Streams</a></li><li><a class="toctext" href="../parallel-computing/">Parallel Computing</a></li><li><a class="toctext" href="../running-external-programs/">Running External Programs</a></li><li><a class="toctext" href="../calling-c-and-fortran-code/">Calling C and Fortran Code</a></li><li><a class="toctext" href="../handling-operating-system-variation/">Handling Operating System Variation</a></li><li><a class="toctext" href="../environment-variables/">Environment Variables</a></li><li><a class="toctext" href="../embedding/">Embedding Julia</a></li><li class="current"><a class="toctext" href>Packages</a><ul class="internal"><li><a class="toctext" href="#Package-Status-1">Package Status</a></li><li><a class="toctext" href="#Adding-and-Removing-Packages-1">Adding and Removing Packages</a></li><li><a class="toctext" href="#Offline-Installation-of-Packages-1">Offline Installation of Packages</a></li><li><a class="toctext" href="#Installing-Unregistered-Packages-1">Installing Unregistered Packages</a></li><li><a class="toctext" href="#Updating-Packages-1">Updating Packages</a></li><li><a class="toctext" href="#Checkout,-Pin-and-Free-1">Checkout, Pin and Free</a></li><li><a class="toctext" href="#Custom-METADATA-Repository-1">Custom METADATA Repository</a></li><li class="toplevel"><a class="toctext" href="#Package-Development-1">Package Development</a></li><li><a class="toctext" href="#man-initial-setup-1">Initial Setup</a></li><li><a class="toctext" href="#Making-changes-to-an-existing-package-1">Making changes to an existing package</a></li><li><a class="toctext" href="#Creating-a-new-Package-1">Creating a new Package</a></li><li><a class="toctext" href="#Fixing-Package-Requirements-1">Fixing Package Requirements</a></li><li><a class="toctext" href="#Requirements-Specification-1">Requirements Specification</a></li></ul></li><li><a class="toctext" href="../code-loading/">Code Loading</a></li><li><a class="toctext" href="../profile/">Profiling</a></li><li><a class="toctext" href="../stacktraces/">Stack Traces</a></li><li><a class="toctext" href="../performance-tips/">Performance Tips</a></li><li><a class="toctext" href="../workflow-tips/">Workflow Tips</a></li><li><a class="toctext" href="../style-guide/">Style Guide</a></li><li><a class="toctext" href="../faq/">Frequently Asked Questions</a></li><li><a class="toctext" href="../noteworthy-differences/">Noteworthy Differences from other Languages</a></li><li><a class="toctext" href="../unicode-input/">Unicode Input</a></li></ul></li><li><span class="toctext">Base</span><ul><li><a class="toctext" href="../../base/base/">Essentials</a></li><li><a class="toctext" href="../../base/collections/">Collections and Data Structures</a></li><li><a class="toctext" href="../../base/math/">Mathematics</a></li><li><a class="toctext" href="../../base/numbers/">Numbers</a></li><li><a class="toctext" href="../../base/strings/">Strings</a></li><li><a class="toctext" href="../../base/arrays/">Arrays</a></li><li><a class="toctext" href="../../base/parallel/">Tasks</a></li><li><a class="toctext" href="../../base/multi-threading/">Multi-Threading</a></li><li><a class="toctext" href="../../base/constants/">Constants</a></li><li><a class="toctext" href="../../base/file/">Filesystem</a></li><li><a class="toctext" href="../../base/io-network/">I/O and Network</a></li><li><a class="toctext" href="../../base/punctuation/">Punctuation</a></li><li><a class="toctext" href="../../base/sort/">Sorting and Related Functions</a></li><li><a class="toctext" href="../../base/iterators/">Iteration utilities</a></li><li><a class="toctext" href="../../base/c/">C Interface</a></li><li><a class="toctext" href="../../base/libc/">C Standard Library</a></li><li><a class="toctext" href="../../base/stacktraces/">StackTraces</a></li><li><a class="toctext" href="../../base/simd-types/">SIMD Support</a></li></ul></li><li><span class="toctext">Standard Library</span><ul><li><a class="toctext" href="../../stdlib/Base64/">Base64</a></li><li><a class="toctext" href="../../stdlib/CRC32c/">CRC32c</a></li><li><a class="toctext" href="../../stdlib/Dates/">Dates</a></li><li><a class="toctext" href="../../stdlib/DelimitedFiles/">Delimited Files</a></li><li><a class="toctext" href="../../stdlib/Distributed/">Distributed Computing</a></li><li><a class="toctext" href="../../stdlib/FileWatching/">File Events</a></li><li><a class="toctext" href="../../stdlib/InteractiveUtils/">Interactive Utilities</a></li><li><a class="toctext" href="../../stdlib/IterativeEigensolvers/">Iterative Eigensolvers</a></li><li><a class="toctext" href="../../stdlib/LibGit2/">LibGit2</a></li><li><a class="toctext" href="../../stdlib/Libdl/">Dynamic Linker</a></li><li><a class="toctext" href="../../stdlib/LinearAlgebra/">Linear Algebra</a></li><li><a class="toctext" href="../../stdlib/Logging/">Logging</a></li><li><a class="toctext" href="../../stdlib/Markdown/">Markdown</a></li><li><a class="toctext" href="../../stdlib/Mmap/">Memory-mapped I/O</a></li><li><a class="toctext" href="../../stdlib/Pkg/">Package Manager Functions</a></li><li><a class="toctext" href="../../stdlib/Pkg3/">Pkg3.jl</a></li><li><a class="toctext" href="../../stdlib/Printf/">Printf</a></li><li><a class="toctext" href="../../stdlib/Profile/">Profiling</a></li><li><a class="toctext" href="../../stdlib/REPL/">The Julia REPL</a></li><li><a class="toctext" href="../../stdlib/Random/">Random Numbers</a></li><li><a class="toctext" href="../../stdlib/SHA/">SHA</a></li><li><a class="toctext" href="../../stdlib/Serialization/">Serialization</a></li><li><a class="toctext" href="../../stdlib/SharedArrays/">Shared Arrays</a></li><li><a class="toctext" href="../../stdlib/Sockets/">Sockets</a></li><li><a class="toctext" href="../../stdlib/SparseArrays/">Sparse Arrays</a></li><li><a class="toctext" href="../../stdlib/Test/">Unit Testing</a></li><li><a class="toctext" href="../../stdlib/UUIDs/">UUIDs</a></li><li><a class="toctext" href="../../stdlib/Unicode/">Unicode</a></li></ul></li><li><span class="toctext">Developer Documentation</span><ul><li><a class="toctext" href="../../devdocs/reflection/">Reflection and introspection</a></li><li><span class="toctext">Documentation of Julia&#39;s Internals</span><ul><li><a class="toctext" href="../../devdocs/init/">Initialization of the Julia runtime</a></li><li><a class="toctext" href="../../devdocs/ast/">Julia ASTs</a></li><li><a class="toctext" href="../../devdocs/types/">More about types</a></li><li><a class="toctext" href="../../devdocs/object/">Memory layout of Julia Objects</a></li><li><a class="toctext" href="../../devdocs/eval/">Eval of Julia code</a></li><li><a class="toctext" href="../../devdocs/callconv/">Calling Conventions</a></li><li><a class="toctext" href="../../devdocs/compiler/">High-level Overview of the Native-Code Generation Process</a></li><li><a class="toctext" href="../../devdocs/functions/">Julia Functions</a></li><li><a class="toctext" href="../../devdocs/cartesian/">Base.Cartesian</a></li><li><a class="toctext" href="../../devdocs/meta/">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="../../devdocs/subarrays/">SubArrays</a></li><li><a class="toctext" href="../../devdocs/sysimg/">System Image Building</a></li><li><a class="toctext" href="../../devdocs/llvm/">Working with LLVM</a></li><li><a class="toctext" href="../../devdocs/stdio/">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="../../devdocs/boundscheck/">Bounds checking</a></li><li><a class="toctext" href="../../devdocs/locks/">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="../../devdocs/offset-arrays/">Arrays with custom indices</a></li><li><a class="toctext" href="../../devdocs/require/">Module loading</a></li><li><a class="toctext" href="../../devdocs/inference/">Inference</a></li></ul></li><li><span class="toctext">Developing/debugging Julia&#39;s C code</span><ul><li><a class="toctext" href="../../devdocs/backtraces/">Reporting and analyzing crashes (segfaults)</a></li><li><a class="toctext" href="../../devdocs/debuggingtips/">gdb debugging tips</a></li><li><a class="toctext" href="../../devdocs/valgrind/">Using Valgrind with Julia</a></li><li><a class="toctext" href="../../devdocs/sanitizers/">Sanitizer support</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href>Packages</a></li></ul><a class="edit-page" href="https://github.com/JuliaLang/julia/blob/master/doc/src/manual/packages.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Packages</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Packages-1" href="#Packages-1">Packages</a></h1><p>Julia has a built-in package manager for installing add-on functionality written in Julia. It can also install external libraries using your operating system&#39;s standard system for doing so, or by compiling from source. The list of registered Julia packages can be found at <a href="http://pkg.julialang.org">http://pkg.julialang.org</a>. All package manager commands are found in the <code>Pkg</code> standard library which becomes available after using <code>import Pkg</code>.</p><p>First we&#39;ll go over the mechanics of the <code>Pkg</code> family of commands and then we&#39;ll provide some guidance on how to get your package registered. Be sure to read the section below on package naming conventions, tagging versions and the importance of a <code>REQUIRE</code> file for when you&#39;re ready to add your code to the curated METADATA repository.</p><h2><a class="nav-anchor" id="Package-Status-1" href="#Package-Status-1">Package Status</a></h2><p>The <a href="../../stdlib/Pkg/#Pkg.status"><code>Pkg.status()</code></a> function prints out a summary of the state of packages you have installed. Initially, you&#39;ll have no packages installed:</p><pre><code class="language-julia-repl">julia&gt; Pkg.status()
INFO: Initializing package repository /Users/someone/.julia/v0.6
INFO: Cloning METADATA from git://github.com/JuliaLang/METADATA.jl
No packages installed.</code></pre><p>Your package directory is automatically initialized the first time you run a <code>Pkg</code> command that expects it to exist – which includes <a href="../../stdlib/Pkg/#Pkg.status"><code>Pkg.status()</code></a>. Here&#39;s an example non-trivial set of required and additional packages:</p><pre><code class="language-julia-repl">julia&gt; Pkg.status()
Required packages:
 - Distributions                 0.2.8
 - SHA                           0.3.2
Additional packages:
 - NumericExtensions             0.2.17
 - Stats                         0.2.6</code></pre><p>These packages are all on registered versions, managed by <code>Pkg</code>. Packages can be in more complicated states, indicated by annotations to the right of the installed package version; we will explain these states and annotations as we encounter them. For programmatic usage, <a href="../../stdlib/Pkg/#Pkg.installed"><code>Pkg.installed()</code></a> returns a dictionary, mapping installed package names to the version of that package which is installed:</p><pre><code class="language-julia-repl">julia&gt; Pkg.installed()
Dict{String,VersionNumber} with 4 entries:
&quot;Distributions&quot;     =&gt; v&quot;0.2.8&quot;
&quot;Stats&quot;             =&gt; v&quot;0.2.6&quot;
&quot;SHA&quot;               =&gt; v&quot;0.3.2&quot;
&quot;NumericExtensions&quot; =&gt; v&quot;0.2.17&quot;</code></pre><h2><a class="nav-anchor" id="Adding-and-Removing-Packages-1" href="#Adding-and-Removing-Packages-1">Adding and Removing Packages</a></h2><p>Julia&#39;s package manager is a little unusual in that it is declarative rather than imperative. This means that you tell it what you want and it figures out what versions to install (or remove) to satisfy those requirements optimally – and minimally. So rather than installing a package, you just add it to the list of requirements and then &quot;resolve&quot; what needs to be installed. In particular, this means that if some package had been installed because it was needed by a previous version of something you wanted, and a newer version doesn&#39;t have that requirement anymore, updating will actually remove that package.</p><p>Your package requirements are in the file <code>~/.julia/v0.6/REQUIRE</code>. You can edit this file by hand and then call <a href="../../stdlib/Pkg/#Pkg.resolve"><code>Pkg.resolve()</code></a> to install, upgrade or remove packages to optimally satisfy the requirements, or you can do <a href="../../stdlib/Pkg/#Pkg.edit"><code>Pkg.edit()</code></a>, which will open <code>REQUIRE</code> in your editor (configured via the <code>EDITOR</code> or <code>VISUAL</code> environment variables), and then automatically call <a href="../../stdlib/Pkg/#Pkg.resolve"><code>Pkg.resolve()</code></a> afterwards if necessary. If you only want to add or remove the requirement for a single package, you can also use the non-interactive <a href="../../stdlib/Pkg/#Pkg.add"><code>Pkg.add()</code></a> and <a href="../../stdlib/Pkg/#Pkg.rm"><code>Pkg.rm()</code></a> commands, which add or remove a single requirement to <code>REQUIRE</code> and then call <a href="../../stdlib/Pkg/#Pkg.resolve"><code>Pkg.resolve()</code></a>.</p><p>You can add a package to the list of requirements with the <a href="../../stdlib/Pkg/#Pkg.add"><code>Pkg.add()</code></a> function, and the package and all the packages that it depends on will be installed:</p><pre><code class="language-julia-repl">julia&gt; Pkg.status()
No packages installed.

julia&gt; Pkg.add(&quot;Distributions&quot;)
INFO: Cloning cache of Distributions from git://github.com/JuliaStats/Distributions.jl.git
INFO: Cloning cache of NumericExtensions from git://github.com/lindahua/NumericExtensions.jl.git
INFO: Cloning cache of Stats from git://github.com/JuliaStats/Stats.jl.git
INFO: Installing Distributions v0.2.7
INFO: Installing NumericExtensions v0.2.17
INFO: Installing Stats v0.2.6
INFO: REQUIRE updated.

julia&gt; Pkg.status()
Required packages:
 - Distributions                 0.2.7
Additional packages:
 - NumericExtensions             0.2.17
 - Stats                         0.2.6</code></pre><p>What this is doing is first adding <code>Distributions</code> to your <code>~/.julia/v0.6/REQUIRE</code> file:</p><pre><code class="language-none">$ cat ~/.julia/v0.6/REQUIRE
Distributions</code></pre><p>It then runs <a href="../../stdlib/Pkg/#Pkg.resolve"><code>Pkg.resolve()</code></a> using these new requirements, which leads to the conclusion that the <code>Distributions</code> package should be installed since it is required but not installed. As stated before, you can accomplish the same thing by editing your <code>~/.julia/v0.6/REQUIRE</code> file by hand and then running <a href="../../stdlib/Pkg/#Pkg.resolve"><code>Pkg.resolve()</code></a> yourself:</p><pre><code class="language-julia-repl">$ echo SHA &gt;&gt; ~/.julia/v0.6/REQUIRE

julia&gt; Pkg.resolve()
INFO: Cloning cache of SHA from git://github.com/staticfloat/SHA.jl.git
INFO: Installing SHA v0.3.2

julia&gt; Pkg.status()
Required packages:
 - Distributions                 0.2.7
 - SHA                           0.3.2
Additional packages:
 - NumericExtensions             0.2.17
 - Stats                         0.2.6</code></pre><p>This is functionally equivalent to calling <a href="../../stdlib/Pkg/#Pkg.add"><code>Pkg.add(&quot;SHA&quot;)</code></a>, except that <a href="../../stdlib/Pkg/#Pkg.add"><code>Pkg.add()</code></a> doesn&#39;t change <code>REQUIRE</code> until <em>after</em> installation has completed, so if there are problems, <code>REQUIRE</code> will be left as it was before calling <a href="../../stdlib/Pkg/#Pkg.add"><code>Pkg.add()</code></a>. The format of the <code>REQUIRE</code> file is described in <a href="#Requirements-Specification-1">Requirements Specification</a>; it allows, among other things, requiring specific ranges of versions of packages.</p><p>When you decide that you don&#39;t want to have a package around any more, you can use <a href="../../stdlib/Pkg/#Pkg.rm"><code>Pkg.rm()</code></a> to remove the requirement for it from the <code>REQUIRE</code> file:</p><pre><code class="language-julia-repl">julia&gt; Pkg.rm(&quot;Distributions&quot;)
INFO: Removing Distributions v0.2.7
INFO: Removing Stats v0.2.6
INFO: Removing NumericExtensions v0.2.17
INFO: REQUIRE updated.

julia&gt; Pkg.status()
Required packages:
 - SHA                           0.3.2

julia&gt; Pkg.rm(&quot;SHA&quot;)
INFO: Removing SHA v0.3.2
INFO: REQUIRE updated.

julia&gt; Pkg.status()
No packages installed.</code></pre><p>Once again, this is equivalent to editing the <code>REQUIRE</code> file to remove the line with each package name on it then running <a href="../../stdlib/Pkg/#Pkg.resolve"><code>Pkg.resolve()</code></a> to update the set of installed packages to match. While <a href="../../stdlib/Pkg/#Pkg.add"><code>Pkg.add()</code></a> and <a href="../../stdlib/Pkg/#Pkg.rm"><code>Pkg.rm()</code></a> are convenient for adding and removing requirements for a single package, when you want to add or remove multiple packages, you can call <a href="../../stdlib/Pkg/#Pkg.edit"><code>Pkg.edit()</code></a> to manually change the contents of <code>REQUIRE</code> and then update your packages accordingly. <a href="../../stdlib/Pkg/#Pkg.edit"><code>Pkg.edit()</code></a> does not roll back the contents of <code>REQUIRE</code> if <a href="../../stdlib/Pkg/#Pkg.resolve"><code>Pkg.resolve()</code></a> fails – rather, you have to run <a href="../../stdlib/Pkg/#Pkg.edit"><code>Pkg.edit()</code></a> again to fix the files contents yourself.</p><p>Because the package manager uses libgit2 internally to manage the package git repositories, users may run into protocol issues (if behind a firewall, for example), when running <a href="../../stdlib/Pkg/#Pkg.add"><code>Pkg.add()</code></a>. By default, all GitHub-hosted packages wil be accessed via &#39;https&#39;; this default can be modified by calling <a href="../../stdlib/Pkg/#Pkg.setprotocol!"><code>Pkg.setprotocol!()</code></a>. The following command can be run from the command line in order to tell git to use &#39;https&#39; instead of the &#39;git&#39; protocol when cloning all repositories, wherever they are hosted:</p><pre><code class="language-none">git config --global url.&quot;https://&quot;.insteadOf git://</code></pre><p>However, this change will be system-wide and thus the use of <a href="../../stdlib/Pkg/#Pkg.setprotocol!"><code>Pkg.setprotocol!()</code></a> is preferable.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>The package manager functions also accept the <code>.jl</code> suffix on package names, though the suffix is stripped internally. For example:</p><pre><code class="language-julia">Pkg.add(&quot;Distributions.jl&quot;)
Pkg.rm(&quot;Distributions.jl&quot;)</code></pre></div></div><h2><a class="nav-anchor" id="Offline-Installation-of-Packages-1" href="#Offline-Installation-of-Packages-1">Offline Installation of Packages</a></h2><p>For machines with no Internet connection, packages may be installed by copying the package root directory (given by <a href="../../stdlib/Pkg/#Pkg.dir"><code>Pkg.dir()</code></a>) from a machine with the same operating system and environment.</p><p><a href="../../stdlib/Pkg/#Pkg.add"><code>Pkg.add()</code></a> does the following within the package root directory:</p><ol><li>Adds the name of the package to <code>REQUIRE</code>.</li><li>Downloads the package to <code>.cache</code>, then copies the package to the package root directory.</li><li>Recursively performs step 2 against all the packages listed in the package&#39;s <code>REQUIRE</code> file.</li><li>Runs <a href="../../stdlib/Pkg/#Pkg.build"><code>Pkg.build()</code></a></li></ol><div class="admonition warning"><div class="admonition-title">Warning</div><div class="admonition-text"><p>Copying installed packages from a different machine is brittle for packages requiring binary external dependencies. Such packages may break due to differences in operating system versions, build environments, and/or absolute path dependencies.</p></div></div><h2><a class="nav-anchor" id="Installing-Unregistered-Packages-1" href="#Installing-Unregistered-Packages-1">Installing Unregistered Packages</a></h2><p>Julia packages are simply git repositories, clonable via any of the <a href="https://www.kernel.org/pub/software/scm/git/docs/git-clone.html#URLS">protocols</a> that git supports, and containing Julia code that follows certain layout conventions. Official Julia packages are registered in the <a href="https://github.com/JuliaLang/METADATA.jl">METADATA.jl</a> repository, available at a well-known location <a href="#footnote-1">[1]</a>. The <a href="../../stdlib/Pkg/#Pkg.add"><code>Pkg.add()</code></a> and <a href="../../stdlib/Pkg/#Pkg.rm"><code>Pkg.rm()</code></a> commands in the previous section interact with registered packages, but the package manager can install and work with unregistered packages too. To install an unregistered package, use <a href="../../stdlib/Pkg/#Pkg.clone"><code>Pkg.clone(url)</code></a>, where <code>url</code> is a git URL from which the package can be cloned:</p><pre><code class="language-julia-repl">julia&gt; Pkg.clone(&quot;git://example.com/path/to/Package.jl.git&quot;)
INFO: Cloning Package from git://example.com/path/to/Package.jl.git
Cloning into &#39;Package&#39;...
remote: Counting objects: 22, done.
remote: Compressing objects: 100% (10/10), done.
remote: Total 22 (delta 8), reused 22 (delta 8)
Receiving objects: 100% (22/22), 2.64 KiB, done.
Resolving deltas: 100% (8/8), done.</code></pre><p>By convention, Julia repository names end with <code>.jl</code> (the additional <code>.git</code> indicates a &quot;bare&quot; git repository), which keeps them from colliding with repositories for other languages, and also makes Julia packages easy to find in search engines. When packages are installed in your <code>.julia/v0.6</code> directory, however, the extension is redundant so we leave it off.</p><p>If unregistered packages contain a <code>REQUIRE</code> file at the top of their source tree, that file will be used to determine which registered packages the unregistered package depends on, and they will automatically be installed. Unregistered packages participate in the same version resolution logic as registered packages, so installed package versions will be adjusted as necessary to satisfy the requirements of both registered and unregistered packages.</p><div class="footnote" id="footnote-1"><a href="#footnote-1"><strong>[1]</strong></a><p>The official set of packages is at <a href="https://github.com/JuliaLang/METADATA.jl">https://github.com/JuliaLang/METADATA.jl</a>, but individuals and organizations can easily use a different metadata repository. This allows control which packages are available for automatic installation. One can allow only audited and approved package versions, and make private packages or forks available. See <a href="#Custom-METADATA-Repository-1">Custom METADATA Repository</a> for details.</p></div><h2><a class="nav-anchor" id="Updating-Packages-1" href="#Updating-Packages-1">Updating Packages</a></h2><p>When package developers publish new registered versions of packages that you&#39;re using, you will, of course, want the new shiny versions. To get the latest and greatest versions of all your packages, just do <a href="../../stdlib/Pkg/#Pkg.update"><code>Pkg.update()</code></a>:</p><pre><code class="language-julia-repl">julia&gt; Pkg.update()
INFO: Updating METADATA...
INFO: Computing changes...
INFO: Upgrading Distributions: v0.2.8 =&gt; v0.2.10
INFO: Upgrading Stats: v0.2.7 =&gt; v0.2.8</code></pre><p>The first step of updating packages is to pull new changes to <code>~/.julia/v0.6/METADATA</code> and see if any new registered package versions have been published. After this, <a href="../../stdlib/Pkg/#Pkg.update"><code>Pkg.update()</code></a> attempts to update packages that are checked out on a branch and not dirty (i.e. no changes have been made to files tracked by git) by pulling changes from the package&#39;s upstream repository. Upstream changes will only be applied if no merging or rebasing is necessary – i.e. if the branch can be <a href="https://git-scm.com/book/en/v2/Git-Branching-Basic-Branching-and-Merging">&quot;fast-forwarded&quot;</a>. If the branch cannot be fast-forwarded, it is assumed that you&#39;re working on it and will update the repository yourself.</p><p>Finally, the update process recomputes an optimal set of package versions to have installed to satisfy your top-level requirements and the requirements of &quot;fixed&quot; packages. A package is considered fixed if it is one of the following:</p><ol><li><strong>Unregistered:</strong> the package is not in <code>METADATA</code> – you installed it with <a href="../../stdlib/Pkg/#Pkg.clone"><code>Pkg.clone()</code></a>.</li><li><strong>Checked out:</strong> the package repo is on a development branch.</li><li><strong>Dirty:</strong> changes have been made to files in the repo.</li></ol><p>If any of these are the case, the package manager cannot freely change the installed version of the package, so its requirements must be satisfied by whatever other package versions it picks. The combination of top-level requirements in <code>~/.julia/v0.6/REQUIRE</code> and the requirement of fixed packages are used to determine what should be installed.</p><p>You can also update only a subset of the installed packages, by providing arguments to the <a href="../../stdlib/Pkg/#Pkg.update"><code>Pkg.update</code></a> function. In that case, only the packages provided as arguments and their dependencies will be updated:</p><pre><code class="language-julia-repl">julia&gt; Pkg.update(&quot;Example&quot;)
INFO: Updating METADATA...
INFO: Computing changes...
INFO: Upgrading Example: v0.4.0 =&gt; 0.4.1</code></pre><p>This partial update process still computes the new set of package versions according to top-level requirements and &quot;fixed&quot; packages, but it additionally considers all other packages except those explicitly provided, and their dependencies, as fixed.</p><h2><a class="nav-anchor" id="Checkout,-Pin-and-Free-1" href="#Checkout,-Pin-and-Free-1">Checkout, Pin and Free</a></h2><p>You may want to use the <code>master</code> version of a package rather than one of its registered versions. There might be fixes or functionality on master that you need that aren&#39;t yet published in any registered versions, or you may be a developer of the package and need to make changes on <code>master</code> or some other development branch. In such cases, you can do <a href="../../stdlib/Pkg/#Pkg.checkout"><code>Pkg.checkout(pkg)</code></a> to checkout the <code>master</code> branch of <code>pkg</code> or <a href="../../stdlib/Pkg/#Pkg.checkout"><code>Pkg.checkout(pkg,branch)</code></a> to checkout some other branch:</p><pre><code class="language-julia-repl">julia&gt; Pkg.add(&quot;Distributions&quot;)
INFO: Installing Distributions v0.2.9
INFO: Installing NumericExtensions v0.2.17
INFO: Installing Stats v0.2.7
INFO: REQUIRE updated.

julia&gt; Pkg.status()
Required packages:
 - Distributions                 0.2.9
Additional packages:
 - NumericExtensions             0.2.17
 - Stats                         0.2.7

julia&gt; Pkg.checkout(&quot;Distributions&quot;)
INFO: Checking out Distributions master...
INFO: No packages to install, update or remove.

julia&gt; Pkg.status()
Required packages:
 - Distributions                 0.2.9+             master
Additional packages:
 - NumericExtensions             0.2.17
 - Stats                         0.2.7</code></pre><p>Immediately after installing <code>Distributions</code> with <a href="../../stdlib/Pkg/#Pkg.add"><code>Pkg.add()</code></a> it is on the current most recent registered version – <code>0.2.9</code> at the time of writing this. Then after running <a href="../../stdlib/Pkg/#Pkg.checkout"><code>Pkg.checkout(&quot;Distributions&quot;)</code></a>, you can see from the output of <a href="../../stdlib/Pkg/#Pkg.status"><code>Pkg.status()</code></a> that <code>Distributions</code> is on an unregistered version greater than <code>0.2.9</code>, indicated by the &quot;pseudo-version&quot; number <code>0.2.9+</code>.</p><p>When you checkout an unregistered version of a package, the copy of the <code>REQUIRE</code> file in the package repo takes precedence over any requirements registered in <code>METADATA</code>, so it is important that developers keep this file accurate and up-to-date, reflecting the actual requirements of the current version of the package. If the <code>REQUIRE</code> file in the package repo is incorrect or missing, dependencies may be removed when the package is checked out. This file is also used to populate newly published versions of the package if you use the API that <code>Pkg</code> provides for this (described below).</p><p>When you decide that you no longer want to have a package checked out on a branch, you can &quot;free&quot; it back to the control of the package manager with <a href="../../stdlib/Pkg/#Pkg.free"><code>Pkg.free(pkg)</code></a>:</p><pre><code class="language-julia-repl">julia&gt; Pkg.free(&quot;Distributions&quot;)
INFO: Freeing Distributions...
INFO: No packages to install, update or remove.

julia&gt; Pkg.status()
Required packages:
 - Distributions                 0.2.9
Additional packages:
 - NumericExtensions             0.2.17
 - Stats                         0.2.7</code></pre><p>After this, since the package is on a registered version and not on a branch, its version will be updated as new registered versions of the package are published.</p><p>If you want to pin a package at a specific version so that calling <a href="../../stdlib/Pkg/#Pkg.update"><code>Pkg.update()</code></a> won&#39;t change the version the package is on, you can use the <a href="../../stdlib/Pkg/#Pkg.pin"><code>Pkg.pin()</code></a> function:</p><pre><code class="language-julia-repl">julia&gt; Pkg.pin(&quot;Stats&quot;)
INFO: Creating Stats branch pinned.47c198b1.tmp

julia&gt; Pkg.status()
Required packages:
 - Distributions                 0.2.9
Additional packages:
 - NumericExtensions             0.2.17
 - Stats                         0.2.7              pinned.47c198b1.tmp</code></pre><p>After this, the <code>Stats</code> package will remain pinned at version <code>0.2.7</code> – or more specifically, at commit <code>47c198b1</code>, but since versions are permanently associated a given git hash, this is the same thing. <a href="../../stdlib/Pkg/#Pkg.pin"><code>Pkg.pin()</code></a> works by creating a throw-away branch for the commit you want to pin the package at and then checking that branch out. By default, it pins a package at the current commit, but you can choose a different version by passing a second argument:</p><pre><code class="language-julia-repl">julia&gt; Pkg.pin(&quot;Stats&quot;,v&quot;0.2.5&quot;)
INFO: Creating Stats branch pinned.1fd0983b.tmp
INFO: No packages to install, update or remove.

julia&gt; Pkg.status()
Required packages:
 - Distributions                 0.2.9
Additional packages:
 - NumericExtensions             0.2.17
 - Stats                         0.2.5              pinned.1fd0983b.tmp</code></pre><p>Now the <code>Stats</code> package is pinned at commit <code>1fd0983b</code>, which corresponds to version <code>0.2.5</code>. When you decide to &quot;unpin&quot; a package and let the package manager update it again, you can use <a href="../../stdlib/Pkg/#Pkg.free"><code>Pkg.free()</code></a> like you would to move off of any branch:</p><pre><code class="language-julia-repl">julia&gt; Pkg.free(&quot;Stats&quot;)
INFO: Freeing Stats...
INFO: No packages to install, update or remove.

julia&gt; Pkg.status()
Required packages:
 - Distributions                 0.2.9
Additional packages:
 - NumericExtensions             0.2.17
 - Stats                         0.2.7</code></pre><p>After this, the <code>Stats</code> package is managed by the package manager again, and future calls to <a href="../../stdlib/Pkg/#Pkg.update"><code>Pkg.update()</code></a> will upgrade it to newer versions when they are published. The throw-away <code>pinned.1fd0983b.tmp</code> branch remains in your local <code>Stats</code> repo, but since git branches are extremely lightweight, this doesn&#39;t really matter; if you feel like cleaning them up, you can go into the repo and delete those branches <a href="#footnote-2">[2]</a>.</p><div class="footnote" id="footnote-2"><a href="#footnote-2"><strong>[2]</strong></a><p>Packages that aren&#39;t on branches will also be marked as dirty if you make changes in the repo, but that&#39;s a less common thing to do.</p></div><h2><a class="nav-anchor" id="Custom-METADATA-Repository-1" href="#Custom-METADATA-Repository-1">Custom METADATA Repository</a></h2><p>By default, Julia assumes you will be using the <a href="https://github.com/JuliaLang/METADATA.jl">official METADATA.jl</a> repository for downloading and installing packages. You can also provide a different metadata repository location. A common approach is to keep your <code>metadata-v2</code> branch up to date with the Julia official branch and add another branch with your custom packages. You can initialize your local metadata repository using that custom location and branch and then periodically rebase your custom branch with the official <code>metadata-v2</code> branch. In order to use a custom repository and branch, issue the following command:</p><pre><code class="language-julia-repl">julia&gt; Pkg.init(&quot;https://me.example.com/METADATA.jl.git&quot;, &quot;branch&quot;)</code></pre><p>The branch argument is optional and defaults to <code>metadata-v2</code>. Once initialized, a file named <code>META_BRANCH</code> in your <code>~/.julia/vX.Y/</code> path will track the branch that your METADATA repository was initialized with. If you want to change branches, you will need to either modify the <code>META_BRANCH</code> file directly (be careful!) or remove the <code>vX.Y</code> directory and re-initialize your METADATA repository using the <code>Pkg.init</code> command.</p><h1><a class="nav-anchor" id="Package-Development-1" href="#Package-Development-1">Package Development</a></h1><p>Julia&#39;s package manager is designed so that when you have a package installed, you are already in a position to look at its source code and full development history. You are also able to make changes to packages, commit them using git, and easily contribute fixes and enhancements upstream. Similarly, the system is designed so that if you want to create a new package, the simplest way to do so is within the infrastructure provided by the package manager.</p><h2><a class="nav-anchor" id="man-initial-setup-1" href="#man-initial-setup-1">Initial Setup</a></h2><p>Since packages are git repositories, before doing any package development you should setup the following standard global git configuration settings:</p><pre><code class="language-none">$ git config --global user.name &quot;FULL NAME&quot;
$ git config --global user.email &quot;EMAIL&quot;</code></pre><p>where <code>FULL NAME</code> is your actual full name (spaces are allowed between the double quotes) and <code>EMAIL</code> is your actual email address. Although it isn&#39;t necessary to use <a href="https://github.com/">GitHub</a> to create or publish Julia packages, most Julia packages as of writing this are hosted on GitHub and the package manager knows how to format origin URLs correctly and otherwise work with the service smoothly. We recommend that you create a <a href="https://github.com/join">free account</a> on GitHub and then do:</p><pre><code class="language-none">$ git config --global github.user &quot;USERNAME&quot;</code></pre><p>where <code>USERNAME</code> is your actual GitHub user name. Once you do this, the package manager knows your GitHub user name and can configure things accordingly. You should also <a href="https://github.com/login?return_to=https%3A%2F%2Fgithub.com%2Fsettings%2Fssh">upload</a> your public SSH key to GitHub and set up an <a href="https://linux.die.net/man/1/ssh-agent">SSH agent</a> on your development machine so that you can push changes with minimal hassle. In the future, we will make this system extensible and support other common git hosting options like <a href="https://bitbucket.org">BitBucket</a> and allow developers to choose their favorite. Since the package development functions has been moved to the <a href="https://github.com/JuliaLang/PkgDev.jl">PkgDev</a> package, you need to run <code>Pkg.add(&quot;PkgDev&quot;); import PkgDev</code> to access the functions starting with <code>PkgDev.</code> in the document below.</p><h2><a class="nav-anchor" id="Making-changes-to-an-existing-package-1" href="#Making-changes-to-an-existing-package-1">Making changes to an existing package</a></h2><h3><a class="nav-anchor" id="Documentation-changes-1" href="#Documentation-changes-1">Documentation changes</a></h3><p>If you want to improve the online documentation of a package, the easiest approach (at least for small changes) is to use GitHub&#39;s online editing functionality. First, navigate to the repository&#39;s GitHub &quot;home page,&quot; find the file (e.g., <code>README.md</code>) within the repository&#39;s folder structure, and click on it. You&#39;ll see the contents displayed, along with a small &quot;pencil&quot; icon in the upper right hand corner. Clicking that icon opens the file in edit mode. Make your changes, write a brief summary describing the changes you want to make (this is your <em>commit message</em>), and then hit &quot;Propose file change.&quot; Your changes will be submitted for consideration by the package owner(s) and collaborators.</p><p>For larger documentation changes–and especially ones that you expect to have to update in response to feedback–you might find it easier to use the procedure for code changes described below.</p><h3><a class="nav-anchor" id="Code-changes-1" href="#Code-changes-1">Code changes</a></h3><h4><a class="nav-anchor" id="Executive-summary-1" href="#Executive-summary-1">Executive summary</a></h4><p>Here we assume you&#39;ve already set up git on your local machine and have a GitHub account (see above). Let&#39;s imagine you&#39;re fixing a bug in the Images package:</p><pre><code class="language-none">Pkg.checkout(&quot;Images&quot;)           # check out the master branch
&lt;here, make sure your bug is still a bug and hasn&#39;t been fixed already&gt;
cd(Pkg.dir(&quot;Images&quot;))
;git checkout -b myfixes         # create a branch for your changes
&lt;edit code&gt;                      # be sure to add a test for your bug
Pkg.test(&quot;Images&quot;)               # make sure everything works now
;git commit -a -m &quot;Fix foo by calling bar&quot;   # write a descriptive message
using PkgDev
PkgDev.submit(&quot;Images&quot;)</code></pre><p>The last line will present you with a link to submit a pull request to incorporate your changes.</p><h4><a class="nav-anchor" id="Detailed-description-1" href="#Detailed-description-1">Detailed description</a></h4><p>If you want to fix a bug or add new functionality, you want to be able to test your changes before you submit them for consideration. You also need to have an easy way to update your proposal in response to the package owner&#39;s feedback. Consequently, in this case the strategy is to work locally on your own machine; once you are satisfied with your changes, you submit them for consideration.  This process is called a <em>pull request</em> because you are asking to &quot;pull&quot; your changes into the project&#39;s main repository. Because the online repository can&#39;t see the code on your private machine, you first <em>push</em> your changes to a publicly-visible location, your own online <em>fork</em> of the package (hosted on your own personal GitHub account).</p><p>Let&#39;s assume you already have the <code>Foo</code> package installed. In the description below, anything starting with <code>Pkg.</code> or <code>PkgDev.</code> is meant to be typed at the Julia prompt; anything starting with <code>git</code> is meant to be typed in <a href="../../stdlib/REPL/#man-shell-mode-1">julia&#39;s shell mode</a> (or using the shell that comes with your operating system). Within Julia, you can combine these two modes:</p><pre><code class="language-julia-repl">julia&gt; cd(Pkg.dir(&quot;Foo&quot;))          # go to Foo&#39;s folder

shell&gt; git command arguments...    # command will apply to Foo</code></pre><p>Now suppose you&#39;re ready to make some changes to <code>Foo</code>. While there are several possible approaches, here is one that is widely used:</p><ul><li><p>From the Julia prompt, type <a href="../../stdlib/Pkg/#Pkg.checkout"><code>Pkg.checkout(&quot;Foo&quot;)</code></a>. This ensures you&#39;re running the latest code (the <code>master</code> branch), rather than just whatever &quot;official release&quot; version you have installed. (If you&#39;re planning to fix a bug, at this point it&#39;s a good idea to check again whether the bug has already been fixed by someone else. If it has, you can request that a new official release be tagged so that the fix gets distributed to the rest of the community.) If you receive an error <code>Foo is dirty, bailing</code>, see <a href="#Dirty-packages-1">Dirty packages</a> below.</p></li><li><p>Create a branch for your changes: navigate to the package folder (the one that Julia reports from <a href="../../stdlib/Pkg/#Pkg.dir"><code>Pkg.dir(&quot;Foo&quot;)</code></a>) and (in shell mode) create a new branch using <code>git checkout -b &lt;newbranch&gt;</code>, where <code>&lt;newbranch&gt;</code> might be some descriptive name (e.g., <code>fixbar</code>). By creating a branch, you ensure that you can easily go back and forth between your new work and the current <code>master</code> branch (see <a href="https://git-scm.com/book/en/v2/Git-Branching-Branches-in-a-Nutshell">https://git-scm.com/book/en/v2/Git-Branching-Branches-in-a-Nutshell</a>).</p><p>If you forget to do this step until after you&#39;ve already made some changes, don&#39;t worry: see <a href="#man-branch-post-hoc-1">more detail about branching</a> below.</p></li><li><p>Make your changes. Whether it&#39;s fixing a bug or adding new functionality, in most cases your change should include updates to both the <code>src/</code> and <code>test/</code> folders. If you&#39;re fixing a bug, add your minimal example demonstrating the bug (on the current code) to the test suite; by contributing a test for the bug, you ensure that the bug won&#39;t accidentally reappear at some later time due to other changes. If you&#39;re adding new functionality, creating tests demonstrates to the package owner that you&#39;ve made sure your code works as intended.</p></li><li><p>Run the package&#39;s tests and make sure they pass. There are several ways to run the tests:</p><ul><li>From Julia, run <a href="../../stdlib/Pkg/#Pkg.test"><code>Pkg.test(&quot;Foo&quot;)</code></a>: this will run your tests in a separate (new) <code>julia</code> process.</li><li>From Julia, <code>include(&quot;runtests.jl&quot;)</code> from the package&#39;s <code>test/</code> folder (it&#39;s possible the file has a different name, look for one that runs all the tests): this allows you to run the tests repeatedly in the same session without reloading all the package code; for packages that take a while to load, this can be much faster. With this approach, you do have to do some extra work to make <a href="../workflow-tips/#man-workflow-tips-1">changes in the package code</a>.</li><li>From the shell, run <code>julia ../test/runtests.jl</code> from within the package&#39;s <code>src/</code> folder.</li></ul></li><li><p>Commit your changes: see <a href="https://git-scm.com/book/en/v2/Git-Basics-Recording-Changes-to-the-Repository">https://git-scm.com/book/en/v2/Git-Basics-Recording-Changes-to-the-Repository</a>.</p></li><li><p>Submit your changes: From the Julia prompt, type <code>PkgDev.submit(&quot;Foo&quot;)</code>. This will push your changes to your GitHub fork, creating it if it doesn&#39;t already exist. (If you encounter an error, <a href="#man-initial-setup-1">make sure you&#39;ve set up your SSH keys</a>.) Julia will then give you a hyperlink; open that link, edit the message, and then click &quot;submit.&quot; At that point, the package owner will be notified of your changes and may initiate discussion. (If you are comfortable with git, you can also do these steps manually from the shell.)</p></li><li><p>The package owner may suggest additional improvements. To respond to those suggestions, you can easily update the pull request (this only works for changes that have not already been merged; for merged pull requests, make new changes by starting a new branch):</p><ul><li>If you&#39;ve changed branches in the meantime, make sure you go back to the same branch with <code>git checkout fixbar</code> (from shell mode) or <a href="../../stdlib/Pkg/#Pkg.checkout"><code>Pkg.checkout(&quot;Foo&quot;, &quot;fixbar&quot;)</code></a> (from the Julia prompt).</li><li>As above, make your changes, run the tests, and commit your changes.</li><li>From the shell, type <code>git push</code>.  This will add your new commit(s) to the same pull request; you should see them appear automatically on the page holding the discussion of your pull request.</li></ul><p>One potential type of change the owner may request is that you squash your commits. See <a href="#man-squashing-and-rebasing-1">Squashing</a> below.</p></li></ul><h3><a class="nav-anchor" id="Dirty-packages-1" href="#Dirty-packages-1">Dirty packages</a></h3><p>If you can&#39;t change branches because the package manager complains that your package is dirty, it means you have some changes that have not been committed. From the shell, use <code>git diff</code> to see what these changes are; you can either discard them (<code>git checkout changedfile.jl</code>) or commit them before switching branches.  If you can&#39;t easily resolve the problems manually, as a last resort you can delete the entire <code>&quot;Foo&quot;</code> folder and reinstall a fresh copy with <a href="../../stdlib/Pkg/#Pkg.add"><code>Pkg.add(&quot;Foo&quot;)</code></a>. Naturally, this deletes any changes you&#39;ve made.</p><h3><a class="nav-anchor" id="man-branch-post-hoc-1" href="#man-branch-post-hoc-1">Making a branch <em>post hoc</em></a></h3><p>Especially for newcomers to git, one often forgets to create a new branch until after some changes have already been made. If you haven&#39;t yet staged or committed your changes, you can create a new branch with <code>git checkout -b &lt;newbranch&gt;</code> just as usual–git will kindly show you that some files have been modified and create the new branch for you. <em>Your changes have not yet been committed to this new branch</em>, so the normal work rules still apply.</p><p>However, if you&#39;ve already made a commit to <code>master</code> but wish to go back to the official <code>master</code> (called <code>origin/master</code>), use the following procedure:</p><ul><li>Create a new branch. This branch will hold your changes.</li><li>Make sure everything is committed to this branch.</li><li><code>git checkout master</code>. If this fails, <em>do not</em> proceed further until you have resolved the problems, or you may lose your changes.</li><li><em>Reset</em><code>master</code> (your current branch) back to an earlier state with <code>git reset --hard origin/master</code> (see <a href="https://git-scm.com/blog/2011/07/11/reset.html">https://git-scm.com/blog/2011/07/11/reset.html</a>).</li></ul><p>This requires a bit more familiarity with git, so it&#39;s much better to get in the habit of creating a branch at the outset.</p><h3><a class="nav-anchor" id="man-squashing-and-rebasing-1" href="#man-squashing-and-rebasing-1">Squashing and rebasing</a></h3><p>Depending on the tastes of the package owner (s)he may ask you to &quot;squash&quot; your commits. This is especially likely if your change is quite simple but your commit history looks like this:</p><pre><code class="language-none">WIP: add new 1-line whizbang function (currently breaks package)
Finish whizbang function
Fix typo in variable name
Oops, don&#39;t forget to supply default argument
Split into two 1-line functions
Rats, forgot to export the second function
...</code></pre><p>This gets into the territory of more advanced git usage, and you&#39;re encouraged to do some reading (<a href="https://git-scm.com/book/en/v2/Git-Branching-Rebasing">https://git-scm.com/book/en/v2/Git-Branching-Rebasing</a>).  However, a brief summary of the procedure is as follows:</p><ul><li>To protect yourself from error, start from your <code>fixbar</code> branch and create a new branch with <code>git checkout -b fixbar_backup</code>.  Since you started from <code>fixbar</code>, this will be a copy. Now go back to the one you intend to modify with <code>git checkout fixbar</code>.</li><li>From the shell, type <code>git rebase -i origin/master</code>.</li><li>To combine commits, change <code>pick</code> to <code>squash</code> (for additional options, consult other sources). Save the file and close the editor window.</li><li>Edit the combined commit message.</li></ul><p>If the rebase goes badly, you can go back to the beginning to try again like this:</p><pre><code class="language-none">git checkout fixbar
git reset --hard fixbar_backup</code></pre><p>Now let&#39;s assume you&#39;ve rebased successfully. Since your <code>fixbar</code> repository has now diverged from the one in your GitHub fork, you&#39;re going to have to do a <em>force push</em>:</p><ul><li>To make it easy to refer to your GitHub fork, create a &quot;handle&quot; for it with <code>git remote add myfork https://github.com/myaccount/Foo.jl.git</code>, where the URL comes from the &quot;clone URL&quot; on your GitHub fork&#39;s page.</li><li>Force-push to your fork with <code>git push myfork +fixbar</code>. The <code>+</code> indicates that this should replace the <code>fixbar</code> branch found at <code>myfork</code>.</li></ul><h2><a class="nav-anchor" id="Creating-a-new-Package-1" href="#Creating-a-new-Package-1">Creating a new Package</a></h2><h3><a class="nav-anchor" id="REQUIRE-speaks-for-itself-1" href="#REQUIRE-speaks-for-itself-1">REQUIRE speaks for itself</a></h3><p>You should have a <code>REQUIRE</code> file in your package repository, with a bare minimum directive of what Julia version you expect your users to be running for the package to work. Putting a floor on what Julia version your package supports is done by simply adding <code>julia 0.x</code> in this file. While this line is partly informational, it also has the consequence of whether <code>Pkg.update()</code> will update code found in <code>.julia</code> version directories. It will not update code found in version directories beneath the floor of what&#39;s specified in your <code>REQUIRE</code>.</p><p>As the development version <code>0.y</code> matures, you may find yourself using it more frequently, and wanting your package to support it. Be warned, the development branch of Julia is the land of breakage, and you can expect things to break. When you go about fixing whatever broke your package in the development <code>0.y</code> branch, you will likely find that you just broke your package on the stable version.</p><p>There is a mechanism found in the <a href="https://github.com/JuliaLang/Compat.jl">Compat</a> package that will enable you to support both the stable version and breaking changes found in the development version. Should you decide to use this solution, you will need to add <code>Compat</code> to your <code>REQUIRE</code> file. In this case, you will still have <code>julia 0.x</code> in your <code>REQUIRE</code>. The <code>x</code> is the floor version of what your package supports.</p><p>You might also have no interest in supporting the development version of Julia. Just as you can add a floor to the version you expect your users to be on, you can set an upper bound. In this case, you would put <code>julia 0.x 0.y-</code> in your <code>REQUIRE</code> file. The <code>-</code> at the end of the version number means pre-release versions of that specific version from the very first commit. By setting it as the ceiling, you mean the code supports everything up to but not including the ceiling version.</p><p>Another scenario is that you are writing the bulk of the code for your package with Julia <code>0.y</code> and do not want to support the current stable version of Julia. If you choose to do this, simply add <code>julia 0.y-</code> to your <code>REQUIRE</code>. Just remember to change the <code>julia 0.y-</code> to <code>julia 0.y</code> in your <code>REQUIRE</code> file once <code>0.y</code> is officially released. If you don&#39;t edit the dash cruft you are suggesting that you support both the development and stable versions of the same version number! That would be madness. See the <a href="#Requirements-Specification-1">Requirements Specification</a> for the full format of <code>REQUIRE</code>.</p><p>Lastly, in many cases you may need extra packages for testing. Additional packages which are only required for tests should be specified in the <code>test/REQUIRE</code> file. This <code>REQUIRE</code> file has the same specification as the standard <code>REQUIRE</code> file.</p><h3><a class="nav-anchor" id="Guidelines-for-naming-a-package-1" href="#Guidelines-for-naming-a-package-1">Guidelines for naming a package</a></h3><p>Package names should be sensible to most Julia users, <em>even to those who are not domain experts</em>. When you submit your package to METADATA, you can expect a little back and forth about the package name with collaborators, especially if it&#39;s ambiguous or can be confused with something other than what it is. During this bike-shedding, it&#39;s not uncommon to get a range of <em>different</em> name suggestions. These are only suggestions though, with the intent being to keep a tidy namespace in the curated METADATA repository. Since this repository belongs to the entire community, there will likely be a few collaborators who care about your package name. Here are some guidelines to follow in naming your package:</p><ol><li><p>Avoid jargon. In particular, avoid acronyms unless there is minimal possibility of confusion.</p><ul><li>It&#39;s ok to say <code>USA</code> if you&#39;re talking about the USA.</li><li>It&#39;s not ok to say <code>PMA</code>, even if you&#39;re talking about positive mental attitude.</li></ul></li><li><p>Avoid using <code>Julia</code> in your package name.</p><ul><li>It is usually clear from context and to your users that the package is a Julia package.</li><li>Having Julia in the name can imply that the package is connected to, or endorsed by, contributors to the Julia language itself.</li></ul></li><li><p>Packages that provide most of their functionality in association with a new type should have pluralized names.</p><ul><li><code>DataFrames</code> provides the <code>DataFrame</code> type.</li><li><code>BloomFilters</code> provides the <code>BloomFilter</code> type.</li><li>In contrast, <code>JuliaParser</code> provides no new type, but instead new functionality in the <code>JuliaParser.parse()</code> function.</li></ul></li><li><p>Err on the side of clarity, even if clarity seems long-winded to you.</p><ul><li><code>RandomMatrices</code> is a less ambiguous name than <code>RndMat</code> or <code>RMT</code>, even though the latter are shorter.</li></ul></li><li><p>A less systematic name may suit a package that implements one of several possible approaches to its domain.</p><ul><li>Julia does not have a single comprehensive plotting package. Instead, <code>Gadfly</code>, <code>PyPlot</code>, <code>Winston</code> and other packages each implement a unique approach based on a particular design philosophy.</li><li>In contrast, <code>SortingAlgorithms</code> provides a consistent interface to use many well-established sorting algorithms.</li></ul></li><li><p>Packages that wrap external libraries or programs should be named after those libraries or programs.</p><ul><li><code>CPLEX.jl</code> wraps the <code>CPLEX</code> library, which can be identified easily in a web search.</li><li><code>MATLAB.jl</code> provides an interface to call the MATLAB engine from within Julia.</li></ul></li></ol><h3><a class="nav-anchor" id="Generating-the-package-1" href="#Generating-the-package-1">Generating the package</a></h3><p>Suppose you want to create a new Julia package called <code>FooBar</code>. To get started, do <code>PkgDev.generate(pkg,license)</code> where <code>pkg</code> is the new package name and <code>license</code> is the name of a license that the package generator knows about:</p><pre><code class="language-julia-repl">julia&gt; PkgDev.generate(&quot;FooBar&quot;,&quot;MIT&quot;)
INFO: Initializing FooBar repo: /Users/someone/.julia/v0.6/FooBar
INFO: Origin: git://github.com/someone/FooBar.jl.git
INFO: Generating LICENSE.md
INFO: Generating README.md
INFO: Generating src/FooBar.jl
INFO: Generating test/runtests.jl
INFO: Generating REQUIRE
INFO: Generating .travis.yml
INFO: Generating appveyor.yml
INFO: Generating .gitignore
INFO: Committing FooBar generated files</code></pre><p>This creates the directory <code>~/.julia/v0.6/FooBar</code>, initializes it as a git repository, generates a bunch of files that all packages should have, and commits them to the repository:</p><pre><code class="language-none">$ cd ~/.julia/v0.6/FooBar &amp;&amp; git show --stat

commit 84b8e266dae6de30ab9703150b3bf771ec7b6285
Author: Some One &lt;some.one@example.com&gt;
Date:   Wed Oct 16 17:57:58 2013 -0400

    FooBar.jl generated files.

        license: MIT
        authors: Some One
        years:   2013
        user:    someone

    Julia Version 0.3.0-prerelease+3217 [5fcfb13*]

 .gitignore       |  2 ++
 .travis.yml      | 13 +++++++++++++
 LICENSE.md       | 22 +++++++++++++++++++++++
 README.md        |  3 +++
 REQUIRE          |  1 +
 appveyor.yml     | 34 ++++++++++++++++++++++++++++++++++
 src/FooBar.jl    |  5 +++++
 test/runtests.jl |  5 +++++
 8 files changed, 85 insertions(+)</code></pre><p>At the moment, the package manager knows about the MIT &quot;Expat&quot; License, indicated by <code>&quot;MIT&quot;</code>, the Simplified BSD License, indicated by <code>&quot;BSD&quot;</code>, and version 2.0 of the Apache Software License, indicated by <code>&quot;ASL&quot;</code>. If you want to use a different license, you can ask us to add it to the package generator, or just pick one of these three and then modify the <code>~/.julia/v0.6/PACKAGE/LICENSE.md</code> file after it has been generated.</p><p>If you created a GitHub account and configured git to know about it, <code>PkgDev.generate()</code> will set an appropriate origin URL for you. It will also automatically generate a <code>.travis.yml</code> file for using the <a href="https://travis-ci.org">Travis</a> automated testing service, and an <code>appveyor.yml</code> file for using <a href="https://www.appveyor.com">AppVeyor</a>. You will have to enable testing on the Travis and AppVeyor websites for your package repository, but once you&#39;ve done that, it will already have working tests. Of course, all the default testing does is verify that <code>using FooBar</code> in Julia works.</p><h3><a class="nav-anchor" id="Loading-Static-Non-Julia-Files-1" href="#Loading-Static-Non-Julia-Files-1">Loading Static Non-Julia Files</a></h3><p>If your package code needs to load static files which are not Julia code, e.g. an external library or data files, and are located within the package directory, use the <code>@__DIR__</code> macro to determine the directory of the current source file. For example if <code>FooBar/src/FooBar.jl</code> needs to load <code>FooBar/data/foo.csv</code>, use the following code:</p><pre><code class="language-julia">datapath = joinpath(@__DIR__, &quot;..&quot;, &quot;data&quot;)
foo = readdlm(joinpath(datapath, &quot;foo.csv&quot;), &#39;,&#39;)</code></pre><h3><a class="nav-anchor" id="Making-Your-Package-Available-1" href="#Making-Your-Package-Available-1">Making Your Package Available</a></h3><p>Once you&#39;ve made some commits and you&#39;re happy with how <code>FooBar</code> is working, you may want to get some other people to try it out. First you&#39;ll need to create the remote repository and push your code to it; we don&#39;t yet automatically do this for you, but we will in the future and it&#39;s not too hard to figure out <a href="#footnote-3">[3]</a>. Once you&#39;ve done this, letting people try out your code is as simple as sending them the URL of the published repo – in this case:</p><pre><code class="language-none">git://github.com/someone/FooBar.jl.git</code></pre><p>For your package, it will be your GitHub user name and the name of your package, but you get the idea. People you send this URL to can use <a href="../../stdlib/Pkg/#Pkg.clone"><code>Pkg.clone()</code></a> to install the package and try it out:</p><pre><code class="language-julia-repl">julia&gt; Pkg.clone(&quot;git://github.com/someone/FooBar.jl.git&quot;)
INFO: Cloning FooBar from git@github.com:someone/FooBar.jl.git</code></pre><div class="footnote" id="footnote-3"><a href="#footnote-3"><strong>[3]</strong></a><p>Installing and using GitHub&#39;s <a href="https://github.com/github/hub">&quot;hub&quot; tool</a> is highly recommended. It allows you to do things like run <code>hub create</code> in the package repo and have it automatically created via GitHub&#39;s API.</p></div><h3><a class="nav-anchor" id="Tagging-and-Publishing-Your-Package-1" href="#Tagging-and-Publishing-Your-Package-1">Tagging and Publishing Your Package</a></h3><div class="admonition tip"><div class="admonition-title">Tip</div><div class="admonition-text"><p>If you are hosting your package on GitHub, you can use the <a href="https://github.com/attobot/attobot">attobot integration</a> to handle package registration, tagging and publishing.</p></div></div><p>Once you&#39;ve decided that <code>FooBar</code> is ready to be registered as an official package, you can add it to your local copy of <code>METADATA</code> using <code>PkgDev.register()</code>:</p><pre><code class="language-julia-repl">julia&gt; PkgDev.register(&quot;FooBar&quot;)
INFO: Registering FooBar at git://github.com/someone/FooBar.jl.git
INFO: Committing METADATA for FooBar</code></pre><p>This creates a commit in the <code>~/.julia/v0.6/METADATA</code> repo:</p><pre><code class="language-none">$ cd ~/.julia/v0.6/METADATA &amp;&amp; git show

commit 9f71f4becb05cadacb983c54a72eed744e5c019d
Author: Some One &lt;some.one@example.com&gt;
Date:   Wed Oct 16 18:46:02 2013 -0400

    Register FooBar

diff --git a/FooBar/url b/FooBar/url
new file mode 100644
index 0000000..30e525e
--- /dev/null
+++ b/FooBar/url
@@ -0,0 +1 @@
+git://github.com/someone/FooBar.jl.git</code></pre><p>This commit is only locally visible, however. To make it visible to the Julia community, you need to merge your local <code>METADATA</code> upstream into the official repo. The <code>PkgDev.publish()</code> command will fork the <code>METADATA</code> repository on GitHub, push your changes to your fork, and open a pull request:</p><pre><code class="language-julia-repl">julia&gt; PkgDev.publish()
INFO: Validating METADATA
INFO: No new package versions to publish
INFO: Submitting METADATA changes
INFO: Forking JuliaLang/METADATA.jl to someone
INFO: Pushing changes as branch pull-request/ef45f54b
INFO: To create a pull-request open:

  https://github.com/someone/METADATA.jl/compare/pull-request/ef45f54b</code></pre><div class="admonition tip"><div class="admonition-title">Tip</div><div class="admonition-text"><p>If <code>PkgDev.publish()</code> fails with error:</p><pre><code class="language-none">ERROR: key not found: &quot;token&quot;</code></pre><p>then you may have encountered an issue from using the GitHub API on multiple systems. The solution is to delete the &quot;Julia Package Manager&quot; personal access token <a href="https://github.com/login?return_to=https%3A%2F%2Fgithub.com%2Fsettings%2Ftokens">from your Github account</a> and try again.</p><p>Other failures may require you to circumvent <code>PkgDev.publish()</code> by <a href="https://help.github.com/articles/creating-a-pull-request/">creating a pull request on GitHub</a>. See: <a href="#Publishing-METADATA-manually-1">Publishing METADATA manually</a> below.</p></div></div><p>Once the package URL for <code>FooBar</code> is registered in the official <code>METADATA</code> repo, people know where to clone the package from, but there still aren&#39;t any registered versions available. You can tag and register it with the <code>PkgDev.tag()</code> command:</p><pre><code class="language-julia-repl">julia&gt; PkgDev.tag(&quot;FooBar&quot;)
INFO: Tagging FooBar v0.0.1
INFO: Committing METADATA for FooBar</code></pre><p>This tags <code>v0.0.1</code> in the <code>FooBar</code> repo:</p><pre><code class="language-none">$ cd ~/.julia/v0.6/FooBar &amp;&amp; git tag
v0.0.1</code></pre><p>It also creates a new version entry in your local <code>METADATA</code> repo for <code>FooBar</code>:</p><pre><code class="language-none">$ cd ~/.julia/v0.6/FooBar &amp;&amp; git show
commit de77ee4dc0689b12c5e8b574aef7f70e8b311b0e
Author: Some One &lt;some.one@example.com&gt;
Date:   Wed Oct 16 23:06:18 2013 -0400

    Tag FooBar v0.0.1

diff --git a/FooBar/versions/0.0.1/sha1 b/FooBar/versions/0.0.1/sha1
new file mode 100644
index 0000000..c1cb1c1
--- /dev/null
+++ b/FooBar/versions/0.0.1/sha1
@@ -0,0 +1 @@
+84b8e266dae6de30ab9703150b3bf771ec7b6285</code></pre><p>The <code>PkgDev.tag()</code> command takes an optional second argument that is either an explicit version number object like <code>v&quot;0.0.1&quot;</code> or one of the symbols <code>:patch</code>, <code>:minor</code> or <code>:major</code>. These increment the patch, minor or major version number of your package intelligently.</p><p>Adding a tagged version of your package will expedite the official registration into METADATA.jl by collaborators. It is strongly recommended that you complete this process, regardless if your package is completely ready for an official release.</p><p>As a general rule, packages should be tagged <code>0.0.1</code> first. Since Julia itself hasn&#39;t achieved <code>1.0</code> status, it&#39;s best to be conservative in your package&#39;s tagged versions.</p><p>As with <code>PkgDev.register()</code>, these changes to <code>METADATA</code> aren&#39;t available to anyone else until they&#39;ve been included upstream. Again, use the <code>PkgDev.publish()</code> command, which first makes sure that individual package repos have been tagged, pushes them if they haven&#39;t already been, and then opens a pull request to <code>METADATA</code>:</p><pre><code class="language-julia-repl">julia&gt; PkgDev.publish()
INFO: Validating METADATA
INFO: Pushing FooBar permanent tags: v0.0.1
INFO: Submitting METADATA changes
INFO: Forking JuliaLang/METADATA.jl to someone
INFO: Pushing changes as branch pull-request/3ef4f5c4
INFO: To create a pull-request open:

  https://github.com/someone/METADATA.jl/compare/pull-request/3ef4f5c4</code></pre><h4><a class="nav-anchor" id="Publishing-METADATA-manually-1" href="#Publishing-METADATA-manually-1">Publishing METADATA manually</a></h4><p>If <code>PkgDev.publish()</code> fails you can follow these instructions to manually publish your package.</p><p>By &quot;forking&quot; the main METADATA repository, you can create a personal copy (of METADATA.jl) under your GitHub account. Once that copy exists, you can push your local changes to your copy (just like any other GitHub project).</p><ol><li><p>Create a <a href="https://github.com/login?return_to=https%3A%2F%2Fgithub.com%2FJuliaLang%2FMETADATA.jl%2Ffork">fork of METADATA.jl</a>.</p></li><li><p>Add your fork as a remote repository for the METADATA repository on your local computer (in the terminal where USERNAME is your github username):</p><pre><code class="language-none">cd ~/.julia/v0.6/METADATA
git remote add USERNAME https://github.com/USERNAME/METADATA.jl.git</code></pre></li><li><p>Push your changes to your fork:</p><pre><code class="language-none">git push USERNAME metadata-v2</code></pre></li><li><p>If all of that works, then go back to the GitHub page for your fork, and click the &quot;pull request&quot; link.</p></li></ol><h2><a class="nav-anchor" id="Fixing-Package-Requirements-1" href="#Fixing-Package-Requirements-1">Fixing Package Requirements</a></h2><p>If you need to fix the registered requirements of an already-published package version, you can do so just by editing the metadata for that version, which will still have the same commit hash – the hash associated with a version is permanent:</p><pre><code class="language-none">$ cd ~/.julia/v0.6/METADATA/FooBar/versions/0.0.1 &amp;&amp; cat requires
julia 0.3-
$ vi requires</code></pre><p>Since the commit hash stays the same, the contents of the <code>REQUIRE</code> file that will be checked out in the repo will <strong>not</strong> match the requirements in <code>METADATA</code> after such a change; this is unavoidable. When you fix the requirements in <code>METADATA</code> for a previous version of a package, however, you should also fix the <code>REQUIRE</code> file in the current version of the package.</p><h2><a class="nav-anchor" id="Requirements-Specification-1" href="#Requirements-Specification-1">Requirements Specification</a></h2><p>The <code>~/.julia/v0.6/REQUIRE</code> file, the <code>REQUIRE</code> file inside packages, and the <code>METADATA</code> package <code>requires</code> files use a simple line-based format to express the ranges of package versions which need to be installed. Package <code>REQUIRE</code> and <code>METADATA requires</code> files should also include the range of versions of <code>julia</code> the package is expected to work with. Additionally, packages can include a <code>test/REQUIRE</code> file to specify additional packages which are only required for testing.</p><p>Here&#39;s how these files are parsed and interpreted.</p><ul><li>Everything after a <code>#</code> mark is stripped from each line as a comment.</li><li>If nothing but whitespace is left, the line is ignored.</li><li>If there are non-whitespace characters remaining, the line is a requirement and the is split on whitespace into words.</li></ul><p>The simplest possible requirement is just the name of a package name on a line by itself:</p><pre><code class="language-julia">Distributions</code></pre><p>This requirement is satisfied by any version of the <code>Distributions</code> package. The package name can be followed by zero or more version numbers in ascending order, indicating acceptable intervals of versions of that package. One version opens an interval, while the next closes it, and the next opens a new interval, and so on; if an odd number of version numbers are given, then arbitrarily large versions will satisfy; if an even number of version numbers are given, the last one is an upper limit on acceptable version numbers. For example, the line:</p><pre><code class="language-none">Distributions 0.1</code></pre><p>is satisfied by any version of <code>Distributions</code> greater than or equal to <code>0.1.0</code>. Suffixing a version with <code>-</code> allows any pre-release versions as well. For example:</p><pre><code class="language-none">Distributions 0.1-</code></pre><p>is satisfied by pre-release versions such as <code>0.1-dev</code> or <code>0.1-rc1</code>, or by any version greater than or equal to <code>0.1.0</code>.</p><p>This requirement entry:</p><pre><code class="language-none">Distributions 0.1 0.2.5</code></pre><p>is satisfied by versions from <code>0.1.0</code> up to, but not including <code>0.2.5</code>. If you want to indicate that any <code>0.1.x</code> version will do, you will want to write:</p><pre><code class="language-none">Distributions 0.1 0.2-</code></pre><p>If you want to start accepting versions after <code>0.2.7</code>, you can write:</p><pre><code class="language-none">Distributions 0.1 0.2- 0.2.7</code></pre><p>If a requirement line has leading words that begin with <code>@</code>, it is a system-dependent requirement. If your system matches these system conditionals, the requirement is included, if not, the requirement is ignored. For example:</p><pre><code class="language-none">@osx Homebrew</code></pre><p>will require the <code>Homebrew</code> package only on systems where the operating system is OS X. The system conditions that are currently supported are (hierarchically):</p><ul><li><p><code>@unix</code></p><ul><li><p><code>@linux</code></p></li><li><p><code>@bsd</code></p><ul><li><code>@osx</code></li></ul></li></ul></li><li><p><code>@windows</code></p></li></ul><p>The <code>@unix</code> condition is satisfied on all UNIX systems, including Linux and BSD. Negated system conditionals are also supported by adding a <code>!</code> after the leading <code>@</code>. Examples:</p><pre><code class="language-none">@!windows
@unix @!osx</code></pre><p>The first condition applies to any system but Windows and the second condition applies to any UNIX system besides OS X.</p><p>Runtime checks for the current version of Julia can be made using the built-in <code>VERSION</code> variable, which is of type <a href="../../base/base/#Base.VersionNumber"><code>VersionNumber</code></a>. Such code is occasionally necessary to keep track of new or deprecated functionality between various releases of Julia. Examples of runtime checks:</p><pre><code class="language-julia">VERSION &lt; v&quot;0.3-&quot; #exclude all pre-release versions of 0.3

v&quot;0.2-&quot; &lt;= VERSION &lt; v&quot;0.3-&quot; #get all 0.2 versions, including pre-releases, up to the above

v&quot;0.2&quot; &lt;= VERSION &lt; v&quot;0.3-&quot; #To get only stable 0.2 versions (Note v&quot;0.2&quot; == v&quot;0.2.0&quot;)

VERSION &gt;= v&quot;0.2.1&quot; #get at least version 0.2.1</code></pre><p>See the section on <a href="../strings/#man-version-number-literals-1">version number literals</a> for a more complete description.</p><footer><hr/><a class="previous" href="../embedding/"><span class="direction">Previous</span><span class="title">Embedding Julia</span></a><a class="next" href="../code-loading/"><span class="direction">Next</span><span class="title">Code Loading</span></a></footer></article></body></html>
