<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Pkg · The Julia Language</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-28835595-6', 'auto');
ga('send', 'pageview');
</script><link rel="canonical" href="https://docs.julialang.org/en/v1/stdlib/Pkg/index.html"/><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../../assets/julia-manual.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../../index.html"><img class="logo" src="../../assets/logo.png" alt="The Julia Language logo"/></a><h1>The Julia Language</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../../manual/getting-started/">Getting Started</a></li><li><a class="toctext" href="../../manual/variables/">Variables</a></li><li><a class="toctext" href="../../manual/integers-and-floating-point-numbers/">Integers and Floating-Point Numbers</a></li><li><a class="toctext" href="../../manual/mathematical-operations/">Mathematical Operations and Elementary Functions</a></li><li><a class="toctext" href="../../manual/complex-and-rational-numbers/">Complex and Rational Numbers</a></li><li><a class="toctext" href="../../manual/strings/">Strings</a></li><li><a class="toctext" href="../../manual/functions/">Functions</a></li><li><a class="toctext" href="../../manual/control-flow/">Control Flow</a></li><li><a class="toctext" href="../../manual/variables-and-scoping/">Scope of Variables</a></li><li><a class="toctext" href="../../manual/types/">Types</a></li><li><a class="toctext" href="../../manual/methods/">Methods</a></li><li><a class="toctext" href="../../manual/constructors/">Constructors</a></li><li><a class="toctext" href="../../manual/conversion-and-promotion/">Conversion and Promotion</a></li><li><a class="toctext" href="../../manual/interfaces/">Interfaces</a></li><li><a class="toctext" href="../../manual/modules/">Modules</a></li><li><a class="toctext" href="../../manual/documentation/">Documentation</a></li><li><a class="toctext" href="../../manual/metaprogramming/">Metaprogramming</a></li><li><a class="toctext" href="../../manual/arrays/">Multi-dimensional Arrays</a></li><li><a class="toctext" href="../../manual/missing/">Missing Values</a></li><li><a class="toctext" href="../../manual/networking-and-streams/">Networking and Streams</a></li><li><a class="toctext" href="../../manual/parallel-computing/">Parallel Computing</a></li><li><a class="toctext" href="../../manual/running-external-programs/">Running External Programs</a></li><li><a class="toctext" href="../../manual/calling-c-and-fortran-code/">Calling C and Fortran Code</a></li><li><a class="toctext" href="../../manual/handling-operating-system-variation/">Handling Operating System Variation</a></li><li><a class="toctext" href="../../manual/environment-variables/">Environment Variables</a></li><li><a class="toctext" href="../../manual/embedding/">Embedding Julia</a></li><li><a class="toctext" href="../../manual/code-loading/">Code Loading</a></li><li><a class="toctext" href="../../manual/profile/">Profiling</a></li><li><a class="toctext" href="../../manual/stacktraces/">Stack Traces</a></li><li><a class="toctext" href="../../manual/performance-tips/">Performance Tips</a></li><li><a class="toctext" href="../../manual/workflow-tips/">Workflow Tips</a></li><li><a class="toctext" href="../../manual/style-guide/">Style Guide</a></li><li><a class="toctext" href="../../manual/faq/">Frequently Asked Questions</a></li><li><a class="toctext" href="../../manual/noteworthy-differences/">Noteworthy Differences from other Languages</a></li><li><a class="toctext" href="../../manual/unicode-input/">Unicode Input</a></li></ul></li><li><span class="toctext">Base</span><ul><li><a class="toctext" href="../../base/base/">Essentials</a></li><li><a class="toctext" href="../../base/collections/">Collections and Data Structures</a></li><li><a class="toctext" href="../../base/math/">Mathematics</a></li><li><a class="toctext" href="../../base/numbers/">Numbers</a></li><li><a class="toctext" href="../../base/strings/">Strings</a></li><li><a class="toctext" href="../../base/arrays/">Arrays</a></li><li><a class="toctext" href="../../base/parallel/">Tasks</a></li><li><a class="toctext" href="../../base/multi-threading/">Multi-Threading</a></li><li><a class="toctext" href="../../base/constants/">Constants</a></li><li><a class="toctext" href="../../base/file/">Filesystem</a></li><li><a class="toctext" href="../../base/io-network/">I/O and Network</a></li><li><a class="toctext" href="../../base/punctuation/">Punctuation</a></li><li><a class="toctext" href="../../base/sort/">Sorting and Related Functions</a></li><li><a class="toctext" href="../../base/iterators/">Iteration utilities</a></li><li><a class="toctext" href="../../base/c/">C Interface</a></li><li><a class="toctext" href="../../base/libc/">C Standard Library</a></li><li><a class="toctext" href="../../base/stacktraces/">StackTraces</a></li><li><a class="toctext" href="../../base/simd-types/">SIMD Support</a></li></ul></li><li><span class="toctext">Standard Library</span><ul><li><a class="toctext" href="../Base64/">Base64</a></li><li><a class="toctext" href="../CRC32c/">CRC32c</a></li><li><a class="toctext" href="../Dates/">Dates</a></li><li><a class="toctext" href="../DelimitedFiles/">Delimited Files</a></li><li><a class="toctext" href="../Distributed/">Distributed Computing</a></li><li><a class="toctext" href="../FileWatching/">File Events</a></li><li><a class="toctext" href="../InteractiveUtils/">Interactive Utilities</a></li><li><a class="toctext" href="../LibGit2/">LibGit2</a></li><li><a class="toctext" href="../Libdl/">Dynamic Linker</a></li><li><a class="toctext" href="../LinearAlgebra/">Linear Algebra</a></li><li><a class="toctext" href="../Logging/">Logging</a></li><li><a class="toctext" href="../Markdown/">Markdown</a></li><li><a class="toctext" href="../Mmap/">Memory-mapped I/O</a></li><li class="current"><a class="toctext" href>Pkg</a><ul class="internal"><li><a class="toctext" href="#Introduction-1">Introduction</a></li><li><a class="toctext" href="#Glossary-1">Glossary</a></li><li><a class="toctext" href="#Getting-Started-1">Getting Started</a></li><li><a class="toctext" href="#Creating-your-own-projects-1">Creating your own projects</a></li><li><a class="toctext" href="#Garbage-collecting-old,-unused-packages-1">Garbage collecting old, unused packages</a></li><li><a class="toctext" href="#Creating-your-own-packages-1">Creating your own packages</a></li><li><a class="toctext" href="#Precompiling-a-project-1">Precompiling a project</a></li><li><a class="toctext" href="#Preview-mode-1">Preview mode</a></li><li><a class="toctext" href="#Using-someone-else&#39;s-project-1">Using someone else&#39;s project</a></li><li><a class="toctext" href="#References-1">References</a></li></ul></li><li><a class="toctext" href="../Printf/">Printf</a></li><li><a class="toctext" href="../Profile/">Profiling</a></li><li><a class="toctext" href="../REPL/">The Julia REPL</a></li><li><a class="toctext" href="../Random/">Random Numbers</a></li><li><a class="toctext" href="../SHA/">SHA</a></li><li><a class="toctext" href="../Serialization/">Serialization</a></li><li><a class="toctext" href="../SharedArrays/">Shared Arrays</a></li><li><a class="toctext" href="../Sockets/">Sockets</a></li><li><a class="toctext" href="../SparseArrays/">Sparse Arrays</a></li><li><a class="toctext" href="../Statistics/">Statistics</a></li><li><a class="toctext" href="../Test/">Unit Testing</a></li><li><a class="toctext" href="../UUIDs/">UUIDs</a></li><li><a class="toctext" href="../Unicode/">Unicode</a></li></ul></li><li><span class="toctext">Developer Documentation</span><ul><li><a class="toctext" href="../../devdocs/reflection/">Reflection and introspection</a></li><li><span class="toctext">Documentation of Julia&#39;s Internals</span><ul><li><a class="toctext" href="../../devdocs/init/">Initialization of the Julia runtime</a></li><li><a class="toctext" href="../../devdocs/ast/">Julia ASTs</a></li><li><a class="toctext" href="../../devdocs/types/">More about types</a></li><li><a class="toctext" href="../../devdocs/object/">Memory layout of Julia Objects</a></li><li><a class="toctext" href="../../devdocs/eval/">Eval of Julia code</a></li><li><a class="toctext" href="../../devdocs/callconv/">Calling Conventions</a></li><li><a class="toctext" href="../../devdocs/compiler/">High-level Overview of the Native-Code Generation Process</a></li><li><a class="toctext" href="../../devdocs/functions/">Julia Functions</a></li><li><a class="toctext" href="../../devdocs/cartesian/">Base.Cartesian</a></li><li><a class="toctext" href="../../devdocs/meta/">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="../../devdocs/subarrays/">SubArrays</a></li><li><a class="toctext" href="../../devdocs/isbitsunionarrays/">isbits Union Optimizations</a></li><li><a class="toctext" href="../../devdocs/sysimg/">System Image Building</a></li><li><a class="toctext" href="../../devdocs/llvm/">Working with LLVM</a></li><li><a class="toctext" href="../../devdocs/stdio/">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="../../devdocs/boundscheck/">Bounds checking</a></li><li><a class="toctext" href="../../devdocs/locks/">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="../../devdocs/offset-arrays/">Arrays with custom indices</a></li><li><a class="toctext" href="../../devdocs/require/">Module loading</a></li><li><a class="toctext" href="../../devdocs/inference/">Inference</a></li></ul></li><li><span class="toctext">Developing/debugging Julia&#39;s C code</span><ul><li><a class="toctext" href="../../devdocs/backtraces/">Reporting and analyzing crashes (segfaults)</a></li><li><a class="toctext" href="../../devdocs/debuggingtips/">gdb debugging tips</a></li><li><a class="toctext" href="../../devdocs/valgrind/">Using Valgrind with Julia</a></li><li><a class="toctext" href="../../devdocs/sanitizers/">Sanitizer support</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Standard Library</li><li><a href>Pkg</a></li></ul><a class="edit-page" href="https://github.com/JuliaLang/julia/blob/master/stdlib/Pkg/docs/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Pkg</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Pkg-1" href="#Pkg-1">Pkg</a></h1><h2><a class="nav-anchor" id="Introduction-1" href="#Introduction-1">Introduction</a></h2><p>Pkg is the standard package manager for Julia 1.0 and newer. Unlike traditional package managers, which install and manage a single global set of packages, Pkg is designed around “environments”: independent sets of packages that can be local to an individual project or shared and selected by name. The exact set of packages and versions in an environment is captured in a <em>manifest file</em> which can be checked into a project repository and tracked in version control, significantly improving reproducibility of projects. If you’ve ever tried to run code you haven’t used in a while only to find that you can’t get anything to work because you’ve updated or uninstalled some of the packages your project was using, you’ll understand the motivation for this approach. In Pkg, since each project maintains its own independent set of package versions, you’ll never have this problem again. Moreover, if you check out a project on a new system, you can simply materialize the environment described by its manifest file and immediately be up and running with a known-good set of dependencies.</p><p>Since environments are managed and updated independently from each other, “dependency hell” is significantly alleviated in Pkg. If you want to use the latest and greatest version of some package in a new project but you’re stuck on an older version in a different project, that’s no problem – since they have separate environments they can just use different versions, which are both installed at the same time in different locations on your system. The location of each package version is canonical, so when environments use the same versions of packages, they can share installations, avoiding unnecessary duplication of the package. Old package versions that are no longer used by any environments are periodically “garbage collected” by the package manager.</p><p>Pkg’s approach to local environments may be familiar to people who have used Python’s <code>virtualenv</code> or Ruby’s <code>bundler</code>. In Julia, instead of hacking the language’s code loading mechanisms to support environments, we have the benefit that Julia natively understands them. In addition, Julia environments are “stackable”: you can overlay one environment with another and thereby have access to additional packages outside of the primary environment. This makes it easy to work on a project, which provides the primary environment, while still having access to all your usual dev tools like profilers, debuggers, and so on, just by having an environment including these dev tools later in the load path.</p><p>Last but not least, Pkg is designed to support federated package registries. This means that it allows multiple registries managed by different parties to interact seamlessly. In particular, this includes private registries which can live behind corporate firewalls. You can install and update your own packages from a private registry with exactly the same tools and workflows that you use to install and manage official Julia packages. If you urgently need to apply a hotfix for a public package that’s critical to your company’s product, you can tag a private version of it in your company’s internal registry and get a fix to your developers and ops teams quickly and easily without having to wait for an upstream patch to be accepted and published. Once an official fix is published, however, you can just upgrade your dependencies and you&#39;ll be back on an official release again.</p><h2><a class="nav-anchor" id="Glossary-1" href="#Glossary-1">Glossary</a></h2><p><strong>Project:</strong> a source tree with a standard layout, including a <code>src</code> directory for the main body of Julia code, a <code>test</code> directory for testing the project, <code>docs</code> for documentation files, and optionally a <code>deps</code> directory for a build script and its outputs. A project will typically also have a project file and may optionally have a manifest file:</p><ul><li><p><strong>Project file:</strong> a file in the root directory of a project, named <code>Project.toml</code> (or <code>JuliaProject.toml</code>) describing metadata about the project, including its name, UUID (for packages), authors, license, and the names and UUIDs of packages and libraries that it depends on.</p></li><li><p><strong>Manifest file:</strong> a file in the root directory of a project, named <code>Manifest.toml</code> (or <code>JuliaManifest.toml</code>) describing a complete dependency graph and exact versions of each package and library used by a project.</p></li></ul><p><strong>Package:</strong> a project which provides reusable functionality that can be used by other Julia projects via <code>import X</code> or <code>using X</code>. A package should have a project file with a <code>uuid</code> entry giving its package UUID. This UUID is used to identify the package in projects that depend on it.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>For legacy reasons it is possible to load a package without a project file or UUID from the REPL or the top-level of a script. It is not possible, however, to load a package without a project file or UUID from a project with them. Once you&#39;ve loaded from a project file, everything needs a project file and UUID.</p></div></div><p><strong>Application:</strong> a project which provides standalone functionality not intended to be reused by other Julia projects. For example a web application or a command-line utility, or simulation/analytics code accompanying a scientific paper. An application may have a UUID but does not need one. An application may also provide global configuration options for packages it depends on. Packages, on the other hand, may not provide global configuration since that could conflict with the configuration of the main application.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p><strong>Projects <em>vs.</em> Packages <em>vs.</em> Applications:</strong></p><ol><li><strong>Project</strong> is an umbrella term: packages and applications are kinds of projects.</li><li><strong>Packages</strong> should have UUIDs, applications can have a UUIDs but don&#39;t need them.</li><li><strong>Applications</strong> can provide global configuration, whereas packages cannot.</li></ol></div></div><p><strong>Library (future work):</strong> a compiled binary dependency (not written in Julia) packaged to be used by a Julia project. These are currently typically built in- place by a <code>deps/build.jl</code> script in a project’s source tree, but in the future we plan to make libraries first-class entities directly installed and upgraded by the package manager.</p><p><strong>Environment:</strong> the combination of the top-level name map provided by a project file combined with the dependency graph and map from packages to their entry points provided by a manifest file. For more detail see the manual section on code loading.</p><ul><li><p><strong>Explicit environment:</strong> an environment in the form of an explicit project file and an optional corresponding manifest file together in a directory. If the manifest file is absent then the implied dependency graph and location maps are empty.</p></li><li><p><strong>Implicit environment:</strong> an environment provided as a directory (without a project file or manifest file) containing packages with entry points of the form <code>X.jl</code>, <code>X.jl/src/X.jl</code> or <code>X/src/X.jl</code>. The top-level name map is implied by these entry points. The dependency graph is implied by the existence of project files inside of these package directories, e.g. <code>X.jl/Project.toml</code> or <code>X/Project.toml</code>. The dependencies of the <code>X</code> package are the dependencies in the corresponding project file if there is one. The location map is implied by the entry points themselves.</p></li></ul><p><strong>Registry:</strong> a source tree with a standard layout recording metadata about a registered set of packages, the tagged versions of them which are available, and which versions of packages are compatible or incompatible with each other. A registry is indexed by package name and UUID, and has a directory for each registered package providing the following metadata about it:</p><ul><li>name – e.g. <code>DataFrames</code></li><li>UUID – e.g. <code>a93c6f00-e57d-5684-b7b6-d8193f3e46c0</code></li><li>authors – e.g. <code>Jane Q. Developer &lt;jane@example.com&gt;</code></li><li>license – e.g. MIT, BSD3, or GPLv2</li><li>repository – e.g. <code>https://github.com/JuliaData/DataFrames.jl.git</code></li><li>description – a block of text summarizing the functionality of a package</li><li>keywords – e.g. <code>data</code>, <code>tabular</code>, <code>analysis</code>, <code>statistics</code></li><li>versions – a list of all registered version tags</li></ul><p>For each registered version of a package, the following information is provided:</p><ul><li>its semantic version number – e.g. <code>v1.2.3</code></li><li>its git tree SHA-1 hash – e.g. <code>7ffb18ea3245ef98e368b02b81e8a86543a11103</code></li><li>a map from names to UUIDs of dependencies</li><li>which versions of other packages it is compatible/incompatible with</li></ul><p>Dependencies and compatibility are stored in a compressed but human-readable format using ranges of package versions.</p><p><strong>Depot:</strong> a directory on a system where various package-related resources live, including:</p><ul><li><code>environments</code>: shared named environments (e.g. <code>v1.0</code>, <code>devtools</code>)</li><li><code>clones</code>: bare clones of package repositories</li><li><code>compiled</code>: cached compiled package images (<code>.ji</code> files)</li><li><code>config</code>: global configuration files (e.g. <code>startup.jl</code>)</li><li><code>dev</code>: default directory for package development</li><li><code>logs</code>: log files (e.g. <code>manifest_usage.toml</code>, <code>repl_history.jl</code>)</li><li><code>packages</code>: installed package versions</li><li><code>registries</code>: clones of registries (e.g. <code>General</code>)</li></ul><p><strong>Load path:</strong> a stack of environments where package identities, their dependencies, and entry-points are searched for. The load path is controlled in Julia by the <code>LOAD_PATH</code> global variable which is populated at startup based on the value of the <code>JULIA_LOAD_PATH</code> environment variable. The first entry is your primary environment, often the current project, while later entries provide additional packages one may want to use from the REPL or top-level scripts.</p><p><strong>Depot path:</strong> a stack of depot locations where the package manager, as well as Julia&#39;s code loading mechanisms, look for registries, installed packages, named environments, repo clones, cached compiled package images, and configuration files. The depot path is controlled by the Julia <code>DEPOT_PATH</code> global variable which is populated at startup based on the value of the <code>JULIA_DEPOT_PATH</code> environment variable. The first entry is the “user depot” and should be writable by and owned by the current user. The user depot is where: registries are cloned, new package versions are installed, named environments are created and updated, package repos are cloned, newly compiled package image files are saved, log files are written, development packages are checked out by default, and global configuration data is saved. Later entries in the depot path are treated as read-only and are appropriate for registries, packages, etc. installed and managed by system administrators.</p><h2><a class="nav-anchor" id="Getting-Started-1" href="#Getting-Started-1">Getting Started</a></h2><p>The Pkg REPL-mode is entered from the Julia REPL using the key <code>]</code>.</p><pre><code class="language-none">(v1.0) pkg&gt;</code></pre><p>The part inside the parenthesis of the prompt shows the name of the current project. Since we haven&#39;t created our own project yet, we are in the default project, located at <code>~/.julia/environments/v1.0</code> (or whatever version of Julia you happen to run).</p><p>To return to the <code>julia&gt;</code> prompt, either press backspace when the input line is empty or press Ctrl+C. Help is available by calling <code>pkg&gt; help</code>. If you are in an environment that does not have access to a REPL you can still use the REPL mode commands using the string macro <code>pkg</code> available after <code>using Pkg</code>. The command <code>pkg&quot;cmd&quot;</code> would be equivalent to executing <code>cmd</code> in the REPL mode.</p><p>The documentation here describes using Pkg from the REPL mode. Documentation of using the Pkg API (by calling <code>Pkg.</code> functions) is in progress of being written.</p><h3><a class="nav-anchor" id="Adding-packages-1" href="#Adding-packages-1">Adding packages</a></h3><p>There are two ways of adding packages, either using the <code>add</code> command or the <code>dev</code> command. The most frequently used one is <code>add</code> and its usage is described first.</p><h4><a class="nav-anchor" id="Adding-registered-packages-1" href="#Adding-registered-packages-1">Adding registered packages</a></h4><p>In the Pkg REPL packages can be added with the <code>add</code> command followed by the name of the package, for example:</p><pre><code class="language-none">(v1.0) pkg&gt; add Example
   Cloning default registries into /Users/kristoffer/.julia/registries
   Cloning registry General from &quot;https://github.com/JuliaRegistries/General.git&quot;
  Updating registry at `~/.julia/registries/General`
  Updating git-repo `https://github.com/JuliaRegistries/General.git`
 Resolving package versions...
  Updating `~/.julia/environments/v1.0/Project.toml`
  [7876af07] + Example v0.5.1
  Updating `~/.julia/environments/v1.0/Manifest.toml`
  [7876af07] + Example v0.5.1
  [8dfed614] + Test</code></pre><p>Here we added the package Example to the current project. In this example, we are using a fresh Julia installation, and this is our first time adding a package using Pkg. By default, Pkg clones Julia&#39;s General registry, and uses this registry to look up packages requested for inclusion in the current environment. The status update shows a short form of the package UUID to the left, then the package name, and the version. Since standard libraries (e.g. <code>Test</code>) are shipped with Julia, they do not have a version. The project status contains the packages you have added yourself, in this case, <code>Example</code>:</p><pre><code class="language-none">(v1.0) pkg&gt; st
    Status `Project.toml`
  [7876af07] Example v0.5.1</code></pre><p>The manifest status, in addition, includes the dependencies of explicitly added packages.</p><pre><code class="language-none">(v1.0) pkg&gt; st --manifest
    Status `Manifest.toml`
  [7876af07] Example v0.5.1
  [8dfed614] Test</code></pre><p>It is possible to add multiple packages in one command as <code>pkg&gt; add A B C</code>.</p><p>After a package is added to the project, it can be loaded in Julia:</p><pre><code class="language-none">julia&gt; using Example

julia&gt; Example.hello(&quot;User&quot;)
&quot;Hello, User&quot;</code></pre><p>A specific version can be installed by appending a version after a <code>@</code> symbol, e.g. <code>@v0.4</code>, to the package name:</p><pre><code class="language-none">(v1.0) pkg&gt; add Example@0.4
 Resolving package versions...
  Updating `~/.julia/environments/v1.0/Project.toml`
  [7876af07] + Example v0.4.1
  Updating `~/.julia/environments/v1.0/Manifest.toml`
  [7876af07] + Example v0.4.1</code></pre><p>If the master branch (or a certain commit SHA) of <code>Example</code> has a hotfix that has not yet included in a registered version, we can explicitly track a branch (or commit) by appending <code>#branch</code> (or <code>#commit</code>) to the package name:</p><pre><code class="language-none">(v1.0) pkg&gt; add Example#master
  Updating git-repo `https://github.com/JuliaLang/Example.jl.git`
 Resolving package versions...
  Updating `~/.julia/environments/v1.0/Project.toml`
  [7876af07] ~ Example v0.5.1 ⇒ v0.5.1+ #master (https://github.com/JuliaLang/Example.jl.git)
  Updating `~/.julia/environments/v1.0/Manifest.toml`
  [7876af07] ~ Example v0.5.1 ⇒ v0.5.1+ #master (https://github.com/JuliaLang/Example.jl.git)</code></pre><p>The status output now shows that we are tracking the <code>master</code> branch of <code>Example</code>. When updating packages, we will pull updates from that branch.</p><p>To go back to tracking the registry version of <code>Example</code>, the command <code>free</code> is used:</p><pre><code class="language-none">(v1.0) pkg&gt; free Example
 Resolving package versions...
  Updating `~/.julia/environments/v1.0/Project.toml`
  [7876af07] ~ Example v0.5.1+ #master (https://github.com/JuliaLang/Example.jl.git) ⇒ v0.5.1
  Updating `~/.julia/environments/v1.0/Manifest.toml`
  [7876af07] ~ Example v0.5.1+ #master )https://github.com/JuliaLang/Example.jl.git) ⇒ v0.5.1</code></pre><h4><a class="nav-anchor" id="Adding-unregistered-packages-1" href="#Adding-unregistered-packages-1">Adding unregistered packages</a></h4><p>If a package is not in a registry, it can still be added by instead of the package name giving the URL to the repository to <code>add</code>.</p><pre><code class="language-none">(v1.0) pkg&gt; add https://github.com/fredrikekre/ImportMacros.jl
  Updating git-repo `https://github.com/fredrikekre/ImportMacros.jl`
 Resolving package versions...
Downloaded MacroTools ─ v0.4.1
  Updating `~/.julia/environments/v1.0/Project.toml`
  [e6797606] + ImportMacros v0.0.0 # (https://github.com/fredrikekre/ImportMacros.jl)
  Updating `~/.julia/environments/v1.0/Manifest.toml`
  [e6797606] + ImportMacros v0.0.0 # (https://github.com/fredrikekre/ImportMacros.jl)
  [1914dd2f] + MacroTools v0.4.1</code></pre><p>The dependencies of the unregistered package (here <code>MacroTools</code>) got installed. For unregistered packages we could have given a branch (or commit SHA) to track using <code>#</code>, just like for registered packages.</p><h4><a class="nav-anchor" id="Adding-a-local-package-1" href="#Adding-a-local-package-1">Adding a local package</a></h4><p>Instead of giving a URL of a git repo to <code>add</code> we could instead have given a local path to a git repo. This works similarly to adding a URL. The local repository will be tracked (at some branch) and updates from that local repo are pulled when packages are updated. Note that changes to files in the local package repository will not immediately be reflected when loading that package. The changes would have to be committed and the packages updated in order to pull in the changes.</p><h4><a class="nav-anchor" id="Developing-packages-1" href="#Developing-packages-1">Developing packages</a></h4><p>By only using <code>add</code> your Manifest will always have a &quot;reproducible state&quot;, in other words, as long as the repositories and registries used are still accessible it is possible to retrieve the exact state of all the dependencies in the project. This has the advantage that you can send your project (<code>Project.toml</code> and <code>Manifest.toml</code>) to someone else and they can &quot;instantiate&quot; that project in the same state as you had it locally. However, when you are developing a package, it is more convenient to load packages at their current state at some path. For this reason, the <code>dev</code> command exists.</p><p>Let&#39;s try to <code>dev</code> a registered package:</p><pre><code class="language-none">(v1.0) pkg&gt; dev Example
  Updating git-repo `https://github.com/JuliaLang/Example.jl.git`
 Resolving package versions...
  Updating `~/.julia/environments/v1.0/Project.toml`
  [7876af07] + Example v0.5.1+ [`~/.julia/dev/Example`]
  Updating `~/.julia/environments/v1.0/Manifest.toml`
  [7876af07] + Example v0.5.1+ [`~/.julia/dev/Example`]</code></pre><p>The <code>dev</code> command fetches a full clone of the package to <code>~/.julia/dev/</code> (the path can be changed by setting the environment variable <code>JULIA_PKG_DEVDIR</code>). When importing <code>Example</code> julia will now import it from <code>~/.julia/dev/Example</code> and whatever local changes have been made to the files in that path are consequently reflected in the code loaded. When we used <code>add</code> we said that we tracked the package repository, we here say that we track the path itself. Note that the package manager will never touch any of the files at a tracked path. It is therefore up to you to pull updates, change branches etc. If we try to <code>dev</code> a package at some branch that already exists at <code>~/.julia/dev/</code> the package manager we will simply use the existing path. For example:</p><pre><code class="language-none">(v1.0) pkg&gt; dev Example
  Updating git-repo `https://github.com/JuliaLang/Example.jl.git`
[ Info: Path `/Users/kristoffer/.julia/dev/Example` exists and looks like the correct package, using existing path instead of cloning</code></pre><p>Note the info message saying that it is using the existing path. As a general rule, the package manager will never touch files that are tracking a path.</p><p>If <code>dev</code> is used on a local path, that path to that package is recorded and used when loading that package. The path will be recorded relative to the project file, unless it is given as an absolute path.</p><p>To stop tracking a path and use the registered version again, use <code>free</code></p><pre><code class="language-none">(v1.0) pkg&gt; free Example
 Resolving package versions...
  Updating `~/.julia/environments/v1.0/Project.toml`
  [7876af07] ↓ Example v0.5.1+ [`~/.julia/dev/Example`] ⇒ v0.5.1
  Updating `~/.julia/environments/v1.0/Manifest.toml`
  [7876af07] ↓ Example v0.5.1+ [`~/.julia/dev/Example`] ⇒ v0.5.1</code></pre><p>It should be pointed out that by using <code>dev</code> your project is now inherently stateful. Its state depends on the current content of the files at the path and the manifest cannot be &quot;instantiated&quot; by someone else without knowing the exact content of all the packages that are tracking a path.</p><p>Note that if you add a dependency to a package that tracks a local path, the Manifest (which contains the whole dependency graph) will become out of sync with the actual dependency graph. This means that the package will not be able to load that dependency since it is not recorded in the Manifest. To update sync the Manifest, use the REPL command <code>resolve</code>.</p><h3><a class="nav-anchor" id="Removing-packages-1" href="#Removing-packages-1">Removing packages</a></h3><p>Packages can be removed from the current project by using <code>pkg&gt; rm Package</code>. This will only remove packages that exist in the project, to remove a package that only exists as a dependency use <code>pkg&gt; rm --manifest DepPackage</code>. Note that this will remove all packages that depends on <code>DepPackage</code>.</p><h3><a class="nav-anchor" id="Updating-packages-1" href="#Updating-packages-1">Updating packages</a></h3><p>When new versions of packages the project is using are released, it is a good idea to update. Simply calling <code>up</code> will try to update <em>all</em> the dependencies of the project to the latest compatible version. Sometimes this is not what you want. You can specify a subset of the dependencies to upgrade by giving them as arguments to <code>up</code>, e.g:</p><pre><code class="language-none">(v1.0) pkg&gt; up Example</code></pre><p>The version of all other packages direct dependencies will stay the same. If you only want to update the minor version of packages, to reduce the risk that your project breaks, you can give the <code>--minor</code> flag, e.g:</p><pre><code class="language-none">(v1.0) pkg&gt; up --minor Example</code></pre><p>Packages that track a repository are not updated when a minor upgrade is done. Packages that track a path are never touched by the package manager.</p><h3><a class="nav-anchor" id="Pinning-a-package-1" href="#Pinning-a-package-1">Pinning a package</a></h3><p>A pinned package will never be updated. A package can be pinned using <code>pin</code> as for example</p><pre><code class="language-none">(v1.0) pkg&gt; pin Example
 Resolving package versions...
  Updating `~/.julia/environments/v1.0/Project.toml`
  [7876af07] ~ Example v0.5.1 ⇒ v0.5.1 ⚲
  Updating `~/.julia/environments/v1.0/Manifest.toml`
  [7876af07] ~ Example v0.5.1 ⇒ v0.5.1 ⚲</code></pre><p>Note the pin symbol <code>⚲</code> showing that the package is pinned. Removing the pin is done using <code>free</code></p><pre><code class="language-none">(v1.0) pkg&gt; free Example
  Updating `~/.julia/environments/v1.0/Project.toml`
  [7876af07] ~ Example v0.5.1 ⚲ ⇒ v0.5.1
  Updating `~/.julia/environments/v1.0/Manifest.toml`
  [7876af07] ~ Example v0.5.1 ⚲ ⇒ v0.5.1</code></pre><h3><a class="nav-anchor" id="Testing-packages-1" href="#Testing-packages-1">Testing packages</a></h3><p>The tests for a package can be run using <code>test</code> command:</p><pre><code class="language-none">(v1.0) pkg&gt; test Example
   Testing Example
   Testing Example tests passed</code></pre><h3><a class="nav-anchor" id="Building-packages-1" href="#Building-packages-1">Building packages</a></h3><p>The build step of a package is automatically run when a package is first installed. The output of the build process is directed to a file. To explicitly run the build step for a package the <code>build</code> command is used:</p><pre><code class="language-none">(v1.0) pkg&gt; build MbedTLS
  Building MbedTLS → `~/.julia/packages/MbedTLS/h1Vu/deps/build.log`

shell&gt; cat ~/.julia/packages/MbedTLS/h1Vu/deps/build.log
┌ Warning: `wait(t::Task)` is deprecated, use `fetch(t)` instead.
│   caller = macro expansion at OutputCollector.jl:63 [inlined]
└ @ Core OutputCollector.jl:63
...
[ Info: using prebuilt binaries</code></pre><h2><a class="nav-anchor" id="Creating-your-own-projects-1" href="#Creating-your-own-projects-1">Creating your own projects</a></h2><p>So far we have added packages to the default project at <code>~/.julia/environments/v1.0</code>, it is, however, easy to create other, independent, projects. It should be pointed out if two projects uses the same package at the same version, the content of this package is not duplicated. In order to create a new project, create a directory for it and then activate that directory to make it the &quot;active project&quot; which package operations manipulate:</p><pre><code class="language-none">shell&gt; mkdir MyProject

shell&gt; cd MyProject
/Users/kristoffer/MyProject

(v1.0) pkg&gt; activate .

(MyProject) pkg&gt; st
    Status `Project.toml`</code></pre><p>Note that the REPL prompt changed when the new project is activated. Since this is a newly created project, the status command show it contains no packages, and in fact, it has no project or manifest file until we add a package to it:</p><pre><code class="language-none">shell&gt; ls -l
total 0

(MyProject) pkg&gt; add Example
  Updating registry at `~/.julia/registries/General`
  Updating git-repo `https://github.com/JuliaRegistries/General.git`
 Resolving package versions...
  Updating `Project.toml`
  [7876af07] + Example v0.5.1
  Updating `Manifest.toml`
  [7876af07] + Example v0.5.1
  [8dfed614] + Test

shell&gt; ls -l
total 8
-rw-r--r-- 1 stefan staff 207 Jul  3 16:35 Manifest.toml
-rw-r--r-- 1 stefan staff  56 Jul  3 16:35 Project.toml

shell&gt; cat Project.toml
[deps]
Example = &quot;7876af07-990d-54b4-ab0e-23690620f79a&quot;

shell&gt; cat Manifest.toml
[[Example]]
deps = [&quot;Test&quot;]
git-tree-sha1 = &quot;8eb7b4d4ca487caade9ba3e85932e28ce6d6e1f8&quot;
uuid = &quot;7876af07-990d-54b4-ab0e-23690620f79a&quot;
version = &quot;0.5.1&quot;

[[Test]]
uuid = &quot;8dfed614-e22c-5e08-85e1-65c5234f0b40&quot;</code></pre><p>This new environment is completely separate from the one we used earlier.</p><h2><a class="nav-anchor" id="Garbage-collecting-old,-unused-packages-1" href="#Garbage-collecting-old,-unused-packages-1">Garbage collecting old, unused packages</a></h2><p>As packages are updated and projects are deleted, installed packages that were once used will inevitably become old and not used from any existing project. Pkg keeps a log of all projects used so it can go through the log and see exactly which projects still exist and what packages those projects used. The rest can be deleted. This is done with the <code>gc</code> command:</p><pre><code class="language-none">(v1.0) pkg&gt; gc
    Active manifests at:
        `/Users/kristoffer/BinaryProvider/Manifest.toml`
        ...
        `/Users/kristoffer/Compat.jl/Manifest.toml`
   Deleted /Users/kristoffer/.julia/packages/BenchmarkTools/1cAj: 146.302 KiB
   Deleted /Users/kristoffer/.julia/packages/Cassette/BXVB: 795.557 KiB
   ...
   Deleted /Users/kristoffer/.julia/packages/WeakRefStrings/YrK6: 27.328 KiB
   Deleted 36 package installations: 113.205 MiB</code></pre><p>Note that only packages in <code>~/.julia/packages</code> are deleted.</p><h2><a class="nav-anchor" id="Creating-your-own-packages-1" href="#Creating-your-own-packages-1">Creating your own packages</a></h2><p>A package is a project with a <code>name</code>, <code>uuid</code> and <code>version</code> entry in the <code>Project.toml</code> file <code>src/PackageName.jl</code> file that defines the module <code>PackageName</code>. This file is executed when the package is loaded.</p><h3><a class="nav-anchor" id="Generating-files-for-a-package-1" href="#Generating-files-for-a-package-1">Generating files for a package</a></h3><p>To generate files for a new package, use <code>pkg&gt; generate</code>.</p><pre><code class="language-none">(v1.0) pkg&gt; generate HelloWorld</code></pre><p>This creates a new project <code>HelloWorld</code> with the following files (visualized with the external <a href="https://linux.die.net/man/1/tree"><code>tree</code> command</a>):</p><pre><code class="language-jl">shell&gt; cd HelloWorld

shell&gt; tree .
.
├── Project.toml
└── src
    └── HelloWorld.jl

1 directory, 2 files</code></pre><p>The <code>Project.toml</code> file contains the name of the package, its unique UUID, its version, the author and eventual dependencies:</p><pre><code class="language-toml">name = &quot;HelloWorld&quot;
uuid = &quot;b4cd1eb8-1e24-11e8-3319-93036a3eb9f3&quot;
version = &quot;0.1.0&quot;
author = [&quot;Some One &lt;someone@email.com&gt;&quot;]

[deps]</code></pre><p>The content of <code>src/HelloWorld.jl</code> is:</p><pre><code class="language-jl">module HelloWorld

greet() = print(&quot;Hello World!&quot;)

end # module</code></pre><p>We can now activate the project and load the package:</p><pre><code class="language-jl">pkg&gt; activate .

julia&gt; import HelloWorld

julia&gt; HelloWorld.greet()
Hello World!</code></pre><h3><a class="nav-anchor" id="Adding-dependencies-to-the-project-1" href="#Adding-dependencies-to-the-project-1">Adding dependencies to the project</a></h3><p>Let’s say we want to use the standard library package <code>Random</code> and the registered package <code>JSON</code> in our project. We simply <code>add</code> these packages (note how the prompt now shows the name of the newly generated project, since we are inside the <code>HelloWorld</code> project directory):</p><pre><code class="language-none">(HelloWorld) pkg&gt; add Random JSON
 Resolving package versions...
  Updating &quot;~/Documents/HelloWorld/Project.toml&quot;
 [682c06a0] + JSON v0.17.1
 [9a3f8284] + Random
  Updating &quot;~/Documents/HelloWorld/Manifest.toml&quot;
 [34da2185] + Compat v0.57.0
 [682c06a0] + JSON v0.17.1
 [4d1e1d77] + Nullables v0.0.4
 ...</code></pre><p>Both <code>Random</code> and <code>JSON</code> got added to the project’s <code>Project.toml</code> file, and the resulting dependencies got added to the <code>Manifest.toml</code> file. The resolver has installed each package with the highest possible version, while still respecting the compatibility that each package enforce on its dependencies.</p><p>We can now use both <code>Random</code> and <code>JSON</code> in our project. Changing <code>src/HelloWorld.jl</code> to</p><pre><code class="language-none">module HelloWorld

import Random
import JSON

greet() = print(&quot;Hello World!&quot;)
greet_alien() = print(&quot;Hello &quot;, Random.randstring(8))

end # module</code></pre><p>and reloading the package, the new <code>greet_alien</code> function that uses <code>Random</code> can be used:</p><pre><code class="language-none">julia&gt; HelloWorld.greet_alien()
Hello aT157rHV</code></pre><h3><a class="nav-anchor" id="Adding-a-build-step-to-the-package.-1" href="#Adding-a-build-step-to-the-package.-1">Adding a build step to the package.</a></h3><p>The build step is executed the first time a package is installed or when explicitly invoked with <code>build</code>. A package is built by executing the file <code>deps/build.jl</code>.</p><pre><code class="language-none">shell&gt; cat deps/build.jl
println(&quot;I am being built...&quot;)

shell&gt; cat deps/build.log
I am being built...

(HelloWorld) pkg&gt; build
  Building HelloWorld → `deps/build.log`
 Resolving package versions...

shell&gt; cat deps/build.log
I am being built...</code></pre><p>If the build step fails, the output of the build step is printed to the console</p><pre><code class="language-none">shell&gt; cat deps/build.jl
error(&quot;Ooops&quot;)

(HelloWorld) pkg&gt; build
  Building HelloWorld → `deps/build.log`
 Resolving package versions...
┌ Error: Error building `HelloWorld`:
│ ERROR: LoadError: Ooops
│ Stacktrace:
│  [1] error(::String) at ./error.jl:33
│  [2] top-level scope at none:0
│  [3] include at ./boot.jl:317 [inlined]
│  [4] include_relative(::Module, ::String) at ./loading.jl:1071
│  [5] include(::Module, ::String) at ./sysimg.jl:29
│  [6] include(::String) at ./client.jl:393
│  [7] top-level scope at none:0
│ in expression starting at /Users/kristoffer/.julia/dev/Pkg/HelloWorld/deps/build.jl:1
└ @ Pkg.Operations Operations.jl:938</code></pre><h3><a class="nav-anchor" id="Adding-tests-to-the-package-1" href="#Adding-tests-to-the-package-1">Adding tests to the package</a></h3><p>When a package is tested the file <code>test/runtests.jl</code> is executed.</p><pre><code class="language-none">shell&gt; cat test/runtests.jl
println(&quot;Testing...&quot;)
(HelloWorld) pkg&gt; test
   Testing HelloWorld
 Resolving package versions...
Testing...
   Testing HelloWorld tests passed</code></pre><h4><a class="nav-anchor" id="Test-specific-dependencies-1" href="#Test-specific-dependencies-1">Test-specific dependencies</a></h4><p>Sometimes one might want to use some packages only at testing time but not enforce a dependency on them when the package is used. This is possible by adding dependencies to <code>[extras]</code> and a <code>test</code> target in <code>[targets]</code> to the Project file. Here we add the <code>Test</code> standard library as a test-only dependency by adding the following to the Project file:</p><pre><code class="language-none">[extras]
Test = &quot;8dfed614-e22c-5e08-85e1-65c5234f0b40&quot;

[targets]
test = [&quot;Test&quot;]</code></pre><p>We can now use <code>Test</code> in the test script and we can see that it gets installed on testing:</p><pre><code class="language-none">shell&gt; cat test/runtests.jl
using Test
@test 1 == 1

(HelloWorld) pkg&gt; test
   Testing HelloWorld
 Resolving package versions...
  Updating `/var/folders/64/76tk_g152sg6c6t0b4nkn1vw0000gn/T/tmpPzUPPw/Project.toml`
  [d8327f2a] + HelloWorld v0.1.0 [`~/.julia/dev/Pkg/HelloWorld`]
  [8dfed614] + Test
  Updating `/var/folders/64/76tk_g152sg6c6t0b4nkn1vw0000gn/T/tmpPzUPPw/Manifest.toml`
  [d8327f2a] + HelloWorld v0.1.0 [`~/.julia/dev/Pkg/HelloWorld`]
   Testing HelloWorld tests passed```</code></pre><h3><a class="nav-anchor" id="Compatibility-1" href="#Compatibility-1">Compatibility</a></h3><p>Compatibility refers to the ability to restrict what version of the dependencies that your project is compatible with. If the compatibility for a dependency is not given, the project is assumed to be compatible with all versions of that dependency.</p><p>Compatibility for a dependency is entered in the <code>Project.toml</code> file as for example:</p><pre><code class="language-toml">[compat]
julia = &quot;1.0&quot;
Example = &quot;0.4.3&quot;</code></pre><p>After a compatibility entry is put into the project file, <code>up</code> can be used to apply it.</p><p>The format of the version specifier is described in detail below.</p><div class="admonition info"><div class="admonition-title">Info</div><div class="admonition-text"><p>There is currently no way to give compatibility from the Pkg REPL mode so for now, one has to manually edit the project file.</p></div></div><h4><a class="nav-anchor" id="Version-specifier-format-1" href="#Version-specifier-format-1">Version specifier format</a></h4><p>Similar to other package managers, the Julia package manager respects <a href="https://semver.org/">semantic versioning</a> (semver). As an example, a version specifier is given as e.g. <code>1.2.3</code> is therefore assumed to be compatible with the versions <code>[1.2.3 - 2.0.0)</code> where <code>)</code> is a non-inclusive upper bound. More specifically, a version specifier is either given as a <strong>caret specifier</strong>, e.g. <code>^1.2.3</code>  or a <strong>tilde specifier</strong> <code>~1.2.3</code>. Caret specifiers are the default and hence <code>1.2.3 == ^1.2.3</code>. The difference between a caret and tilde is described in the next section. The intersection of multiple version specifiers can be formed by comma separating indiviual version specifiers.</p><h5><a class="nav-anchor" id="Caret-specifiers-1" href="#Caret-specifiers-1">Caret specifiers</a></h5><p>A caret specifier allows upgrade that would be compatible according to semver. An updated dependency is considered compatible if the new version does not modify the left-most non zero digit in the version specifier.</p><p>Some examples are shown below.</p><pre><code class="language-none">^1.2.3 = [1.2.3, 2.0.0)
^1.2 = [1.2.0, 2.0.0)
^1 =  [1.0.0, 2.0.0)
^0.2.3 = [0.2.3, 0.3.0)
^0.0.3 = [0.0.3, 0.0.4)
^0.0 = [0.0.0, 0.1.0)
^0 = [0.0.0, 1.0.0)</code></pre><p>While the semver specification says that all versions with a major version of 0 are incompatible with each other, we have made that choice that a version given as <code>0.a.b</code> is considered compatible with <code>0.a.c</code> if <code>a != 0</code> and  <code>c &gt;= b</code>.</p><h5><a class="nav-anchor" id="Tilde-specifiers-1" href="#Tilde-specifiers-1">Tilde specifiers</a></h5><p>A tilde specifier provides more limited upgrade possibilities. With a tilde, only the last specified digit is allowed to increment by one. This gives the following example.</p><pre><code class="language-none">~1.2.3 = [1.2.3, 1.2.4)
~1.2 = [1.2.0, 1.3.0)
~1 = [1.0.0, 2.0.0)</code></pre><h4><a class="nav-anchor" id="Inequality-specifiers-1" href="#Inequality-specifiers-1">Inequality specifiers</a></h4><p>Inequalities can also be used to specify version ranges:</p><pre><code class="language-none">&gt;= 1.2.3 = [1.2.3,  ∞)
≥ 1.2.3 = [1.2.3,  ∞)
= 1.2.3 = [1.2.3, 1.2.3]
&lt; 1.2.3 = [0.0.0, 1.2.2]</code></pre><h2><a class="nav-anchor" id="Precompiling-a-project-1" href="#Precompiling-a-project-1">Precompiling a project</a></h2><p>The REPL command <code>precompile</code> can be used to precompile all the dependencies in the project. You can for example do</p><pre><code class="language-none">(HelloWorld) pkg&gt; update; precompile</code></pre><p>to update the dependencies and then precompile them.</p><h2><a class="nav-anchor" id="Preview-mode-1" href="#Preview-mode-1">Preview mode</a></h2><p>If you just want to see the effects of running a command, but not change your state you can <code>preview</code> a command. For example:</p><pre><code class="language-none">(HelloWorld) pkg&gt; preview add Plots</code></pre><p>or</p><pre><code class="language-none">(HelloWorld) pkg&gt; preview up</code></pre><p>will show you the effects of adding <code>Plots</code>, or doing a full upgrade, respectively, would have on your project. However, nothing would be installed and your <code>Project.toml</code> and <code>Manifest.toml</code> are untouched.</p><h2><a class="nav-anchor" id="Using-someone-else&#39;s-project-1" href="#Using-someone-else&#39;s-project-1">Using someone else&#39;s project</a></h2><p>Simply clone their project using e.g. <code>git clone</code>, <code>cd</code> to the project directory and call</p><pre><code class="language-none">(v1.0) pkg&gt; activate .

(SomeProject) pkg&gt; instantiate</code></pre><p>If the project contains a manifest, this will install the packages in the same state that is given by that manifest. Otherwise, it will resolve the latest versions of the dependencies compatible with the project.</p><h2><a class="nav-anchor" id="References-1" href="#References-1">References</a></h2><p>This section describes the &quot;API mode&quot; of interacting with Pkg.jl which is recommended for non-interactive usage, in i.e. scripts. In the REPL mode packages (with associated version, UUID, URL etc) are parsed from strings, for example, <code>&quot;Package#master&quot;</code>,<code>&quot;Package@v0.1&quot;</code>, <code>&quot;www.mypkg.com/MyPkg#my/feature&quot;</code>. It is possible to use strings as arguments for simple commands in the API mode (like <code>Pkg.add([&quot;PackageA&quot;, &quot;PackageB&quot;])</code>, more complicated commands, that e.g. specify URLs or version range, uses a more structured format over strings. This is done by creating an instance of a <a href="#Pkg.PackageSpec"><code>PackageSpec</code></a> which are passed in to functions.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Pkg.PackageSpec" href="#Pkg.PackageSpec"><code>Pkg.PackageSpec</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">PackageSpec(name::String, [uuid::UUID, version::VersionNumber])
PackageSpec(; name, url, path, rev, version, mode, level)</code></pre><p>A <code>PackageSpec</code> is a representation of a package with various metadata. This includes:</p><ul><li>The <code>name</code> of the package.</li><li>The package unique <code>uuid</code>.</li><li>A <code>version</code> (for example when adding a package. When upgrading, can also be an instance of</li></ul><p>the enum <a href="#Pkg.UpgradeLevel"><code>UpgradeLevel</code></a></p><ul><li>A <code>url</code> and an optional git <code>rev</code>ision. <code>rev</code> could be a branch name or a git commit SHA.</li><li>A local path <code>path</code>. This is equivalent to using the <code>url</code> argument but can be more descriptive.</li><li>A <code>mode</code>, which is an instance of the enum <a href="#Pkg.PackageMode"><code>PackageMode</code></a> which can be either <code>PKGMODE_PROJECT</code> or</li></ul><p><code>PKGMODE_MANIFEST</code>, defaults to <code>PKGMODE_PROJECT</code>. Used in e.g. <a href="#Pkg.rm"><code>Pkg.rm</code></a>.</p><p>Most functions in Pkg take a <code>Vector</code> of <code>PackageSpec</code> and do the operation on all the packages in the vector.</p><p>Below is a comparison between the REPL version and the <code>PackageSpec</code> version:</p><table><tr><th><code>REPL</code></th><th><code>API</code></th></tr><tr><td><code>Package</code></td><td><code>PackageSpec(&quot;Package&quot;)</code></td></tr><tr><td><code>Package@0.2</code></td><td><code>PackageSpec(name=&quot;Package&quot;, version=&quot;0.2&quot;)</code></td></tr><tr><td><code>Package=a67d...</code></td><td><code>PackageSpec(name=&quot;Package&quot;, uuid=&quot;a67d...&quot;</code></td></tr><tr><td><code>Package#master</code></td><td><code>PackageSpec(name=&quot;Package&quot;, rev=&quot;master&quot;)</code></td></tr><tr><td><code>local/path#feature</code></td><td><code>PackageSpec(path=&quot;local/path&quot;; rev=&quot;feature)</code></td></tr><tr><td><code>www.mypkg.com</code></td><td><code>PackageSpec(url=&quot;www.mypkg.com&quot;)</code></td></tr><tr><td><code>--manifest Package</code></td><td><code>PackageSpec(name=&quot;Package&quot;, mode=PKGSPEC_MANIFEST)</code></td></tr><tr><td><code>--major Package</code></td><td><code>PackageSpec(name=&quot;Package&quot;, version=PKGLEVEL_MAJOR</code>)</td></tr></table></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/993e7d77333b79c0a7756074644cd1a3cf16597e/stdlib/Pkg/src/Pkg.jl#L294-L325">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Pkg.PackageMode" href="#Pkg.PackageMode"><code>Pkg.PackageMode</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">PackageMode</code></pre><p>An enum with the instances</p><ul><li><code>PKGMODE_MANIFEST</code></li><li><code>PKGMODE_PROJECT</code></li></ul><p>Determines if operations should be made on a project or manifest level. Used as an argument to  <a href="#Pkg.PackageSpec"><code>PackageSpec</code></a> or as an argument to <a href="#Pkg.rm"><code>Pkg.rm</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/993e7d77333b79c0a7756074644cd1a3cf16597e/stdlib/Pkg/src/Pkg.jl#L46-L56">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Pkg.UpgradeLevel" href="#Pkg.UpgradeLevel"><code>Pkg.UpgradeLevel</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">UpgradeLevel</code></pre><p>An enum with the instances</p><ul><li><code>UPLEVEL_FIXED</code></li><li><code>UPLEVEL_PATCH</code></li><li><code>UPLEVEL_MINOR</code></li><li><code>UPLEVEL_MAJOR</code></li></ul><p>Determines how much a package is allowed to be updated. Used as an argument to  <a href="#Pkg.PackageSpec"><code>PackageSpec</code></a> or as an argument to <a href="#Pkg.update"><code>Pkg.update</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/993e7d77333b79c0a7756074644cd1a3cf16597e/stdlib/Pkg/src/Pkg.jl#L60-L72">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Pkg.add" href="#Pkg.add"><code>Pkg.add</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">Pkg.add(pkg::Union{String, Vector{String}})
Pkg.add(pkg::Union{PackageSpec, Vector{PackageSpec}})</code></pre><p>Add a package to the current project. This package will be available using the <code>import</code> and <code>using</code> keywords in the Julia REPL and if the current project is a package, also inside that package.</p><p><strong>Examples</strong></p><pre><code class="language-julia">Pkg.add(&quot;Example&quot;) # Add a package from registry
Pkg.add(PackageSpec(name=&quot;Example&quot;, version=&quot;0.3&quot;)) # Specify version
Pkg.add(PackageSpec(url=&quot;https://github.com/JuliaLang/Example.jl&quot;, rev=&quot;master&quot;)) # From url
Pkg.add(PackageSpec(url=&quot;/remote/mycompany/juliapackages/OurPackage&quot;))` # From path (has to be a gitrepo)</code></pre><p>See also <a href="#Pkg.PackageSpec"><code>PackageSpec</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/993e7d77333b79c0a7756074644cd1a3cf16597e/stdlib/Pkg/src/Pkg.jl#L76-L93">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Pkg.develop" href="#Pkg.develop"><code>Pkg.develop</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">Pkg.develop(pkg::Union{String, Vector{String}})
Pkg.develop(pkgs::Union{Packagespec, Vector{Packagespec}})</code></pre><p>Make a package available for development by tracking it by path. If <code>pkg</code> is given with only a name or by a URL the packages will be downloaded to the location by the environment variable <code>JULIA_PKG_DEVDIR</code> with <code>.julia/dev</code> as the default.</p><p>If <code>pkg</code> is given as a local path, the package at that path will be tracked.</p><p><strong>Examples</strong></p><pre><code class="language-julia"># By name
Pkg.develop(&quot;Example&quot;)

# By url
Pkg.develop(PackageSpec(url=&quot;https://github.com/JuliaLang/Compat.jl&quot;))

# By path
Pkg.develop(PackageSpec(path=&quot;MyJuliaPackages/Package.jl&quot;)</code></pre><p>See also <a href="#Pkg.PackageSpec"><code>PackageSpec</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/993e7d77333b79c0a7756074644cd1a3cf16597e/stdlib/Pkg/src/Pkg.jl#L205-L230">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Pkg.activate" href="#Pkg.activate"><code>Pkg.activate</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">Pkg.activate([s::String]; shared::Bool=false)</code></pre><p>Activate the environment at <code>s</code>. The active environment is the environment that is modified by executing package commands. The logic for what path is activated is as follows:</p><ul><li>If <code>shared</code> is <code>true</code>, the first existing environment named <code>s</code> from the depots in the depot stack will be activated. If no such environment exists, create and activate that environment in the first depot.</li><li>If <code>s</code> is an existing path, then activate the environment at that path.</li><li>If <code>s</code> is a package in the current project and <code>s</code> is tracking a path, then activate the environment at the tracked path.</li><li>Else, <code>s</code> is interpreted as a non-existing path, activate that path.</li></ul><p>If no argument is given to <code>activate</code>, then activate the home project. The home project is specified by either the <code>--project</code> command line option to the julia executable, or the <code>JULIA_PROJECT</code> environment variable.</p><p><strong>Examples</strong></p><pre><code class="language-none">Pkg.activate()
Pkg.activate(&quot;local/path&quot;)
Pkg.activate(&quot;MyDependency&quot;)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/993e7d77333b79c0a7756074644cd1a3cf16597e/stdlib/Pkg/src/Pkg.jl#L265-L290">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Pkg.rm" href="#Pkg.rm"><code>Pkg.rm</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">Pkg.rm(pkg::Union{String, Vector{String}})
Pkg.rm(pkg::Union{PackageSpec, Vector{PackageSpec}})</code></pre><p>Remove a package from the current project. If the <code>mode</code> of <code>pkg</code> is <code>PKGMODE_MANIFEST</code> also remove it from the manifest including all recursive dependencies of <code>pkg</code>.</p><p>See also <a href="#Pkg.PackageSpec"><code>PackageSpec</code></a>, <a href="#Pkg.PackageMode"><code>PackageMode</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/993e7d77333b79c0a7756074644cd1a3cf16597e/stdlib/Pkg/src/Pkg.jl#L96-L105">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Pkg.update" href="#Pkg.update"><code>Pkg.update</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">Pkg.update(; level::UpgradeLevel=UPLEVEL_MAJOR, mode::PackageMode = PKGMODE_PROJECT)
Pkg.update(pkg::Union{String, Vector{String}})
Pkg.update(pkg::Union{PackageSpec, Vector{PackageSpec}})</code></pre><p>Update a package <code>pkg</code>. If no posistional argument is given, update all packages in the manifest if <code>mode</code> is <code>PKGMODE_MANIFEST</code> and packages in both manifest and project if <code>mode</code> is <code>PKGMODE_PROJECT</code>. If no positional argument is given <code>level</code> can be used to control what how much packages are allowed to be upgraded (major, minor, patch, fixed).</p><p>See also <a href="#Pkg.PackageSpec"><code>PackageSpec</code></a>, <a href="#Pkg.PackageMode"><code>PackageMode</code></a>, <a href="#Pkg.UpgradeLevel"><code>UpgradeLevel</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/993e7d77333b79c0a7756074644cd1a3cf16597e/stdlib/Pkg/src/Pkg.jl#L108-L117">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Pkg.test" href="#Pkg.test"><code>Pkg.test</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">Pkg.test(; coverage::Bool=true)
Pkg.test(pkg::Union{String, Vector{String}; coverage::Bool=true)
Pkg.test(pkgs::Union{PackageSpec, Vector{PackageSpec}}; coverage::Bool=true)</code></pre><p>Run the tests for package <code>pkg</code> or if no positional argument is given to <code>test</code>, the current project is tested (which thus needs to be a package). A package is tested by running its <code>test/runtests.jl</code> file.</p><p>The tests are run by generating a temporary environment with only <code>pkg</code> and its (recursive) dependencies (recursively) in it. If a manifest exist, the versions in that manifest is used, otherwise a feasible set of package are resolved and installed.</p><p>During the test, test-specific dependencies are active, which are given in the project file as e.g.</p><pre><code class="language-none">[extras]
Test = &quot;8dfed614-e22c-5e08-85e1-65c5234f0b40&quot;

[targets]
test = [Test]</code></pre><p>Coverage statistics for the packages may be generated by passing <code>coverage=true</code>. The default behavior is not to run coverage.</p><p>The tests are executed in a new process with <code>check-bounds=yes</code> and by default <code>startup-file=no</code>. If using the startup file (<code>~/.julia/config/startup.jl</code>) is desired, start julia with <code>--startup-file=yes</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/993e7d77333b79c0a7756074644cd1a3cf16597e/stdlib/Pkg/src/Pkg.jl#L121-L150">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Pkg.build" href="#Pkg.build"><code>Pkg.build</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">Pkg.build()
Pkg.build(pkg::Union{String, Vector{String}})
Pkg.build(pkgs::Union{PackageSpec, Vector{PackageSpec}})</code></pre><p>Run the build script in <code>deps/build.jl</code> for <code>pkg</code> and all of the dependencies in depth-first recursive order. If no argument is given to <code>build</code>, the current project is built, which thus needs to be a package. This function is called automatically one any package that gets installed for the first time.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/993e7d77333b79c0a7756074644cd1a3cf16597e/stdlib/Pkg/src/Pkg.jl#L163-L174">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Pkg.pin" href="#Pkg.pin"><code>Pkg.pin</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">Pkg.pin(pkg::Union{String, Vector{String}})
Pkg.pin(pkgs::Union{Packagespec, Vector{Packagespec}})</code></pre><p>Pin a package to the current version (or the one given in the <code>packagespec</code> or a certain git revision. A pinned package is never updated.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/993e7d77333b79c0a7756074644cd1a3cf16597e/stdlib/Pkg/src/Pkg.jl#L180-L186">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Pkg.free" href="#Pkg.free"><code>Pkg.free</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">Pkg.free(pkg::Union{String, Vector{String}})
Pkg.free(pkgs::Union{Packagespec, Vector{Packagespec}})</code></pre><p>Free a package which removes a <code>pin</code> if it exists, or if the package is tracking a path, e.g. after <a href="#Pkg.develop"><code>Pkg.develop</code></a>, go back to tracking registered versions.</p><p><strong>Examples</strong></p><pre><code class="language-julia">Pkg.free(&quot;Package&quot;)
Pkg.free(PackageSpec(&quot;Package&quot;))</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/993e7d77333b79c0a7756074644cd1a3cf16597e/stdlib/Pkg/src/Pkg.jl#L189-L201">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Pkg.instantiate" href="#Pkg.instantiate"><code>Pkg.instantiate</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">Pkg.instantiate()</code></pre><p>If a <code>Manifest.toml</code> file exist in the current project, download all the packages declared in that manifest. Else, resolve a set of feasible packages from the <code>Project.toml</code> files and install them.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/993e7d77333b79c0a7756074644cd1a3cf16597e/stdlib/Pkg/src/Pkg.jl#L236-L243">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Pkg.resolve" href="#Pkg.resolve"><code>Pkg.resolve</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">Pkg.resolve()</code></pre><p>Update the current manifest with eventual changes to the dependency graph from packages that are tracking a path.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/993e7d77333b79c0a7756074644cd1a3cf16597e/stdlib/Pkg/src/Pkg.jl#L246-L251">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Pkg.setprotocol!" href="#Pkg.setprotocol!"><code>Pkg.setprotocol!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">Pkg.setprotocol!(proto::Union{Nothing, AbstractString}=nothing)</code></pre><p>Set the protocol used to access GitHub-hosted packages when <code>add</code>ing a url or <code>develop</code>ing a package. Defaults to &#39;https&#39;, with <code>proto == nothing</code> delegating the choice to the package developer.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/993e7d77333b79c0a7756074644cd1a3cf16597e/stdlib/Pkg/src/Pkg.jl#L328-L333">source</a></section><footer><hr/><a class="previous" href="../Mmap/"><span class="direction">Previous</span><span class="title">Memory-mapped I/O</span></a><a class="next" href="../Printf/"><span class="direction">Next</span><span class="title">Printf</span></a></footer></article></body></html>
