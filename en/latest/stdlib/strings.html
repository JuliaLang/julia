<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Strings · The Julia Language</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-28835595-6', 'auto');
ga('send', 'pageview');
</script><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/styles/default.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Ubuntu+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../../versions.js"></script></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="The Julia Language logo"/></a><h1>The Julia Language</h1><form class="search" action="../search.html"><select id="version-selector" onChange="window.location.href=this.value"><option value="#" selected="selected" disabled="disabled">Version</option></select><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../manual/introduction.html">Introduction</a></li><li><a class="toctext" href="../manual/getting-started.html">Getting Started</a></li><li><a class="toctext" href="../manual/variables.html">Variables</a></li><li><a class="toctext" href="../manual/integers-and-floating-point-numbers.html">Integers and Floating-Point Numbers</a></li><li><a class="toctext" href="../manual/mathematical-operations.html">Mathematical Operations and Elementary Functions</a></li><li><a class="toctext" href="../manual/complex-and-rational-numbers.html">Complex and Rational Numbers</a></li><li><a class="toctext" href="../manual/strings.html">Strings</a></li><li><a class="toctext" href="../manual/functions.html">Functions</a></li><li><a class="toctext" href="../manual/control-flow.html">Control Flow</a></li><li><a class="toctext" href="../manual/variables-and-scoping.html">Scope of Variables</a></li><li><a class="toctext" href="../manual/types.html">Types</a></li><li><a class="toctext" href="../manual/methods.html">Methods</a></li><li><a class="toctext" href="../manual/constructors.html">Constructors</a></li><li><a class="toctext" href="../manual/conversion-and-promotion.html">Conversion and Promotion</a></li><li><a class="toctext" href="../manual/interfaces.html">Interfaces</a></li><li><a class="toctext" href="../manual/modules.html">Modules</a></li><li><a class="toctext" href="../manual/documentation.html">Documentation</a></li><li><a class="toctext" href="../manual/metaprogramming.html">Metaprogramming</a></li><li><a class="toctext" href="../manual/arrays.html">Multi-dimensional Arrays</a></li><li><a class="toctext" href="../manual/linear-algebra.html">Linear algebra</a></li><li><a class="toctext" href="../manual/networking-and-streams.html">Networking and Streams</a></li><li><a class="toctext" href="../manual/parallel-computing.html">Parallel Computing</a></li><li><a class="toctext" href="../manual/dates.html">Date and DateTime</a></li><li><a class="toctext" href="../manual/interacting-with-julia.html">Interacting With Julia</a></li><li><a class="toctext" href="../manual/running-external-programs.html">Running External Programs</a></li><li><a class="toctext" href="../manual/calling-c-and-fortran-code.html">Calling C and Fortran Code</a></li><li><a class="toctext" href="../manual/handling-operating-system-variation.html">Handling Operating System Variation</a></li><li><a class="toctext" href="../manual/interacting-with-julia.html">Interacting With Julia</a></li><li><a class="toctext" href="../manual/embedding.html">Embedding Julia</a></li><li><a class="toctext" href="../manual/packages.html">Packages</a></li><li><a class="toctext" href="../manual/profile.html">Profiling</a></li><li><a class="toctext" href="../manual/stacktraces.html">Stack Traces</a></li><li><a class="toctext" href="../manual/performance-tips.html">Performance Tips</a></li><li><a class="toctext" href="../manual/workflow-tips.html">Workflow Tips</a></li><li><a class="toctext" href="../manual/style-guide.html">Style Guide</a></li><li><a class="toctext" href="../manual/faq.html">Frequently Asked Questions</a></li><li><a class="toctext" href="../manual/noteworthy-differences.html">Noteworthy Differences from other Languages</a></li><li><a class="toctext" href="../manual/unicode-input.html">Unicode Input</a></li></ul></li><li><span class="toctext">Standard Library</span><ul><li><a class="toctext" href="base.html">Essentials</a></li><li><a class="toctext" href="collections.html">Collections and Data Structures</a></li><li><a class="toctext" href="math.html">Mathematics</a></li><li><a class="toctext" href="numbers.html">Numbers</a></li><li class="current"><a class="toctext" href="strings.html">Strings</a><ul class="internal"></ul></li><li><a class="toctext" href="arrays.html">Arrays</a></li><li><a class="toctext" href="parallel.html">Tasks and Parallel Computing</a></li><li><a class="toctext" href="linalg.html">Linear Algebra</a></li><li><a class="toctext" href="constants.html">Constants</a></li><li><a class="toctext" href="file.html">Filesystem</a></li><li><a class="toctext" href="io-network.html">I/O and Network</a></li><li><a class="toctext" href="punctuation.html">Punctuation</a></li><li><a class="toctext" href="sort.html">Sorting and Related Functions</a></li><li><a class="toctext" href="pkg.html">Package Manager Functions</a></li><li><a class="toctext" href="dates.html">Dates and Time</a></li><li><a class="toctext" href="iterators.html">Iteration utilities</a></li><li><a class="toctext" href="test.html">Unit Testing</a></li><li><a class="toctext" href="c.html">C Interface</a></li><li><a class="toctext" href="libc.html">C Standard Library</a></li><li><a class="toctext" href="libdl.html">Dynamic Linker</a></li><li><a class="toctext" href="profile.html">Profiling</a></li><li><a class="toctext" href="stacktraces.html">StackTraces</a></li><li><a class="toctext" href="simd-types.html">SIMD Support</a></li></ul></li><li><span class="toctext">Developer Documentation</span><ul><li><a class="toctext" href="../devdocs/reflection.html">Reflection and introspection</a></li><li><span class="toctext">Documentation of Julia&#39;s Internals</span><ul><li><a class="toctext" href="../devdocs/init.html">Initialization of the Julia runtime</a></li><li><a class="toctext" href="../devdocs/eval.html">Eval of Julia code</a></li><li><a class="toctext" href="../devdocs/ast.html">Julia ASTs</a></li><li><a class="toctext" href="../devdocs/types.html">More about types</a></li><li><a class="toctext" href="../devdocs/object.html">Memory layout of Julia Objects</a></li><li><a class="toctext" href="../devdocs/functions.html">Julia Functions</a></li><li><a class="toctext" href="../devdocs/callconv.html">Calling Conventions</a></li><li><a class="toctext" href="../devdocs/cartesian.html">Base.Cartesian</a></li><li><a class="toctext" href="../devdocs/meta.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="../devdocs/subarrays.html">SubArrays</a></li><li><a class="toctext" href="../devdocs/sysimg.html">System Image Building</a></li><li><a class="toctext" href="../devdocs/llvm.html">Working with LLVM</a></li><li><a class="toctext" href="../devdocs/stdio.html">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="../devdocs/boundscheck.html">Bounds checking</a></li><li><a class="toctext" href="../devdocs/locks.html">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="../devdocs/offset-arrays.html">Arrays with custom indices</a></li></ul></li><li><span class="toctext">Developing/debugging Julia&#39;s C code</span><ul><li><a class="toctext" href="../devdocs/backtraces.html">Reporting and analyzing crashes (segfaults)</a></li><li><a class="toctext" href="../devdocs/debuggingtips.html">gdb debugging tips</a></li><li><a class="toctext" href="../devdocs/valgrind.html">Using Valgrind with Julia</a></li><li><a class="toctext" href="../devdocs/sanitizers.html">Sanitizer support</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Standard Library</li><li><a href="strings.html">Strings</a></li></ul><a class="edit-page" href="https://github.com/JuliaLang/julia/tree/6eaec18eb79593468d7ca93bb6164335fd0687e4/doc/src/stdlib/strings.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><h1><a class="nav-anchor" id="lib-strings-1" href="#lib-strings-1">Strings</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.length-Tuple{AbstractString}" href="#Base.length-Tuple{AbstractString}"><code>Base.length</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">length(s::AbstractString)</code></pre><p>The number of characters in string <code>s</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/6eaec18eb79593468d7ca93bb6164335fd0687e4/base/strings/basic.jl#L113-L117">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.sizeof-Tuple{AbstractString}" href="#Base.sizeof-Tuple{AbstractString}"><code>Base.sizeof</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">sizeof(s::AbstractString)</code></pre><p>The number of bytes in string <code>s</code>.</p><pre><code class="language-julia">julia&gt; sizeof(&quot;❤&quot;)
3</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/6eaec18eb79593468d7ca93bb6164335fd0687e4/base/strings/basic.jl#L81-L90">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:*-Tuple{AbstractString,Vararg{Any,N}}" href="#Base.:*-Tuple{AbstractString,Vararg{Any,N}}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">*(x, y...)</code></pre><p>Multiplication operator. <code>x*y*z*...</code> calls this function with all arguments, i.e. <code>*(x, y, z, ...)</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/6eaec18eb79593468d7ca93bb6164335fd0687e4/base/docs/helpdb/Base.jl#L1771-L1777">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:^-Tuple{AbstractString,Integer}" href="#Base.:^-Tuple{AbstractString,Integer}"><code>Base.:^</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">^(s::AbstractString, n::Integer)</code></pre><p>Repeat <code>n</code> times the string <code>s</code>. The <a href="linalg.html#Base.repeat"><code>repeat</code></a> function is an alias to this operator.</p><pre><code class="language-julia">julia&gt; &quot;Test &quot;^3
&quot;Test Test Test &quot;</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/6eaec18eb79593468d7ca93bb6164335fd0687e4/base/strings/types.jl#L153-L163">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.string" href="#Base.string"><code>Base.string</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">string(xs...)</code></pre><p>Create a string from any values using the <a href="io-network.html#Base.print"><code>print</code></a> function.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/6eaec18eb79593468d7ca93bb6164335fd0687e4/base/strings/io.jl#L97-L101">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.repr" href="#Base.repr"><code>Base.repr</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">repr(x)</code></pre><p>Create a string from any value using the <a href="io-network.html#Base.showall"><code>showall</code></a> function.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/6eaec18eb79593468d7ca93bb6164335fd0687e4/base/strings/io.jl#L121-L125">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Core.String-Tuple{AbstractString}" href="#Core.String-Tuple{AbstractString}"><code>Core.String</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">String(s::AbstractString)</code></pre><p>Convert a string to a contiguous byte array representation encoded as UTF-8 bytes. This representation is often appropriate for passing strings to C.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/6eaec18eb79593468d7ca93bb6164335fd0687e4/base/strings/basic.jl#L13-L18">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.transcode" href="#Base.transcode"><code>Base.transcode</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">transcode(T, src)</code></pre><p>Convert string data between Unicode encodings. <code>src</code> is either a <code>String</code> or a <code>Vector{UIntXX}</code> of UTF-XX code units, where <code>XX</code> is 8, 16, or 32. <code>T</code> indicates the encoding of the return value: <code>String</code> to return a (UTF-8 encoded) <code>String</code> or <code>UIntXX</code> to return a <code>Vector{UIntXX}</code> of UTF-<code>XX</code> data.   (The alias <code>Cwchar_t</code> can also be used as the integer type, for converting <code>wchar_t*</code> strings used by external C libraries.)</p><p>The <code>transcode</code> function succeeds as long as the input data can be reasonably represented in the target encoding; it always succeeds for conversions between UTF-XX encodings, even for invalid Unicode data.</p><p>Only conversion to/from UTF-8 is currently supported.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/6eaec18eb79593468d7ca93bb6164335fd0687e4/base/c.jl#L145-L161">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.unsafe_string" href="#Base.unsafe_string"><code>Base.unsafe_string</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">unsafe_string(p::Ptr{UInt8}, [length::Integer])</code></pre><p>Copy a string from the address of a C-style (NUL-terminated) string encoded as UTF-8. (The pointer can be safely freed afterwards.) If <code>length</code> is specified (the length of the data in bytes), the string does not have to be NUL-terminated.</p><p>This function is labelled &quot;unsafe&quot; because it will crash if <code>p</code> is not a valid memory address to data of the requested length.</p><p>See also <a href="c.html#Base.unsafe_wrap-Tuple{Union{Type{Array{T,N}},Type{Array{T,N}},Type{Array}},Ptr{T},Tuple{Vararg{Int64,N}}}"><code>unsafe_wrap(String, p, [length])</code></a>, which takes a pointer and wraps a string object around it without making a copy.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/6eaec18eb79593468d7ca93bb6164335fd0687e4/base/strings/basic.jl#L38-L50">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.unsafe_wrap-Tuple{Type{String},Union{Ptr{Int8},Ptr{UInt8}},Integer,Bool}" href="#Base.unsafe_wrap-Tuple{Type{String},Union{Ptr{Int8},Ptr{UInt8}},Integer,Bool}"><code>Base.unsafe_wrap</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">unsafe_wrap(String, p::Ptr{UInt8}, [length,] own=false)</code></pre><p>Wrap a pointer <code>p</code> to an array of bytes in a <code>String</code> object, interpreting the bytes as UTF-8 encoded characters <em>without making a copy</em>. The optional <code>length</code> argument indicates the length in bytes of the pointer&#39;s data; if it is omitted, the data is assumed to be NUL-terminated.  The <code>own</code> argument optionally specifies whether Julia should take ownership of the memory, calling <code>free</code> on the pointer when the array is no longer referenced.</p><p>This function is labelled &quot;unsafe&quot; because it will crash if <code>p</code> is not a valid memory address to data of the requested length.</p><p>See also <a href="strings.html#Base.unsafe_string"><code>unsafe_string</code></a>, which takes a pointer and makes a copy of the data.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/6eaec18eb79593468d7ca93bb6164335fd0687e4/base/pointer.jl#L98-L114">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.ascii" href="#Base.ascii"><code>Base.ascii</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">ascii(s::AbstractString)</code></pre><p>Convert a string to <code>String</code> type and check that it contains only ASCII data, otherwise throwing an <code>ArgumentError</code> indicating the position of the first non-ASCII byte.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/6eaec18eb79593468d7ca93bb6164335fd0687e4/base/strings/util.jl#L455-L460">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.@r_str" href="#Base.@r_str"><code>Base.@r_str</code></a> — <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@r_str -&gt; Regex</code></pre><p>Construct a regex, such as <code>r&quot;^[a-z]*$&quot;</code>. The regex also accepts one or more flags, listed after the ending quote, to change its behaviour:</p><ul><li><p><code>i</code> enables case-insensitive matching</p></li><li><p><code>m</code> treats the <code>^</code> and <code>$</code> tokens as matching the start and end of individual lines, as opposed to the whole string.</p></li><li><p><code>s</code> allows the <code>.</code> modifier to match newlines.</p></li><li><p><code>x</code> enables &quot;comment mode&quot;: whitespace is enabled except when escaped with <code>\</code>, and <code>#</code> is treated as starting a comment.</p></li></ul><p>For example, this regex has all three flags enabled:</p><pre><code class="language-julia">julia&gt; match(r&quot;a+.*b+.*?d$&quot;ism, &quot;Goodbye,\nOh, angry,\nBad world\n&quot;)
RegexMatch(&quot;angry,\nBad world&quot;)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/6eaec18eb79593468d7ca93bb6164335fd0687e4/base/regex.jl#L63-L82">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Docs.@html_str" href="#Base.Docs.@html_str"><code>Base.Docs.@html_str</code></a> — <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@html_str -&gt; Docs.HTML</code></pre><p>Create an <code>HTML</code> object from a literal string.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/6eaec18eb79593468d7ca93bb6164335fd0687e4/base/docs/utils.jl#L37-L41">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Docs.@text_str" href="#Base.Docs.@text_str"><code>Base.Docs.@text_str</code></a> — <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@text_str -&gt; Docs.Text</code></pre><p>Create a <code>Text</code> object from a literal string.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/6eaec18eb79593468d7ca93bb6164335fd0687e4/base/docs/utils.jl#L75-L79">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.UTF8proc.normalize_string" href="#Base.UTF8proc.normalize_string"><code>Base.UTF8proc.normalize_string</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">normalize_string(s::AbstractString, normalform::Symbol)</code></pre><p>Normalize the string <code>s</code> according to one of the four &quot;normal forms&quot; of the Unicode standard: <code>normalform</code> can be <code>:NFC</code>, <code>:NFD</code>, <code>:NFKC</code>, or <code>:NFKD</code>.  Normal forms C (canonical composition) and D (canonical decomposition) convert different visually identical representations of the same abstract string into a single canonical form, with form C being more compact.  Normal forms KC and KD additionally canonicalize &quot;compatibility equivalents&quot;: they convert characters that are abstractly similar but visually distinct into a single canonical choice (e.g. they expand ligatures into the individual characters), with form KC being more compact.</p><p>Alternatively, finer control and additional transformations may be be obtained by calling <code>normalize_string(s; keywords...)</code>, where any number of the following boolean keywords options (which all default to <code>false</code> except for <code>compose</code>) are specified:</p><ul><li><p><code>compose=false</code>: do not perform canonical composition</p></li><li><p><code>decompose=true</code>: do canonical decomposition instead of canonical composition (<code>compose=true</code> is ignored if present)</p></li><li><p><code>compat=true</code>: compatibility equivalents are canonicalized</p></li><li><p><code>casefold=true</code>: perform Unicode case folding, e.g. for case-insensitive string comparison</p></li><li><p><code>newline2lf=true</code>, <code>newline2ls=true</code>, or <code>newline2ps=true</code>: convert various newline sequences (LF, CRLF, CR, NEL) into a linefeed (LF), line-separation (LS), or paragraph-separation (PS) character, respectively</p></li><li><p><code>stripmark=true</code>: strip diacritical marks (e.g. accents)</p></li><li><p><code>stripignore=true</code>: strip Unicode&#39;s &quot;default ignorable&quot; characters (e.g. the soft hyphen or the left-to-right marker)</p></li><li><p><code>stripcc=true</code>: strip control characters; horizontal tabs and form feeds are converted to spaces; newlines are also converted to spaces unless a newline-conversion flag was specified</p></li><li><p><code>rejectna=true</code>: throw an error if unassigned code points are found</p></li><li><p><code>stable=true</code>: enforce Unicode Versioning Stability</p></li></ul><p>For example, NFKC corresponds to the options <code>compose=true, compat=true, stable=true</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/6eaec18eb79593468d7ca93bb6164335fd0687e4/base/strings/utf8proc.jl#L141-L174">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.UTF8proc.graphemes" href="#Base.UTF8proc.graphemes"><code>Base.UTF8proc.graphemes</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">graphemes(s::AbstractString) -&gt; GraphemeIterator</code></pre><p>Returns an iterator over substrings of <code>s</code> that correspond to the extended graphemes in the string, as defined by Unicode UAX #29. (Roughly, these are what users would perceive as single characters, even though they may contain more than one codepoint; for example a letter combined with an accent mark is a single grapheme.)</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/6eaec18eb79593468d7ca93bb6164335fd0687e4/base/strings/utf8proc.jl#L358-L365">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isvalid-Tuple{Any}" href="#Base.isvalid-Tuple{Any}"><code>Base.isvalid</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">isvalid(value) -&gt; Bool</code></pre><p>Returns <code>true</code> if the given value is valid for its type, which currently can be either <code>Char</code> or <code>String</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/6eaec18eb79593468d7ca93bb6164335fd0687e4/base/docs/helpdb/Base.jl#L2236-L2241">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isvalid-Tuple{Any,Any}" href="#Base.isvalid-Tuple{Any,Any}"><code>Base.isvalid</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">isvalid(T, value) -&gt; Bool</code></pre><p>Returns <code>true</code> if the given value is valid for that type. Types currently can be either <code>Char</code> or <code>String</code>. Values for <code>Char</code> can be of type <code>Char</code> or <code>UInt32</code>. Values for <code>String</code> can be of that type, or <code>Vector{UInt8}</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/6eaec18eb79593468d7ca93bb6164335fd0687e4/base/docs/helpdb/Base.jl#L2244-L2250">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isvalid-Tuple{AbstractString,Integer}" href="#Base.isvalid-Tuple{AbstractString,Integer}"><code>Base.isvalid</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">isvalid(str::AbstractString, i::Integer)</code></pre><p>Tells whether index <code>i</code> is valid for the given string.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/6eaec18eb79593468d7ca93bb6164335fd0687e4/base/strings/basic.jl#L170-L174">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.UTF8proc.is_assigned_char" href="#Base.UTF8proc.is_assigned_char"><code>Base.UTF8proc.is_assigned_char</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">is_assigned_char(c) -&gt; Bool</code></pre><p>Returns <code>true</code> if the given char or integer is an assigned Unicode code point.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/6eaec18eb79593468d7ca93bb6164335fd0687e4/base/strings/utf8proc.jl#L207-L211">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.ismatch" href="#Base.ismatch"><code>Base.ismatch</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">ismatch(r::Regex, s::AbstractString) -&gt; Bool</code></pre><p>Test whether a string contains a match of the given regular expression.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/6eaec18eb79593468d7ca93bb6164335fd0687e4/base/docs/helpdb/Base.jl#L1787-L1791">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.match" href="#Base.match"><code>Base.match</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">match(r::Regex, s::AbstractString[, idx::Integer[, addopts]])</code></pre><p>Search for the first match of the regular expression <code>r</code> in <code>s</code> and return a <code>RegexMatch</code> object containing the match, or nothing if the match failed. The matching substring can be retrieved by accessing <code>m.match</code> and the captured sequences can be retrieved by accessing <code>m.captures</code> The optional <code>idx</code> argument specifies an index at which to start the search.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/6eaec18eb79593468d7ca93bb6164335fd0687e4/base/docs/helpdb/Base.jl#L1941-L1948">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.eachmatch" href="#Base.eachmatch"><code>Base.eachmatch</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">eachmatch(r::Regex, s::AbstractString[, overlap::Bool=false])</code></pre><p>Search for all matches of a the regular expression <code>r</code> in <code>s</code> and return a iterator over the matches. If overlap is <code>true</code>, the matching sequences are allowed to overlap indices in the original string, otherwise they must be from distinct character ranges.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/6eaec18eb79593468d7ca93bb6164335fd0687e4/base/docs/helpdb/Base.jl#L602-L608">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.matchall" href="#Base.matchall"><code>Base.matchall</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">matchall(r::Regex, s::AbstractString[, overlap::Bool=false]) -&gt; Vector{AbstractString}</code></pre><p>Return a vector of the matching substrings from <a href="strings.html#Base.eachmatch"><code>eachmatch</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/6eaec18eb79593468d7ca93bb6164335fd0687e4/base/docs/helpdb/Base.jl#L1794-L1798">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.lpad" href="#Base.lpad"><code>Base.lpad</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">lpad(s, n::Integer, p::AbstractString=&quot; &quot;)</code></pre><p>Make a string at least <code>n</code> columns wide when printed by padding <code>s</code> on the left with copies of <code>p</code>.</p><pre><code class="language-julia">julia&gt; lpad(&quot;March&quot;,10)
&quot;     March&quot;</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/6eaec18eb79593468d7ca93bb6164335fd0687e4/base/strings/util.jl#L200-L210">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.rpad" href="#Base.rpad"><code>Base.rpad</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">rpad(s, n::Integer, p::AbstractString=&quot; &quot;)</code></pre><p>Make a string at least <code>n</code> columns wide when printed by padding <code>s</code> on the right with copies of <code>p</code>.</p><pre><code class="language-julia">julia&gt; rpad(&quot;March&quot;,20)
&quot;March               &quot;</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/6eaec18eb79593468d7ca93bb6164335fd0687e4/base/strings/util.jl#L213-L223">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.search" href="#Base.search"><code>Base.search</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">search(string::AbstractString, chars::Chars, [start::Integer])</code></pre><p>Search for the first occurrence of the given characters within the given string. The second argument may be a single character, a vector or a set of characters, a string, or a regular expression (though regular expressions are only allowed on contiguous strings, such as ASCII or UTF-8 strings). The third argument optionally specifies a starting index. The return value is a range of indexes where the matching sequence is found, such that <code>s[search(s,x)] == x</code>:</p><p><code>search(string, &quot;substring&quot;)</code> = <code>start:end</code> such that <code>string[start:end] == &quot;substring&quot;</code>, or <code>0:-1</code> if unmatched.</p><p><code>search(string, &#39;c&#39;)</code> = <code>index</code> such that <code>string[index] == &#39;c&#39;</code>, or <code>0</code> if unmatched.</p><pre><code class="language-julia">julia&gt; search(&quot;Hello to the world&quot;, &quot;z&quot;)
0:-1

julia&gt; search(&quot;JuliaLang&quot;,&quot;Julia&quot;)
1:5</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/6eaec18eb79593468d7ca93bb6164335fd0687e4/base/strings/search.jl#L3-L24">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.rsearch" href="#Base.rsearch"><code>Base.rsearch</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">rsearch(s::AbstractString, chars::Chars, [start::Integer])</code></pre><p>Similar to <a href="strings.html#Base.search"><code>search</code></a>, but returning the last occurrence of the given characters within the given string, searching in reverse from <code>start</code>.</p><pre><code class="language-julia">julia&gt; rsearch(&quot;aaabbb&quot;,&quot;b&quot;)
6:6</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/6eaec18eb79593468d7ca93bb6164335fd0687e4/base/strings/search.jl#L189-L199">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.searchindex" href="#Base.searchindex"><code>Base.searchindex</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">searchindex(s::AbstractString, substring, [start::Integer])</code></pre><p>Similar to <a href="strings.html#Base.search"><code>search</code></a>, but return only the start index at which the substring is found, or <code>0</code> if it is not.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/6eaec18eb79593468d7ca93bb6164335fd0687e4/base/strings/search.jl#L144-L149">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.rsearchindex" href="#Base.rsearchindex"><code>Base.rsearchindex</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">rsearchindex(s::AbstractString, substring, [start::Integer])</code></pre><p>Similar to <a href="strings.html#Base.rsearch"><code>rsearch</code></a>, but return only the start index at which the substring is found, or <code>0</code> if it is not.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/6eaec18eb79593468d7ca93bb6164335fd0687e4/base/strings/search.jl#L304-L308">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.contains" href="#Base.contains"><code>Base.contains</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">contains(haystack::AbstractString, needle::AbstractString)</code></pre><p>Determine whether the second argument is a substring of the first.</p><pre><code class="language-julia">julia&gt; contains(&quot;JuliaLang is pretty cool!&quot;, &quot;Julia&quot;)
true</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/6eaec18eb79593468d7ca93bb6164335fd0687e4/base/strings/search.jl#L356-L365">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.reverse-Tuple{AbstractString}" href="#Base.reverse-Tuple{AbstractString}"><code>Base.reverse</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">reverse(s::AbstractString) -&gt; AbstractString</code></pre><p>Reverses a string.</p><pre><code class="language-julia">julia&gt; reverse(&quot;JuliaLang&quot;)
&quot;gnaLailuJ&quot;</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/6eaec18eb79593468d7ca93bb6164335fd0687e4/base/strings/types.jl#L116-L124">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.replace" href="#Base.replace"><code>Base.replace</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">replace(string::AbstractString, pat, r[, n::Integer=0])</code></pre><p>Search for the given pattern <code>pat</code>, and replace each occurrence with <code>r</code>. If <code>n</code> is provided, replace at most <code>n</code> occurrences. As with search, the second argument may be a single character, a vector or a set of characters, a string, or a regular expression. If <code>r</code> is a function, each occurrence is replaced with <code>r(s)</code> where <code>s</code> is the matched substring. If <code>pat</code> is a regular expression and <code>r</code> is a <code>SubstitutionString</code>, then capture group references in <code>r</code> are replaced with the corresponding matched text.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/6eaec18eb79593468d7ca93bb6164335fd0687e4/base/strings/util.jl#L364-L373">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.split" href="#Base.split"><code>Base.split</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">split(s::AbstractString, [chars]; limit::Integer=0, keep::Bool=true)</code></pre><p>Return an array of substrings by splitting the given string on occurrences of the given character delimiters, which may be specified in any of the formats allowed by <code>search</code>&#39;s second argument (i.e. a single character, collection of characters, string, or regular expression). If <code>chars</code> is omitted, it defaults to the set of all space characters, and <code>keep</code> is taken to be <code>false</code>. The two keyword arguments are optional: they are a maximum size for the result and a flag determining whether empty fields should be kept in the result.</p><pre><code class="language-julia">julia&gt; a = &quot;Ma.rch&quot;
&quot;Ma.rch&quot;

julia&gt; split(a,&quot;.&quot;)
2-element Array{SubString{String},1}:
 &quot;Ma&quot;
 &quot;rch&quot;</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/6eaec18eb79593468d7ca93bb6164335fd0687e4/base/strings/util.jl#L231-L251">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.rsplit" href="#Base.rsplit"><code>Base.rsplit</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">rsplit(s::AbstractString, [chars]; limit::Integer=0, keep::Bool=true)</code></pre><p>Similar to <a href="strings.html#Base.split"><code>split</code></a>, but starting from the end of the string.</p><pre><code class="language-julia">julia&gt; a = &quot;M.a.r.c.h&quot;
&quot;M.a.r.c.h&quot;

julia&gt; rsplit(a,&quot;.&quot;)
5-element Array{SubString{String},1}:
 &quot;M&quot;
 &quot;a&quot;
 &quot;r&quot;
 &quot;c&quot;
 &quot;h&quot;

julia&gt; rsplit(a,&quot;.&quot;;limit=1)
1-element Array{SubString{String},1}:
 &quot;M.a.r.c.h&quot;

julia&gt; rsplit(a,&quot;.&quot;;limit=2)
2-element Array{SubString{String},1}:
 &quot;M.a.r.c&quot;
 &quot;h&quot;</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/6eaec18eb79593468d7ca93bb6164335fd0687e4/base/strings/util.jl#L280-L306">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.strip" href="#Base.strip"><code>Base.strip</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">strip(s::AbstractString, [chars::Chars])</code></pre><p>Return <code>s</code> with any leading and trailing whitespace removed. If <code>chars</code> (a character, or vector or set of characters) is provided, instead remove characters contained in it.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/6eaec18eb79593468d7ca93bb6164335fd0687e4/base/strings/util.jl#L162-L168">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.lstrip" href="#Base.lstrip"><code>Base.lstrip</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">lstrip(s::AbstractString[, chars::Chars])</code></pre><p>Return <code>s</code> with any leading whitespace and delimiters removed. The default delimiters to remove are <code>&#39; &#39;</code>, <code>\t</code>, <code>\n</code>, <code>\v</code>, <code>\f</code>, and <code>\r</code>. If <code>chars</code> (a character, or vector or set of characters) is provided, instead remove characters contained in it.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/6eaec18eb79593468d7ca93bb6164335fd0687e4/base/strings/util.jl#L111-L119">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.rstrip" href="#Base.rstrip"><code>Base.rstrip</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">rstrip(s::AbstractString[, chars::Chars])</code></pre><p>Return <code>s</code> with any trailing whitespace and delimiters removed. The default delimiters to remove are <code>&#39; &#39;</code>, <code>\t</code>, <code>\n</code>, <code>\v</code>, <code>\f</code>, and <code>\r</code>. If <code>chars</code> (a character, or vector or set of characters) is provided, instead remove characters contained in it.</p><pre><code class="language-julia">julia&gt; a = rpad(&quot;March&quot;,20)
&quot;March               &quot;

julia&gt; rstrip(a)
&quot;March&quot;</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/6eaec18eb79593468d7ca93bb6164335fd0687e4/base/strings/util.jl#L132-L148">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.startswith" href="#Base.startswith"><code>Base.startswith</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">startswith(s::AbstractString, prefix::AbstractString)</code></pre><p>Returns <code>true</code> if <code>s</code> starts with <code>prefix</code>. If <code>prefix</code> is a vector or set of characters, tests whether the first character of <code>s</code> belongs to that set.</p><pre><code class="language-julia">julia&gt; startswith(&quot;JuliaLang&quot;, &quot;Julia&quot;)
true</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/6eaec18eb79593468d7ca93bb6164335fd0687e4/base/strings/util.jl#L5-L15">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.endswith" href="#Base.endswith"><code>Base.endswith</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">endswith(s::AbstractString, suffix::AbstractString)</code></pre><p>Returns <code>true</code> if <code>s</code> ends with <code>suffix</code>. If <code>suffix</code> is a vector or set of characters, tests whether the last character of <code>s</code> belongs to that set.</p><pre><code class="language-julia">julia&gt; endswith(&quot;Sunday&quot;, &quot;day&quot;)
true</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/6eaec18eb79593468d7ca93bb6164335fd0687e4/base/strings/util.jl#L28-L38">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.uppercase" href="#Base.uppercase"><code>Base.uppercase</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">uppercase(s::AbstractString)</code></pre><p>Returns <code>s</code> with all characters converted to uppercase.</p><pre><code class="language-julia">julia&gt; uppercase(&quot;Julia&quot;)
&quot;JULIA&quot;</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/6eaec18eb79593468d7ca93bb6164335fd0687e4/base/strings/basic.jl#L383-L392">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.lowercase" href="#Base.lowercase"><code>Base.lowercase</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">lowercase(s::AbstractString)</code></pre><p>Returns <code>s</code> with all characters converted to lowercase.</p><pre><code class="language-julia">julia&gt; lowercase(&quot;STRINGS AND THINGS&quot;)
&quot;strings and things&quot;</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/6eaec18eb79593468d7ca93bb6164335fd0687e4/base/strings/basic.jl#L395-L404">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.titlecase" href="#Base.titlecase"><code>Base.titlecase</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">titlecase(s::AbstractString)</code></pre><p>Capitalizes the first character of each word in <code>s</code>.</p><pre><code class="language-julia">julia&gt; titlecase(&quot;the julia programming language&quot;)
&quot;The Julia Programming Language&quot;</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/6eaec18eb79593468d7ca93bb6164335fd0687e4/base/strings/basic.jl#L407-L416">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.ucfirst" href="#Base.ucfirst"><code>Base.ucfirst</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">ucfirst(s::AbstractString)</code></pre><p>Returns <code>string</code> with the first character converted to uppercase.</p><pre><code class="language-julia">julia&gt; ucfirst(&quot;python&quot;)
&quot;Python&quot;</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/6eaec18eb79593468d7ca93bb6164335fd0687e4/base/strings/basic.jl#L432-L441">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.lcfirst" href="#Base.lcfirst"><code>Base.lcfirst</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">lcfirst(s::AbstractString)</code></pre><p>Returns <code>string</code> with the first character converted to lowercase.</p><pre><code class="language-julia">julia&gt; lcfirst(&quot;Julia&quot;)
&quot;julia&quot;</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/6eaec18eb79593468d7ca93bb6164335fd0687e4/base/strings/basic.jl#L446-L455">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.join" href="#Base.join"><code>Base.join</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">join(io::IO, strings, delim, [last])</code></pre><p>Join an array of <code>strings</code> into a single string, inserting the given delimiter between adjacent strings. If <code>last</code> is given, it will be used instead of <code>delim</code> between the last two strings. For example,</p><pre><code class="language-julia">julia&gt; join([&quot;apples&quot;, &quot;bananas&quot;, &quot;pineapples&quot;], &quot;, &quot;, &quot; and &quot;)
&quot;apples, bananas and pineapples&quot;</code></pre><p><code>strings</code> can be any iterable over elements <code>x</code> which are convertible to strings via <code>print(io::IOBuffer, x)</code>. <code>strings</code> will be printed to <code>io</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/6eaec18eb79593468d7ca93bb6164335fd0687e4/base/strings/io.jl#L144-L158">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.chop" href="#Base.chop"><code>Base.chop</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">chop(s::AbstractString)</code></pre><p>Remove the last character from <code>s</code>.</p><pre><code class="language-julia">julia&gt; a = &quot;March&quot;
&quot;March&quot;

julia&gt; chop(a)
&quot;Marc&quot;</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/6eaec18eb79593468d7ca93bb6164335fd0687e4/base/strings/util.jl#L61-L73">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.chomp" href="#Base.chomp"><code>Base.chomp</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">chomp(s::AbstractString)</code></pre><p>Remove a single trailing newline from a string.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/6eaec18eb79593468d7ca93bb6164335fd0687e4/base/strings/util.jl#L76-L80">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.ind2chr" href="#Base.ind2chr"><code>Base.ind2chr</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">ind2chr(s::AbstractString, i::Integer)</code></pre><p>Convert a byte index <code>i</code> to a character index with respect to string <code>s</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/6eaec18eb79593468d7ca93bb6164335fd0687e4/base/strings/basic.jl#L272-L277">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.chr2ind" href="#Base.chr2ind"><code>Base.chr2ind</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">chr2ind(s::AbstractString, i::Integer)</code></pre><p>Convert a character index <code>i</code> to a byte index.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/6eaec18eb79593468d7ca93bb6164335fd0687e4/base/strings/basic.jl#L292-L296">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.nextind" href="#Base.nextind"><code>Base.nextind</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">nextind(str::AbstractString, i::Integer)</code></pre><p>Get the next valid string index after <code>i</code>. Returns a value greater than <code>endof(str)</code> at or after the end of the string.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/6eaec18eb79593468d7ca93bb6164335fd0687e4/base/strings/basic.jl#L240-L245">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.prevind" href="#Base.prevind"><code>Base.prevind</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">prevind(str::AbstractString, i::Integer)</code></pre><p>Get the previous valid string index before <code>i</code>. Returns a value less than <code>1</code> at the beginning of the string.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/6eaec18eb79593468d7ca93bb6164335fd0687e4/base/strings/basic.jl#L219-L224">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Random.randstring" href="#Base.Random.randstring"><code>Base.Random.randstring</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">randstring([rng,] len=8)</code></pre><p>Create a random ASCII string of length <code>len</code>, consisting of upper- and lower-case letters and the digits 0-9. The optional <code>rng</code> argument specifies a random number generator, see <a href="numbers.html#Random-Numbers-1">Random Numbers</a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/6eaec18eb79593468d7ca93bb6164335fd0687e4/base/docs/helpdb/Base.jl#L848-L854">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.UTF8proc.charwidth" href="#Base.UTF8proc.charwidth"><code>Base.UTF8proc.charwidth</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">charwidth(c)</code></pre><p>Gives the number of columns needed to print a character.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/6eaec18eb79593468d7ca93bb6164335fd0687e4/base/strings/utf8proc.jl#L187-L191">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.strwidth" href="#Base.strwidth"><code>Base.strwidth</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">strwidth(s::AbstractString)</code></pre><p>Gives the number of columns needed to print a string.</p><pre><code class="language-julia">julia&gt; strwidth(&quot;March&quot;)
5</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/6eaec18eb79593468d7ca93bb6164335fd0687e4/base/strings/basic.jl#L328-L337">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.UTF8proc.isalnum" href="#Base.UTF8proc.isalnum"><code>Base.UTF8proc.isalnum</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">isalnum(c::Union{Char,AbstractString}) -&gt; Bool</code></pre><p>Tests whether a character is alphanumeric, or whether this is true for all elements of a string. A character is classified as alphabetic if it belongs to the Unicode general category Letter or Number, i.e. a character whose category code begins with &#39;L&#39; or &#39;N&#39;.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/6eaec18eb79593468d7ca93bb6164335fd0687e4/base/strings/utf8proc.jl#L265-L271">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.UTF8proc.isalpha" href="#Base.UTF8proc.isalpha"><code>Base.UTF8proc.isalpha</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">isalpha(c::Union{Char,AbstractString}) -&gt; Bool</code></pre><p>Tests whether a character is alphabetic, or whether this is true for all elements of a string. A character is classified as alphabetic if it belongs to the Unicode general category Letter, i.e. a character whose category code begins with &#39;L&#39;.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/6eaec18eb79593468d7ca93bb6164335fd0687e4/base/strings/utf8proc.jl#L247-L253">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isascii" href="#Base.isascii"><code>Base.isascii</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">isascii(c::Union{Char,AbstractString}) -&gt; Bool</code></pre><p>Tests whether a character belongs to the ASCII character set, or whether this is true for all elements of a string.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/6eaec18eb79593468d7ca93bb6164335fd0687e4/base/strings/basic.jl#L340-L345">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.UTF8proc.iscntrl" href="#Base.UTF8proc.iscntrl"><code>Base.UTF8proc.iscntrl</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">iscntrl(c::Union{Char,AbstractString}) -&gt; Bool</code></pre><p>Tests whether a character is a control character, or whether this is true for all elements of a string. Control characters are the non-printing characters of the Latin-1 subset of Unicode.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/6eaec18eb79593468d7ca93bb6164335fd0687e4/base/strings/utf8proc.jl#L280-L285">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.UTF8proc.isdigit" href="#Base.UTF8proc.isdigit"><code>Base.UTF8proc.isdigit</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">isdigit(c::Union{Char,AbstractString}) -&gt; Bool</code></pre><p>Tests whether a character is a numeric digit (0-9), or whether this is true for all elements of a string.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/6eaec18eb79593468d7ca93bb6164335fd0687e4/base/strings/utf8proc.jl#L239-L244">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.UTF8proc.isgraph" href="#Base.UTF8proc.isgraph"><code>Base.UTF8proc.isgraph</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">isgraph(c::Union{Char,AbstractString}) -&gt; Bool</code></pre><p>Tests whether a character is printable, and not a space, or whether this is true for all elements of a string. Any character that would cause a printer to use ink should be classified with <code>isgraph(c)==true</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/6eaec18eb79593468d7ca93bb6164335fd0687e4/base/strings/utf8proc.jl#L318-L324">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.UTF8proc.islower" href="#Base.UTF8proc.islower"><code>Base.UTF8proc.islower</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">islower(c::Union{Char,AbstractString}) -&gt; Bool</code></pre><p>Tests whether a character is a lowercase letter, or whether this is true for all elements of a string. A character is classified as lowercase if it belongs to Unicode category Ll, Letter: Lowercase.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/6eaec18eb79593468d7ca93bb6164335fd0687e4/base/strings/utf8proc.jl#L216-L222">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.UTF8proc.isnumber" href="#Base.UTF8proc.isnumber"><code>Base.UTF8proc.isnumber</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">isnumber(c::Union{Char,AbstractString}) -&gt; Bool</code></pre><p>Tests whether a character is numeric, or whether this is true for all elements of a string. A character is classified as numeric if it belongs to the Unicode general category Number, i.e. a character whose category code begins with &#39;N&#39;.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/6eaec18eb79593468d7ca93bb6164335fd0687e4/base/strings/utf8proc.jl#L256-L262">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.UTF8proc.isprint" href="#Base.UTF8proc.isprint"><code>Base.UTF8proc.isprint</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">isprint(c::Union{Char,AbstractString}) -&gt; Bool</code></pre><p>Tests whether a character is printable, including spaces, but not a control character. For strings, tests whether this is true for all elements of the string.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/6eaec18eb79593468d7ca93bb6164335fd0687e4/base/strings/utf8proc.jl#L308-L313">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.UTF8proc.ispunct" href="#Base.UTF8proc.ispunct"><code>Base.UTF8proc.ispunct</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">ispunct(c::Union{Char,AbstractString}) -&gt; Bool</code></pre><p>Tests whether a character belongs to the Unicode general category Punctuation, i.e. a character whose category code begins with &#39;P&#39;. For strings, tests whether this is true for all elements of the string.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/6eaec18eb79593468d7ca93bb6164335fd0687e4/base/strings/utf8proc.jl#L288-L294">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.UTF8proc.isspace" href="#Base.UTF8proc.isspace"><code>Base.UTF8proc.isspace</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">isspace(c::Union{Char,AbstractString}) -&gt; Bool</code></pre><p>Tests whether a character is any whitespace character. Includes ASCII characters &#39;\t&#39;, &#39;\n&#39;, &#39;\v&#39;, &#39;\f&#39;, &#39;\r&#39;, and &#39; &#39;, Latin-1 character U+0085, and characters in Unicode category Zs. For strings, tests whether this is true for all elements of the string.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/6eaec18eb79593468d7ca93bb6164335fd0687e4/base/strings/utf8proc.jl#L299-L305">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.UTF8proc.isupper" href="#Base.UTF8proc.isupper"><code>Base.UTF8proc.isupper</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">isupper(c::Union{Char,AbstractString}) -&gt; Bool</code></pre><p>Tests whether a character is an uppercase letter, or whether this is true for all elements of a string. A character is classified as uppercase if it belongs to Unicode category Lu, Letter: Uppercase, or Lt, Letter: Titlecase.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/6eaec18eb79593468d7ca93bb6164335fd0687e4/base/strings/utf8proc.jl#L227-L233">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isxdigit" href="#Base.isxdigit"><code>Base.isxdigit</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">isxdigit(c::Union{Char,AbstractString}) -&gt; Bool</code></pre><p>Tests whether a character is a valid hexadecimal digit, or whether this is true for all elements of a string.</p><pre><code class="language-julia">julia&gt; isxdigit(&quot;abc&quot;)
true

julia&gt; isxdigit(&quot;0x9&quot;)
false</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/6eaec18eb79593468d7ca93bb6164335fd0687e4/base/strings/basic.jl#L353-L365">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Core.Symbol" href="#Core.Symbol"><code>Core.Symbol</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Symbol(x...) -&gt; Symbol</code></pre><p>Create a <code>Symbol</code> by concatenating the string representations of the arguments together.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/6eaec18eb79593468d7ca93bb6164335fd0687e4/base/docs/helpdb/Base.jl#L2229-L2233">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.escape_string" href="#Base.escape_string"><code>Base.escape_string</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">escape_string([io,] str::AbstractString[, esc::AbstractString]) -&gt; AbstractString</code></pre><p>General escaping of traditional C and Unicode escape sequences. Any characters in <code>esc</code> are also escaped (with a backslash). See also <a href="strings.html#Base.unescape_string"><code>unescape_string</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/6eaec18eb79593468d7ca93bb6164335fd0687e4/base/strings/io.jl#L197-L203">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.unescape_string" href="#Base.unescape_string"><code>Base.unescape_string</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">unescape_string([io,] s::AbstractString) -&gt; AbstractString</code></pre><p>General unescaping of traditional C and Unicode escape sequences. Reverse of <a href="strings.html#Base.escape_string"><code>escape_string</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/6eaec18eb79593468d7ca93bb6164335fd0687e4/base/strings/io.jl#L250-L255">source</a><br/></section><footer><hr/><a class="previous" href="numbers.html"><span class="direction">Previous</span><span class="title">Numbers</span></a><a class="next" href="arrays.html"><span class="direction">Next</span><span class="title">Arrays</span></a></footer></article></body></html>
