

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Frequently Asked Questions &mdash; Julia Language 0.3.13-pre documentation</title>
  

  
  

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/julia.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../../_static/julia.css" type="text/css" />
  
    <link rel="top" title="Julia Language 0.3.13-pre documentation" href="../../"/>
        <link rel="next" title="Noteworthy Differences from other Languages" href="../noteworthy-differences/"/>
        <link rel="prev" title="Style Guide" href="../style-guide/"/> 

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        <a href="http://julialang.org/"><img src="../../_static/julia-logo.svg" class="logo"></a>
        <!--
        <a href="../../" class="fa fa-home"> Julia Language</a>
        -->
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search/" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
        
            <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../introduction/">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../getting-started/">Getting Started</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../getting-started/#resources">Resources</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../variables/">Variables</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../variables/#allowed-variable-names">Allowed Variable Names</a></li>
<li class="toctree-l2"><a class="reference internal" href="../variables/#stylistic-conventions">Stylistic Conventions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../integers-and-floating-point-numbers/">Integers and Floating-Point Numbers</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../integers-and-floating-point-numbers/#integers">Integers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../integers-and-floating-point-numbers/#floating-point-numbers">Floating-Point Numbers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../integers-and-floating-point-numbers/#arbitrary-precision-arithmetic">Arbitrary Precision Arithmetic</a></li>
<li class="toctree-l2"><a class="reference internal" href="../integers-and-floating-point-numbers/#numeric-literal-coefficients">Numeric Literal Coefficients</a></li>
<li class="toctree-l2"><a class="reference internal" href="../integers-and-floating-point-numbers/#literal-zero-and-one">Literal zero and one</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../mathematical-operations/">Mathematical Operations and Elementary Functions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../mathematical-operations/#arithmetic-operators">Arithmetic Operators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical-operations/#bitwise-operators">Bitwise Operators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical-operations/#updating-operators">Updating operators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical-operations/#numeric-comparisons">Numeric Comparisons</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical-operations/#elementary-functions">Elementary Functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../complex-and-rational-numbers/">Complex and Rational Numbers</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../complex-and-rational-numbers/#complex-numbers">Complex Numbers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../complex-and-rational-numbers/#rational-numbers">Rational Numbers</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../strings/">Strings</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../strings/#characters">Characters</a></li>
<li class="toctree-l2"><a class="reference internal" href="../strings/#string-basics"><tt class="docutils literal"><span class="pre">String</span></tt> Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../strings/#unicode-and-utf-8">Unicode and UTF-8</a></li>
<li class="toctree-l2"><a class="reference internal" href="../strings/#interpolation">Interpolation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../strings/#common-operations">Common Operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../strings/#non-standard-string-literals">Non-Standard String Literals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../strings/#regular-expressions">Regular Expressions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../strings/#id3">Byte Array Literals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../strings/#version-number-literals">Version Number Literals</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../functions/">Functions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../functions/#argument-passing-behavior">Argument Passing Behavior</a></li>
<li class="toctree-l2"><a class="reference internal" href="../functions/#the-return-keyword">The <tt class="docutils literal"><span class="pre">return</span></tt> Keyword</a></li>
<li class="toctree-l2"><a class="reference internal" href="../functions/#id1">Operators Are Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../functions/#operators-with-special-names">Operators With Special Names</a></li>
<li class="toctree-l2"><a class="reference internal" href="../functions/#anonymous-functions">Anonymous Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../functions/#multiple-return-values">Multiple Return Values</a></li>
<li class="toctree-l2"><a class="reference internal" href="../functions/#varargs-functions">Varargs Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../functions/#optional-arguments">Optional Arguments</a></li>
<li class="toctree-l2"><a class="reference internal" href="../functions/#keyword-arguments">Keyword Arguments</a></li>
<li class="toctree-l2"><a class="reference internal" href="../functions/#evaluation-scope-of-default-values">Evaluation Scope of Default Values</a></li>
<li class="toctree-l2"><a class="reference internal" href="../functions/#do-block-syntax-for-function-arguments">Do-Block Syntax for Function Arguments</a></li>
<li class="toctree-l2"><a class="reference internal" href="../functions/#further-reading">Further Reading</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../control-flow/">Control Flow</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../control-flow/#compound-expressions">Compound Expressions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../control-flow/#conditional-evaluation">Conditional Evaluation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../control-flow/#short-circuit-evaluation">Short-Circuit Evaluation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../control-flow/#repeated-evaluation-loops">Repeated Evaluation: Loops</a></li>
<li class="toctree-l2"><a class="reference internal" href="../control-flow/#exception-handling">Exception Handling</a></li>
<li class="toctree-l2"><a class="reference internal" href="../control-flow/#tasks-aka-coroutines">Tasks (aka Coroutines)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../variables-and-scoping/">Scope of Variables</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../variables-and-scoping/#for-loops-and-comprehensions">For Loops and Comprehensions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../variables-and-scoping/#constants">Constants</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../types/">Types</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../types/#type-declarations">Type Declarations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../types/#abstract-types">Abstract Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../types/#bits-types">Bits Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../types/#composite-types">Composite Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../types/#immutable-composite-types">Immutable Composite Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../types/#declared-types">Declared Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../types/#tuple-types">Tuple Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../types/#type-unions">Type Unions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../types/#man-parametric-types">Parametric Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../types/#type-aliases">Type Aliases</a></li>
<li class="toctree-l2"><a class="reference internal" href="../types/#operations-on-types">Operations on Types</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../methods/">Methods</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../methods/#defining-methods">Defining Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="../methods/#method-ambiguities">Method Ambiguities</a></li>
<li class="toctree-l2"><a class="reference internal" href="../methods/#parametric-methods">Parametric Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="../methods/#note-on-optional-and-keyword-arguments">Note on Optional and keyword Arguments</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../constructors/">Constructors</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../constructors/#outer-constructor-methods">Outer Constructor Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="../constructors/#inner-constructor-methods">Inner Constructor Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="../constructors/#incomplete-initialization">Incomplete Initialization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../constructors/#parametric-constructors">Parametric Constructors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../constructors/#case-study-rational">Case Study: Rational</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../conversion-and-promotion/">Conversion and Promotion</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../conversion-and-promotion/#conversion">Conversion</a></li>
<li class="toctree-l2"><a class="reference internal" href="../conversion-and-promotion/#promotion">Promotion</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../modules/">Modules</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../modules/#summary-of-module-usage">Summary of module usage</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../metaprogramming/">Metaprogramming</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../metaprogramming/#program-representation">Program representation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../metaprogramming/#expressions-and-evaluation">Expressions and evaluation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../metaprogramming/#macros">Macros</a></li>
<li class="toctree-l2"><a class="reference internal" href="../metaprogramming/#code-generation">Code Generation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../metaprogramming/#non-standard-string-literals">Non-Standard String Literals</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../arrays/">Multi-dimensional Arrays</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../arrays/#arrays">Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="../arrays/#sparse-matrices">Sparse Matrices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../linear-algebra/">Linear algebra</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../linear-algebra/#matrix-factorizations">Matrix factorizations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../linear-algebra/#special-matrices">Special matrices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../networking-and-streams/">Networking and Streams</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../networking-and-streams/#basic-stream-i-o">Basic Stream I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../networking-and-streams/#text-i-o">Text I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../networking-and-streams/#working-with-files">Working with Files</a></li>
<li class="toctree-l2"><a class="reference internal" href="../networking-and-streams/#a-simple-tcp-example">A simple TCP example</a></li>
<li class="toctree-l2"><a class="reference internal" href="../networking-and-streams/#resolving-ip-addresses">Resolving IP Addresses</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../parallel-computing/">Parallel Computing</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../parallel-computing/#code-availability-and-loading-packages">Code Availability and Loading Packages</a></li>
<li class="toctree-l2"><a class="reference internal" href="../parallel-computing/#data-movement">Data Movement</a></li>
<li class="toctree-l2"><a class="reference internal" href="../parallel-computing/#parallel-map-and-loops">Parallel Map and Loops</a></li>
<li class="toctree-l2"><a class="reference internal" href="../parallel-computing/#synchronization-with-remote-references">Synchronization With Remote References</a></li>
<li class="toctree-l2"><a class="reference internal" href="../parallel-computing/#scheduling">Scheduling</a></li>
<li class="toctree-l2"><a class="reference internal" href="../parallel-computing/#distributed-arrays">Distributed Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="../parallel-computing/#constructing-distributed-arrays">Constructing Distributed Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="../parallel-computing/#distributed-array-operations">Distributed Array Operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../parallel-computing/#shared-arrays-experimental">Shared Arrays (Experimental)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../parallel-computing/#clustermanagers">ClusterManagers</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../running-external-programs/">Running External Programs</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../running-external-programs/#interpolation">Interpolation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../running-external-programs/#quoting">Quoting</a></li>
<li class="toctree-l2"><a class="reference internal" href="../running-external-programs/#pipelines">Pipelines</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../calling-c-and-fortran-code/">Calling C and Fortran Code</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../calling-c-and-fortran-code/#mapping-c-types-to-julia">Mapping C Types to Julia</a></li>
<li class="toctree-l2"><a class="reference internal" href="../calling-c-and-fortran-code/#accessing-data-through-a-pointer">Accessing Data through a Pointer</a></li>
<li class="toctree-l2"><a class="reference internal" href="../calling-c-and-fortran-code/#passing-pointers-for-modifying-inputs">Passing Pointers for Modifying Inputs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../calling-c-and-fortran-code/#garbage-collection-safety">Garbage Collection Safety</a></li>
<li class="toctree-l2"><a class="reference internal" href="../calling-c-and-fortran-code/#non-constant-function-specifications">Non-constant Function Specifications</a></li>
<li class="toctree-l2"><a class="reference internal" href="../calling-c-and-fortran-code/#indirect-calls">Indirect Calls</a></li>
<li class="toctree-l2"><a class="reference internal" href="../calling-c-and-fortran-code/#calling-convention">Calling Convention</a></li>
<li class="toctree-l2"><a class="reference internal" href="../calling-c-and-fortran-code/#accessing-global-variables">Accessing Global Variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="../calling-c-and-fortran-code/#passing-julia-callback-functions-to-c">Passing Julia Callback Functions to C</a></li>
<li class="toctree-l2"><a class="reference internal" href="../calling-c-and-fortran-code/#c">C++</a></li>
<li class="toctree-l2"><a class="reference internal" href="../calling-c-and-fortran-code/#handling-platform-variations">Handling Platform Variations</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../interacting-with-julia/">Interacting With Julia</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../interacting-with-julia/#the-different-prompt-modes">The different prompt modes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../interacting-with-julia/#key-bindings">Key bindings</a></li>
<li class="toctree-l2"><a class="reference internal" href="../interacting-with-julia/#tab-completion">Tab completion</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../embedding/">Embedding Julia</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../embedding/#high-level-embedding">High-Level Embedding</a></li>
<li class="toctree-l2"><a class="reference internal" href="../embedding/#converting-types">Converting Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../embedding/#calling-julia-functions">Calling Julia Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../embedding/#memory-management">Memory Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="../embedding/#working-with-arrays">Working with Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="../embedding/#exceptions">Exceptions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../packages/">Packages</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../packages/#package-status">Package Status</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/#adding-and-removing-packages">Adding and Removing Packages</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/#installing-unregistered-packages">Installing Unregistered Packages</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/#updating-packages">Updating Packages</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/#checkout-pin-and-free">Checkout, Pin and Free</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../packages/#package-development">Package Development</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../packages/#initial-setup">Initial Setup</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/#making-changes-to-an-existing-package">Making changes to an existing package</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/#creating-a-new-package">Creating a new Package</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/#tagging-package-versions">Tagging Package Versions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/#fixing-package-requirements">Fixing Package Requirements</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/#man-package-requirements">Requirements Specification</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../profile/">Profiling</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../profile/#basic-usage">Basic usage</a></li>
<li class="toctree-l2"><a class="reference internal" href="../profile/#accumulation-and-clearing">Accumulation and clearing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../profile/#options-for-controlling-the-display-of-profile-results">Options for controlling the display of profile results</a></li>
<li class="toctree-l2"><a class="reference internal" href="../profile/#configuration">Configuration</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../profile/#memory-allocation-analysis">Memory allocation analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../performance-tips/">Performance Tips</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../performance-tips/#avoid-global-variables">Avoid global variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="../performance-tips/#measure-performance-with-time-and-pay-attention-to-memory-allocation">Measure performance with <tt class="docutils literal"><span class="pre">&#64;time</span></tt> and pay attention to memory allocation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../performance-tips/#tools">Tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="../performance-tips/#avoid-containers-with-abstract-type-parameters">Avoid containers with abstract type parameters</a></li>
<li class="toctree-l2"><a class="reference internal" href="../performance-tips/#type-declarations">Type declarations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../performance-tips/#break-functions-into-multiple-definitions">Break functions into multiple definitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../performance-tips/#write-type-stable-functions">Write &#8220;type-stable&#8221; functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../performance-tips/#avoid-changing-the-type-of-a-variable">Avoid changing the type of a variable</a></li>
<li class="toctree-l2"><a class="reference internal" href="../performance-tips/#separate-kernel-functions">Separate kernel functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../performance-tips/#access-arrays-in-memory-order-along-columns">Access arrays in memory order, along columns</a></li>
<li class="toctree-l2"><a class="reference internal" href="../performance-tips/#pre-allocating-outputs">Pre-allocating outputs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../performance-tips/#avoid-string-interpolation-for-i-o">Avoid string interpolation for I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../performance-tips/#optimize-network-i-o-during-parallel-execution">Optimize network I/O during parallel execution</a></li>
<li class="toctree-l2"><a class="reference internal" href="../performance-tips/#fix-deprecation-warnings">Fix deprecation warnings</a></li>
<li class="toctree-l2"><a class="reference internal" href="../performance-tips/#tweaks">Tweaks</a></li>
<li class="toctree-l2"><a class="reference internal" href="../performance-tips/#performance-annotations">Performance Annotations</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../workflow-tips/">Workflow Tips</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../workflow-tips/#repl-based-workflow">REPL-based workflow</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflow-tips/#browser-based-workflow">Browser-based workflow</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../style-guide/">Style Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#write-functions-not-just-scripts">Write functions, not just scripts</a></li>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#avoid-writing-overly-specific-types">Avoid writing overly-specific types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#handle-excess-argument-diversity-in-the-caller">Handle excess argument diversity in the caller</a></li>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#append-to-names-of-functions-that-modify-their-arguments">Append <cite>!</cite> to names of functions that modify their arguments</a></li>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#avoid-strange-type-unions">Avoid strange type Unions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#try-to-avoid-nullable-fields">Try to avoid nullable fields</a></li>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#avoid-elaborate-container-types">Avoid elaborate container types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#use-naming-conventions-consistent-with-julia-s-base">Use naming conventions consistent with Julia&#8217;s <tt class="docutils literal"><span class="pre">base/</span></tt></a></li>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#don-t-overuse-try-catch">Don&#8217;t overuse try-catch</a></li>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#don-t-parenthesize-conditions">Don&#8217;t parenthesize conditions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#don-t-overuse">Don&#8217;t overuse ...</a></li>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#don-t-use-unnecessary-static-parameters">Don&#8217;t use unnecessary static parameters</a></li>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#avoid-confusion-about-whether-something-is-an-instance-or-a-type">Avoid confusion about whether something is an instance or a type</a></li>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#don-t-overuse-macros">Don&#8217;t overuse macros</a></li>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#don-t-expose-unsafe-operations-at-the-interface-level">Don&#8217;t expose unsafe operations at the interface level</a></li>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#don-t-overload-methods-of-base-container-types">Don&#8217;t overload methods of base container types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#be-careful-with-type-equality">Be careful with type equality</a></li>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#do-not-write-x-f-x">Do not write <tt class="docutils literal"><span class="pre">x-&gt;f(x)</span></tt></a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="current reference internal" href="">Frequently Asked Questions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#sessions-and-the-repl">Sessions and the REPL</a></li>
<li class="toctree-l2"><a class="reference internal" href="#functions">Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#types-type-declarations-and-constructors">Types, type declarations, and constructors</a></li>
<li class="toctree-l2"><a class="reference internal" href="#nothingness-and-missing-values">Nothingness and missing values</a></li>
<li class="toctree-l2"><a class="reference internal" href="#memory">Memory</a></li>
<li class="toctree-l2"><a class="reference internal" href="#julia-releases">Julia Releases</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../noteworthy-differences/">Noteworthy Differences from other Languages</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../noteworthy-differences/#noteworthy-differences-from-matlab">Noteworthy differences from MATLAB</a></li>
<li class="toctree-l2"><a class="reference internal" href="../noteworthy-differences/#noteworthy-differences-from-r">Noteworthy differences from R</a></li>
<li class="toctree-l2"><a class="reference internal" href="../noteworthy-differences/#noteworthy-differences-from-python">Noteworthy differences from Python</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../unicode-input/">Unicode Input</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/base/">Essentials</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/base/#introduction">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/base/#getting-around">Getting Around</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/base/#all-objects">All Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/base/#types">Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/base/#generic-functions">Generic Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/base/#syntax">Syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/base/#system">System</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/base/#errors">Errors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/base/#events">Events</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/base/#reflection">Reflection</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/base/#internals">Internals</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/collections/">Collections and Data Structures</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/collections/#iteration">Iteration</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/collections/#general-collections">General Collections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/collections/#iterable-collections">Iterable Collections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/collections/#indexable-collections">Indexable Collections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/collections/#associative-collections">Associative Collections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/collections/#set-like-collections">Set-Like Collections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/collections/#dequeues">Dequeues</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/collections/#priorityqueue">PriorityQueue</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/collections/#heap-functions">Heap Functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/math/">Mathematics</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/math/#mathematical-operators">Mathematical Operators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/math/#mathematical-functions">Mathematical Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/math/#statistics">Statistics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/math/#signal-processing">Signal Processing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/math/#numerical-integration">Numerical Integration</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/numbers/">Numbers</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/numbers/#standard-numeric-types">Standard Numeric Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/numbers/#data-formats">Data Formats</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/numbers/#id1">Numbers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/numbers/#bigfloats">BigFloats</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/numbers/#random-numbers">Random Numbers</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/strings/">Strings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/arrays/">Arrays</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/arrays/#basic-functions">Basic functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/arrays/#constructors">Constructors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/arrays/#mathematical-operators-and-functions">Mathematical operators and functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/arrays/#indexing-assignment-and-concatenation">Indexing, Assignment, and Concatenation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/arrays/#array-functions">Array functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/arrays/#combinatorics">Combinatorics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/arrays/#bitarrays">BitArrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/arrays/#sparse-matrices">Sparse Matrices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/parallel/">Tasks and Parallel Computing</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/parallel/#tasks">Tasks</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/parallel/#general-parallel-computing-support">General Parallel Computing Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/parallel/#distributed-arrays">Distributed Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/parallel/#shared-arrays-experimental-unix-only-feature">Shared Arrays (Experimental, UNIX-only feature)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/linalg/">Linear Algebra</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/linalg/#module-Base.LinAlg">Standard Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/linalg/#module-Base.LinAlg.BLAS">BLAS Functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/constants/">Constants</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/file/">Filesystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/io-network/">I/O and Network</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/io-network/#general-i-o">General I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/io-network/#network-i-o">Network I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/io-network/#text-i-o">Text I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/io-network/#multimedia-i-o">Multimedia I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/io-network/#memory-mapped-i-o">Memory-mapped I/O</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/punctuation/">Punctuation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/sort/">Sorting and Related Functions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/sort/#sorting-functions">Sorting Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/sort/#order-related-functions">Order-Related Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/sort/#sorting-algorithms">Sorting Algorithms</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/pkg/">Package Manager Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/collections/">Collections and Data Structures</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/collections/#iteration">Iteration</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/collections/#general-collections">General Collections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/collections/#iterable-collections">Iterable Collections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/collections/#indexable-collections">Indexable Collections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/collections/#associative-collections">Associative Collections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/collections/#set-like-collections">Set-Like Collections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/collections/#dequeues">Dequeues</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/collections/#priorityqueue">PriorityQueue</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/collections/#heap-functions">Heap Functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/graphics/">Graphics</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/graphics/#geometry">Geometry</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/test/">Unit and Functional Testing</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/test/#overview">Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/test/#handlers">Handlers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/test/#macros">Macros</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/test/#functions">Functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/test/#testing-base-julia">Testing Base Julia</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/c/">C Interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/profile/">Profiling</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../devdocs/reflection/">Reflection and introspection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../devdocs/julia/">Documentation of Julia&#8217;s Internals</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/cartesian/">Base.Cartesian</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/sysimg/">System Image Building</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../devdocs/C/">Developing/debugging Julia&#8217;s C code</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/backtraces/">Reporting and analyzing crashes (segfaults)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/debuggingtips/">gdb debugging tips</a></li>
</ul>
</li>
</ul>

        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../">Julia Language</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../">Docs</a> &raquo;</li>
      
    <li>Frequently Asked Questions</li>
      <li class="wy-breadcrumbs-aside">
        
          <a href="../../_sources/manual/faq.txt" rel="nofollow"> View page source</a>
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document">
            
  <div class="section" id="frequently-asked-questions">
<span id="man-faq"></span><h1>Frequently Asked Questions<a class="headerlink" href="#frequently-asked-questions" title="Permalink to this headline">¶</a></h1>
<div class="section" id="sessions-and-the-repl">
<h2>Sessions and the REPL<a class="headerlink" href="#sessions-and-the-repl" title="Permalink to this headline">¶</a></h2>
<div class="section" id="how-do-i-delete-an-object-in-memory">
<h3>How do I delete an object in memory?<a class="headerlink" href="#how-do-i-delete-an-object-in-memory" title="Permalink to this headline">¶</a></h3>
<p>Julia does not have an analog of MATLAB&#8217;s <tt class="docutils literal"><span class="pre">clear</span></tt> function; once a
name is defined in a Julia session (technically, in module <tt class="docutils literal"><span class="pre">Main</span></tt>),
it is always present.</p>
<p>If memory usage is your concern, you can always replace objects with
ones that consume less memory.  For example, if <tt class="docutils literal"><span class="pre">A</span></tt> is a
gigabyte-sized array that you no longer need, you can free the memory
with <tt class="docutils literal"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">0</span></tt>.  The memory will be released the next time the garbage
collector runs; you can force this to happen with <a class="reference internal" href="../../stdlib/base/#Base.gc" title="Base.gc"><tt class="xref jl jl-func docutils literal"><span class="pre">gc()</span></tt></a>.</p>
</div>
<div class="section" id="how-can-i-modify-the-declaration-of-a-type-immutable-in-my-session">
<h3>How can I modify the declaration of a type/immutable in my session?<a class="headerlink" href="#how-can-i-modify-the-declaration-of-a-type-immutable-in-my-session" title="Permalink to this headline">¶</a></h3>
<p>Perhaps you&#8217;ve defined a type and then realize you need to add a
new field.  If you try this at the REPL, you get the error:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">ERROR</span><span class="p">:</span> <span class="n">invalid</span> <span class="n">redefinition</span> <span class="n">of</span> <span class="n">constant</span> <span class="n">MyType</span>
</pre></div>
</div>
<p>Types in module <tt class="docutils literal"><span class="pre">Main</span></tt> cannot be redefined.</p>
<p>While this can be inconvenient when you are developing new code,
there&#8217;s an excellent workaround.  Modules can be replaced by
redefining them, and so if you wrap all your new code inside a module
you can redefine types and constants.  You can&#8217;t import the type names
into <tt class="docutils literal"><span class="pre">Main</span></tt> and then expect to be able to redefine them there, but
you can use the module name to resolve the scope.  In other words,
while developing you might use a workflow something like this:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">include</span><span class="p">(</span><span class="s">&quot;mynewcode.jl&quot;</span><span class="p">)</span>              <span class="c"># this defines a module MyModule</span>
<span class="n">obj1</span> <span class="o">=</span> <span class="n">MyModule</span><span class="o">.</span><span class="n">ObjConstructor</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="n">obj2</span> <span class="o">=</span> <span class="n">MyModule</span><span class="o">.</span><span class="n">somefunction</span><span class="p">(</span><span class="n">obj1</span><span class="p">)</span>
<span class="c"># Got an error. Change something in &quot;mynewcode.jl&quot;</span>
<span class="n">include</span><span class="p">(</span><span class="s">&quot;mynewcode.jl&quot;</span><span class="p">)</span>              <span class="c"># reload the module</span>
<span class="n">obj1</span> <span class="o">=</span> <span class="n">MyModule</span><span class="o">.</span><span class="n">ObjConstructor</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="c"># old objects are no longer valid, must reconstruct</span>
<span class="n">obj2</span> <span class="o">=</span> <span class="n">MyModule</span><span class="o">.</span><span class="n">somefunction</span><span class="p">(</span><span class="n">obj1</span><span class="p">)</span>   <span class="c"># this time it worked!</span>
<span class="n">obj3</span> <span class="o">=</span> <span class="n">MyModule</span><span class="o">.</span><span class="n">someotherfunction</span><span class="p">(</span><span class="n">obj2</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
<span class="o">...</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="functions">
<h2>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h2>
<div class="section" id="i-passed-an-argument-x-to-a-function-modified-it-inside-that-function-but-on-the-outside-the-variable-x-is-still-unchanged-why">
<h3>I passed an argument <tt class="docutils literal"><span class="pre">x</span></tt> to a function, modified it inside that function, but on the outside, the variable <tt class="docutils literal"><span class="pre">x</span></tt> is still unchanged. Why?<a class="headerlink" href="#i-passed-an-argument-x-to-a-function-modified-it-inside-that-function-but-on-the-outside-the-variable-x-is-still-unchanged-why" title="Permalink to this headline">¶</a></h3>
<p>Suppose you call a function like this:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">julia</span><span class="o">&gt;</span> <span class="k">function</span><span class="nf"> change_value</span><span class="o">!</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="c"># Create a new function</span>
           <span class="n">y</span> <span class="o">=</span> <span class="mi">17</span>
       <span class="k">end</span>
<span class="n">julia</span><span class="o">&gt;</span> <span class="n">change_value!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">julia</span><span class="o">&gt;</span> <span class="n">x</span> <span class="c"># x is unchanged!</span>
<span class="mi">10</span>
</pre></div>
</div>
<p>In Julia, any function (including <tt class="docutils literal"><span class="pre">change_value!()</span></tt>) can&#8217;t change the binding of a local variable. If <tt class="docutils literal"><span class="pre">x</span></tt> (in the calling scope) is bound to a immutable object (like a real number), you can&#8217;t modify the object; likewise, if x is bound in the calling scope to a Dict, you can&#8217;t change it to be bound to an ASCIIString.</p>
<p>But here is a thing you should pay attention to: suppose <tt class="docutils literal"><span class="pre">x</span></tt> is bound to an Array (or any other mutable type). You cannot &#8220;unbind&#8221; <tt class="docutils literal"><span class="pre">x</span></tt> from this Array. But, since an Array is a <em>mutable</em> type, you can change its content. For example:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="mi">3</span><span class="o">-</span><span class="n">element</span> <span class="n">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">1</span><span class="p">}:</span>
<span class="mi">1</span>
<span class="mi">2</span>
<span class="mi">3</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="k">function</span><span class="nf"> change_array</span><span class="o">!</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="c"># Create a new function</span>
           <span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span>
       <span class="k">end</span>
<span class="n">julia</span><span class="o">&gt;</span> <span class="n">change_array!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">julia</span><span class="o">&gt;</span> <span class="n">x</span>
<span class="mi">3</span><span class="o">-</span><span class="n">element</span> <span class="n">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">1</span><span class="p">}:</span>
<span class="mi">5</span>
<span class="mi">2</span>
<span class="mi">3</span>
</pre></div>
</div>
<p>Here we created a function <tt class="docutils literal"><span class="pre">change_array!()</span></tt>, that assigns <tt class="docutils literal"><span class="pre">5</span></tt> to the first element of the Array. We passed <tt class="docutils literal"><span class="pre">x</span></tt> (which was previously bound to an Array) to the function. Notice that, after the function call, <tt class="docutils literal"><span class="pre">x</span></tt> is still bound to the same Array, but the content of that Array changed.</p>
</div>
<div class="section" id="can-i-use-using-or-import-inside-a-function">
<h3>Can I use <tt class="docutils literal"><span class="pre">using</span></tt> or <tt class="docutils literal"><span class="pre">import</span></tt> inside a function?<a class="headerlink" href="#can-i-use-using-or-import-inside-a-function" title="Permalink to this headline">¶</a></h3>
<p>No, you are not allowed to have a <tt class="docutils literal"><span class="pre">using</span></tt> or <tt class="docutils literal"><span class="pre">import</span></tt> statement inside
a function.  If you want to import a module but only use its symbols
inside a specific function or set of functions, you have two options:</p>
<ol class="arabic">
<li><p class="first">Use <tt class="docutils literal"><span class="pre">import</span></tt>:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="n">Foo</span>
<span class="k">function</span><span class="nf"> bar</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
    <span class="o">...</span> <span class="n">refer</span> <span class="n">to</span> <span class="n">Foo</span> <span class="n">symbols</span> <span class="n">via</span> <span class="n">Foo</span><span class="o">.</span><span class="n">baz</span> <span class="o">...</span>
<span class="k">end</span>
</pre></div>
</div>
<p>This loads the module <tt class="docutils literal"><span class="pre">Foo</span></tt> and defines a variable <tt class="docutils literal"><span class="pre">Foo</span></tt> that refers
to the module, but does not import any of the other symbols from the
module into the current namespace.  You refer to the <tt class="docutils literal"><span class="pre">Foo</span></tt> symbols by
their qualified names <tt class="docutils literal"><span class="pre">Foo.bar</span></tt> etc.</p>
</li>
<li><p class="first">Wrap your function in a module:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="k">module</span> <span class="n">Bar</span>
<span class="k">export</span> <span class="n">bar</span>
<span class="k">using</span> <span class="n">Foo</span>
<span class="k">function</span><span class="nf"> bar</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
    <span class="o">...</span> <span class="n">refer</span> <span class="n">to</span> <span class="n">Foo</span><span class="o">.</span><span class="n">baz</span> <span class="n">as</span> <span class="n">simply</span> <span class="n">baz</span> <span class="o">....</span>
<span class="k">end</span>
<span class="k">end</span>
<span class="k">using</span> <span class="n">Bar</span>
</pre></div>
</div>
<p>This imports all the symbols from <tt class="docutils literal"><span class="pre">Foo</span></tt>, but only inside the module <tt class="docutils literal"><span class="pre">Bar</span></tt>.</p>
</li>
</ol>
</div>
<div class="section" id="what-does-the-operator-do">
<span id="man-slurping-splatting"></span><h3>What does the <tt class="docutils literal"><span class="pre">...</span></tt> operator do?<a class="headerlink" href="#what-does-the-operator-do" title="Permalink to this headline">¶</a></h3>
</div>
<div class="section" id="the-two-uses-of-the-operator-slurping-and-splatting">
<h3>The two uses of the <cite>...</cite> operator: slurping and splatting<a class="headerlink" href="#the-two-uses-of-the-operator-slurping-and-splatting" title="Permalink to this headline">¶</a></h3>
<p>Many newcomers to Julia find the use of <tt class="docutils literal"><span class="pre">...</span></tt> operator confusing. Part of
what makes the <tt class="docutils literal"><span class="pre">...</span></tt> operator confusing is that it means two different things
depending on context.</p>
</div>
<div class="section" id="combines-many-arguments-into-one-argument-in-function-definitions">
<h3><tt class="docutils literal"><span class="pre">...</span></tt> combines many arguments into one argument in function definitions<a class="headerlink" href="#combines-many-arguments-into-one-argument-in-function-definitions" title="Permalink to this headline">¶</a></h3>
<p>In the context of function definitions, the <tt class="docutils literal"><span class="pre">...</span></tt> operator is used to combine
many different arguments into a single argument. This use of <tt class="docutils literal"><span class="pre">...</span></tt> for
combining many different arguments into a single argument is called slurping:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="k">function</span><span class="nf"> printargs</span><span class="p">(</span><span class="n">args</span><span class="o">...</span><span class="p">)</span>
           <span class="p">@</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="nb">typeof</span><span class="p">(</span><span class="n">args</span><span class="p">))</span>
           <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span> <span class="k">in</span> <span class="n">enumerate</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
               <span class="p">@</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Arg </span><span class="si">%d</span><span class="s"> = </span><span class="si">%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span>
           <span class="k">end</span>
       <span class="k">end</span>
<span class="n">printargs</span> <span class="p">(</span><span class="n">generic</span> <span class="k">function</span><span class="nf"> with</span> <span class="mi">1</span> <span class="n">method</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">printargs</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="p">(</span><span class="kt">Int64</span><span class="p">,</span><span class="kt">Int64</span><span class="p">,</span><span class="kt">Int64</span><span class="p">)</span>
<span class="n">Arg</span> <span class="mi">1</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">Arg</span> <span class="mi">2</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">Arg</span> <span class="mi">3</span> <span class="o">=</span> <span class="mi">3</span>
</pre></div>
</div>
<p>If Julia were a language that made more liberal use of ASCII characters, the
slurping operator might have been written as <tt class="docutils literal"><span class="pre">&lt;-...</span></tt> instead of <tt class="docutils literal"><span class="pre">...</span></tt>.</p>
</div>
<div class="section" id="splits-one-argument-into-many-different-arguments-in-function-calls">
<h3><tt class="docutils literal"><span class="pre">...</span></tt> splits one argument into many different arguments in function calls<a class="headerlink" href="#splits-one-argument-into-many-different-arguments-in-function-calls" title="Permalink to this headline">¶</a></h3>
<p>In contrast to the use of the <tt class="docutils literal"><span class="pre">...</span></tt> operator to denote slurping many
different arguments into one argument when defining a function, the <tt class="docutils literal"><span class="pre">...</span></tt>
operator is also used to cause a single function argument to be split apart
into many different arguments when used in the context of a function call. This
use of <tt class="docutils literal"><span class="pre">...</span></tt> is called splatting:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="k">function</span><span class="nf"> threeargs</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
           <span class="p">@</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;a = </span><span class="si">%s</span><span class="s">::</span><span class="si">%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="nb">typeof</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
           <span class="p">@</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;b = </span><span class="si">%s</span><span class="s">::</span><span class="si">%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="nb">typeof</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
           <span class="p">@</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;c = </span><span class="si">%s</span><span class="s">::</span><span class="si">%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="nb">typeof</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
       <span class="k">end</span>
<span class="n">threeargs</span> <span class="p">(</span><span class="n">generic</span> <span class="k">function</span><span class="nf"> with</span> <span class="mi">1</span> <span class="n">method</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">vec</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="mi">3</span><span class="o">-</span><span class="n">element</span> <span class="n">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">1</span><span class="p">}:</span>
 <span class="mi">1</span>
 <span class="mi">2</span>
 <span class="mi">3</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">threeargs</span><span class="p">(</span><span class="n">vec</span><span class="o">...</span><span class="p">)</span>
<span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">::</span><span class="kt">Int64</span>
<span class="n">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">::</span><span class="kt">Int64</span>
<span class="n">c</span> <span class="o">=</span> <span class="mi">3</span><span class="p">::</span><span class="kt">Int64</span>
</pre></div>
</div>
<p>If Julia were a language that made more liberal use of ASCII characters,
the splatting operator might have been written as <tt class="docutils literal"><span class="pre">...-&gt;</span></tt> instead of <tt class="docutils literal"><span class="pre">...</span></tt>.</p>
</div>
</div>
<div class="section" id="types-type-declarations-and-constructors">
<h2>Types, type declarations, and constructors<a class="headerlink" href="#types-type-declarations-and-constructors" title="Permalink to this headline">¶</a></h2>
<div class="section" id="what-does-type-stable-mean">
<span id="man-type-stable"></span><h3>What does &#8220;type-stable&#8221; mean?<a class="headerlink" href="#what-does-type-stable-mean" title="Permalink to this headline">¶</a></h3>
<p>It means that the type of the output is predictable from the types
of the inputs.  In particular, it means that the type of the output
cannot vary depending on the <em>values</em> of the inputs. The following
code is <em>not</em> type-stable:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="k">function</span><span class="nf"> unstable</span><span class="p">(</span><span class="n">flag</span><span class="p">::</span><span class="kt">Bool</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">flag</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="k">else</span>
        <span class="k">return</span> <span class="mf">1.0</span>
    <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
<p>It returns either an <tt class="docutils literal"><span class="pre">Int</span></tt> or a <tt class="docutils literal"><span class="pre">Float64</span></tt> depending on the value of its
argument. Since Julia can&#8217;t predict the return type of this function at
compile-time, any computation that uses it will have to guard against both
types possibly occurring, making generation of fast machine code difficult.</p>
</div>
<div class="section" id="why-does-julia-give-a-domainerror-for-certain-seemingly-sensible-operations">
<span id="man-domain-error"></span><h3>Why does Julia give a <tt class="docutils literal"><span class="pre">DomainError</span></tt> for certain seemingly-sensible operations?<a class="headerlink" href="#why-does-julia-give-a-domainerror-for-certain-seemingly-sensible-operations" title="Permalink to this headline">¶</a></h3>
<p>Certain operations make mathematical sense but result in errors:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">sqrt</span><span class="p">(</span><span class="o">-</span><span class="mf">2.0</span><span class="p">)</span>
<span class="n">ERROR</span><span class="p">:</span> <span class="n">DomainError</span>
 <span class="k">in</span> <span class="n">sqrt</span> <span class="n">at</span> <span class="n">math</span><span class="o">.</span><span class="n">jl</span><span class="p">:</span><span class="mi">128</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="mi">2</span><span class="o">^-</span><span class="mi">5</span>
<span class="n">ERROR</span><span class="p">:</span> <span class="n">DomainError</span>
 <span class="k">in</span> <span class="n">power_by_squaring</span> <span class="n">at</span> <span class="n">intfuncs</span><span class="o">.</span><span class="n">jl</span><span class="p">:</span><span class="mi">70</span>
 <span class="k">in</span> <span class="o">^</span> <span class="n">at</span> <span class="n">intfuncs</span><span class="o">.</span><span class="n">jl</span><span class="p">:</span><span class="mi">84</span>
</pre></div>
</div>
<p>This behavior is an inconvenient consequence of the requirement for
type-stability.  In the case of <a class="reference internal" href="../../stdlib/math/#Base.sqrt" title="Base.sqrt"><tt class="xref jl jl-func docutils literal"><span class="pre">sqrt()</span></tt></a>, most users want
<tt class="docutils literal"><span class="pre">sqrt(2.0)</span></tt> to give a real number, and would be unhappy if it
produced the complex number <tt class="docutils literal"><span class="pre">1.4142135623730951</span> <span class="pre">+</span> <span class="pre">0.0im</span></tt>.  One could
write the <a class="reference internal" href="../../stdlib/math/#Base.sqrt" title="Base.sqrt"><tt class="xref jl jl-func docutils literal"><span class="pre">sqrt()</span></tt></a> function to switch to a complex-valued output only
when passed a negative number (which is what <a class="reference internal" href="../../stdlib/math/#Base.sqrt" title="Base.sqrt"><tt class="xref jl jl-func docutils literal"><span class="pre">sqrt()</span></tt></a> does in some
other languages), but then the result would not be <a class="reference external" href="#man-type-stable">type-stable</a> and the <a class="reference internal" href="../../stdlib/math/#Base.sqrt" title="Base.sqrt"><tt class="xref jl jl-func docutils literal"><span class="pre">sqrt()</span></tt></a> function would have poor
performance.</p>
<p>In these and other cases, you can get the result you want by choosing
an <em>input type</em> that conveys your willingness to accept an <em>output type</em> in
which the result can be represented:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">sqrt</span><span class="p">(</span><span class="o">-</span><span class="mf">2.0</span><span class="o">+</span><span class="mi">0</span><span class="nb">im</span><span class="p">)</span>
<span class="mf">0.0</span> <span class="o">+</span> <span class="mf">1.4142135623730951</span><span class="nb">im</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="mf">2.0</span><span class="o">^-</span><span class="mi">5</span>
<span class="mf">0.03125</span>
</pre></div>
</div>
</div>
<div class="section" id="why-does-julia-use-native-machine-integer-arithmetic">
<h3>Why does Julia use native machine integer arithmetic?<a class="headerlink" href="#why-does-julia-use-native-machine-integer-arithmetic" title="Permalink to this headline">¶</a></h3>
<p>Julia uses machine arithmetic for integer computations. This means that the range of <tt class="docutils literal"><span class="pre">Int</span></tt> values is bounded and wraps around at either end so that adding, subtracting and multiplying integers can overflow or underflow, leading to some results that can be unsettling at first:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="nb">typemax</span><span class="p">(</span><span class="kt">Int</span><span class="p">)</span>
<span class="mi">9223372036854775807</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">ans</span><span class="o">+</span><span class="mi">1</span>
<span class="o">-</span><span class="mi">9223372036854775808</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="o">-</span><span class="n">ans</span>
<span class="o">-</span><span class="mi">9223372036854775808</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="mi">2</span><span class="o">*</span><span class="n">ans</span>
<span class="mi">0</span>
</pre></div>
</div>
<p>Clearly, this is far from the way mathematical integers behave, and you might
think it less than ideal for a high-level programming language to expose this
to the user. For numerical work where efficiency and transparency are at a
premium, however, the alternatives are worse.</p>
<p>One alternative to consider would be to check each integer operation for
overflow and promote results to bigger integer types such as <tt class="docutils literal"><span class="pre">Int128</span></tt> or
<a class="reference internal" href="../../stdlib/numbers/#Base.BigInt" title="Base.BigInt"><tt class="xref jl jl-class docutils literal"><span class="pre">BigInt</span></tt></a> in the case of overflow. Unfortunately, this introduces major
overhead on every integer operation (think incrementing a loop counter) – it
requires emitting code to perform run-time overflow checks after arithmetic
instructions and branches to handle potential overflows. Worse still, this
would cause every computation involving integers to be type-unstable. As we
mentioned above, <a class="reference external" href="#man-type-stable">type-stability is crucial</a> for effective
generation of efficient code. If you can&#8217;t count on the results of integer
operations being integers, it&#8217;s impossible to generate fast, simple code the
way C and Fortran compilers do.</p>
<p>A variation on this approach, which avoids the appearance of type instability is to merge the <tt class="docutils literal"><span class="pre">Int</span></tt> and <a class="reference internal" href="../../stdlib/numbers/#Base.BigInt" title="Base.BigInt"><tt class="xref jl jl-class docutils literal"><span class="pre">BigInt</span></tt></a> types into a single hybrid integer type, that internally changes representation when a result no longer fits into the size of a machine integer. While this superficially avoids type-instability at the level of Julia code, it just sweeps the problem under the rug by foisting all of the same difficulties onto the C code implementing this hybrid integer type. This approach <em>can</em> be made to work and can even be made quite fast in many cases, but has several drawbacks. One problem is that the in-memory representation of integers and arrays of integers no longer match the natural representation used by C, Fortran and other languages with native machine integers. Thus, to interoperate with those languages, we would ultimately need to introduce native integer types anyway. Any unbounded representation of integers cannot have a fixed number of bits, and thus cannot be stored inline in an array with fixed-size slots –&nbsp;large integer values will always require separate heap-allocated storage. And of course, no matter how clever a hybrid integer implementation one uses, there are always performance traps – situations where performance degrades unexpectedly. Complex representation, lack of interoperability with C and Fortran, the inability to represent integer arrays without additional heap storage, and unpredictable performance characteristics make even the cleverest hybrid integer implementations a poor choice for high-performance numerical work.</p>
<p>An alternative to using hybrid integers or promoting to BigInts is to use
saturating integer arithmetic, where adding to the largest integer value
leaves it unchanged and likewise for subtracting from the smallest integer
value. This is precisely what Matlab™ does:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;</span> <span class="n">int64</span><span class="p">(</span><span class="mi">9223372036854775807</span><span class="p">)</span>

<span class="n">ans</span> <span class="o">=</span>

  <span class="mi">9223372036854775807</span>

<span class="o">&gt;&gt;</span> <span class="n">int64</span><span class="p">(</span><span class="mi">9223372036854775807</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

<span class="n">ans</span> <span class="o">=</span>

  <span class="mi">9223372036854775807</span>

<span class="o">&gt;&gt;</span> <span class="n">int64</span><span class="p">(</span><span class="o">-</span><span class="mi">9223372036854775808</span><span class="p">)</span>

<span class="n">ans</span> <span class="o">=</span>

 <span class="o">-</span><span class="mi">9223372036854775808</span>

<span class="o">&gt;&gt;</span> <span class="n">int64</span><span class="p">(</span><span class="o">-</span><span class="mi">9223372036854775808</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

<span class="n">ans</span> <span class="o">=</span>

 <span class="o">-</span><span class="mi">9223372036854775808</span>
</pre></div>
</div>
<p>At first blush, this seems reasonable enough since 9223372036854775807 is much closer to 9223372036854775808 than -9223372036854775808 is and integers are still represented with a fixed size in a natural way that is compatible with C and Fortran. Saturated integer arithmetic, however, is deeply problematic. The first and most obvious issue is that this is not the way machine integer arithmetic works, so implementing saturated operations requires emitting instructions after each machine integer operation to check for underflow or overflow and replace the result with <a class="reference internal" href="../../stdlib/base/#Base.typemin" title="Base.typemin"><tt class="xref jl jl-func docutils literal"><span class="pre">typemin(Int)</span></tt></a> or <a class="reference internal" href="../../stdlib/base/#Base.typemax" title="Base.typemax"><tt class="xref jl jl-func docutils literal"><span class="pre">typemax(Int)</span></tt></a> as appropriate. This alone expands each integer operation from a single, fast instruction into half a dozen instructions, probably including branches. Ouch. But it gets worse –&nbsp;saturating integer arithmetic isn&#8217;t associative. Consider this Matlab computation:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;</span> <span class="n">n</span> <span class="o">=</span> <span class="n">int64</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">^</span><span class="mi">62</span>
<span class="mi">4611686018427387904</span>

<span class="o">&gt;&gt;</span> <span class="n">n</span> <span class="o">+</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
<span class="mi">9223372036854775807</span>

<span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="n">n</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
<span class="mi">9223372036854775806</span>
</pre></div>
</div>
<p>This makes it hard to write many basic integer algorithms since a lot of
common techniques depend on the fact that machine addition with overflow <em>is</em>
associative. Consider finding the midpoint between integer values <tt class="docutils literal"><span class="pre">lo</span></tt> and
<tt class="docutils literal"><span class="pre">hi</span></tt> in Julia using the expression <tt class="docutils literal"><span class="pre">(lo</span> <span class="pre">+</span> <span class="pre">hi)</span> <span class="pre">&gt;&gt;&gt;</span> <span class="pre">1</span></tt>:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">2</span><span class="o">^</span><span class="mi">62</span>
<span class="mi">4611686018427387904</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">2</span><span class="n">n</span><span class="p">)</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">1</span>
<span class="mi">6917529027641081856</span>
</pre></div>
</div>
<p>See? No problem. That&#8217;s the correct midpoint between 2^62 and 2^63, despite
the fact that <tt class="docutils literal"><span class="pre">n</span> <span class="pre">+</span> <span class="pre">2n</span></tt> is -4611686018427387904. Now try it in Matlab:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>

<span class="n">ans</span> <span class="o">=</span>

  <span class="mi">4611686018427387904</span>
</pre></div>
</div>
<p>Oops. Adding a <tt class="docutils literal"><span class="pre">&gt;&gt;&gt;</span></tt> operator to Matlab wouldn&#8217;t help, because saturation
that occurs when adding <tt class="docutils literal"><span class="pre">n</span></tt> and <tt class="docutils literal"><span class="pre">2n</span></tt> has already destroyed the information
necessary to compute the correct midpoint.</p>
<p>Not only is lack of associativity unfortunate for programmers who cannot rely
it for techniques like this, but it also defeats almost anything compilers
might want to do to optimize integer arithmetic. For example, since Julia
integers use normal machine integer arithmetic, LLVM is free to aggressively
optimize simple little functions like <tt class="docutils literal"><span class="pre">f(k)</span> <span class="pre">=</span> <span class="pre">5k-1</span></tt>. The machine code for
this function is just this:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">code_native</span><span class="p">(</span><span class="n">f</span><span class="p">,(</span><span class="kt">Int</span><span class="p">,))</span>
    <span class="o">.</span><span class="n">section</span>    <span class="n">__TEXT</span><span class="p">,</span><span class="n">__text</span><span class="p">,</span><span class="n">regular</span><span class="p">,</span><span class="n">pure_instructions</span>
<span class="n">Filename</span><span class="p">:</span> <span class="n">none</span>
<span class="n">Source</span> <span class="n">line</span><span class="p">:</span> <span class="mi">1</span>
    <span class="n">push</span>    <span class="n">RBP</span>
    <span class="n">mov</span> <span class="n">RBP</span><span class="p">,</span> <span class="n">RSP</span>
<span class="n">Source</span> <span class="n">line</span><span class="p">:</span> <span class="mi">1</span>
    <span class="n">lea</span> <span class="n">RAX</span><span class="p">,</span> <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">RDI</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">RDI</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">pop</span> <span class="n">RBP</span>
    <span class="n">ret</span>
</pre></div>
</div>
<p>The actual body of the function is a single <tt class="docutils literal"><span class="pre">lea</span></tt> instruction, which
computes the integer multiply and add at once. This is even more beneficial
when <tt class="docutils literal"><span class="pre">f</span></tt> gets inlined into another function:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="k">function</span><span class="nf"> g</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
         <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">:</span><span class="n">n</span>
           <span class="n">k</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
         <span class="k">end</span>
         <span class="k">return</span> <span class="n">k</span>
       <span class="k">end</span>
<span class="n">g</span> <span class="p">(</span><span class="n">generic</span> <span class="k">function</span><span class="nf"> with</span> <span class="mi">2</span> <span class="n">methods</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">code_native</span><span class="p">(</span><span class="n">g</span><span class="p">,(</span><span class="kt">Int</span><span class="p">,</span><span class="kt">Int</span><span class="p">))</span>
    <span class="o">.</span><span class="n">section</span>    <span class="n">__TEXT</span><span class="p">,</span><span class="n">__text</span><span class="p">,</span><span class="n">regular</span><span class="p">,</span><span class="n">pure_instructions</span>
<span class="n">Filename</span><span class="p">:</span> <span class="n">none</span>
<span class="n">Source</span> <span class="n">line</span><span class="p">:</span> <span class="mi">3</span>
    <span class="n">push</span>    <span class="n">RBP</span>
    <span class="n">mov</span> <span class="n">RBP</span><span class="p">,</span> <span class="n">RSP</span>
    <span class="n">test</span>    <span class="n">RSI</span><span class="p">,</span> <span class="n">RSI</span>
    <span class="n">jle</span> <span class="mi">22</span>
    <span class="n">mov</span> <span class="n">EAX</span><span class="p">,</span> <span class="mi">1</span>
<span class="n">Source</span> <span class="n">line</span><span class="p">:</span> <span class="mi">3</span>
    <span class="n">lea</span> <span class="n">RDI</span><span class="p">,</span> <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">RDI</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">RDI</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">inc</span> <span class="n">RAX</span>
    <span class="n">cmp</span> <span class="n">RAX</span><span class="p">,</span> <span class="n">RSI</span>
<span class="n">Source</span> <span class="n">line</span><span class="p">:</span> <span class="mi">2</span>
    <span class="n">jle</span> <span class="o">-</span><span class="mi">17</span>
<span class="n">Source</span> <span class="n">line</span><span class="p">:</span> <span class="mi">5</span>
    <span class="n">mov</span> <span class="n">RAX</span><span class="p">,</span> <span class="n">RDI</span>
    <span class="n">pop</span> <span class="n">RBP</span>
    <span class="n">ret</span>
</pre></div>
</div>
<p>Since the call to <tt class="docutils literal"><span class="pre">f</span></tt> gets inlined, the loop body ends up being just a
single <tt class="docutils literal"><span class="pre">lea</span></tt> instruction. Next, consider what happens if we make the number
of loop iterations fixed:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="k">function</span><span class="nf"> g</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
         <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">:</span><span class="mi">10</span>
           <span class="n">k</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
         <span class="k">end</span>
         <span class="k">return</span> <span class="n">k</span>
       <span class="k">end</span>
<span class="n">g</span> <span class="p">(</span><span class="n">generic</span> <span class="k">function</span><span class="nf"> with</span> <span class="mi">2</span> <span class="n">methods</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">code_native</span><span class="p">(</span><span class="n">g</span><span class="p">,(</span><span class="kt">Int</span><span class="p">,))</span>
    <span class="o">.</span><span class="n">section</span>    <span class="n">__TEXT</span><span class="p">,</span><span class="n">__text</span><span class="p">,</span><span class="n">regular</span><span class="p">,</span><span class="n">pure_instructions</span>
<span class="n">Filename</span><span class="p">:</span> <span class="n">none</span>
<span class="n">Source</span> <span class="n">line</span><span class="p">:</span> <span class="mi">3</span>
    <span class="n">push</span>    <span class="n">RBP</span>
    <span class="n">mov</span> <span class="n">RBP</span><span class="p">,</span> <span class="n">RSP</span>
<span class="n">Source</span> <span class="n">line</span><span class="p">:</span> <span class="mi">3</span>
    <span class="n">imul</span>    <span class="n">RAX</span><span class="p">,</span> <span class="n">RDI</span><span class="p">,</span> <span class="mi">9765625</span>
    <span class="n">add</span> <span class="n">RAX</span><span class="p">,</span> <span class="o">-</span><span class="mi">2441406</span>
<span class="n">Source</span> <span class="n">line</span><span class="p">:</span> <span class="mi">5</span>
    <span class="n">pop</span> <span class="n">RBP</span>
    <span class="n">ret</span>
</pre></div>
</div>
<p>Because the compiler knows that integer addition and multiplication are
associative and that multiplication distributes over addition – neither of
which is true of saturating arithmetic – it can optimize the entire loop down
to just a multiply and an add. Saturated arithmetic completely defeats this
kind of optimization since associativity and distributivity can fail at each
loop iteration, causing different outcomes depending on which iteration the
failure occurs in. The compiler can unroll the loop, but it cannot
algebraically reduce multiple operations into fewer equivalent operations.</p>
<p>The most reasonable alternative to having integer arithmetic silently overflow
is to do checked arithmetic everywhere, raising errors when adds, subtracts,
and multiplies overflow, producing values that are not value-correct. In this
<a class="reference external" href="http://danluu.com/integer-overflow">blog post</a>, Dan Luu analyzes this and
finds that rather than the trivial cost that this approach should in theory
have, it ends up having a substantial cost due to compilers (LLVM and GCC)
not gracefully optimizing around the added overflow checks. If this improves
in the future, we could consider defaulting to checked integer arithmetic in
Julia, but for now, we have to live with the possibility of overflow.</p>
</div>
<div class="section" id="how-do-abstract-or-ambiguous-fields-in-types-interact-with-the-compiler">
<span id="man-abstract-fields"></span><h3>How do &#8220;abstract&#8221; or ambiguous fields in types interact with the compiler?<a class="headerlink" href="#how-do-abstract-or-ambiguous-fields-in-types-interact-with-the-compiler" title="Permalink to this headline">¶</a></h3>
<p>Types can be declared without specifying the types of their fields:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="k">type</span><span class="nc"> MyAmbiguousType</span>
           <span class="n">a</span>
       <span class="k">end</span>
</pre></div>
</div>
<p>This allows <tt class="docutils literal"><span class="pre">a</span></tt> to be of any type. This can often be useful, but it
does have a downside: for objects of type <tt class="docutils literal"><span class="pre">MyAmbiguousType</span></tt>, the
compiler will not be able to generate high-performance code.  The
reason is that the compiler uses the types of objects, not their
values, to determine how to build code. Unfortunately, very little can
be inferred about an object of type <tt class="docutils literal"><span class="pre">MyAmbiguousType</span></tt>:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">MyAmbiguousType</span><span class="p">(</span><span class="s">&quot;Hello&quot;</span><span class="p">)</span>
<span class="n">MyAmbiguousType</span><span class="p">(</span><span class="s">&quot;Hello&quot;</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="n">MyAmbiguousType</span><span class="p">(</span><span class="mi">17</span><span class="p">)</span>
<span class="n">MyAmbiguousType</span><span class="p">(</span><span class="mi">17</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nb">typeof</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="n">MyAmbiguousType</span> <span class="p">(</span><span class="n">constructor</span> <span class="n">with</span> <span class="mi">1</span> <span class="n">method</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nb">typeof</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="n">MyAmbiguousType</span> <span class="p">(</span><span class="n">constructor</span> <span class="n">with</span> <span class="mi">1</span> <span class="n">method</span><span class="p">)</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">b</span></tt> and <tt class="docutils literal"><span class="pre">c</span></tt> have the same type, yet their underlying
representation of data in memory is very different. Even if you stored
just numeric values in field <tt class="docutils literal"><span class="pre">a</span></tt>, the fact that the memory
representation of a <tt class="docutils literal"><span class="pre">Uint8</span></tt> differs from a <tt class="docutils literal"><span class="pre">Float64</span></tt> also means
that the CPU needs to handle them using two different kinds of
instructions.  Since the required information is not available in the
type, such decisions have to be made at run-time. This slows
performance.</p>
<p>You can do better by declaring the type of <tt class="docutils literal"><span class="pre">a</span></tt>. Here, we are focused
on the case where <tt class="docutils literal"><span class="pre">a</span></tt> might be any one of several types, in which
case the natural solution is to use parameters. For example:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="k">type</span><span class="nc"> MyType</span><span class="p">{</span><span class="n">T</span><span class="o">&lt;:</span><span class="n">FloatingPoint</span><span class="p">}</span>
         <span class="n">a</span><span class="p">::</span><span class="n">T</span>
       <span class="k">end</span>
</pre></div>
</div>
<p>This is a better choice than</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="k">type</span><span class="nc"> MyStillAmbiguousType</span>
         <span class="n">a</span><span class="p">::</span><span class="n">FloatingPoint</span>
       <span class="k">end</span>
</pre></div>
</div>
<p>because the first version specifies the type of <tt class="docutils literal"><span class="pre">a</span></tt> from the type of
the wrapper object.  For example:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">m</span> <span class="o">=</span> <span class="n">MyType</span><span class="p">(</span><span class="mf">3.2</span><span class="p">)</span>
<span class="n">MyType</span><span class="p">{</span><span class="kt">Float64</span><span class="p">}(</span><span class="mf">3.2</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">t</span> <span class="o">=</span> <span class="n">MyStillAmbiguousType</span><span class="p">(</span><span class="mf">3.2</span><span class="p">)</span>
<span class="n">MyStillAmbiguousType</span><span class="p">(</span><span class="mf">3.2</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nb">typeof</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="n">MyType</span><span class="p">{</span><span class="kt">Float64</span><span class="p">}</span> <span class="p">(</span><span class="n">constructor</span> <span class="n">with</span> <span class="mi">1</span> <span class="n">method</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nb">typeof</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="n">MyStillAmbiguousType</span> <span class="p">(</span><span class="n">constructor</span> <span class="n">with</span> <span class="mi">2</span> <span class="n">methods</span><span class="p">)</span>
</pre></div>
</div>
<p>The type of field <tt class="docutils literal"><span class="pre">a</span></tt> can be readily determined from the type of
<tt class="docutils literal"><span class="pre">m</span></tt>, but not from the type of <tt class="docutils literal"><span class="pre">t</span></tt>.  Indeed, in <tt class="docutils literal"><span class="pre">t</span></tt> it&#8217;s possible
to change the type of field <tt class="docutils literal"><span class="pre">a</span></tt>:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="nb">typeof</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">a</span><span class="p">)</span>
<span class="kt">Float64</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">t</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="mf">4.5f0</span>
<span class="mf">4.5f0</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nb">typeof</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">a</span><span class="p">)</span>
<span class="kt">Float32</span>
</pre></div>
</div>
<p>In contrast, once <tt class="docutils literal"><span class="pre">m</span></tt> is constructed, the type of <tt class="docutils literal"><span class="pre">m.a</span></tt> cannot
change:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">m</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="mf">4.5f0</span>
<span class="mf">4.5</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nb">typeof</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">a</span><span class="p">)</span>
<span class="kt">Float64</span>
</pre></div>
</div>
<p>The fact that the type of <tt class="docutils literal"><span class="pre">m.a</span></tt> is known from <tt class="docutils literal"><span class="pre">m</span></tt>&#8216;s type&#8212;coupled
with the fact that its type cannot change mid-function&#8212;allows the
compiler to generate highly-optimized code for objects like <tt class="docutils literal"><span class="pre">m</span></tt> but
not for objects like <tt class="docutils literal"><span class="pre">t</span></tt>.</p>
<p>Of course, all of this is true only if we construct <tt class="docutils literal"><span class="pre">m</span></tt> with a
concrete type.  We can break this by explicitly constructing it with
an abstract type:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">m</span> <span class="o">=</span> <span class="n">MyType</span><span class="p">{</span><span class="n">FloatingPoint</span><span class="p">}(</span><span class="mf">3.2</span><span class="p">)</span>
<span class="n">MyType</span><span class="p">{</span><span class="n">FloatingPoint</span><span class="p">}(</span><span class="mf">3.2</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nb">typeof</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">a</span><span class="p">)</span>
<span class="kt">Float64</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">m</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="mf">4.5f0</span>
<span class="mf">4.5f0</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nb">typeof</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">a</span><span class="p">)</span>
<span class="kt">Float32</span>
</pre></div>
</div>
<p>For all practical purposes, such objects behave identically to those
of <tt class="docutils literal"><span class="pre">MyStillAmbiguousType</span></tt>.</p>
<p>It&#8217;s quite instructive to compare the sheer amount code generated for
a simple function</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">func</span><span class="p">(</span><span class="n">m</span><span class="p">::</span><span class="n">MyType</span><span class="p">)</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">a</span><span class="o">+</span><span class="mi">1</span>
</pre></div>
</div>
<p>using</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">code_llvm</span><span class="p">(</span><span class="n">func</span><span class="p">,(</span><span class="n">MyType</span><span class="p">{</span><span class="kt">Float64</span><span class="p">},))</span>
<span class="n">code_llvm</span><span class="p">(</span><span class="n">func</span><span class="p">,(</span><span class="n">MyType</span><span class="p">{</span><span class="n">FloatingPoint</span><span class="p">},))</span>
<span class="n">code_llvm</span><span class="p">(</span><span class="n">func</span><span class="p">,(</span><span class="n">MyType</span><span class="p">,))</span>
</pre></div>
</div>
<p>For reasons of length the results are not shown here, but you may wish
to try this yourself. Because the type is fully-specified in the first
case, the compiler doesn&#8217;t need to generate any code to resolve the
type at run-time.  This results in shorter and faster code.</p>
</div>
<div class="section" id="how-should-i-declare-abstract-container-type-fields">
<span id="man-abstract-container-type"></span><h3>How should I declare &#8220;abstract container type&#8221; fields?<a class="headerlink" href="#how-should-i-declare-abstract-container-type-fields" title="Permalink to this headline">¶</a></h3>
<p>The same best practices that apply in the <a class="reference external" href="#man-abstract-fields">previous section</a> also work for container types:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="k">type</span><span class="nc"> MySimpleContainer</span><span class="p">{</span><span class="n">A</span><span class="o">&lt;:</span><span class="n">AbstractVector</span><span class="p">}</span>
         <span class="n">a</span><span class="p">::</span><span class="n">A</span>
       <span class="k">end</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="k">type</span><span class="nc"> MyAmbiguousContainer</span><span class="p">{</span><span class="n">T</span><span class="p">}</span>
         <span class="n">a</span><span class="p">::</span><span class="n">AbstractVector</span><span class="p">{</span><span class="n">T</span><span class="p">}</span>
       <span class="k">end</span>
</pre></div>
</div>
<p>For example:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="n">MySimpleContainer</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">);</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nb">typeof</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="n">MySimpleContainer</span><span class="p">{</span><span class="n">UnitRange</span><span class="p">{</span><span class="kt">Int64</span><span class="p">}}</span> <span class="p">(</span><span class="n">constructor</span> <span class="n">with</span> <span class="mi">1</span> <span class="n">method</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="n">MySimpleContainer</span><span class="p">([</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">]);</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nb">typeof</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="n">MySimpleContainer</span><span class="p">{</span><span class="n">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">1</span><span class="p">}}</span> <span class="p">(</span><span class="n">constructor</span> <span class="n">with</span> <span class="mi">1</span> <span class="n">method</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">MyAmbiguousContainer</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">);</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nb">typeof</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="n">MyAmbiguousContainer</span><span class="p">{</span><span class="kt">Int64</span><span class="p">}</span> <span class="p">(</span><span class="n">constructor</span> <span class="n">with</span> <span class="mi">1</span> <span class="n">method</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">MyAmbiguousContainer</span><span class="p">([</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">]);</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nb">typeof</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="n">MyAmbiguousContainer</span><span class="p">{</span><span class="kt">Int64</span><span class="p">}</span> <span class="p">(</span><span class="n">constructor</span> <span class="n">with</span> <span class="mi">1</span> <span class="n">method</span><span class="p">)</span>
</pre></div>
</div>
<p>For <tt class="docutils literal"><span class="pre">MySimpleContainer</span></tt>, the object is fully-specified by its type
and parameters, so the compiler can generate optimized functions. In
most instances, this will probably suffice.</p>
<p>While the compiler can now do its job perfectly well, there are cases
where <em>you</em> might wish that your code could do different things
depending on the <em>element type</em> of <tt class="docutils literal"><span class="pre">a</span></tt>.  Usually the best way to
achieve this is to wrap your specific operation (here, <tt class="docutils literal"><span class="pre">foo</span></tt>) in a
separate function:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="k">function</span><span class="nf"> sumfoo</span><span class="p">(</span><span class="n">c</span><span class="p">::</span><span class="n">MySimpleContainer</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">x</span> <span class="k">in</span> <span class="n">c</span><span class="o">.</span><span class="n">a</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="n">foo</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">end</span>
    <span class="n">s</span>
<span class="k">end</span>

<span class="n">foo</span><span class="p">(</span><span class="n">x</span><span class="p">::</span><span class="n">Integer</span><span class="p">)</span> <span class="o">=</span> <span class="n">x</span>
<span class="n">foo</span><span class="p">(</span><span class="n">x</span><span class="p">::</span><span class="n">FloatingPoint</span><span class="p">)</span> <span class="o">=</span> <span class="n">round</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>This keeps things simple, while allowing the compiler to generate
optimized code in all cases.</p>
<p>However, there are cases where you may need to declare different
versions of the outer function for different element types of
<tt class="docutils literal"><span class="pre">a</span></tt>. You could do it like this:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="k">function</span><span class="nf"> myfun</span><span class="p">{</span><span class="n">T</span><span class="o">&lt;:</span><span class="n">FloatingPoint</span><span class="p">}(</span><span class="n">c</span><span class="p">::</span><span class="n">MySimpleContainer</span><span class="p">{</span><span class="n">Vector</span><span class="p">{</span><span class="n">T</span><span class="p">}})</span>
    <span class="o">...</span>
<span class="k">end</span>
<span class="k">function</span><span class="nf"> myfun</span><span class="p">{</span><span class="n">T</span><span class="o">&lt;:</span><span class="n">Integer</span><span class="p">}(</span><span class="n">c</span><span class="p">::</span><span class="n">MySimpleContainer</span><span class="p">{</span><span class="n">Vector</span><span class="p">{</span><span class="n">T</span><span class="p">}})</span>
    <span class="o">...</span>
<span class="k">end</span>
</pre></div>
</div>
<p>This works fine for <tt class="docutils literal"><span class="pre">Vector{T}</span></tt>, but we&#8217;d also have to write
explicit versions for <tt class="docutils literal"><span class="pre">UnitRange{T}</span></tt> or other abstract types. To
prevent such tedium, you can use two parameters in the declaration of
<tt class="docutils literal"><span class="pre">MyContainer</span></tt>:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="k">type</span><span class="nc"> MyContainer</span><span class="p">{</span><span class="n">T</span><span class="p">,</span> <span class="n">A</span><span class="o">&lt;:</span><span class="n">AbstractVector</span><span class="p">}</span>
    <span class="n">a</span><span class="p">::</span><span class="n">A</span>
<span class="k">end</span>
<span class="n">MyContainer</span><span class="p">(</span><span class="n">v</span><span class="p">::</span><span class="n">AbstractVector</span><span class="p">)</span> <span class="o">=</span> <span class="n">MyContainer</span><span class="p">{</span><span class="n">eltype</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="nb">typeof</span><span class="p">(</span><span class="n">v</span><span class="p">)}(</span><span class="n">v</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">MyContainer</span><span class="p">(</span><span class="mf">1.3</span><span class="p">:</span><span class="mi">5</span><span class="p">);</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nb">typeof</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="n">MyContainer</span><span class="p">{</span><span class="kt">Float64</span><span class="p">,</span><span class="n">UnitRange</span><span class="p">{</span><span class="kt">Float64</span><span class="p">}}</span>
</pre></div>
</div>
<p>Note the somewhat surprising fact that <tt class="docutils literal"><span class="pre">T</span></tt> doesn&#8217;t appear in the
declaration of field <tt class="docutils literal"><span class="pre">a</span></tt>, a point that we&#8217;ll return to in a moment.
With this approach, one can write functions such as:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="k">function</span><span class="nf"> myfunc</span><span class="p">{</span><span class="n">T</span><span class="o">&lt;:</span><span class="n">Integer</span><span class="p">,</span> <span class="n">A</span><span class="o">&lt;:</span><span class="n">AbstractArray</span><span class="p">}(</span><span class="n">c</span><span class="p">::</span><span class="n">MyContainer</span><span class="p">{</span><span class="n">T</span><span class="p">,</span><span class="n">A</span><span class="p">})</span>
    <span class="k">return</span> <span class="n">c</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span>
<span class="k">end</span>
<span class="c"># Note: because we can only define MyContainer for</span>
<span class="c"># A&lt;:AbstractArray, and any unspecified parameters are arbitrary,</span>
<span class="c"># the previous could have been written more succinctly as</span>
<span class="c">#     function myfunc{T&lt;:Integer}(c::MyContainer{T})</span>

<span class="k">function</span><span class="nf"> myfunc</span><span class="p">{</span><span class="n">T</span><span class="o">&lt;:</span><span class="n">FloatingPoint</span><span class="p">}(</span><span class="n">c</span><span class="p">::</span><span class="n">MyContainer</span><span class="p">{</span><span class="n">T</span><span class="p">})</span>
    <span class="k">return</span> <span class="n">c</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">2</span>
<span class="k">end</span>

<span class="k">function</span><span class="nf"> myfunc</span><span class="p">{</span><span class="n">T</span><span class="o">&lt;:</span><span class="n">Integer</span><span class="p">}(</span><span class="n">c</span><span class="p">::</span><span class="n">MyContainer</span><span class="p">{</span><span class="n">T</span><span class="p">,</span><span class="n">Vector</span><span class="p">{</span><span class="n">T</span><span class="p">}})</span>
    <span class="k">return</span> <span class="n">c</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">3</span>
<span class="k">end</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">myfunc</span><span class="p">(</span><span class="n">MyContainer</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">))</span>
<span class="mi">2</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">myfunc</span><span class="p">(</span><span class="n">MyContainer</span><span class="p">(</span><span class="mf">1.0</span><span class="p">:</span><span class="mi">3</span><span class="p">))</span>
<span class="mf">3.0</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">myfunc</span><span class="p">(</span><span class="n">MyContainer</span><span class="p">([</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">]))</span>
<span class="mi">4</span>
</pre></div>
</div>
<p>As you can see, with this approach it&#8217;s possible to specialize on both
the element type <tt class="docutils literal"><span class="pre">T</span></tt> and the array type <tt class="docutils literal"><span class="pre">A</span></tt>.</p>
<p>However, there&#8217;s one remaining hole: we haven&#8217;t enforced that <tt class="docutils literal"><span class="pre">A</span></tt>
has element type <tt class="docutils literal"><span class="pre">T</span></tt>, so it&#8217;s perfectly possible to construct an
object like this:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">MyContainer</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span> <span class="n">UnitRange</span><span class="p">{</span><span class="kt">Float64</span><span class="p">}}(</span><span class="mf">1.3</span><span class="p">:</span><span class="mi">5</span><span class="p">);</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nb">typeof</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="n">MyContainer</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="n">UnitRange</span><span class="p">{</span><span class="kt">Float64</span><span class="p">}}</span>
</pre></div>
</div>
<p>To prevent this, we can add an inner constructor:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="k">type</span><span class="nc"> MyBetterContainer</span><span class="p">{</span><span class="n">T</span><span class="o">&lt;:</span><span class="n">Real</span><span class="p">,</span> <span class="n">A</span><span class="o">&lt;:</span><span class="n">AbstractVector</span><span class="p">}</span>
    <span class="n">a</span><span class="p">::</span><span class="n">A</span>

    <span class="n">MyBetterContainer</span><span class="p">(</span><span class="n">v</span><span class="p">::</span><span class="n">AbstractVector</span><span class="p">{</span><span class="n">T</span><span class="p">})</span> <span class="o">=</span> <span class="nb">new</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
<span class="k">end</span>
<span class="n">MyBetterContainer</span><span class="p">(</span><span class="n">v</span><span class="p">::</span><span class="n">AbstractVector</span><span class="p">)</span> <span class="o">=</span> <span class="n">MyBetterContainer</span><span class="p">{</span><span class="n">eltype</span><span class="p">(</span><span class="n">v</span><span class="p">),</span><span class="nb">typeof</span><span class="p">(</span><span class="n">v</span><span class="p">)}(</span><span class="n">v</span><span class="p">)</span>


<span class="n">julia</span><span class="o">&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">MyBetterContainer</span><span class="p">(</span><span class="mf">1.3</span><span class="p">:</span><span class="mi">5</span><span class="p">);</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nb">typeof</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="n">MyBetterContainer</span><span class="p">{</span><span class="kt">Float64</span><span class="p">,</span><span class="n">UnitRange</span><span class="p">{</span><span class="kt">Float64</span><span class="p">}}</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">MyBetterContainer</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span> <span class="n">UnitRange</span><span class="p">{</span><span class="kt">Float64</span><span class="p">}}(</span><span class="mf">1.3</span><span class="p">:</span><span class="mi">5</span><span class="p">);</span>
<span class="n">ERROR</span><span class="p">:</span> <span class="n">no</span> <span class="n">method</span> <span class="n">MyBetterContainer</span><span class="p">(</span><span class="n">UnitRange</span><span class="p">{</span><span class="kt">Float64</span><span class="p">},)</span>
</pre></div>
</div>
<p>The inner constructor requires that the element type of <tt class="docutils literal"><span class="pre">A</span></tt> be <tt class="docutils literal"><span class="pre">T</span></tt>.</p>
</div>
</div>
<div class="section" id="nothingness-and-missing-values">
<h2>Nothingness and missing values<a class="headerlink" href="#nothingness-and-missing-values" title="Permalink to this headline">¶</a></h2>
<div class="section" id="how-does-null-or-nothingness-work-in-julia">
<h3>How does &#8220;null&#8221; or &#8220;nothingness&#8221; work in Julia?<a class="headerlink" href="#how-does-null-or-nothingness-work-in-julia" title="Permalink to this headline">¶</a></h3>
<p>Unlike many languages (for example, C and Java), Julia does not have a
&#8220;null&#8221; value. When a reference (variable, object field, or array element)
is uninitialized, accessing it will immediately throw an error. This
situation can be detected using the <tt class="docutils literal"><span class="pre">isdefined</span></tt> function.</p>
<p>Some functions are used only for their side effects, and do not need to
return a value. In these cases, the convention is to return the value
<tt class="docutils literal"><span class="pre">nothing</span></tt>, which is just a singleton object of type <tt class="docutils literal"><span class="pre">Nothing</span></tt>. This
is an ordinary type with no fields; there is nothing special about it
except for this convention, and that the REPL does not print anything
for it. Some language constructs that would not otherwise have a value
also yield <tt class="docutils literal"><span class="pre">nothing</span></tt>, for example <tt class="docutils literal"><span class="pre">if</span> <span class="pre">false;</span> <span class="pre">end</span></tt>.</p>
<p>Note that <tt class="docutils literal"><span class="pre">Nothing</span></tt> (uppercase) is the type of <tt class="docutils literal"><span class="pre">nothing</span></tt>, and should
only be used in a context where a type is required (e.g. a declaration).</p>
<p>You may occasionally see <tt class="docutils literal"><span class="pre">None</span></tt>, which is quite different. It is the
empty (or &#8220;bottom&#8221;) type, a type with no values and no subtypes (except
itself). You will generally not need to use this type.</p>
<p>The empty tuple (<tt class="docutils literal"><span class="pre">()</span></tt>) is another form of nothingness. But, it should not
really be thought of as nothing but rather a tuple of zero values.</p>
</div>
</div>
<div class="section" id="memory">
<h2>Memory<a class="headerlink" href="#memory" title="Permalink to this headline">¶</a></h2>
<div class="section" id="why-does-x-y-allocate-memory-when-x-and-y-are-arrays">
<h3>Why does <tt class="docutils literal"><span class="pre">x</span> <span class="pre">+=</span> <span class="pre">y</span></tt> allocate memory when <tt class="docutils literal"><span class="pre">x</span></tt> and <tt class="docutils literal"><span class="pre">y</span></tt> are arrays?<a class="headerlink" href="#why-does-x-y-allocate-memory-when-x-and-y-are-arrays" title="Permalink to this headline">¶</a></h3>
<p>In julia, <tt class="docutils literal"><span class="pre">x</span> <span class="pre">+=</span> <span class="pre">y</span></tt> gets replaced during parsing by <tt class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">y</span></tt>.
For arrays, this has the consequence that, rather than storing the
result in the same location in memory as <tt class="docutils literal"><span class="pre">x</span></tt>, it allocates a new
array to store the result.</p>
<p>While this behavior might surprise some, the choice is deliberate. The
main reason is the presence of <tt class="docutils literal"><span class="pre">immutable</span></tt> objects within julia,
which cannot change their value once created.  Indeed, a number is an
immutable object; the statements <tt class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">5;</span> <span class="pre">x</span> <span class="pre">+=</span> <span class="pre">1</span></tt> do not modify the
meaning of <tt class="docutils literal"><span class="pre">5</span></tt>, they modify the value bound to <tt class="docutils literal"><span class="pre">x</span></tt>. For an
immutable, the only way to change the value is to reassign it.</p>
<p>To amplify a bit further, consider the following function:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="k">function</span><span class="nf"> power_by_squaring</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="p">::</span><span class="kt">Int</span><span class="p">)</span>
    <span class="n">ispow2</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">||</span> <span class="nb">error</span><span class="p">(</span><span class="s">&quot;This implementation only works for powers of 2&quot;</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">2</span>
        <span class="n">x</span> <span class="o">*=</span> <span class="n">x</span>
        <span class="n">n</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span>
    <span class="k">end</span>
    <span class="n">x</span>
<span class="k">end</span>
</pre></div>
</div>
<p>After a call like <tt class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">5;</span> <span class="pre">y</span> <span class="pre">=</span> <span class="pre">power_by_squaring(x,</span> <span class="pre">4)</span></tt>, you would
get the expected result: <tt class="docutils literal"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">5</span> <span class="pre">&amp;&amp;</span> <span class="pre">y</span> <span class="pre">==</span> <span class="pre">625</span></tt>.  However, now suppose
that <tt class="docutils literal"><span class="pre">*=</span></tt>, when used with matrices, instead mutated the left hand
side.  There would be two problems:</p>
<ul class="simple">
<li>For general square matrices, <tt class="docutils literal"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">A*B</span></tt> cannot be implemented
without temporary storage: <tt class="docutils literal"><span class="pre">A[1,1]</span></tt> gets computed and stored on
the left hand side before you&#8217;re done using it on the right hand
side.</li>
<li>Suppose you were willing to allocate a temporary for the computation
(which would eliminate most of the point of making <tt class="docutils literal"><span class="pre">*=</span></tt> work
in-place); if you took advantage of the mutability of <tt class="docutils literal"><span class="pre">x</span></tt>, then
this function would behave differently for mutable vs. immutable
inputs. In particular, for immutable <tt class="docutils literal"><span class="pre">x</span></tt>, after the call you&#8217;d
have (in general) <tt class="docutils literal"><span class="pre">y</span> <span class="pre">!=</span> <span class="pre">x</span></tt>, but for mutable <tt class="docutils literal"><span class="pre">x</span></tt> you&#8217;d have <tt class="docutils literal"><span class="pre">y</span>
<span class="pre">==</span> <span class="pre">x</span></tt>.</li>
</ul>
<p>Because supporting generic programming is deemed more important than
potential performance optimizations that can be achieved by other
means (e.g., using explicit loops), operators like <tt class="docutils literal"><span class="pre">+=</span></tt> and <tt class="docutils literal"><span class="pre">*=</span></tt>
work by rebinding new values.</p>
</div>
</div>
<div class="section" id="julia-releases">
<h2>Julia Releases<a class="headerlink" href="#julia-releases" title="Permalink to this headline">¶</a></h2>
<div class="section" id="do-i-want-to-use-a-release-beta-or-nightly-version-of-julia">
<h3>Do I want to use a release, beta, or nightly version of Julia?<a class="headerlink" href="#do-i-want-to-use-a-release-beta-or-nightly-version-of-julia" title="Permalink to this headline">¶</a></h3>
<p>You may prefer the release version of Julia if you are looking for a stable code base. Releases generally occur every 6 months, giving you a stable platform for writing code.</p>
<p>You may prefer the beta version of Julia if you don&#8217;t mind being slightly behind the latest bugfixes and changes, but find the slightly faster rate of changes more appealing. Additionally, these binaries are tested before they are published to ensure they are fully functional.</p>
<p>You may prefer the nightly version of Julia if you want to take advantage of the latest updates to the language, and don&#8217;t mind if the version available today occasionally doesn&#8217;t actually work.</p>
<p>Finally, you may also consider building Julia from source for yourself. This option is mainly for those individuals who are comfortable at the command line, or interested in learning. If this describes you, you may also be interested in reading our <a class="reference external" href="https://github.com/JuliaLang/julia/blob/master/CONTRIBUTING.md">guidelines for contributing</a>.</p>
<p>Links to each of these download types can be found on the download page at <a class="reference external" href="http://julialang.org/downloads/">http://julialang.org/downloads/</a>. Note that not all versions of Julia are available for all platforms.</p>
</div>
<div class="section" id="when-are-deprecated-functions-removed">
<h3>When are deprecated functions removed?<a class="headerlink" href="#when-are-deprecated-functions-removed" title="Permalink to this headline">¶</a></h3>
<p>Deprecated functions are removed after the subsequent release. For example, functions marked as deprecated in the 0.1 release will not be available starting with the 0.2 release.</p>
</div>
</div>
</div>


          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../noteworthy-differences/" class="btn btn-neutral float-right" title="Noteworthy Differences from other Languages">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../style-guide/" class="btn btn-neutral" title="Style Guide"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
    </p>
  </div>

  <a href="https://github.com/snide/sphinx_rtd_theme">Sphinx theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>
</footer>
        </div>
      </div>

    </section>

  </div>
  

  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'0.3.13-pre',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>
      <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>