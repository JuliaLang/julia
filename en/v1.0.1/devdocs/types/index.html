<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>More about types Â· The Julia Language</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-28835595-6', 'auto');
ga('send', 'pageview');
</script><link rel="canonical" href="https://docs.julialang.org/en/v1/devdocs/types/index.html"/><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../../assets/julia-manual.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../../index.html"><img class="logo" src="../../assets/logo.png" alt="The Julia Language logo"/></a><h1>The Julia Language</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../../manual/getting-started/">Getting Started</a></li><li><a class="toctext" href="../../manual/variables/">Variables</a></li><li><a class="toctext" href="../../manual/integers-and-floating-point-numbers/">Integers and Floating-Point Numbers</a></li><li><a class="toctext" href="../../manual/mathematical-operations/">Mathematical Operations and Elementary Functions</a></li><li><a class="toctext" href="../../manual/complex-and-rational-numbers/">Complex and Rational Numbers</a></li><li><a class="toctext" href="../../manual/strings/">Strings</a></li><li><a class="toctext" href="../../manual/functions/">Functions</a></li><li><a class="toctext" href="../../manual/control-flow/">Control Flow</a></li><li><a class="toctext" href="../../manual/variables-and-scoping/">Scope of Variables</a></li><li><a class="toctext" href="../../manual/types/">Types</a></li><li><a class="toctext" href="../../manual/methods/">Methods</a></li><li><a class="toctext" href="../../manual/constructors/">Constructors</a></li><li><a class="toctext" href="../../manual/conversion-and-promotion/">Conversion and Promotion</a></li><li><a class="toctext" href="../../manual/interfaces/">Interfaces</a></li><li><a class="toctext" href="../../manual/modules/">Modules</a></li><li><a class="toctext" href="../../manual/documentation/">Documentation</a></li><li><a class="toctext" href="../../manual/metaprogramming/">Metaprogramming</a></li><li><a class="toctext" href="../../manual/arrays/">Multi-dimensional Arrays</a></li><li><a class="toctext" href="../../manual/missing/">Missing Values</a></li><li><a class="toctext" href="../../manual/networking-and-streams/">Networking and Streams</a></li><li><a class="toctext" href="../../manual/parallel-computing/">Parallel Computing</a></li><li><a class="toctext" href="../../manual/running-external-programs/">Running External Programs</a></li><li><a class="toctext" href="../../manual/calling-c-and-fortran-code/">Calling C and Fortran Code</a></li><li><a class="toctext" href="../../manual/handling-operating-system-variation/">Handling Operating System Variation</a></li><li><a class="toctext" href="../../manual/environment-variables/">Environment Variables</a></li><li><a class="toctext" href="../../manual/embedding/">Embedding Julia</a></li><li><a class="toctext" href="../../manual/code-loading/">Code Loading</a></li><li><a class="toctext" href="../../manual/profile/">Profiling</a></li><li><a class="toctext" href="../../manual/stacktraces/">Stack Traces</a></li><li><a class="toctext" href="../../manual/performance-tips/">Performance Tips</a></li><li><a class="toctext" href="../../manual/workflow-tips/">Workflow Tips</a></li><li><a class="toctext" href="../../manual/style-guide/">Style Guide</a></li><li><a class="toctext" href="../../manual/faq/">Frequently Asked Questions</a></li><li><a class="toctext" href="../../manual/noteworthy-differences/">Noteworthy Differences from other Languages</a></li><li><a class="toctext" href="../../manual/unicode-input/">Unicode Input</a></li></ul></li><li><span class="toctext">Base</span><ul><li><a class="toctext" href="../../base/base/">Essentials</a></li><li><a class="toctext" href="../../base/collections/">Collections and Data Structures</a></li><li><a class="toctext" href="../../base/math/">Mathematics</a></li><li><a class="toctext" href="../../base/numbers/">Numbers</a></li><li><a class="toctext" href="../../base/strings/">Strings</a></li><li><a class="toctext" href="../../base/arrays/">Arrays</a></li><li><a class="toctext" href="../../base/parallel/">Tasks</a></li><li><a class="toctext" href="../../base/multi-threading/">Multi-Threading</a></li><li><a class="toctext" href="../../base/constants/">Constants</a></li><li><a class="toctext" href="../../base/file/">Filesystem</a></li><li><a class="toctext" href="../../base/io-network/">I/O and Network</a></li><li><a class="toctext" href="../../base/punctuation/">Punctuation</a></li><li><a class="toctext" href="../../base/sort/">Sorting and Related Functions</a></li><li><a class="toctext" href="../../base/iterators/">Iteration utilities</a></li><li><a class="toctext" href="../../base/c/">C Interface</a></li><li><a class="toctext" href="../../base/libc/">C Standard Library</a></li><li><a class="toctext" href="../../base/stacktraces/">StackTraces</a></li><li><a class="toctext" href="../../base/simd-types/">SIMD Support</a></li></ul></li><li><span class="toctext">Standard Library</span><ul><li><a class="toctext" href="../../stdlib/Base64/">Base64</a></li><li><a class="toctext" href="../../stdlib/CRC32c/">CRC32c</a></li><li><a class="toctext" href="../../stdlib/Dates/">Dates</a></li><li><a class="toctext" href="../../stdlib/DelimitedFiles/">Delimited Files</a></li><li><a class="toctext" href="../../stdlib/Distributed/">Distributed Computing</a></li><li><a class="toctext" href="../../stdlib/FileWatching/">File Events</a></li><li><a class="toctext" href="../../stdlib/InteractiveUtils/">Interactive Utilities</a></li><li><a class="toctext" href="../../stdlib/LibGit2/">LibGit2</a></li><li><a class="toctext" href="../../stdlib/Libdl/">Dynamic Linker</a></li><li><a class="toctext" href="../../stdlib/LinearAlgebra/">Linear Algebra</a></li><li><a class="toctext" href="../../stdlib/Logging/">Logging</a></li><li><a class="toctext" href="../../stdlib/Markdown/">Markdown</a></li><li><a class="toctext" href="../../stdlib/Mmap/">Memory-mapped I/O</a></li><li><a class="toctext" href="../../stdlib/Pkg/">Pkg</a></li><li><a class="toctext" href="../../stdlib/Printf/">Printf</a></li><li><a class="toctext" href="../../stdlib/Profile/">Profiling</a></li><li><a class="toctext" href="../../stdlib/REPL/">The Julia REPL</a></li><li><a class="toctext" href="../../stdlib/Random/">Random Numbers</a></li><li><a class="toctext" href="../../stdlib/SHA/">SHA</a></li><li><a class="toctext" href="../../stdlib/Serialization/">Serialization</a></li><li><a class="toctext" href="../../stdlib/SharedArrays/">Shared Arrays</a></li><li><a class="toctext" href="../../stdlib/Sockets/">Sockets</a></li><li><a class="toctext" href="../../stdlib/SparseArrays/">Sparse Arrays</a></li><li><a class="toctext" href="../../stdlib/Statistics/">Statistics</a></li><li><a class="toctext" href="../../stdlib/Test/">Unit Testing</a></li><li><a class="toctext" href="../../stdlib/UUIDs/">UUIDs</a></li><li><a class="toctext" href="../../stdlib/Unicode/">Unicode</a></li></ul></li><li><span class="toctext">Developer Documentation</span><ul><li><a class="toctext" href="../reflection/">Reflection and introspection</a></li><li><span class="toctext">Documentation of Julia&#39;s Internals</span><ul><li><a class="toctext" href="../init/">Initialization of the Julia runtime</a></li><li><a class="toctext" href="../ast/">Julia ASTs</a></li><li class="current"><a class="toctext" href>More about types</a><ul class="internal"><li><a class="toctext" href="#Types-and-sets-(and-Any-and-Union{}/Bottom)-1">Types and sets (and <code>Any</code> and <code>Union{}</code>/<code>Bottom</code>)</a></li><li><a class="toctext" href="#UnionAll-types-1">UnionAll types</a></li><li><a class="toctext" href="#Free-variables-1">Free variables</a></li><li><a class="toctext" href="#TypeNames-1">TypeNames</a></li><li><a class="toctext" href="#Tuple-types-1">Tuple types</a></li><li><a class="toctext" href="#Diagonal-types-1">Diagonal types</a></li><li><a class="toctext" href="#Subtyping-diagonal-variables-1">Subtyping diagonal variables</a></li><li><a class="toctext" href="#Introduction-to-the-internal-machinery-1">Introduction to the internal machinery</a></li><li><a class="toctext" href="#Subtyping-and-method-sorting-1">Subtyping and method sorting</a></li></ul></li><li><a class="toctext" href="../object/">Memory layout of Julia Objects</a></li><li><a class="toctext" href="../eval/">Eval of Julia code</a></li><li><a class="toctext" href="../callconv/">Calling Conventions</a></li><li><a class="toctext" href="../compiler/">High-level Overview of the Native-Code Generation Process</a></li><li><a class="toctext" href="../functions/">Julia Functions</a></li><li><a class="toctext" href="../cartesian/">Base.Cartesian</a></li><li><a class="toctext" href="../meta/">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="../subarrays/">SubArrays</a></li><li><a class="toctext" href="../isbitsunionarrays/">isbits Union Optimizations</a></li><li><a class="toctext" href="../sysimg/">System Image Building</a></li><li><a class="toctext" href="../llvm/">Working with LLVM</a></li><li><a class="toctext" href="../stdio/">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="../boundscheck/">Bounds checking</a></li><li><a class="toctext" href="../locks/">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="../offset-arrays/">Arrays with custom indices</a></li><li><a class="toctext" href="../require/">Module loading</a></li><li><a class="toctext" href="../inference/">Inference</a></li></ul></li><li><span class="toctext">Developing/debugging Julia&#39;s C code</span><ul><li><a class="toctext" href="../backtraces/">Reporting and analyzing crashes (segfaults)</a></li><li><a class="toctext" href="../debuggingtips/">gdb debugging tips</a></li><li><a class="toctext" href="../valgrind/">Using Valgrind with Julia</a></li><li><a class="toctext" href="../sanitizers/">Sanitizer support</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Developer Documentation</li><li>Documentation of Julia&#39;s Internals</li><li><a href>More about types</a></li></ul><a class="edit-page" href="https://github.com/JuliaLang/julia/blob/master/doc/src/devdocs/types.md"><span class="fa">ï</span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>More about types</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="More-about-types-1" href="#More-about-types-1">More about types</a></h1><p>If you&#39;ve used Julia for a while, you understand the fundamental role that types play.  Here we try to get under the hood, focusing particularly on <a href="../../manual/types/#Parametric-Types-1">Parametric Types</a>.</p><h2><a class="nav-anchor" id="Types-and-sets-(and-Any-and-Union{}/Bottom)-1" href="#Types-and-sets-(and-Any-and-Union{}/Bottom)-1">Types and sets (and <code>Any</code> and <code>Union{}</code>/<code>Bottom</code>)</a></h2><p>It&#39;s perhaps easiest to conceive of Julia&#39;s type system in terms of sets. While programs manipulate individual values, a type refers to a set of values. This is not the same thing as a collection; for example a <code>Set</code> of values is itself a single <code>Set</code> value. Rather, a type describes a set of <em>possible</em> values, expressing uncertainty about which value we have.</p><p>A <em>concrete</em> type <code>T</code> describes the set of values whose direct tag, as returned by the <code>typeof</code> function, is <code>T</code>. An <em>abstract</em> type describes some possibly-larger set of values.</p><p><code>Any</code> describes the entire universe of possible values. <a href="../../base/numbers/#Core.Integer"><code>Integer</code></a> is a subset of <code>Any</code> that includes <code>Int</code>, <a href="../../base/numbers/#Core.Int8"><code>Int8</code></a>, and other concrete types. Internally, Julia also makes heavy use of another type known as <code>Bottom</code>, which can also be written as <code>Union{}</code>. This corresponds to the empty set.</p><p>Julia&#39;s types support the standard operations of set theory: you can ask whether <code>T1</code> is a &quot;subset&quot; (subtype) of <code>T2</code> with <code>T1 &lt;: T2</code>. Likewise, you intersect two types using <code>typeintersect</code>, take their union with <code>Union</code>, and compute a type that contains their union with <code>typejoin</code>:</p><pre><code class="language-julia-repl">julia&gt; typeintersect(Int, Float64)
Union{}

julia&gt; Union{Int, Float64}
Union{Float64, Int64}

julia&gt; typejoin(Int, Float64)
Real

julia&gt; typeintersect(Signed, Union{UInt8, Int8})
Int8

julia&gt; Union{Signed, Union{UInt8, Int8}}
Union{UInt8, Signed}

julia&gt; typejoin(Signed, Union{UInt8, Int8})
Integer

julia&gt; typeintersect(Tuple{Integer,Float64}, Tuple{Int,Real})
Tuple{Int64,Float64}

julia&gt; Union{Tuple{Integer,Float64}, Tuple{Int,Real}}
Union{Tuple{Int64,Real}, Tuple{Integer,Float64}}

julia&gt; typejoin(Tuple{Integer,Float64}, Tuple{Int,Real})
Tuple{Integer,Real}</code></pre><p>While these operations may seem abstract, they lie at the heart of Julia.  For example, method dispatch is implemented by stepping through the items in a method list until reaching one for which the type of the argument tuple is a subtype of the method signature. For this algorithm to work, it&#39;s important that methods be sorted by their specificity, and that the search begins with the most specific methods. Consequently, Julia also implements a partial order on types; this is achieved by functionality that is similar to <code>&lt;:</code>, but with differences that will be discussed below.</p><h2><a class="nav-anchor" id="UnionAll-types-1" href="#UnionAll-types-1">UnionAll types</a></h2><p>Julia&#39;s type system can also express an <em>iterated union</em> of types: a union of types over all values of some variable. This is needed to describe parametric types where the values of some parameters are not known.</p><p>For example, :obj:<code>Array</code> has two parameters as in <code>Array{Int,2}</code>. If we did not know the element type, we could write <code>Array{T,2} where T</code>, which is the union of <code>Array{T,2}</code> for all values of <code>T</code>: <code>Union{Array{Int8,2}, Array{Int16,2}, ...}</code>.</p><p>Such a type is represented by a <code>UnionAll</code> object, which contains a variable (<code>T</code> in this example, of type <code>TypeVar</code>), and a wrapped type (<code>Array{T,2}</code> in this example).</p><p>Consider the following methods:</p><pre><code class="language-julia">f1(A::Array) = 1
f2(A::Array{Int}) = 2
f3(A::Array{T}) where {T&lt;:Any} = 3
f4(A::Array{Any}) = 4</code></pre><p>The signature of <code>f3</code> is a <code>UnionAll</code> type wrapping a tuple type. All but <code>f4</code> can be called with <code>a = [1,2]</code>; all but <code>f2</code> can be called with <code>b = Any[1,2]</code>.</p><p>Let&#39;s look at these types a little more closely:</p><pre><code class="language-julia-repl">julia&gt; dump(Array)
UnionAll
  var: TypeVar
    name: Symbol T
    lb: Core.TypeofBottom Union{}
    ub: Any
  body: UnionAll
    var: TypeVar
      name: Symbol N
      lb: Core.TypeofBottom Union{}
      ub: Any
    body: Array{T,N} &lt;: DenseArray{T,N}</code></pre><p>This indicates that <code>Array</code> actually names a <code>UnionAll</code> type. There is one <code>UnionAll</code> type for each parameter, nested. The syntax <code>Array{Int,2}</code> is equivalent to <code>Array{Int}{2}</code>; internally each <code>UnionAll</code> is instantiated with a particular variable value, one at a time, outermost-first. This gives a natural meaning to the omission of trailing type parameters; <code>Array{Int}</code> gives a type equivalent to <code>Array{Int,N} where N</code>.</p><p>A <code>TypeVar</code> is not itself a type, but rather should be considered part of the structure of a <code>UnionAll</code> type. Type variables have lower and upper bounds on their values (in the fields <code>lb</code> and <code>ub</code>). The symbol <code>name</code> is purely cosmetic. Internally, <code>TypeVar</code>s are compared by address, so they are defined as mutable types to ensure that &quot;different&quot; type variables can be distinguished. However, by convention they should not be mutated.</p><p>One can construct <code>TypeVar</code>s manually:</p><pre><code class="language-julia-repl">julia&gt; TypeVar(:V, Signed, Real)
Signed&lt;:V&lt;:Real</code></pre><p>There are convenience versions that allow you to omit any of these arguments except the <code>name</code> symbol.</p><p>The syntax <code>Array{T} where T&lt;:Integer</code> is lowered to</p><pre><code class="language-julia">let T = TypeVar(:T,Integer)
    UnionAll(T, Array{T})
end</code></pre><p>so it is seldom necessary to construct a <code>TypeVar</code> manually (indeed, this is to be avoided).</p><h2><a class="nav-anchor" id="Free-variables-1" href="#Free-variables-1">Free variables</a></h2><p>The concept of a <em>free</em> type variable is extremely important in the type system. We say that a variable <code>V</code> is free in type <code>T</code> if <code>T</code> does not contain the <code>UnionAll</code> that introduces variable <code>V</code>. For example, the type <code>Array{Array{V} where V&lt;:Integer}</code> has no free variables, but the <code>Array{V}</code> part inside of it does have a free variable, <code>V</code>.</p><p>A type with free variables is, in some sense, not really a type at all. Consider the type <code>Array{Array{T}} where T</code>, which refers to all homogeneous arrays of arrays. The inner type <code>Array{T}</code>, seen by itself, might seem to refer to any kind of array. However, every element of the outer array must have the <em>same</em> array type, so <code>Array{T}</code> cannot refer to just any old array. One could say that <code>Array{T}</code> effectively &quot;occurs&quot; multiple times, and <code>T</code> must have the same value each &quot;time&quot;.</p><p>For this reason, the function <code>jl_has_free_typevars</code> in the C API is very important. Types for which it returns true will not give meaningful answers in subtyping and other type functions.</p><h2><a class="nav-anchor" id="TypeNames-1" href="#TypeNames-1">TypeNames</a></h2><p>The following two <a href="../../base/arrays/#Core.Array"><code>Array</code></a> types are functionally equivalent, yet print differently:</p><pre><code class="language-julia-repl">julia&gt; TV, NV = TypeVar(:T), TypeVar(:N)
(T, N)

julia&gt; Array
Array

julia&gt; Array{TV,NV}
Array{T,N}</code></pre><p>These can be distinguished by examining the <code>name</code> field of the type, which is an object of type <code>TypeName</code>:</p><pre><code class="language-julia-repl">julia&gt; dump(Array{Int,1}.name)
TypeName
  name: Symbol Array
  module: Module Core
  names: empty SimpleVector
  wrapper: UnionAll
    var: TypeVar
      name: Symbol T
      lb: Core.TypeofBottom Union{}
      ub: Any
    body: UnionAll
      var: TypeVar
        name: Symbol N
        lb: Core.TypeofBottom Union{}
        ub: Any
      body: Array{T,N} &lt;: DenseArray{T,N}
  cache: SimpleVector
    ...

  linearcache: SimpleVector
    ...

  hash: Int64 -7900426068641098781
  mt: MethodTable
    name: Symbol Array
    defs: Nothing nothing
    cache: Nothing nothing
    max_args: Int64 0
    kwsorter: #undef
    module: Module Core
    : Int64 0
    : Int64 0</code></pre><p>In this case, the relevant field is <code>wrapper</code>, which holds a reference to the top-level type used to make new <code>Array</code> types.</p><pre><code class="language-julia-repl">julia&gt; pointer_from_objref(Array)
Ptr{Cvoid} @0x00007fcc7de64850

julia&gt; pointer_from_objref(Array.body.body.name.wrapper)
Ptr{Cvoid} @0x00007fcc7de64850

julia&gt; pointer_from_objref(Array{TV,NV})
Ptr{Cvoid} @0x00007fcc80c4d930

julia&gt; pointer_from_objref(Array{TV,NV}.name.wrapper)
Ptr{Cvoid} @0x00007fcc7de64850</code></pre><p>The <code>wrapper</code> field of <a href="../../base/arrays/#Core.Array"><code>Array</code></a> points to itself, but for <code>Array{TV,NV}</code> it points back to the original definition of the type.</p><p>What about the other fields? <code>hash</code> assigns an integer to each type.  To examine the <code>cache</code> field, it&#39;s helpful to pick a type that is less heavily used than Array. Let&#39;s first create our own type:</p><pre><code class="language-julia-repl">julia&gt; struct MyType{T,N} end

julia&gt; MyType{Int,2}
MyType{Int64,2}

julia&gt; MyType{Float32, 5}
MyType{Float32,5}

julia&gt; MyType.body.body.name.cache
svec(MyType{Int64,2}, MyType{Float32,5}, #undef, #undef, #undef, #undef, #undef, #undef)</code></pre><p>(The cache is pre-allocated to have length 8, but only the first two entries are populated.) Consequently, when you instantiate a parametric type, each concrete type gets saved in a type cache.  However, instances containing free type variables are not cached.</p><h2><a class="nav-anchor" id="Tuple-types-1" href="#Tuple-types-1">Tuple types</a></h2><p>Tuple types constitute an interesting special case.  For dispatch to work on declarations like <code>x::Tuple</code>, the type has to be able to accommodate any tuple.  Let&#39;s check the parameters:</p><pre><code class="language-julia-repl">julia&gt; Tuple
Tuple

julia&gt; Tuple.parameters
svec(Vararg{Any,N} where N)</code></pre><p>Unlike other types, tuple types are covariant in their parameters, so this definition permits <code>Tuple</code> to match any type of tuple:</p><pre><code class="language-julia-repl">julia&gt; typeintersect(Tuple, Tuple{Int,Float64})
Tuple{Int64,Float64}

julia&gt; typeintersect(Tuple{Vararg{Any}}, Tuple{Int,Float64})
Tuple{Int64,Float64}</code></pre><p>However, if a variadic (<code>Vararg</code>) tuple type has free variables it can describe different kinds of tuples:</p><pre><code class="language-julia-repl">julia&gt; typeintersect(Tuple{Vararg{T} where T}, Tuple{Int,Float64})
Tuple{Int64,Float64}

julia&gt; typeintersect(Tuple{Vararg{T}} where T, Tuple{Int,Float64})
Union{}</code></pre><p>Notice that when <code>T</code> is free with respect to the <code>Tuple</code> type (i.e. its binding <code>UnionAll</code> type is outside the <code>Tuple</code> type), only one <code>T</code> value must work over the whole type. Therefore a heterogeneous tuple does not match.</p><p>Finally, it&#39;s worth noting that <code>Tuple{}</code> is distinct:</p><pre><code class="language-julia-repl">julia&gt; Tuple{}
Tuple{}

julia&gt; Tuple{}.parameters
svec()

julia&gt; typeintersect(Tuple{}, Tuple{Int})
Union{}</code></pre><p>What is the &quot;primary&quot; tuple-type?</p><pre><code class="language-julia-repl">julia&gt; pointer_from_objref(Tuple)
Ptr{Cvoid} @0x00007f5998a04370

julia&gt; pointer_from_objref(Tuple{})
Ptr{Cvoid} @0x00007f5998a570d0

julia&gt; pointer_from_objref(Tuple.name.wrapper)
Ptr{Cvoid} @0x00007f5998a04370

julia&gt; pointer_from_objref(Tuple{}.name.wrapper)
Ptr{Cvoid} @0x00007f5998a04370</code></pre><p>so <code>Tuple == Tuple{Vararg{Any}}</code> is indeed the primary type.</p><h2><a class="nav-anchor" id="Diagonal-types-1" href="#Diagonal-types-1">Diagonal types</a></h2><p>Consider the type <code>Tuple{T,T} where T</code>. A method with this signature would look like:</p><pre><code class="language-julia">f(x::T, y::T) where {T} = ...</code></pre><p>According to the usual interpretation of a <code>UnionAll</code> type, this <code>T</code> ranges over all types, including <code>Any</code>, so this type should be equivalent to <code>Tuple{Any,Any}</code>. However, this interpretation causes some practical problems.</p><p>First, a value of <code>T</code> needs to be available inside the method definition. For a call like <code>f(1, 1.0)</code>, it&#39;s not clear what <code>T</code> should be. It could be <code>Union{Int,Float64}</code>, or perhaps <a href="../../base/numbers/#Core.Real"><code>Real</code></a>. Intuitively, we expect the declaration <code>x::T</code> to mean <code>T === typeof(x)</code>. To make sure that invariant holds, we need <code>typeof(x) === typeof(y) === T</code> in this method. That implies the method should only be called for arguments of the exact same type.</p><p>It turns out that being able to dispatch on whether two values have the same type is very useful (this is used by the promotion system for example), so we have multiple reasons to want a different interpretation of <code>Tuple{T,T} where T</code>. To make this work we add the following rule to subtyping: if a variable occurs more than once in covariant position, it is restricted to ranging over only concrete types. (&quot;Covariant position&quot; means that only <code>Tuple</code> and <code>Union</code> types occur between an occurrence of a variable and the <code>UnionAll</code> type that introduces it.) Such variables are called &quot;diagonal variables&quot; or &quot;concrete variables&quot;.</p><p>So for example, <code>Tuple{T,T} where T</code> can be seen as <code>Union{Tuple{Int8,Int8}, Tuple{Int16,Int16}, ...}</code>, where <code>T</code> ranges over all concrete types. This gives rise to some interesting subtyping results. For example <code>Tuple{Real,Real}</code> is not a subtype of <code>Tuple{T,T} where T</code>, because it includes some types like <code>Tuple{Int8,Int16}</code> where the two elements have different types. <code>Tuple{Real,Real}</code> and <code>Tuple{T,T} where T</code> have the non-trivial intersection <code>Tuple{T,T} where T&lt;:Real</code>. However, <code>Tuple{Real}</code> <em>is</em> a subtype of <code>Tuple{T} where T</code>, because in that case <code>T</code> occurs only once and so is not diagonal.</p><p>Next consider a signature like the following:</p><pre><code class="language-julia">f(a::Array{T}, x::T, y::T) where {T} = ...</code></pre><p>In this case, <code>T</code> occurs in invariant position inside <code>Array{T}</code>. That means whatever type of array is passed unambiguously determines the value of <code>T</code> â- we say <code>T</code> has an <em>equality constraint</em> on it. Therefore in this case the diagonal rule is not really necessary, since the array determines <code>T</code> and we can then allow <code>x</code> and <code>y</code> to be of any subtypes of <code>T</code>. So variables that occur in invariant position are never considered diagonal. This choice of behavior is slightly controversial â- some feel this definition should be written as</p><pre><code class="language-julia">f(a::Array{T}, x::S, y::S) where {T, S&lt;:T} = ...</code></pre><p>to clarify whether <code>x</code> and <code>y</code> need to have the same type. In this version of the signature they would, or we could introduce a third variable for the type of <code>y</code> if <code>x</code> and <code>y</code> can have different types.</p><p>The next complication is the interaction of unions and diagonal variables, e.g.</p><pre><code class="language-julia">f(x::Union{Nothing,T}, y::T) where {T} = ...</code></pre><p>Consider what this declaration means. <code>y</code> has type <code>T</code>. <code>x</code> then can have either the same type <code>T</code>, or else be of type <code>Nothing</code>. So all of the following calls should match:</p><pre><code class="language-julia">f(1, 1)
f(&quot;&quot;, &quot;&quot;)
f(2.0, 2.0)
f(nothing, 1)
f(nothing, &quot;&quot;)
f(nothing, 2.0)</code></pre><p>These examples are telling us something: when <code>x</code> is <code>nothing::Nothing</code>, there are no extra constraints on <code>y</code>. It is as if the method signature had <code>y::Any</code>. This means that whether a variable is diagonal is not a static property based on where it appears in a type. Rather, it depends on where a variable appears when the subtyping algorithm <em>uses</em> it. When <code>x</code> has type <code>Nothing</code>, we don&#39;t need to use the <code>T</code> in <code>Union{Nothing,T}</code>, so <code>T</code> does not &quot;occur&quot;. Indeed, we have the following type equivalence:</p><pre><code class="language-julia">(Tuple{Union{Nothing,T},T} where T) == Union{Tuple{Nothing,Any}, Tuple{T,T} where T}</code></pre><h2><a class="nav-anchor" id="Subtyping-diagonal-variables-1" href="#Subtyping-diagonal-variables-1">Subtyping diagonal variables</a></h2><p>The subtyping algorithm for diagonal variables has two components: (1) identifying variable occurrences, and (2) ensuring that diagonal variables range over concrete types only.</p><p>The first task is accomplished by keeping counters <code>occurs_inv</code> and <code>occurs_cov</code> (in <code>src/subtype.c</code>) for each variable in the environment, tracking the number of invariant and covariant occurrences, respectively. A variable is diagonal when <code>occurs_inv == 0 &amp;&amp; occurs_cov &gt; 1</code>.</p><p>The second task is accomplished by imposing a condition on a variable&#39;s lower bound. As the subtyping algorithm runs, it narrows the bounds of each variable (raising lower bounds and lowering upper bounds) to keep track of the range of variable values for which the subtype relation would hold. When we are done evaluating the body of a <code>UnionAll</code> type whose variable is diagonal, we look at the final values of the bounds. Since the variable must be concrete, a contradiction occurs if its lower bound could not be a subtype of a concrete type. For example, an abstract type like <a href="../../base/arrays/#Core.AbstractArray"><code>AbstractArray</code></a> cannot be a subtype of a concrete type, but a concrete type like <code>Int</code> can be, and the empty type <code>Bottom</code> can be as well. If a lower bound fails this test the algorithm stops with the answer <code>false</code>.</p><p>For example, in the problem <code>Tuple{Int,String} &lt;: Tuple{T,T} where T</code>, we derive that this would be true if <code>T</code> were a supertype of <code>Union{Int,String}</code>. However, <code>Union{Int,String}</code> is an abstract type, so the relation does not hold.</p><p>This concreteness test is done by the function <code>is_leaf_bound</code>. Note that this test is slightly different from <code>jl_is_leaf_type</code>, since it also returns <code>true</code> for <code>Bottom</code>. Currently this function is heuristic, and does not catch all possible concrete types. The difficulty is that whether a lower bound is concrete might depend on the values of other type variable bounds. For example, <code>Vector{T}</code> is equivalent to the concrete type <code>Vector{Int}</code> only if both the upper and lower bounds of <code>T</code> equal <code>Int</code>. We have not yet worked out a complete algorithm for this.</p><h2><a class="nav-anchor" id="Introduction-to-the-internal-machinery-1" href="#Introduction-to-the-internal-machinery-1">Introduction to the internal machinery</a></h2><p>Most operations for dealing with types are found in the files <code>jltypes.c</code> and <code>subtype.c</code>. A good way to start is to watch subtyping in action. Build Julia with <code>make debug</code> and fire up Julia within a debugger. <a href="../debuggingtips/#gdb-debugging-tips-1">gdb debugging tips</a> has some tips which may be useful.</p><p>Because the subtyping code is used heavily in the REPL itselfâand hence breakpoints in this code get triggered oftenâit will be easiest if you make the following definition:</p><pre><code class="language-julia-repl">julia&gt; function mysubtype(a,b)
           ccall(:jl_breakpoint, Cvoid, (Any,), nothing)
           a &lt;: b
       end</code></pre><p>and then set a breakpoint in <code>jl_breakpoint</code>.  Once this breakpoint gets triggered, you can set breakpoints in other functions.</p><p>As a warm-up, try the following:</p><pre><code class="language-julia">mysubtype(Tuple{Int,Float64}, Tuple{Integer,Real})</code></pre><p>We can make it more interesting by trying a more complex case:</p><pre><code class="language-julia">mysubtype(Tuple{Array{Int,2}, Int8}, Tuple{Array{T}, T} where T)</code></pre><h2><a class="nav-anchor" id="Subtyping-and-method-sorting-1" href="#Subtyping-and-method-sorting-1">Subtyping and method sorting</a></h2><p>The <code>type_morespecific</code> functions are used for imposing a partial order on functions in method tables (from most-to-least specific). Specificity is strict; if <code>a</code> is more specific than <code>b</code>, then <code>a</code> does not equal <code>b</code> and <code>b</code> is not more specific than <code>a</code>.</p><p>If <code>a</code> is a strict subtype of <code>b</code>, then it is automatically considered more specific. From there, <code>type_morespecific</code> employs some less formal rules. For example, <code>subtype</code> is sensitive to the number of arguments, but <code>type_morespecific</code> may not be. In particular, <code>Tuple{Int,AbstractFloat}</code> is more specific than <code>Tuple{Integer}</code>, even though it is not a subtype.  (Of <code>Tuple{Int,AbstractFloat}</code> and <code>Tuple{Integer,Float64}</code>, neither is more specific than the other.)  Likewise, <code>Tuple{Int,Vararg{Int}}</code> is not a subtype of <code>Tuple{Integer}</code>, but it is considered more specific. However, <code>morespecific</code> does get a bonus for length: in particular, <code>Tuple{Int,Int}</code> is more specific than <code>Tuple{Int,Vararg{Int}}</code>.</p><p>If you&#39;re debugging how methods get sorted, it can be convenient to define the function:</p><pre><code class="language-julia">type_morespecific(a, b) = ccall(:jl_type_morespecific, Cint, (Any,Any), a, b)</code></pre><p>which allows you to test whether tuple type <code>a</code> is more specific than tuple type <code>b</code>.</p><footer><hr/><a class="previous" href="../ast/"><span class="direction">Previous</span><span class="title">Julia ASTs</span></a><a class="next" href="../object/"><span class="direction">Next</span><span class="title">Memory layout of Julia Objects</span></a></footer></article></body></html>
