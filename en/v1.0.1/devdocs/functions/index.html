<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Julia Functions Â· The Julia Language</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-28835595-6', 'auto');
ga('send', 'pageview');
</script><link rel="canonical" href="https://docs.julialang.org/en/v1/devdocs/functions/index.html"/><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../../assets/julia-manual.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../../index.html"><img class="logo" src="../../assets/logo.png" alt="The Julia Language logo"/></a><h1>The Julia Language</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../../manual/getting-started/">Getting Started</a></li><li><a class="toctext" href="../../manual/variables/">Variables</a></li><li><a class="toctext" href="../../manual/integers-and-floating-point-numbers/">Integers and Floating-Point Numbers</a></li><li><a class="toctext" href="../../manual/mathematical-operations/">Mathematical Operations and Elementary Functions</a></li><li><a class="toctext" href="../../manual/complex-and-rational-numbers/">Complex and Rational Numbers</a></li><li><a class="toctext" href="../../manual/strings/">Strings</a></li><li><a class="toctext" href="../../manual/functions/">Functions</a></li><li><a class="toctext" href="../../manual/control-flow/">Control Flow</a></li><li><a class="toctext" href="../../manual/variables-and-scoping/">Scope of Variables</a></li><li><a class="toctext" href="../../manual/types/">Types</a></li><li><a class="toctext" href="../../manual/methods/">Methods</a></li><li><a class="toctext" href="../../manual/constructors/">Constructors</a></li><li><a class="toctext" href="../../manual/conversion-and-promotion/">Conversion and Promotion</a></li><li><a class="toctext" href="../../manual/interfaces/">Interfaces</a></li><li><a class="toctext" href="../../manual/modules/">Modules</a></li><li><a class="toctext" href="../../manual/documentation/">Documentation</a></li><li><a class="toctext" href="../../manual/metaprogramming/">Metaprogramming</a></li><li><a class="toctext" href="../../manual/arrays/">Multi-dimensional Arrays</a></li><li><a class="toctext" href="../../manual/missing/">Missing Values</a></li><li><a class="toctext" href="../../manual/networking-and-streams/">Networking and Streams</a></li><li><a class="toctext" href="../../manual/parallel-computing/">Parallel Computing</a></li><li><a class="toctext" href="../../manual/running-external-programs/">Running External Programs</a></li><li><a class="toctext" href="../../manual/calling-c-and-fortran-code/">Calling C and Fortran Code</a></li><li><a class="toctext" href="../../manual/handling-operating-system-variation/">Handling Operating System Variation</a></li><li><a class="toctext" href="../../manual/environment-variables/">Environment Variables</a></li><li><a class="toctext" href="../../manual/embedding/">Embedding Julia</a></li><li><a class="toctext" href="../../manual/code-loading/">Code Loading</a></li><li><a class="toctext" href="../../manual/profile/">Profiling</a></li><li><a class="toctext" href="../../manual/stacktraces/">Stack Traces</a></li><li><a class="toctext" href="../../manual/performance-tips/">Performance Tips</a></li><li><a class="toctext" href="../../manual/workflow-tips/">Workflow Tips</a></li><li><a class="toctext" href="../../manual/style-guide/">Style Guide</a></li><li><a class="toctext" href="../../manual/faq/">Frequently Asked Questions</a></li><li><a class="toctext" href="../../manual/noteworthy-differences/">Noteworthy Differences from other Languages</a></li><li><a class="toctext" href="../../manual/unicode-input/">Unicode Input</a></li></ul></li><li><span class="toctext">Base</span><ul><li><a class="toctext" href="../../base/base/">Essentials</a></li><li><a class="toctext" href="../../base/collections/">Collections and Data Structures</a></li><li><a class="toctext" href="../../base/math/">Mathematics</a></li><li><a class="toctext" href="../../base/numbers/">Numbers</a></li><li><a class="toctext" href="../../base/strings/">Strings</a></li><li><a class="toctext" href="../../base/arrays/">Arrays</a></li><li><a class="toctext" href="../../base/parallel/">Tasks</a></li><li><a class="toctext" href="../../base/multi-threading/">Multi-Threading</a></li><li><a class="toctext" href="../../base/constants/">Constants</a></li><li><a class="toctext" href="../../base/file/">Filesystem</a></li><li><a class="toctext" href="../../base/io-network/">I/O and Network</a></li><li><a class="toctext" href="../../base/punctuation/">Punctuation</a></li><li><a class="toctext" href="../../base/sort/">Sorting and Related Functions</a></li><li><a class="toctext" href="../../base/iterators/">Iteration utilities</a></li><li><a class="toctext" href="../../base/c/">C Interface</a></li><li><a class="toctext" href="../../base/libc/">C Standard Library</a></li><li><a class="toctext" href="../../base/stacktraces/">StackTraces</a></li><li><a class="toctext" href="../../base/simd-types/">SIMD Support</a></li></ul></li><li><span class="toctext">Standard Library</span><ul><li><a class="toctext" href="../../stdlib/Base64/">Base64</a></li><li><a class="toctext" href="../../stdlib/CRC32c/">CRC32c</a></li><li><a class="toctext" href="../../stdlib/Dates/">Dates</a></li><li><a class="toctext" href="../../stdlib/DelimitedFiles/">Delimited Files</a></li><li><a class="toctext" href="../../stdlib/Distributed/">Distributed Computing</a></li><li><a class="toctext" href="../../stdlib/FileWatching/">File Events</a></li><li><a class="toctext" href="../../stdlib/InteractiveUtils/">Interactive Utilities</a></li><li><a class="toctext" href="../../stdlib/LibGit2/">LibGit2</a></li><li><a class="toctext" href="../../stdlib/Libdl/">Dynamic Linker</a></li><li><a class="toctext" href="../../stdlib/LinearAlgebra/">Linear Algebra</a></li><li><a class="toctext" href="../../stdlib/Logging/">Logging</a></li><li><a class="toctext" href="../../stdlib/Markdown/">Markdown</a></li><li><a class="toctext" href="../../stdlib/Mmap/">Memory-mapped I/O</a></li><li><a class="toctext" href="../../stdlib/Pkg/">Pkg</a></li><li><a class="toctext" href="../../stdlib/Printf/">Printf</a></li><li><a class="toctext" href="../../stdlib/Profile/">Profiling</a></li><li><a class="toctext" href="../../stdlib/REPL/">The Julia REPL</a></li><li><a class="toctext" href="../../stdlib/Random/">Random Numbers</a></li><li><a class="toctext" href="../../stdlib/SHA/">SHA</a></li><li><a class="toctext" href="../../stdlib/Serialization/">Serialization</a></li><li><a class="toctext" href="../../stdlib/SharedArrays/">Shared Arrays</a></li><li><a class="toctext" href="../../stdlib/Sockets/">Sockets</a></li><li><a class="toctext" href="../../stdlib/SparseArrays/">Sparse Arrays</a></li><li><a class="toctext" href="../../stdlib/Statistics/">Statistics</a></li><li><a class="toctext" href="../../stdlib/Test/">Unit Testing</a></li><li><a class="toctext" href="../../stdlib/UUIDs/">UUIDs</a></li><li><a class="toctext" href="../../stdlib/Unicode/">Unicode</a></li></ul></li><li><span class="toctext">Developer Documentation</span><ul><li><a class="toctext" href="../reflection/">Reflection and introspection</a></li><li><span class="toctext">Documentation of Julia&#39;s Internals</span><ul><li><a class="toctext" href="../init/">Initialization of the Julia runtime</a></li><li><a class="toctext" href="../ast/">Julia ASTs</a></li><li><a class="toctext" href="../types/">More about types</a></li><li><a class="toctext" href="../object/">Memory layout of Julia Objects</a></li><li><a class="toctext" href="../eval/">Eval of Julia code</a></li><li><a class="toctext" href="../callconv/">Calling Conventions</a></li><li><a class="toctext" href="../compiler/">High-level Overview of the Native-Code Generation Process</a></li><li class="current"><a class="toctext" href>Julia Functions</a><ul class="internal"><li><a class="toctext" href="#Method-Tables-1">Method Tables</a></li><li><a class="toctext" href="#Function-calls-1">Function calls</a></li><li><a class="toctext" href="#Adding-methods-1">Adding methods</a></li><li><a class="toctext" href="#Creating-generic-functions-1">Creating generic functions</a></li><li><a class="toctext" href="#Closures-1">Closures</a></li><li><a class="toctext" href="#Constructors-1">Constructors</a></li><li><a class="toctext" href="#Builtins-1">Builtins</a></li><li><a class="toctext" href="#Keyword-arguments-1">Keyword arguments</a></li><li><a class="toctext" href="#Compiler-efficiency-issues-1">Compiler efficiency issues</a></li></ul></li><li><a class="toctext" href="../cartesian/">Base.Cartesian</a></li><li><a class="toctext" href="../meta/">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="../subarrays/">SubArrays</a></li><li><a class="toctext" href="../isbitsunionarrays/">isbits Union Optimizations</a></li><li><a class="toctext" href="../sysimg/">System Image Building</a></li><li><a class="toctext" href="../llvm/">Working with LLVM</a></li><li><a class="toctext" href="../stdio/">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="../boundscheck/">Bounds checking</a></li><li><a class="toctext" href="../locks/">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="../offset-arrays/">Arrays with custom indices</a></li><li><a class="toctext" href="../require/">Module loading</a></li><li><a class="toctext" href="../inference/">Inference</a></li></ul></li><li><span class="toctext">Developing/debugging Julia&#39;s C code</span><ul><li><a class="toctext" href="../backtraces/">Reporting and analyzing crashes (segfaults)</a></li><li><a class="toctext" href="../debuggingtips/">gdb debugging tips</a></li><li><a class="toctext" href="../valgrind/">Using Valgrind with Julia</a></li><li><a class="toctext" href="../sanitizers/">Sanitizer support</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Developer Documentation</li><li>Documentation of Julia&#39;s Internals</li><li><a href>Julia Functions</a></li></ul><a class="edit-page" href="https://github.com/JuliaLang/julia/blob/master/doc/src/devdocs/functions.md"><span class="fa">ï</span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Julia Functions</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Julia-Functions-1" href="#Julia-Functions-1">Julia Functions</a></h1><p>This document will explain how functions, method definitions, and method tables work.</p><h2><a class="nav-anchor" id="Method-Tables-1" href="#Method-Tables-1">Method Tables</a></h2><p>Every function in Julia is a generic function. A generic function is conceptually a single function, but consists of many definitions, or methods. The methods of a generic function are stored in a method table. Method tables (type <code>MethodTable</code>) are associated with <code>TypeName</code>s. A <code>TypeName</code> describes a family of parameterized types. For example <code>Complex{Float32}</code> and <code>Complex{Float64}</code> share the same <code>Complex</code> type name object.</p><p>All objects in Julia are potentially callable, because every object has a type, which in turn has a <code>TypeName</code>.</p><h2><a class="nav-anchor" id="Function-calls-1" href="#Function-calls-1">Function calls</a></h2><p>Given the call <code>f(x,y)</code>, the following steps are performed: first, the method table to use is accessed as <code>typeof(f).name.mt</code>. Second, an argument tuple type is formed, <code>Tuple{typeof(f), typeof(x), typeof(y)}</code>. Note that the type of the function itself is the first element. This is because the type might have parameters, and so needs to take part in dispatch. This tuple type is looked up in the method table.</p><p>This dispatch process is performed by <code>jl_apply_generic</code>, which takes two arguments: a pointer to an array of the values f, x, and y, and the number of values (in this case 3).</p><p>Throughout the system, there are two kinds of APIs that handle functions and argument lists: those that accept the function and arguments separately, and those that accept a single argument structure. In the first kind of API, the &quot;arguments&quot; part does <em>not</em> contain information about the function, since that is passed separately. In the second kind of API, the function is the first element of the argument structure.</p><p>For example, the following function for performing a call accepts just an <code>args</code> pointer, so the first element of the args array will be the function to call:</p><pre><code class="language-c">jl_value_t *jl_apply(jl_value_t **args, uint32_t nargs)</code></pre><p>This entry point for the same functionality accepts the function separately, so the <code>args</code> array does not contain the function:</p><pre><code class="language-c">jl_value_t *jl_call(jl_function_t *f, jl_value_t **args, int32_t nargs);</code></pre><h2><a class="nav-anchor" id="Adding-methods-1" href="#Adding-methods-1">Adding methods</a></h2><p>Given the above dispatch process, conceptually all that is needed to add a new method is (1) a tuple type, and (2) code for the body of the method. <code>jl_method_def</code> implements this operation. <code>jl_first_argument_datatype</code> is called to extract the relevant method table from what would be the type of the first argument. This is much more complicated than the corresponding procedure during dispatch, since the argument tuple type might be abstract. For example, we can define:</p><pre><code class="language-julia">(::Union{Foo{Int},Foo{Int8}})(x) = 0</code></pre><p>which works since all possible matching methods would belong to the same method table.</p><h2><a class="nav-anchor" id="Creating-generic-functions-1" href="#Creating-generic-functions-1">Creating generic functions</a></h2><p>Since every object is callable, nothing special is needed to create a generic function. Therefore <code>jl_new_generic_function</code> simply creates a new singleton (0 size) subtype of <code>Function</code> and returns its instance. A function can have a mnemonic &quot;display name&quot; which is used in debug info and when printing objects. For example the name of <code>Base.sin</code> is <code>sin</code>. By convention, the name of the created <em>type</em> is the same as the function name, with a <code>#</code> prepended. So <code>typeof(sin)</code> is <code>Base.#sin</code>.</p><h2><a class="nav-anchor" id="Closures-1" href="#Closures-1">Closures</a></h2><p>A closure is simply a callable object with field names corresponding to captured variables. For example, the following code:</p><pre><code class="language-julia">function adder(x)
    return y-&gt;x+y
end</code></pre><p>is lowered to (roughly):</p><pre><code class="language-julia">struct ##1{T}
    x::T
end

(_::##1)(y) = _.x + y

function adder(x)
    return ##1(x)
end</code></pre><h2><a class="nav-anchor" id="Constructors-1" href="#Constructors-1">Constructors</a></h2><p>A constructor call is just a call to a type. The method table for <code>Type</code> contains all constructor definitions. All subtypes of <code>Type</code> (<code>Type</code>, <code>UnionAll</code>, <code>Union</code>, and <code>DataType</code>) currently share a method table via special arrangement.</p><h2><a class="nav-anchor" id="Builtins-1" href="#Builtins-1">Builtins</a></h2><p>The &quot;builtin&quot; functions, defined in the <code>Core</code> module, are:</p><pre><code class="language-none">=== typeof sizeof &lt;: isa typeassert throw tuple getfield setfield! fieldtype
nfields isdefined arrayref arrayset arraysize applicable invoke apply_type _apply
_expr svec</code></pre><p>These are all singleton objects whose types are subtypes of <code>Builtin</code>, which is a subtype of <code>Function</code>. Their purpose is to expose entry points in the run time that use the &quot;jlcall&quot; calling convention:</p><pre><code class="language-c">jl_value_t *(jl_value_t*, jl_value_t**, uint32_t)</code></pre><p>The method tables of builtins are empty. Instead, they have a single catch-all method cache entry (<code>Tuple{Vararg{Any}}</code>) whose jlcall fptr points to the correct function. This is kind of a hack but works reasonably well.</p><h2><a class="nav-anchor" id="Keyword-arguments-1" href="#Keyword-arguments-1">Keyword arguments</a></h2><p>Keyword arguments work by associating a special, hidden function object with each method table that has definitions with keyword arguments. This function is called the &quot;keyword argument sorter&quot; or &quot;keyword sorter&quot;, or &quot;kwsorter&quot;, and is stored in the <code>kwsorter</code> field of <code>MethodTable</code> objects. Every definition in the kwsorter function has the same arguments as some definition in the normal method table, except with a single <code>NamedTuple</code> argument prepended, which gives the names and values of passed keyword arguments. The kwsorter&#39;s job is to move keyword arguments into their canonical positions based on name, plus evaluate and substitute any needed default value expressions. The result is a normal positional argument list, which is then passed to yet another compiler-generated function.</p><p>The easiest way to understand the process is to look at how a keyword argument method definition is lowered. The code:</p><pre><code class="language-julia">function circle(center, radius; color = black, fill::Bool = true, options...)
    # draw
end</code></pre><p>actually produces <em>three</em> method definitions. The first is a function that accepts all arguments (including keyword arguments) as positional arguments, and includes the code for the method body. It has an auto-generated name:</p><pre><code class="language-julia">function #circle#1(color, fill::Bool, options, circle, center, radius)
    # draw
end</code></pre><p>The second method is an ordinary definition for the original <code>circle</code> function, which handles the case where no keyword arguments are passed:</p><pre><code class="language-julia">function circle(center, radius)
    #circle#1(black, true, pairs(NamedTuple()), circle, center, radius)
end</code></pre><p>This simply dispatches to the first method, passing along default values. <code>pairs</code> is applied to the named tuple of rest arguments to provide key-value pair iteration. Note that if the method doesn&#39;t accept rest keyword arguments then this argument is absent.</p><p>Finally there is the kwsorter definition:</p><pre><code class="language-none">function (::Core.kwftype(typeof(circle)))(kws, circle, center, radius)
    if haskey(kws, :color)
        color = kws.color
    else
        color = black
    end
    # etc.

    # put remaining kwargs in `options`
    options = structdiff(kws, NamedTuple{(:color, :fill)})

    # if the method doesn&#39;t accept rest keywords, throw an error
    # unless `options` is empty

    #circle#1(color, fill, pairs(options), circle, center, radius)
end</code></pre><p>The function <code>Core.kwftype(t)</code> creates the field <code>t.name.mt.kwsorter</code> (if it hasn&#39;t been created yet), and returns the type of that function.</p><p>This design has the feature that call sites that don&#39;t use keyword arguments require no special handling; everything works as if they were not part of the language at all. Call sites that do use keyword arguments are dispatched directly to the called function&#39;s kwsorter. For example the call:</p><pre><code class="language-julia">circle((0,0), 1.0, color = red; other...)</code></pre><p>is lowered to:</p><pre><code class="language-julia">kwfunc(circle)(merge((color = red,), other), circle, (0,0), 1.0)</code></pre><p><code>kwfunc</code> (also in<code>Core</code>) fetches the kwsorter for the called function. The keyword splatting operation (written as <code>other...</code>) calls the named tuple <code>merge</code> function. This function further unpacks each <em>element</em> of <code>other</code>, expecting each one to contain two values (a symbol and a value). Naturally, a more efficient implementation is available if all splatted arguments are named tuples. Notice that the original <code>circle</code> function is passed through, to handle closures.</p><h2><a class="nav-anchor" id="Compiler-efficiency-issues-1" href="#Compiler-efficiency-issues-1">Compiler efficiency issues</a></h2><p>Generating a new type for every function has potentially serious consequences for compiler resource use when combined with Julia&#39;s &quot;specialize on all arguments by default&quot; design. Indeed, the initial implementation of this design suffered from much longer build and test times, higher memory use, and a system image nearly 2x larger than the baseline. In a naive implementation, the problem is bad enough to make the system nearly unusable. Several significant optimizations were needed to make the design practical.</p><p>The first issue is excessive specialization of functions for different values of function-valued arguments. Many functions simply &quot;pass through&quot; an argument to somewhere else, e.g. to another function or to a storage location. Such functions do not need to be specialized for every closure that might be passed in. Fortunately this case is easy to distinguish by simply considering whether a function <em>calls</em> one of its arguments (i.e. the argument appears in &quot;head position&quot; somewhere). Performance-critical higher-order functions like <code>map</code> certainly call their argument function and so will still be specialized as expected. This optimization is implemented by recording which arguments are called during the <code>analyze-variables</code> pass in the front end. When <code>cache_method</code> sees an argument in the <code>Function</code> type hierarchy passed to a slot declared as <code>Any</code> or <code>Function</code>, it behaves as if the <code>@nospecialize</code> annotation were applied. This heuristic seems to be extremely effective in practice.</p><p>The next issue concerns the structure of method cache hash tables. Empirical studies show that the vast majority of dynamically-dispatched calls involve one or two arguments. In turn, many of these cases can be resolved by considering only the first argument. (Aside: proponents of single dispatch would not be surprised by this at all. However, this argument means &quot;multiple dispatch is easy to optimize in practice&quot;, and that we should therefore use it, <em>not</em> &quot;we should use single dispatch&quot;!) So the method cache uses the type of the first argument as its primary key. Note, however, that this corresponds to the <em>second</em> element of the tuple type for a function call (the first element being the type of the function itself). Typically, type variation in head position is extremely low â indeed, the majority of functions belong to singleton types with no parameters. However, this is not the case for constructors, where a single method table holds constructors for every type. Therefore the <code>Type</code> method table is special-cased to use the <em>first</em> tuple type element instead of the second.</p><p>The front end generates type declarations for all closures. Initially, this was implemented by generating normal type declarations. However, this produced an extremely large number of constructors, all of which were trivial (simply passing all arguments through to <a href="../../base/base/#new"><code>new</code></a>). Since methods are partially ordered, inserting all of these methods is O(n^2), plus there are just too many of them to keep around. This was optimized by generating <code>struct_type</code> expressions directly (bypassing default constructor generation), and using <code>new</code> directly to create closure instances. Not the prettiest thing ever, but you do what you gotta do.</p><p>The next problem was the <code>@test</code> macro, which generated a 0-argument closure for each test case. This is not really necessary, since each test case is simply run once in place. Therefore, <code>@test</code> was modified to expand to a try-catch block that records the test result (true, false, or exception raised) and calls the test suite handler on it.</p><footer><hr/><a class="previous" href="../compiler/"><span class="direction">Previous</span><span class="title">High-level Overview of the Native-Code Generation Process</span></a><a class="next" href="../cartesian/"><span class="direction">Next</span><span class="title">Base.Cartesian</span></a></footer></article></body></html>
