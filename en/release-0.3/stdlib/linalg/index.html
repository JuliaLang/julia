

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Linear Algebra &mdash; Julia Language 0.3.13-pre documentation</title>
  

  
  

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/julia.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../../_static/julia.css" type="text/css" />
  
    <link rel="top" title="Julia Language 0.3.13-pre documentation" href="../../"/>
        <link rel="next" title="Constants" href="../constants/"/>
        <link rel="prev" title="Tasks and Parallel Computing" href="../parallel/"/> 

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        <a href="http://julialang.org/"><img src="../../_static/julia-logo.svg" class="logo"></a>
        <!--
        <a href="../../" class="fa fa-home"> Julia Language</a>
        -->
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search/" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
        
            <ul>
<li class="toctree-l1"><a class="reference internal" href="../../manual/introduction/">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/getting-started/">Getting Started</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/getting-started/#resources">Resources</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/variables/">Variables</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/variables/#allowed-variable-names">Allowed Variable Names</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/variables/#stylistic-conventions">Stylistic Conventions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/integers-and-floating-point-numbers/">Integers and Floating-Point Numbers</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/integers-and-floating-point-numbers/#integers">Integers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/integers-and-floating-point-numbers/#floating-point-numbers">Floating-Point Numbers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/integers-and-floating-point-numbers/#arbitrary-precision-arithmetic">Arbitrary Precision Arithmetic</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/integers-and-floating-point-numbers/#numeric-literal-coefficients">Numeric Literal Coefficients</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/integers-and-floating-point-numbers/#literal-zero-and-one">Literal zero and one</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/mathematical-operations/">Mathematical Operations and Elementary Functions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/mathematical-operations/#arithmetic-operators">Arithmetic Operators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/mathematical-operations/#bitwise-operators">Bitwise Operators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/mathematical-operations/#updating-operators">Updating operators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/mathematical-operations/#numeric-comparisons">Numeric Comparisons</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/mathematical-operations/#elementary-functions">Elementary Functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/complex-and-rational-numbers/">Complex and Rational Numbers</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/complex-and-rational-numbers/#complex-numbers">Complex Numbers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/complex-and-rational-numbers/#rational-numbers">Rational Numbers</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/strings/">Strings</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/strings/#characters">Characters</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/strings/#string-basics"><tt class="docutils literal"><span class="pre">String</span></tt> Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/strings/#unicode-and-utf-8">Unicode and UTF-8</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/strings/#interpolation">Interpolation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/strings/#common-operations">Common Operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/strings/#non-standard-string-literals">Non-Standard String Literals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/strings/#regular-expressions">Regular Expressions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/strings/#id3">Byte Array Literals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/strings/#version-number-literals">Version Number Literals</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/functions/">Functions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/functions/#argument-passing-behavior">Argument Passing Behavior</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/functions/#the-return-keyword">The <tt class="docutils literal"><span class="pre">return</span></tt> Keyword</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/functions/#id1">Operators Are Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/functions/#operators-with-special-names">Operators With Special Names</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/functions/#anonymous-functions">Anonymous Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/functions/#multiple-return-values">Multiple Return Values</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/functions/#varargs-functions">Varargs Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/functions/#optional-arguments">Optional Arguments</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/functions/#keyword-arguments">Keyword Arguments</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/functions/#evaluation-scope-of-default-values">Evaluation Scope of Default Values</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/functions/#do-block-syntax-for-function-arguments">Do-Block Syntax for Function Arguments</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/functions/#further-reading">Further Reading</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/control-flow/">Control Flow</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/control-flow/#compound-expressions">Compound Expressions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/control-flow/#conditional-evaluation">Conditional Evaluation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/control-flow/#short-circuit-evaluation">Short-Circuit Evaluation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/control-flow/#repeated-evaluation-loops">Repeated Evaluation: Loops</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/control-flow/#exception-handling">Exception Handling</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/control-flow/#tasks-aka-coroutines">Tasks (aka Coroutines)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/variables-and-scoping/">Scope of Variables</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/variables-and-scoping/#for-loops-and-comprehensions">For Loops and Comprehensions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/variables-and-scoping/#constants">Constants</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/types/">Types</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/types/#type-declarations">Type Declarations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/types/#abstract-types">Abstract Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/types/#bits-types">Bits Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/types/#composite-types">Composite Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/types/#immutable-composite-types">Immutable Composite Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/types/#declared-types">Declared Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/types/#tuple-types">Tuple Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/types/#type-unions">Type Unions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/types/#man-parametric-types">Parametric Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/types/#type-aliases">Type Aliases</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/types/#operations-on-types">Operations on Types</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/methods/">Methods</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/methods/#defining-methods">Defining Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/methods/#method-ambiguities">Method Ambiguities</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/methods/#parametric-methods">Parametric Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/methods/#note-on-optional-and-keyword-arguments">Note on Optional and keyword Arguments</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/constructors/">Constructors</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/constructors/#outer-constructor-methods">Outer Constructor Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/constructors/#inner-constructor-methods">Inner Constructor Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/constructors/#incomplete-initialization">Incomplete Initialization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/constructors/#parametric-constructors">Parametric Constructors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/constructors/#case-study-rational">Case Study: Rational</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/conversion-and-promotion/">Conversion and Promotion</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/conversion-and-promotion/#conversion">Conversion</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/conversion-and-promotion/#promotion">Promotion</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/modules/">Modules</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/modules/#summary-of-module-usage">Summary of module usage</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/metaprogramming/">Metaprogramming</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/metaprogramming/#program-representation">Program representation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/metaprogramming/#expressions-and-evaluation">Expressions and evaluation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/metaprogramming/#macros">Macros</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/metaprogramming/#code-generation">Code Generation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/metaprogramming/#non-standard-string-literals">Non-Standard String Literals</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/arrays/">Multi-dimensional Arrays</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/arrays/#arrays">Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/arrays/#sparse-matrices">Sparse Matrices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/linear-algebra/">Linear algebra</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/linear-algebra/#matrix-factorizations">Matrix factorizations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/linear-algebra/#special-matrices">Special matrices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/networking-and-streams/">Networking and Streams</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/networking-and-streams/#basic-stream-i-o">Basic Stream I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/networking-and-streams/#text-i-o">Text I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/networking-and-streams/#working-with-files">Working with Files</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/networking-and-streams/#a-simple-tcp-example">A simple TCP example</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/networking-and-streams/#resolving-ip-addresses">Resolving IP Addresses</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/parallel-computing/">Parallel Computing</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/parallel-computing/#code-availability-and-loading-packages">Code Availability and Loading Packages</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/parallel-computing/#data-movement">Data Movement</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/parallel-computing/#parallel-map-and-loops">Parallel Map and Loops</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/parallel-computing/#synchronization-with-remote-references">Synchronization With Remote References</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/parallel-computing/#scheduling">Scheduling</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/parallel-computing/#distributed-arrays">Distributed Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/parallel-computing/#constructing-distributed-arrays">Constructing Distributed Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/parallel-computing/#distributed-array-operations">Distributed Array Operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/parallel-computing/#shared-arrays-experimental">Shared Arrays (Experimental)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/parallel-computing/#clustermanagers">ClusterManagers</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/running-external-programs/">Running External Programs</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/running-external-programs/#interpolation">Interpolation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/running-external-programs/#quoting">Quoting</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/running-external-programs/#pipelines">Pipelines</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/calling-c-and-fortran-code/">Calling C and Fortran Code</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/calling-c-and-fortran-code/#mapping-c-types-to-julia">Mapping C Types to Julia</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/calling-c-and-fortran-code/#accessing-data-through-a-pointer">Accessing Data through a Pointer</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/calling-c-and-fortran-code/#passing-pointers-for-modifying-inputs">Passing Pointers for Modifying Inputs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/calling-c-and-fortran-code/#garbage-collection-safety">Garbage Collection Safety</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/calling-c-and-fortran-code/#non-constant-function-specifications">Non-constant Function Specifications</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/calling-c-and-fortran-code/#indirect-calls">Indirect Calls</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/calling-c-and-fortran-code/#calling-convention">Calling Convention</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/calling-c-and-fortran-code/#accessing-global-variables">Accessing Global Variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/calling-c-and-fortran-code/#passing-julia-callback-functions-to-c">Passing Julia Callback Functions to C</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/calling-c-and-fortran-code/#c">C++</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/calling-c-and-fortran-code/#handling-platform-variations">Handling Platform Variations</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/interacting-with-julia/">Interacting With Julia</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/interacting-with-julia/#the-different-prompt-modes">The different prompt modes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/interacting-with-julia/#key-bindings">Key bindings</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/interacting-with-julia/#tab-completion">Tab completion</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/embedding/">Embedding Julia</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/embedding/#high-level-embedding">High-Level Embedding</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/embedding/#converting-types">Converting Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/embedding/#calling-julia-functions">Calling Julia Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/embedding/#memory-management">Memory Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/embedding/#working-with-arrays">Working with Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/embedding/#exceptions">Exceptions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/packages/">Packages</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/packages/#package-status">Package Status</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/packages/#adding-and-removing-packages">Adding and Removing Packages</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/packages/#installing-unregistered-packages">Installing Unregistered Packages</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/packages/#updating-packages">Updating Packages</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/packages/#checkout-pin-and-free">Checkout, Pin and Free</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/packages/#package-development">Package Development</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/packages/#initial-setup">Initial Setup</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/packages/#making-changes-to-an-existing-package">Making changes to an existing package</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/packages/#creating-a-new-package">Creating a new Package</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/packages/#tagging-package-versions">Tagging Package Versions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/packages/#fixing-package-requirements">Fixing Package Requirements</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/packages/#man-package-requirements">Requirements Specification</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/profile/">Profiling</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/profile/#basic-usage">Basic usage</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/profile/#accumulation-and-clearing">Accumulation and clearing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/profile/#options-for-controlling-the-display-of-profile-results">Options for controlling the display of profile results</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/profile/#configuration">Configuration</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/profile/#memory-allocation-analysis">Memory allocation analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/performance-tips/">Performance Tips</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#avoid-global-variables">Avoid global variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#measure-performance-with-time-and-pay-attention-to-memory-allocation">Measure performance with <tt class="docutils literal"><span class="pre">&#64;time</span></tt> and pay attention to memory allocation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#tools">Tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#avoid-containers-with-abstract-type-parameters">Avoid containers with abstract type parameters</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#type-declarations">Type declarations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#break-functions-into-multiple-definitions">Break functions into multiple definitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#write-type-stable-functions">Write &#8220;type-stable&#8221; functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#avoid-changing-the-type-of-a-variable">Avoid changing the type of a variable</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#separate-kernel-functions">Separate kernel functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#access-arrays-in-memory-order-along-columns">Access arrays in memory order, along columns</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#pre-allocating-outputs">Pre-allocating outputs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#avoid-string-interpolation-for-i-o">Avoid string interpolation for I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#optimize-network-i-o-during-parallel-execution">Optimize network I/O during parallel execution</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#fix-deprecation-warnings">Fix deprecation warnings</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#tweaks">Tweaks</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/performance-tips/#performance-annotations">Performance Annotations</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/workflow-tips/">Workflow Tips</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/workflow-tips/#repl-based-workflow">REPL-based workflow</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/workflow-tips/#browser-based-workflow">Browser-based workflow</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/style-guide/">Style Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#write-functions-not-just-scripts">Write functions, not just scripts</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#avoid-writing-overly-specific-types">Avoid writing overly-specific types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#handle-excess-argument-diversity-in-the-caller">Handle excess argument diversity in the caller</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#append-to-names-of-functions-that-modify-their-arguments">Append <cite>!</cite> to names of functions that modify their arguments</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#avoid-strange-type-unions">Avoid strange type Unions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#try-to-avoid-nullable-fields">Try to avoid nullable fields</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#avoid-elaborate-container-types">Avoid elaborate container types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#use-naming-conventions-consistent-with-julia-s-base">Use naming conventions consistent with Julia&#8217;s <tt class="docutils literal"><span class="pre">base/</span></tt></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#don-t-overuse-try-catch">Don&#8217;t overuse try-catch</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#don-t-parenthesize-conditions">Don&#8217;t parenthesize conditions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#don-t-overuse">Don&#8217;t overuse ...</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#don-t-use-unnecessary-static-parameters">Don&#8217;t use unnecessary static parameters</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#avoid-confusion-about-whether-something-is-an-instance-or-a-type">Avoid confusion about whether something is an instance or a type</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#don-t-overuse-macros">Don&#8217;t overuse macros</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#don-t-expose-unsafe-operations-at-the-interface-level">Don&#8217;t expose unsafe operations at the interface level</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#don-t-overload-methods-of-base-container-types">Don&#8217;t overload methods of base container types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#be-careful-with-type-equality">Be careful with type equality</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/style-guide/#do-not-write-x-f-x">Do not write <tt class="docutils literal"><span class="pre">x-&gt;f(x)</span></tt></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/faq/">Frequently Asked Questions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/faq/#sessions-and-the-repl">Sessions and the REPL</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/faq/#functions">Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/faq/#types-type-declarations-and-constructors">Types, type declarations, and constructors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/faq/#nothingness-and-missing-values">Nothingness and missing values</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/faq/#memory">Memory</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/faq/#julia-releases">Julia Releases</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/noteworthy-differences/">Noteworthy Differences from other Languages</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/noteworthy-differences/#noteworthy-differences-from-matlab">Noteworthy differences from MATLAB</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/noteworthy-differences/#noteworthy-differences-from-r">Noteworthy differences from R</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/noteworthy-differences/#noteworthy-differences-from-python">Noteworthy differences from Python</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/unicode-input/">Unicode Input</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../base/">Essentials</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../base/#introduction">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../base/#getting-around">Getting Around</a></li>
<li class="toctree-l2"><a class="reference internal" href="../base/#all-objects">All Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="../base/#types">Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../base/#generic-functions">Generic Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../base/#syntax">Syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="../base/#system">System</a></li>
<li class="toctree-l2"><a class="reference internal" href="../base/#errors">Errors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../base/#events">Events</a></li>
<li class="toctree-l2"><a class="reference internal" href="../base/#reflection">Reflection</a></li>
<li class="toctree-l2"><a class="reference internal" href="../base/#internals">Internals</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../collections/">Collections and Data Structures</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../collections/#iteration">Iteration</a></li>
<li class="toctree-l2"><a class="reference internal" href="../collections/#general-collections">General Collections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../collections/#iterable-collections">Iterable Collections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../collections/#indexable-collections">Indexable Collections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../collections/#associative-collections">Associative Collections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../collections/#set-like-collections">Set-Like Collections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../collections/#dequeues">Dequeues</a></li>
<li class="toctree-l2"><a class="reference internal" href="../collections/#priorityqueue">PriorityQueue</a></li>
<li class="toctree-l2"><a class="reference internal" href="../collections/#heap-functions">Heap Functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../math/">Mathematics</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../math/#mathematical-operators">Mathematical Operators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../math/#mathematical-functions">Mathematical Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../math/#statistics">Statistics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../math/#signal-processing">Signal Processing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../math/#numerical-integration">Numerical Integration</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../numbers/">Numbers</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../numbers/#standard-numeric-types">Standard Numeric Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../numbers/#data-formats">Data Formats</a></li>
<li class="toctree-l2"><a class="reference internal" href="../numbers/#id1">Numbers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../numbers/#bigfloats">BigFloats</a></li>
<li class="toctree-l2"><a class="reference internal" href="../numbers/#random-numbers">Random Numbers</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../strings/">Strings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../arrays/">Arrays</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../arrays/#basic-functions">Basic functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../arrays/#constructors">Constructors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../arrays/#mathematical-operators-and-functions">Mathematical operators and functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../arrays/#indexing-assignment-and-concatenation">Indexing, Assignment, and Concatenation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../arrays/#array-functions">Array functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../arrays/#combinatorics">Combinatorics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../arrays/#bitarrays">BitArrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="../arrays/#sparse-matrices">Sparse Matrices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../parallel/">Tasks and Parallel Computing</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../parallel/#tasks">Tasks</a></li>
<li class="toctree-l2"><a class="reference internal" href="../parallel/#general-parallel-computing-support">General Parallel Computing Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../parallel/#distributed-arrays">Distributed Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="../parallel/#shared-arrays-experimental-unix-only-feature">Shared Arrays (Experimental, UNIX-only feature)</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="current reference internal" href="">Linear Algebra</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#module-Base.LinAlg">Standard Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-Base.LinAlg.BLAS">BLAS Functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../constants/">Constants</a></li>
<li class="toctree-l1"><a class="reference internal" href="../file/">Filesystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../io-network/">I/O and Network</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../io-network/#general-i-o">General I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../io-network/#network-i-o">Network I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../io-network/#text-i-o">Text I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../io-network/#multimedia-i-o">Multimedia I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../io-network/#memory-mapped-i-o">Memory-mapped I/O</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../punctuation/">Punctuation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sort/">Sorting and Related Functions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../sort/#sorting-functions">Sorting Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sort/#order-related-functions">Order-Related Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sort/#sorting-algorithms">Sorting Algorithms</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../pkg/">Package Manager Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../collections/">Collections and Data Structures</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../collections/#iteration">Iteration</a></li>
<li class="toctree-l2"><a class="reference internal" href="../collections/#general-collections">General Collections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../collections/#iterable-collections">Iterable Collections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../collections/#indexable-collections">Indexable Collections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../collections/#associative-collections">Associative Collections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../collections/#set-like-collections">Set-Like Collections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../collections/#dequeues">Dequeues</a></li>
<li class="toctree-l2"><a class="reference internal" href="../collections/#priorityqueue">PriorityQueue</a></li>
<li class="toctree-l2"><a class="reference internal" href="../collections/#heap-functions">Heap Functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../graphics/">Graphics</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../graphics/#geometry">Geometry</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../test/">Unit and Functional Testing</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../test/#overview">Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="../test/#handlers">Handlers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../test/#macros">Macros</a></li>
<li class="toctree-l2"><a class="reference internal" href="../test/#functions">Functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../test/#testing-base-julia">Testing Base Julia</a></li>
<li class="toctree-l1"><a class="reference internal" href="../c/">C Interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../profile/">Profiling</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../devdocs/reflection/">Reflection and introspection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../devdocs/julia/">Documentation of Julia&#8217;s Internals</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/cartesian/">Base.Cartesian</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/sysimg/">System Image Building</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../devdocs/C/">Developing/debugging Julia&#8217;s C code</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/backtraces/">Reporting and analyzing crashes (segfaults)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/debuggingtips/">gdb debugging tips</a></li>
</ul>
</li>
</ul>

        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../">Julia Language</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../">Docs</a> &raquo;</li>
      
    <li>Linear Algebra</li>
      <li class="wy-breadcrumbs-aside">
        
          <a href="../../_sources/stdlib/linalg.txt" rel="nofollow"> View page source</a>
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document">
            
  <div class="section" id="linear-algebra">
<span id="stdlib-linalg"></span><h1>Linear Algebra<a class="headerlink" href="#linear-algebra" title="Permalink to this headline">¶</a></h1>
<div class="section" id="module-Base.LinAlg">
<span id="standard-functions"></span><h2>Standard Functions<a class="headerlink" href="#module-Base.LinAlg" title="Permalink to this headline">¶</a></h2>
<p>Linear algebra functions in Julia are largely implemented by calling functions from <a class="reference external" href="http://www.netlib.org/lapack/">LAPACK</a>.  Sparse factorizations call functions from <a class="reference external" href="http://faculty.cse.tamu.edu/davis/suitesparse.html">SuiteSparse</a>.</p>
<dl class="function">
<dt>
<tt class="descname">*</tt><big>(</big><em>A</em>, <em>B</em><big>)</big></dt>
<dd><p>Matrix multiplication</p>
</dd></dl>

<dl class="function">
<dt>
<tt class="descname">\</tt><big>(</big><em>A</em>, <em>B</em><big>)</big></dt>
<dd><p>Matrix division using a polyalgorithm. For input matrices <tt class="docutils literal"><span class="pre">A</span></tt> and <tt class="docutils literal"><span class="pre">B</span></tt>, the result <tt class="docutils literal"><span class="pre">X</span></tt> is such that <tt class="docutils literal"><span class="pre">A*X</span> <span class="pre">==</span> <span class="pre">B</span></tt> when <tt class="docutils literal"><span class="pre">A</span></tt> is square.  The solver that is used depends upon the structure of <tt class="docutils literal"><span class="pre">A</span></tt>.  A direct solver is used for upper- or lower triangular <tt class="docutils literal"><span class="pre">A</span></tt>.  For Hermitian <tt class="docutils literal"><span class="pre">A</span></tt> (equivalent to symmetric <tt class="docutils literal"><span class="pre">A</span></tt> for non-complex <tt class="docutils literal"><span class="pre">A</span></tt>) the <tt class="docutils literal"><span class="pre">BunchKaufman</span></tt> factorization is used.  Otherwise an LU factorization is used. For rectangular <tt class="docutils literal"><span class="pre">A</span></tt> the result is the minimum-norm least squares solution computed by a pivoted QR factorization of <tt class="docutils literal"><span class="pre">A</span></tt> and a rank estimate of A based on the R factor. For sparse, square <tt class="docutils literal"><span class="pre">A</span></tt> the LU factorization (from UMFPACK) is used.</p>
</dd></dl>

<dl class="function">
<dt id="Base.dot">
<tt class="descname">dot</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#Base.dot" title="Permalink to this definition">¶</a></dt>
<dt id="Base.⋅">
<tt class="descname">⋅</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#Base.⋅" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the dot product. For complex vectors, the first vector is conjugated.</p>
</dd></dl>

<dl class="function">
<dt id="Base.cross">
<tt class="descname">cross</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#Base.cross" title="Permalink to this definition">¶</a></dt>
<dt id="Base.×">
<tt class="descname">×</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#Base.×" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the cross product of two 3-vectors.</p>
</dd></dl>

<dl class="function">
<dt id="Base.rref">
<tt class="descname">rref</tt><big>(</big><em>A</em><big>)</big><a class="headerlink" href="#Base.rref" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the reduced row echelon form of the matrix A.</p>
</dd></dl>

<dl class="function">
<dt id="Base.factorize">
<tt class="descname">factorize</tt><big>(</big><em>A</em><big>)</big><a class="headerlink" href="#Base.factorize" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute a convenient factorization (including LU, Cholesky, Bunch-Kaufman, Triangular) of A, based upon the type of the input matrix. The return value can then be reused for efficient solving of multiple systems. For example: <tt class="docutils literal"><span class="pre">A=factorize(A);</span> <span class="pre">x=A\\b;</span> <span class="pre">y=A\\C</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.factorize!">
<tt class="descname">factorize!</tt><big>(</big><em>A</em><big>)</big><a class="headerlink" href="#Base.factorize!" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="docutils literal"><span class="pre">factorize!</span></tt> is the same as <a class="reference internal" href="#Base.factorize" title="Base.factorize"><tt class="xref jl jl-func docutils literal"><span class="pre">factorize()</span></tt></a>, but saves space by overwriting the input <tt class="docutils literal"><span class="pre">A</span></tt>, instead of creating a copy.</p>
</dd></dl>

<dl class="function">
<dt id="Base.lu">
<tt class="descname">lu</tt><big>(</big><em>A</em><big>)</big> &rarr; L, U, p<a class="headerlink" href="#Base.lu" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the LU factorization of <tt class="docutils literal"><span class="pre">A</span></tt>, such that <tt class="docutils literal"><span class="pre">A[p,:]</span> <span class="pre">=</span> <span class="pre">L*U</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.lufact">
<tt class="descname">lufact</tt><big>(</big><em>A</em><span class="optional">[</span>, <em>pivot=true</em><span class="optional">]</span><big>)</big> &rarr; F<a class="headerlink" href="#Base.lufact" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the LU factorization of <tt class="docutils literal"><span class="pre">A</span></tt>. The return type of <tt class="docutils literal"><span class="pre">F</span></tt> depends on the type of <tt class="docutils literal"><span class="pre">A</span></tt>. In most cases, if <tt class="docutils literal"><span class="pre">A</span></tt> is a subtype <tt class="docutils literal"><span class="pre">S</span></tt> of AbstractMatrix with an element type <tt class="docutils literal"><span class="pre">T`</span></tt> supporting <tt class="docutils literal"><span class="pre">+</span></tt>, <tt class="docutils literal"><span class="pre">-</span></tt>, <tt class="docutils literal"><span class="pre">*</span></tt> and <tt class="docutils literal"><span class="pre">/</span></tt> the return type is <tt class="docutils literal"><span class="pre">LU{T,S{T}}</span></tt>. If pivoting is chosen (default) the element type should also support <tt class="docutils literal"><span class="pre">abs</span></tt> and <tt class="docutils literal"><span class="pre">&lt;</span></tt>. When <tt class="docutils literal"><span class="pre">A</span></tt> is sparse and have element of type <tt class="docutils literal"><span class="pre">Float32</span></tt>, <tt class="docutils literal"><span class="pre">Float64</span></tt>, <tt class="docutils literal"><span class="pre">Complex{Float32}</span></tt>, or <tt class="docutils literal"><span class="pre">Complex{Float64}</span></tt> the return type is <tt class="docutils literal"><span class="pre">UmfpackLU</span></tt>. Some examples are shown in the table below.</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="27%" />
<col width="48%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Type of input <tt class="docutils literal"><span class="pre">A</span></tt></td>
<td>Type of output <tt class="docutils literal"><span class="pre">F</span></tt></td>
<td>Relationship between <tt class="docutils literal"><span class="pre">F</span></tt> and <tt class="docutils literal"><span class="pre">A</span></tt></td>
</tr>
<tr class="row-even"><td><tt class="xref jl jl-func docutils literal"><span class="pre">Matrix()</span></tt></td>
<td><tt class="docutils literal"><span class="pre">LU</span></tt></td>
<td><tt class="docutils literal"><span class="pre">F[:L]*F[:U]</span> <span class="pre">==</span> <span class="pre">A[F[:p],</span> <span class="pre">:]</span></tt></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Base.Tridiagonal" title="Base.Tridiagonal"><tt class="xref jl jl-func docutils literal"><span class="pre">Tridiagonal()</span></tt></a></td>
<td><tt class="docutils literal"><span class="pre">LU{T,Tridiagonal{T}}</span></tt></td>
<td>N/A</td>
</tr>
<tr class="row-even"><td><tt class="xref jl jl-func docutils literal"><span class="pre">SparseMatrixCSC()</span></tt></td>
<td><tt class="docutils literal"><span class="pre">UmfpackLU</span></tt></td>
<td><tt class="docutils literal"><span class="pre">F[:L]*F[:U]</span> <span class="pre">==</span> <span class="pre">F[:Rs]</span> <span class="pre">.*</span> <span class="pre">A[F[:p],</span> <span class="pre">F[:q]]</span></tt></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>The individual components of the factorization <tt class="docutils literal"><span class="pre">F</span></tt> can be accessed by indexing:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="12%" />
<col width="42%" />
<col width="6%" />
<col width="26%" />
<col width="14%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Component</td>
<td>Description</td>
<td><tt class="docutils literal"><span class="pre">LU</span></tt></td>
<td><tt class="docutils literal"><span class="pre">LU{T,Tridiagonal{T}}</span></tt></td>
<td><tt class="docutils literal"><span class="pre">UmfpackLU</span></tt></td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">F[:L]</span></tt></td>
<td><tt class="docutils literal"><span class="pre">L</span></tt> (lower triangular) part of <tt class="docutils literal"><span class="pre">LU</span></tt></td>
<td>✓</td>
<td>&nbsp;</td>
<td>✓</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">F[:U]</span></tt></td>
<td><tt class="docutils literal"><span class="pre">U</span></tt> (upper triangular) part of <tt class="docutils literal"><span class="pre">LU</span></tt></td>
<td>✓</td>
<td>&nbsp;</td>
<td>✓</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">F[:p]</span></tt></td>
<td>(right) permutation <tt class="docutils literal"><span class="pre">Vector</span></tt></td>
<td>✓</td>
<td>&nbsp;</td>
<td>✓</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">F[:P]</span></tt></td>
<td>(right) permutation <tt class="docutils literal"><span class="pre">Matrix</span></tt></td>
<td>✓</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">F[:q]</span></tt></td>
<td>left permutation <tt class="docutils literal"><span class="pre">Vector</span></tt></td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>✓</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">F[:Rs]</span></tt></td>
<td><tt class="docutils literal"><span class="pre">Vector</span></tt> of scaling factors</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>✓</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">F[:(:)]</span></tt></td>
<td><tt class="docutils literal"><span class="pre">(L,U,p,q,Rs)</span></tt> components</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>✓</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="10%" />
<col width="39%" />
<col width="21%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Supported function</td>
<td><tt class="docutils literal"><span class="pre">LU</span></tt></td>
<td><tt class="docutils literal"><span class="pre">LU{T,Tridiagonal{T}}</span></tt></td>
<td><tt class="docutils literal"><span class="pre">UmfpackLU</span></tt></td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">/</span></tt></td>
<td>✓</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">\</span></tt></td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">cond</span></tt></td>
<td>✓</td>
<td>&nbsp;</td>
<td>✓</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">det</span></tt></td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">size</span></tt></td>
<td>✓</td>
<td>✓</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="Base.lufact!">
<tt class="descname">lufact!</tt><big>(</big><em>A</em><big>)</big> &rarr; LU<a class="headerlink" href="#Base.lufact!" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="docutils literal"><span class="pre">lufact!</span></tt> is the same as <a class="reference internal" href="#Base.lufact" title="Base.lufact"><tt class="xref jl jl-func docutils literal"><span class="pre">lufact()</span></tt></a>, but saves space by overwriting the input A, instead of creating a copy.  For sparse <tt class="docutils literal"><span class="pre">A</span></tt> the <tt class="docutils literal"><span class="pre">nzval</span></tt> field is not overwritten but the index fields, <tt class="docutils literal"><span class="pre">colptr</span></tt> and <tt class="docutils literal"><span class="pre">rowval</span></tt> are decremented in place, converting from 1-based indices to 0-based indices.</p>
</dd></dl>

<dl class="function">
<dt id="Base.chol">
<tt class="descname">chol</tt><big>(</big><em>A</em><span class="optional">[</span>, <em>LU</em><span class="optional">]</span><big>)</big> &rarr; F<a class="headerlink" href="#Base.chol" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Cholesky factorization of a symmetric positive definite matrix <tt class="docutils literal"><span class="pre">A</span></tt> and return the matrix <tt class="docutils literal"><span class="pre">F</span></tt>. If <tt class="docutils literal"><span class="pre">LU</span></tt> is <tt class="docutils literal"><span class="pre">:L</span></tt> (Lower), <tt class="docutils literal"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">L*L'</span></tt>. If <tt class="docutils literal"><span class="pre">LU</span></tt> is <tt class="docutils literal"><span class="pre">:U</span></tt> (Upper), <tt class="docutils literal"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">R'*R</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.cholfact">
<tt class="descname">cholfact</tt><big>(</big><em>A, [LU,][pivot=false,][tol=-1.0]</em><big>)</big> &rarr; Cholesky<a class="headerlink" href="#Base.cholfact" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Cholesky factorization of a dense symmetric positive (semi)definite matrix <tt class="docutils literal"><span class="pre">A</span></tt> and return either a <tt class="docutils literal"><span class="pre">Cholesky</span></tt> if <tt class="docutils literal"><span class="pre">pivot=false</span></tt> or <tt class="docutils literal"><span class="pre">CholeskyPivoted</span></tt> if <tt class="docutils literal"><span class="pre">pivot=true</span></tt>. <tt class="docutils literal"><span class="pre">LU</span></tt> may be <tt class="docutils literal"><span class="pre">:L</span></tt> for using the lower part or <tt class="docutils literal"><span class="pre">:U</span></tt> for the upper part. The default is to use <tt class="docutils literal"><span class="pre">:U</span></tt>. The triangular matrix can be obtained from the factorization <tt class="docutils literal"><span class="pre">F</span></tt> with: <tt class="docutils literal"><span class="pre">F[:L]</span></tt> and <tt class="docutils literal"><span class="pre">F[:U]</span></tt>. The following functions are available for <tt class="docutils literal"><span class="pre">Cholesky</span></tt> objects: <tt class="docutils literal"><span class="pre">size</span></tt>, <tt class="docutils literal"><span class="pre">\</span></tt>, <tt class="docutils literal"><span class="pre">inv</span></tt>, <tt class="docutils literal"><span class="pre">det</span></tt>. For <tt class="docutils literal"><span class="pre">CholeskyPivoted</span></tt> there is also defined a <tt class="docutils literal"><span class="pre">rank</span></tt>. If <tt class="docutils literal"><span class="pre">pivot=false</span></tt> a <tt class="docutils literal"><span class="pre">PosDefException</span></tt> exception is thrown in case the matrix is not positive definite. The argument <tt class="docutils literal"><span class="pre">tol</span></tt> determines the tolerance for determining the rank. For negative values, the tolerance is the machine precision.</p>
</dd></dl>

<dl class="function">
<dt>
<tt class="descname">cholfact</tt><big>(</big><em>A</em><span class="optional">[</span>, <em>ll</em><span class="optional">]</span><big>)</big> &rarr; CholmodFactor</dt>
<dd><p>Compute the sparse Cholesky factorization of a sparse matrix <tt class="docutils literal"><span class="pre">A</span></tt>.  If <tt class="docutils literal"><span class="pre">A</span></tt> is Hermitian its Cholesky factor is determined.  If <tt class="docutils literal"><span class="pre">A</span></tt> is not Hermitian the Cholesky factor of <tt class="docutils literal"><span class="pre">A*A'</span></tt> is determined. A fill-reducing permutation is used.  Methods for <tt class="docutils literal"><span class="pre">size</span></tt>, <tt class="docutils literal"><span class="pre">solve</span></tt>, <tt class="docutils literal"><span class="pre">\</span></tt>, <tt class="docutils literal"><span class="pre">findn_nzs</span></tt>, <tt class="docutils literal"><span class="pre">diag</span></tt>, <tt class="docutils literal"><span class="pre">det</span></tt> and <tt class="docutils literal"><span class="pre">logdet</span></tt> are available for <tt class="docutils literal"><span class="pre">CholmodFactor</span></tt> objects.  One of the solve methods includes an integer argument that can be used to solve systems involving parts of the factorization only.  The optional boolean argument, <tt class="docutils literal"><span class="pre">ll</span></tt> determines whether the factorization returned is of the <tt class="docutils literal"><span class="pre">A[p,p]</span> <span class="pre">=</span> <span class="pre">L*L'</span></tt> form, where <tt class="docutils literal"><span class="pre">L</span></tt> is lower triangular or <tt class="docutils literal"><span class="pre">A[p,p]</span> <span class="pre">=</span> <span class="pre">L*Diagonal(D)*L'</span></tt> form where <tt class="docutils literal"><span class="pre">L</span></tt> is unit lower triangular and <tt class="docutils literal"><span class="pre">D</span></tt> is a non-negative vector.  The default is LDL. The symbolic factorization can also be reused for other matrices with the same structure as <tt class="docutils literal"><span class="pre">A</span></tt> by calling <tt class="docutils literal"><span class="pre">cholfact!</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.cholfact!">
<tt class="descname">cholfact!</tt><big>(</big><em>A, [LU,][pivot=false,][tol=-1.0]</em><big>)</big> &rarr; Cholesky<a class="headerlink" href="#Base.cholfact!" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="docutils literal"><span class="pre">cholfact!</span></tt> is the same as <a class="reference internal" href="#Base.cholfact" title="Base.cholfact"><tt class="xref jl jl-func docutils literal"><span class="pre">cholfact()</span></tt></a>, but saves space by overwriting the input <tt class="docutils literal"><span class="pre">A</span></tt>, instead of creating a copy. <tt class="docutils literal"><span class="pre">cholfact!</span></tt> can also reuse the symbolic factorization from a different matrix <tt class="docutils literal"><span class="pre">F</span></tt> with the same structure when used as: <tt class="docutils literal"><span class="pre">cholfact!(F::CholmodFactor,</span> <span class="pre">A)</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.ldltfact">
<tt class="descname">ldltfact</tt><big>(</big><em>A</em><big>)</big> &rarr; LDLtFactorization<a class="headerlink" href="#Base.ldltfact" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute a factorization of a positive definite matrix <tt class="docutils literal"><span class="pre">A</span></tt> such that <tt class="docutils literal"><span class="pre">A=L*Diagonal(d)*L'</span></tt> where <tt class="docutils literal"><span class="pre">L</span></tt> is a unit lower triangular matrix and <tt class="docutils literal"><span class="pre">d</span></tt> is a vector with non-negative elements.</p>
</dd></dl>

<dl class="function">
<dt id="Base.qr">
<tt class="descname">qr</tt><big>(</big><em>A, [pivot=false,][thin=true]</em><big>)</big> &rarr; Q, R, [p]<a class="headerlink" href="#Base.qr" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the (pivoted) QR factorization of <tt class="docutils literal"><span class="pre">A</span></tt> such that either <tt class="docutils literal"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">Q*R</span></tt> or <tt class="docutils literal"><span class="pre">A[:,p]</span> <span class="pre">=</span> <span class="pre">Q*R</span></tt>. Also see <tt class="docutils literal"><span class="pre">qrfact</span></tt>. The default is to compute a thin factorization. Note that <tt class="docutils literal"><span class="pre">R</span></tt> is not extended with zeros when the full <tt class="docutils literal"><span class="pre">Q</span></tt> is requested.</p>
</dd></dl>

<dl class="function">
<dt id="Base.qrfact">
<tt class="descname">qrfact</tt><big>(</big><em>A</em><span class="optional">[</span>, <em>pivot=false</em><span class="optional">]</span><big>)</big> &rarr; F<a class="headerlink" href="#Base.qrfact" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the QR factorization of <tt class="docutils literal"><span class="pre">A</span></tt>. The return type of <tt class="docutils literal"><span class="pre">F</span></tt> depends on the element type of <tt class="docutils literal"><span class="pre">A</span></tt> and whether pivoting is specified (with <tt class="docutils literal"><span class="pre">pivot=true</span></tt>).</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="22%" />
<col width="11%" />
<col width="47%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Return type</td>
<td><tt class="docutils literal"><span class="pre">eltype(A)</span></tt></td>
<td><tt class="docutils literal"><span class="pre">pivot</span></tt></td>
<td>Relationship between <tt class="docutils literal"><span class="pre">F</span></tt> and <tt class="docutils literal"><span class="pre">A</span></tt></td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">QR</span></tt></td>
<td>not <tt class="docutils literal"><span class="pre">BlasFloat</span></tt></td>
<td>either</td>
<td><tt class="docutils literal"><span class="pre">A==F[:Q]*F[:R]</span></tt></td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">QRCompactWY</span></tt></td>
<td><tt class="docutils literal"><span class="pre">BlasFloat</span></tt></td>
<td><tt class="docutils literal"><span class="pre">false</span></tt></td>
<td><tt class="docutils literal"><span class="pre">A==F[:Q]*F[:R]</span></tt></td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">QRPivoted</span></tt></td>
<td><tt class="docutils literal"><span class="pre">BlasFloat</span></tt></td>
<td><tt class="docutils literal"><span class="pre">true</span></tt></td>
<td><tt class="docutils literal"><span class="pre">A[:,F[:p]]==F[:Q]*F[:R]</span></tt></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p><tt class="docutils literal"><span class="pre">BlasFloat</span></tt> refers to any of: <tt class="docutils literal"><span class="pre">Float32</span></tt>, <tt class="docutils literal"><span class="pre">Float64</span></tt>, <tt class="docutils literal"><span class="pre">Complex64</span></tt> or <tt class="docutils literal"><span class="pre">Complex128</span></tt>.</p>
<p>The individual components of the factorization <tt class="docutils literal"><span class="pre">F</span></tt> can be accessed by indexing:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="10%" />
<col width="40%" />
<col width="16%" />
<col width="19%" />
<col width="16%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Component</td>
<td>Description</td>
<td><tt class="docutils literal"><span class="pre">QR</span></tt></td>
<td><tt class="docutils literal"><span class="pre">QRCompactWY</span></tt></td>
<td><tt class="docutils literal"><span class="pre">QRPivoted</span></tt></td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">F[:Q]</span></tt></td>
<td><tt class="docutils literal"><span class="pre">Q</span></tt> (orthogonal/unitary) part of <tt class="docutils literal"><span class="pre">QR</span></tt></td>
<td>✓ (<tt class="docutils literal"><span class="pre">QRPackedQ</span></tt>)</td>
<td>✓ (<tt class="docutils literal"><span class="pre">QRCompactWYQ</span></tt>)</td>
<td>✓ (<tt class="docutils literal"><span class="pre">QRPackedQ</span></tt>)</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">F[:R]</span></tt></td>
<td><tt class="docutils literal"><span class="pre">R</span></tt> (upper right triangular) part of <tt class="docutils literal"><span class="pre">QR</span></tt></td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">F[:p]</span></tt></td>
<td>pivot <tt class="docutils literal"><span class="pre">Vector</span></tt></td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>✓</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">F[:P]</span></tt></td>
<td>(pivot) permutation <tt class="docutils literal"><span class="pre">Matrix</span></tt></td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>✓</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>The following functions are available for the <tt class="docutils literal"><span class="pre">QR</span></tt> objects: <tt class="docutils literal"><span class="pre">size</span></tt>, <tt class="docutils literal"><span class="pre">\</span></tt>. When <tt class="docutils literal"><span class="pre">A</span></tt> is rectangular, <tt class="docutils literal"><span class="pre">\</span></tt> will return a least squares solution and if the solution is not unique, the one with smallest norm is returned.</p>
<p>Multiplication with respect to either thin or full <tt class="docutils literal"><span class="pre">Q</span></tt> is allowed, i.e. both <tt class="docutils literal"><span class="pre">F[:Q]*F[:R]</span></tt> and <tt class="docutils literal"><span class="pre">F[:Q]*A</span></tt> are supported. A <tt class="docutils literal"><span class="pre">Q</span></tt> matrix can be converted into a regular matrix with <a class="reference internal" href="../arrays/#Base.full" title="Base.full"><tt class="xref jl jl-func docutils literal"><span class="pre">full()</span></tt></a> which has a named argument <tt class="docutils literal"><span class="pre">thin</span></tt>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p><tt class="docutils literal"><span class="pre">qrfact</span></tt> returns multiple types because LAPACK uses several representations that minimize the memory storage requirements of products of Householder elementary reflectors, so that the <tt class="docutils literal"><span class="pre">Q</span></tt> and <tt class="docutils literal"><span class="pre">R</span></tt> matrices can be stored compactly rather as two separate dense matrices.</p>
<p>The data contained in <tt class="docutils literal"><span class="pre">QR</span></tt> or <tt class="docutils literal"><span class="pre">QRPivoted</span></tt> can be used to construct the <tt class="docutils literal"><span class="pre">QRPackedQ</span></tt> type, which is a compact representation of the rotation matrix:</p>
<blockquote>
<div><div class="math">
\[Q = \prod_{i=1}^{\min(m,n)} (I - \tau_i v_i v_i^T)\]</div>
</div></blockquote>
<p>where <span class="math">\(\tau_i\)</span> is the scale factor and <span class="math">\(v_i\)</span> is the projection vector associated with the <span class="math">\(i^{th}\)</span> Householder elementary reflector.</p>
<p>The data contained in <tt class="docutils literal"><span class="pre">QRCompactWY</span></tt> can be used to construct the <tt class="docutils literal"><span class="pre">QRCompactWYQ</span></tt> type, which is a compact representation of the rotation matrix</p>
<blockquote>
<div><div class="math">
\[Q = I + Y T Y^T\]</div>
</div></blockquote>
<p class="last">where <tt class="docutils literal"><span class="pre">Y</span></tt> is <span class="math">\(m \times r\)</span> lower trapezoidal and <tt class="docutils literal"><span class="pre">T</span></tt> is <span class="math">\(r \times r\)</span> upper triangular. The <em>compact WY</em> representation <a class="reference internal" href="#schreiber1989" id="id1">[Schreiber1989]</a> is not to be confused with the older, <em>WY</em> representation <a class="reference internal" href="#bischof1987" id="id2">[Bischof1987]</a>. (The LAPACK documentation uses <tt class="docutils literal"><span class="pre">V</span></tt> in lieu of <tt class="docutils literal"><span class="pre">Y</span></tt>.)</p>
</div>
<table class="docutils citation" frame="void" id="bischof1987" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[Bischof1987]</a></td><td>C Bischof and C Van Loan, The WY representation for products of Householder matrices, SIAM J Sci Stat Comput 8 (1987), s2-s13. doi:10.1137/0908009</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="schreiber1989" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[Schreiber1989]</a></td><td>R Schreiber and C Van Loan, A storage-efficient WY representation for products of Householder transformations, SIAM J Sci Stat Comput 10 (1989), 53-57. doi:10.1137/0910005</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Base.qrfact!">
<tt class="descname">qrfact!</tt><big>(</big><em>A</em><span class="optional">[</span>, <em>pivot=false</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#Base.qrfact!" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="docutils literal"><span class="pre">qrfact!</span></tt> is the same as <a class="reference internal" href="#Base.qrfact" title="Base.qrfact"><tt class="xref jl jl-func docutils literal"><span class="pre">qrfact()</span></tt></a>, but saves space by overwriting the input <tt class="docutils literal"><span class="pre">A</span></tt>, instead of creating a copy.</p>
</dd></dl>

<dl class="function">
<dt id="Base.bkfact">
<tt class="descname">bkfact</tt><big>(</big><em>A</em><big>)</big> &rarr; BunchKaufman<a class="headerlink" href="#Base.bkfact" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Bunch-Kaufman <a class="reference internal" href="#bunch1977" id="id3">[Bunch1977]</a> factorization of a real symmetric or complex Hermitian matrix <tt class="docutils literal"><span class="pre">A</span></tt> and return a <tt class="docutils literal"><span class="pre">BunchKaufman</span></tt> object. The following functions are available for <tt class="docutils literal"><span class="pre">BunchKaufman</span></tt> objects: <tt class="docutils literal"><span class="pre">size</span></tt>, <tt class="docutils literal"><span class="pre">\</span></tt>, <tt class="docutils literal"><span class="pre">inv</span></tt>, <tt class="docutils literal"><span class="pre">issym</span></tt>, <tt class="docutils literal"><span class="pre">ishermitian</span></tt>.</p>
</dd></dl>

<table class="docutils citation" frame="void" id="bunch1977" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[Bunch1977]</a></td><td>J R Bunch and L Kaufman, Some stable methods for calculating inertia and solving symmetric linear systems, Mathematics of Computation 31:137 (1977), 163-179. <a class="reference external" href="http://www.ams.org/journals/mcom/1977-31-137/S0025-5718-1977-0428694-0">url</a>.</td></tr>
</tbody>
</table>
<dl class="function">
<dt id="Base.bkfact!">
<tt class="descname">bkfact!</tt><big>(</big><em>A</em><big>)</big> &rarr; BunchKaufman<a class="headerlink" href="#Base.bkfact!" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="docutils literal"><span class="pre">bkfact!</span></tt> is the same as <a class="reference internal" href="#Base.bkfact" title="Base.bkfact"><tt class="xref jl jl-func docutils literal"><span class="pre">bkfact()</span></tt></a>, but saves space by overwriting the input <tt class="docutils literal"><span class="pre">A</span></tt>, instead of creating a copy.</p>
</dd></dl>

<dl class="function">
<dt id="Base.sqrtm">
<tt class="descname">sqrtm</tt><big>(</big><em>A</em><big>)</big><a class="headerlink" href="#Base.sqrtm" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the matrix square root of <tt class="docutils literal"><span class="pre">A</span></tt>. If <tt class="docutils literal"><span class="pre">B</span> <span class="pre">=</span> <span class="pre">sqrtm(A)</span></tt>, then <tt class="docutils literal"><span class="pre">B*B</span> <span class="pre">==</span> <span class="pre">A</span></tt> within roundoff error.</p>
<p><tt class="docutils literal"><span class="pre">sqrtm</span></tt> uses a polyalgorithm, computing the matrix square root using Schur factorizations (<a class="reference internal" href="#Base.schurfact" title="Base.schurfact"><tt class="xref jl jl-func docutils literal"><span class="pre">schurfact()</span></tt></a>) unless it detects the matrix to be Hermitian or real symmetric, in which case it computes the matrix square root from an eigendecomposition (<a class="reference internal" href="#Base.eigfact" title="Base.eigfact"><tt class="xref jl jl-func docutils literal"><span class="pre">eigfact()</span></tt></a>). In the latter situation for positive definite matrices, the matrix square root has <tt class="docutils literal"><span class="pre">Real</span></tt> elements, otherwise it has <tt class="docutils literal"><span class="pre">Complex</span></tt> elements.</p>
</dd></dl>

<dl class="function">
<dt id="Base.eig">
<tt class="descname">eig</tt><big>(</big><em>A,[irange,][vl,][vu,][permute=true,][scale=true]</em><big>)</big> &rarr; D, V<a class="headerlink" href="#Base.eig" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes eigenvalues and eigenvectors of <tt class="docutils literal"><span class="pre">A</span></tt>. See <a class="reference internal" href="#Base.eigfact" title="Base.eigfact"><tt class="xref jl jl-func docutils literal"><span class="pre">eigfact()</span></tt></a> for
details on the <tt class="docutils literal"><span class="pre">balance</span></tt> keyword argument.</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">eig</span><span class="p">([</span><span class="mf">1.0</span> <span class="mf">0.0</span> <span class="mf">0.0</span><span class="p">;</span> <span class="mf">0.0</span> <span class="mf">3.0</span> <span class="mf">0.0</span><span class="p">;</span> <span class="mf">0.0</span> <span class="mf">0.0</span> <span class="mf">18.0</span><span class="p">])</span>
<span class="p">([</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">3.0</span><span class="p">,</span><span class="mf">18.0</span><span class="p">],</span>
<span class="mi">3</span><span class="n">x3</span> <span class="n">Array</span><span class="p">{</span><span class="kt">Float64</span><span class="p">,</span><span class="mi">2</span><span class="p">}:</span>
 <span class="mf">1.0</span>  <span class="mf">0.0</span>  <span class="mf">0.0</span>
 <span class="mf">0.0</span>  <span class="mf">1.0</span>  <span class="mf">0.0</span>
 <span class="mf">0.0</span>  <span class="mf">0.0</span>  <span class="mf">1.0</span><span class="p">)</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">eig</span></tt> is a wrapper around <a class="reference internal" href="#Base.eigfact" title="Base.eigfact"><tt class="xref jl jl-func docutils literal"><span class="pre">eigfact()</span></tt></a>, extracting all parts of the
factorization to a tuple; where possible, using <a class="reference internal" href="#Base.eigfact" title="Base.eigfact"><tt class="xref jl jl-func docutils literal"><span class="pre">eigfact()</span></tt></a> is
recommended.</p>
</dd></dl>

<dl class="function">
<dt>
<tt class="descname">eig</tt><big>(</big><em>A</em>, <em>B</em><big>)</big> &rarr; D, V</dt>
<dd><p>Computes generalized eigenvalues and vectors of <tt class="docutils literal"><span class="pre">A</span></tt> with respect to <tt class="docutils literal"><span class="pre">B</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">eig</span></tt> is a wrapper around <a class="reference internal" href="#Base.eigfact" title="Base.eigfact"><tt class="xref jl jl-func docutils literal"><span class="pre">eigfact()</span></tt></a>, extracting all parts of the
factorization to a tuple; where possible, using <a class="reference internal" href="#Base.eigfact" title="Base.eigfact"><tt class="xref jl jl-func docutils literal"><span class="pre">eigfact()</span></tt></a> is
recommended.</p>
</dd></dl>

<dl class="function">
<dt id="Base.eigvals">
<tt class="descname">eigvals</tt><big>(</big><em>A,[irange,][vl,][vu]</em><big>)</big><a class="headerlink" href="#Base.eigvals" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the eigenvalues of <tt class="docutils literal"><span class="pre">A</span></tt>. If <tt class="docutils literal"><span class="pre">A</span></tt> is <tt class="xref jl jl-class docutils literal"><span class="pre">Symmetric</span></tt>,
<tt class="xref jl jl-class docutils literal"><span class="pre">Hermitian</span></tt> or <a class="reference internal" href="#Base.SymTridiagonal" title="Base.SymTridiagonal"><tt class="xref jl jl-class docutils literal"><span class="pre">SymTridiagonal</span></tt></a>, it is possible to calculate
only a subset of the eigenvalues by specifying either a <tt class="xref jl jl-class docutils literal"><span class="pre">UnitRange</span></tt>
<tt class="docutils literal"><span class="pre">irange</span></tt> covering indices of the sorted eigenvalues, or a pair <tt class="docutils literal"><span class="pre">vl</span></tt> and
<tt class="docutils literal"><span class="pre">vu</span></tt> for the lower and upper boundaries of the eigenvalues.</p>
<p>For general non-symmetric matrices it is possible to specify how the matrix
is balanced before the eigenvector calculation. The option <tt class="docutils literal"><span class="pre">permute=true</span></tt>
permutes the matrix to become closer to upper triangular, and <tt class="docutils literal"><span class="pre">scale=true</span></tt>
scales the matrix by its diagonal elements to make rows and columns more
equal in norm. The default is <tt class="docutils literal"><span class="pre">true</span></tt> for both options.</p>
</dd></dl>

<dl class="function">
<dt id="Base.eigmax">
<tt class="descname">eigmax</tt><big>(</big><em>A</em><big>)</big><a class="headerlink" href="#Base.eigmax" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the largest eigenvalue of <tt class="docutils literal"><span class="pre">A</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.eigmin">
<tt class="descname">eigmin</tt><big>(</big><em>A</em><big>)</big><a class="headerlink" href="#Base.eigmin" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the smallest eigenvalue of <tt class="docutils literal"><span class="pre">A</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.eigvecs">
<tt class="descname">eigvecs</tt><big>(</big><em>A, [eigvals,][permute=true,][scale=true]</em><big>)</big> &rarr; Matrix<a class="headerlink" href="#Base.eigvecs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a matrix <tt class="docutils literal"><span class="pre">M</span></tt> whose columns are the eigenvectors of <tt class="docutils literal"><span class="pre">A</span></tt>.
(The <tt class="docutils literal"><span class="pre">k``th</span> <span class="pre">eigenvector</span> <span class="pre">can</span> <span class="pre">be</span> <span class="pre">obtained</span> <span class="pre">from</span> <span class="pre">the</span> <span class="pre">slice</span> <span class="pre">``M[:,</span> <span class="pre">k]</span></tt>.)
The <tt class="docutils literal"><span class="pre">permute</span></tt> and <tt class="docutils literal"><span class="pre">scale</span></tt> keywords are the same as for <a class="reference internal" href="#Base.eigfact" title="Base.eigfact"><tt class="xref jl jl-func docutils literal"><span class="pre">eigfact()</span></tt></a>.</p>
<p>For <a class="reference internal" href="#Base.SymTridiagonal" title="Base.SymTridiagonal"><tt class="xref jl jl-class docutils literal"><span class="pre">SymTridiagonal</span></tt></a> matrices, if the optional vector of eigenvalues
<tt class="docutils literal"><span class="pre">eigvals</span></tt> is specified, returns the specific corresponding eigenvectors.</p>
</dd></dl>

<dl class="function">
<dt id="Base.eigfact">
<tt class="descname">eigfact</tt><big>(</big><em>A,[irange,][vl,][vu,][permute=true,][scale=true]</em><big>)</big> &rarr; Eigen<a class="headerlink" href="#Base.eigfact" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the eigenvalue decomposition of <tt class="docutils literal"><span class="pre">A</span></tt>, returning an <tt class="docutils literal"><span class="pre">Eigen</span></tt>
factorization object <tt class="docutils literal"><span class="pre">F</span></tt> which contains the eigenvalues in <tt class="docutils literal"><span class="pre">F[:values]</span></tt>
and the eigenvectors in the columns of the matrix <tt class="docutils literal"><span class="pre">F[:vectors]</span></tt>. (The
<tt class="docutils literal"><span class="pre">k``th</span> <span class="pre">eigenvector</span> <span class="pre">can</span> <span class="pre">be</span> <span class="pre">obtained</span> <span class="pre">from</span> <span class="pre">the</span> <span class="pre">slice</span> <span class="pre">``F[:vectors][:,</span> <span class="pre">k]</span></tt>.)</p>
<p>The following functions are available for <tt class="docutils literal"><span class="pre">Eigen</span></tt> objects: <tt class="docutils literal"><span class="pre">inv</span></tt>,
<tt class="docutils literal"><span class="pre">det</span></tt>.</p>
<p>If <tt class="docutils literal"><span class="pre">A</span></tt> is <tt class="xref jl jl-class docutils literal"><span class="pre">Symmetric</span></tt>, <tt class="xref jl jl-class docutils literal"><span class="pre">Hermitian</span></tt> or <a class="reference internal" href="#Base.SymTridiagonal" title="Base.SymTridiagonal"><tt class="xref jl jl-class docutils literal"><span class="pre">SymTridiagonal</span></tt></a>,
it is possible to calculate only a subset of the eigenvalues by specifying
either a <tt class="xref jl jl-class docutils literal"><span class="pre">UnitRange</span></tt> <tt class="docutils literal"><span class="pre">irange</span></tt> covering indices of the sorted
eigenvalues or a pair <tt class="docutils literal"><span class="pre">vl</span></tt> and <tt class="docutils literal"><span class="pre">vu</span></tt> for the lower and upper boundaries
of the eigenvalues.</p>
<p>For general nonsymmetric matrices it is possible to specify how the matrix
is balanced before the eigenvector calculation. The option <tt class="docutils literal"><span class="pre">permute=true</span></tt>
permutes the matrix to become closer to upper triangular, and <tt class="docutils literal"><span class="pre">scale=true</span></tt>
scales the matrix by its diagonal elements to make rows and columns more
equal in norm. The default is <tt class="docutils literal"><span class="pre">true</span></tt> for both options.</p>
</dd></dl>

<dl class="function">
<dt>
<tt class="descname">eigfact</tt><big>(</big><em>A</em>, <em>B</em><big>)</big> &rarr; GeneralizedEigen</dt>
<dd><p>Computes the generalized eigenvalue decomposition of <tt class="docutils literal"><span class="pre">A</span></tt> and <tt class="docutils literal"><span class="pre">B</span></tt>,
returning a <tt class="docutils literal"><span class="pre">GeneralizedEigen</span></tt> factorization object <tt class="docutils literal"><span class="pre">F</span></tt> which contains
the generalized eigenvalues in <tt class="docutils literal"><span class="pre">F[:values]</span></tt> and the generalized
eigenvectors in the columns of the matrix <tt class="docutils literal"><span class="pre">F[:vectors]</span></tt>. (The <tt class="docutils literal"><span class="pre">k``th</span>
<span class="pre">generalized</span> <span class="pre">eigenvector</span> <span class="pre">can</span> <span class="pre">be</span> <span class="pre">obtained</span> <span class="pre">from</span> <span class="pre">the</span> <span class="pre">slice</span> <span class="pre">``F[:vectors][:,</span>
<span class="pre">k]</span></tt>.)</p>
</dd></dl>

<dl class="function">
<dt id="Base.eigfact!">
<tt class="descname">eigfact!</tt><big>(</big><em>A</em><span class="optional">[</span>, <em>B</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#Base.eigfact!" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as <a class="reference internal" href="#Base.eigfact" title="Base.eigfact"><tt class="xref jl jl-func docutils literal"><span class="pre">eigfact()</span></tt></a>, but saves space by overwriting the input <tt class="docutils literal"><span class="pre">A</span></tt> (and
<tt class="docutils literal"><span class="pre">B</span></tt>), instead of creating a copy.</p>
</dd></dl>

<dl class="function">
<dt id="Base.hessfact">
<tt class="descname">hessfact</tt><big>(</big><em>A</em><big>)</big><a class="headerlink" href="#Base.hessfact" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Hessenberg decomposition of <tt class="docutils literal"><span class="pre">A</span></tt> and return a <tt class="docutils literal"><span class="pre">Hessenberg</span></tt> object. If <tt class="docutils literal"><span class="pre">F</span></tt> is the factorization object, the unitary matrix can be accessed with <tt class="docutils literal"><span class="pre">F[:Q]</span></tt> and the Hessenberg matrix with <tt class="docutils literal"><span class="pre">F[:H]</span></tt>. When <tt class="docutils literal"><span class="pre">Q</span></tt> is extracted, the resulting type is the <tt class="docutils literal"><span class="pre">HessenbergQ</span></tt> object, and may be converted to a regular matrix with <a class="reference internal" href="../arrays/#Base.full" title="Base.full"><tt class="xref jl jl-func docutils literal"><span class="pre">full()</span></tt></a>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.hessfact!">
<tt class="descname">hessfact!</tt><big>(</big><em>A</em><big>)</big><a class="headerlink" href="#Base.hessfact!" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="docutils literal"><span class="pre">hessfact!</span></tt> is the same as <a class="reference internal" href="#Base.hessfact" title="Base.hessfact"><tt class="xref jl jl-func docutils literal"><span class="pre">hessfact()</span></tt></a>, but saves space by overwriting the input A, instead of creating a copy.</p>
</dd></dl>

<dl class="function">
<dt id="Base.schurfact">
<tt class="descname">schurfact</tt><big>(</big><em>A</em><big>)</big> &rarr; Schur<a class="headerlink" href="#Base.schurfact" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the Schur factorization of the matrix <tt class="docutils literal"><span class="pre">A</span></tt>. The (quasi) triangular Schur factor can be obtained from the <tt class="docutils literal"><span class="pre">Schur</span></tt> object <tt class="docutils literal"><span class="pre">F</span></tt> with either <tt class="docutils literal"><span class="pre">F[:Schur]</span></tt> or <tt class="docutils literal"><span class="pre">F[:T]</span></tt> and the unitary/orthogonal Schur vectors can be obtained with <tt class="docutils literal"><span class="pre">F[:vectors]</span></tt> or <tt class="docutils literal"><span class="pre">F[:Z]</span></tt> such that <tt class="docutils literal"><span class="pre">A=F[:vectors]*F[:Schur]*F[:vectors]'</span></tt>. The eigenvalues of <tt class="docutils literal"><span class="pre">A</span></tt> can be obtained with <tt class="docutils literal"><span class="pre">F[:values]</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.schurfact!">
<tt class="descname">schurfact!</tt><big>(</big><em>A</em><big>)</big><a class="headerlink" href="#Base.schurfact!" title="Permalink to this definition">¶</a></dt>
<dd><p>Computer the Schur factorization of <tt class="docutils literal"><span class="pre">A</span></tt>, overwriting <tt class="docutils literal"><span class="pre">A</span></tt> in the process. See <a class="reference internal" href="#Base.schurfact" title="Base.schurfact"><tt class="xref jl jl-func docutils literal"><span class="pre">schurfact()</span></tt></a></p>
</dd></dl>

<dl class="function">
<dt id="Base.schur">
<tt class="descname">schur</tt><big>(</big><em>A</em><big>)</big> &rarr; Schur[:T], Schur[:Z], Schur[:values]<a class="headerlink" href="#Base.schur" title="Permalink to this definition">¶</a></dt>
<dd><p>See <a class="reference internal" href="#Base.schurfact" title="Base.schurfact"><tt class="xref jl jl-func docutils literal"><span class="pre">schurfact()</span></tt></a></p>
</dd></dl>

<dl class="function">
<dt>
<tt class="descname">schurfact</tt><big>(</big><em>A</em>, <em>B</em><big>)</big> &rarr; GeneralizedSchur</dt>
<dd><p>Computes the Generalized Schur (or QZ) factorization of the matrices <tt class="docutils literal"><span class="pre">A</span></tt> and <tt class="docutils literal"><span class="pre">B</span></tt>. The (quasi) triangular Schur factors can be obtained from the <tt class="docutils literal"><span class="pre">Schur</span></tt> object <tt class="docutils literal"><span class="pre">F</span></tt> with <tt class="docutils literal"><span class="pre">F[:S]</span></tt> and <tt class="docutils literal"><span class="pre">F[:T]</span></tt>, the left unitary/orthogonal Schur vectors can be obtained with <tt class="docutils literal"><span class="pre">F[:left]</span></tt> or <tt class="docutils literal"><span class="pre">F[:Q]</span></tt> and the right unitary/orthogonal Schur vectors can be obtained with <tt class="docutils literal"><span class="pre">F[:right]</span></tt> or <tt class="docutils literal"><span class="pre">F[:Z]</span></tt> such that <tt class="docutils literal"><span class="pre">A=F[:left]*F[:S]*F[:right]'</span></tt> and <tt class="docutils literal"><span class="pre">B=F[:left]*F[:T]*F[:right]'</span></tt>. The generalized eigenvalues of <tt class="docutils literal"><span class="pre">A</span></tt> and <tt class="docutils literal"><span class="pre">B</span></tt> can be obtained with <tt class="docutils literal"><span class="pre">F[:alpha]./F[:beta]</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt>
<tt class="descname">schur</tt><big>(</big><em>A</em>, <em>B</em><big>)</big> &rarr; GeneralizedSchur[:S], GeneralizedSchur[:T], GeneralizedSchur[:Q], GeneralizedSchur[:Z]</dt>
<dd><p>See <a class="reference internal" href="#Base.schurfact" title="Base.schurfact"><tt class="xref jl jl-func docutils literal"><span class="pre">schurfact()</span></tt></a></p>
</dd></dl>

<dl class="function">
<dt id="Base.svdfact">
<tt class="descname">svdfact</tt><big>(</big><em>A</em><span class="optional">[</span>, <em>thin=true</em><span class="optional">]</span><big>)</big> &rarr; SVD<a class="headerlink" href="#Base.svdfact" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Singular Value Decomposition (SVD) of <tt class="docutils literal"><span class="pre">A</span></tt> and return an <tt class="docutils literal"><span class="pre">SVD</span></tt> object. <tt class="docutils literal"><span class="pre">U</span></tt>, <tt class="docutils literal"><span class="pre">S</span></tt>, <tt class="docutils literal"><span class="pre">V</span></tt> and <tt class="docutils literal"><span class="pre">Vt</span></tt> can be obtained from the factorization <tt class="docutils literal"><span class="pre">F</span></tt> with <tt class="docutils literal"><span class="pre">F[:U]</span></tt>, <tt class="docutils literal"><span class="pre">F[:S]</span></tt>, <tt class="docutils literal"><span class="pre">F[:V]</span></tt> and <tt class="docutils literal"><span class="pre">F[:Vt]</span></tt>, such that <tt class="docutils literal"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">U*diagm(S)*Vt</span></tt>. If <tt class="docutils literal"><span class="pre">thin</span></tt> is <tt class="docutils literal"><span class="pre">true</span></tt>, an economy mode decomposition is returned. The algorithm produces <tt class="docutils literal"><span class="pre">Vt</span></tt> and hence <tt class="docutils literal"><span class="pre">Vt</span></tt> is more efficient to extract than <tt class="docutils literal"><span class="pre">V</span></tt>. The default is to produce a thin decomposition.</p>
</dd></dl>

<dl class="function">
<dt id="Base.svdfact!">
<tt class="descname">svdfact!</tt><big>(</big><em>A</em><span class="optional">[</span>, <em>thin=true</em><span class="optional">]</span><big>)</big> &rarr; SVD<a class="headerlink" href="#Base.svdfact!" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="docutils literal"><span class="pre">svdfact!</span></tt> is the same as <a class="reference internal" href="#Base.svdfact" title="Base.svdfact"><tt class="xref jl jl-func docutils literal"><span class="pre">svdfact()</span></tt></a>, but saves space by overwriting the input A, instead of creating a copy. If <tt class="docutils literal"><span class="pre">thin</span></tt> is <tt class="docutils literal"><span class="pre">true</span></tt>, an economy mode decomposition is returned. The default is to produce a thin decomposition.</p>
</dd></dl>

<dl class="function">
<dt id="Base.svd">
<tt class="descname">svd</tt><big>(</big><em>A</em><span class="optional">[</span>, <em>thin=true</em><span class="optional">]</span><big>)</big> &rarr; U, S, V<a class="headerlink" href="#Base.svd" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper around <tt class="docutils literal"><span class="pre">svdfact</span></tt> extracting all parts the factorization to a tuple. Direct use of <tt class="docutils literal"><span class="pre">svdfact</span></tt> is therefore generally more efficient. Computes the SVD of A, returning <tt class="docutils literal"><span class="pre">U</span></tt>, vector <tt class="docutils literal"><span class="pre">S</span></tt>, and <tt class="docutils literal"><span class="pre">V</span></tt> such that <tt class="docutils literal"><span class="pre">A</span> <span class="pre">==</span> <span class="pre">U*diagm(S)*V'</span></tt>. If <tt class="docutils literal"><span class="pre">thin</span></tt> is <tt class="docutils literal"><span class="pre">true</span></tt>, an economy mode decomposition is returned. The default is to produce a thin decomposition.</p>
</dd></dl>

<dl class="function">
<dt id="Base.svdvals">
<tt class="descname">svdvals</tt><big>(</big><em>A</em><big>)</big><a class="headerlink" href="#Base.svdvals" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the singular values of <tt class="docutils literal"><span class="pre">A</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.svdvals!">
<tt class="descname">svdvals!</tt><big>(</big><em>A</em><big>)</big><a class="headerlink" href="#Base.svdvals!" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the singular values of <tt class="docutils literal"><span class="pre">A</span></tt>, while saving space by overwriting the input.</p>
</dd></dl>

<dl class="function">
<dt>
<tt class="descname">svdfact</tt><big>(</big><em>A</em>, <em>B</em><big>)</big> &rarr; GeneralizedSVD</dt>
<dd><p>Compute the generalized SVD of <tt class="docutils literal"><span class="pre">A</span></tt> and <tt class="docutils literal"><span class="pre">B</span></tt>, returning a <tt class="docutils literal"><span class="pre">GeneralizedSVD</span></tt> Factorization object <tt class="docutils literal"><span class="pre">F</span></tt>, such that <tt class="docutils literal"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">F[:U]*F[:D1]*F[:R0]*F[:Q]'</span></tt> and <tt class="docutils literal"><span class="pre">B</span> <span class="pre">=</span> <span class="pre">F[:V]*F[:D2]*F[:R0]*F[:Q]'</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt>
<tt class="descname">svd</tt><big>(</big><em>A</em>, <em>B</em><big>)</big> &rarr; U, V, Q, D1, D2, R0</dt>
<dd><p>Wrapper around <tt class="docutils literal"><span class="pre">svdfact</span></tt> extracting all parts the factorization to a tuple. Direct use of <tt class="docutils literal"><span class="pre">svdfact</span></tt> is therefore generally more efficient. The function returns the generalized SVD of <tt class="docutils literal"><span class="pre">A</span></tt> and <tt class="docutils literal"><span class="pre">B</span></tt>, returning <tt class="docutils literal"><span class="pre">U</span></tt>, <tt class="docutils literal"><span class="pre">V</span></tt>, <tt class="docutils literal"><span class="pre">Q</span></tt>, <tt class="docutils literal"><span class="pre">D1</span></tt>, <tt class="docutils literal"><span class="pre">D2</span></tt>, and <tt class="docutils literal"><span class="pre">R0</span></tt> such that <tt class="docutils literal"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">U*D1*R0*Q'</span></tt> and <tt class="docutils literal"><span class="pre">B</span> <span class="pre">=</span> <span class="pre">V*D2*R0*Q'</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt>
<tt class="descname">svdvals</tt><big>(</big><em>A</em>, <em>B</em><big>)</big></dt>
<dd><p>Return only the singular values from the generalized singular value decomposition of <tt class="docutils literal"><span class="pre">A</span></tt> and <tt class="docutils literal"><span class="pre">B</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.triu">
<tt class="descname">triu</tt><big>(</big><em>M</em><big>)</big><a class="headerlink" href="#Base.triu" title="Permalink to this definition">¶</a></dt>
<dd><p>Upper triangle of a matrix.</p>
</dd></dl>

<dl class="function">
<dt id="Base.triu!">
<tt class="descname">triu!</tt><big>(</big><em>M</em><big>)</big><a class="headerlink" href="#Base.triu!" title="Permalink to this definition">¶</a></dt>
<dd><p>Upper triangle of a matrix, overwriting <tt class="docutils literal"><span class="pre">M</span></tt> in the process.</p>
</dd></dl>

<dl class="function">
<dt id="Base.tril">
<tt class="descname">tril</tt><big>(</big><em>M</em><big>)</big><a class="headerlink" href="#Base.tril" title="Permalink to this definition">¶</a></dt>
<dd><p>Lower triangle of a matrix.</p>
</dd></dl>

<dl class="function">
<dt id="Base.tril!">
<tt class="descname">tril!</tt><big>(</big><em>M</em><big>)</big><a class="headerlink" href="#Base.tril!" title="Permalink to this definition">¶</a></dt>
<dd><p>Lower triangle of a matrix, overwriting <tt class="docutils literal"><span class="pre">M</span></tt> in the process.</p>
</dd></dl>

<dl class="function">
<dt id="Base.diagind">
<tt class="descname">diagind</tt><big>(</big><em>M</em><span class="optional">[</span>, <em>k</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#Base.diagind" title="Permalink to this definition">¶</a></dt>
<dd><p>A <tt class="docutils literal"><span class="pre">Range</span></tt> giving the indices of the <tt class="docutils literal"><span class="pre">k</span></tt>-th diagonal of the matrix <tt class="docutils literal"><span class="pre">M</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.diag">
<tt class="descname">diag</tt><big>(</big><em>M</em><span class="optional">[</span>, <em>k</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#Base.diag" title="Permalink to this definition">¶</a></dt>
<dd><p>The <tt class="docutils literal"><span class="pre">k</span></tt>-th diagonal of a matrix, as a vector. Use <tt class="docutils literal"><span class="pre">diagm</span></tt> to construct a diagonal matrix.</p>
</dd></dl>

<dl class="function">
<dt id="Base.diagm">
<tt class="descname">diagm</tt><big>(</big><em>v</em><span class="optional">[</span>, <em>k</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#Base.diagm" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a diagonal matrix and place <tt class="docutils literal"><span class="pre">v</span></tt> on the <tt class="docutils literal"><span class="pre">k</span></tt>-th diagonal.</p>
</dd></dl>

<dl class="function">
<dt id="Base.scale">
<tt class="descname">scale</tt><big>(</big><em>A</em>, <em>b</em><big>)</big><a class="headerlink" href="#Base.scale" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt>
<tt class="descname">scale</tt><big>(</big><em>b</em>, <em>A</em><big>)</big></dt>
<dd><p>Scale an array <tt class="docutils literal"><span class="pre">A</span></tt> by a scalar <tt class="docutils literal"><span class="pre">b</span></tt>, returning a new array.</p>
<p>If <tt class="docutils literal"><span class="pre">A</span></tt> is a matrix and <tt class="docutils literal"><span class="pre">b</span></tt> is a vector, then <tt class="docutils literal"><span class="pre">scale(A,b)</span></tt>
scales each column <tt class="docutils literal"><span class="pre">i</span></tt> of <tt class="docutils literal"><span class="pre">A</span></tt> by <tt class="docutils literal"><span class="pre">b[i]</span></tt> (similar to
<tt class="docutils literal"><span class="pre">A*diagm(b)</span></tt>), while <tt class="docutils literal"><span class="pre">scale(b,A)</span></tt> scales each row <tt class="docutils literal"><span class="pre">i</span></tt> of
<tt class="docutils literal"><span class="pre">A</span></tt> by <tt class="docutils literal"><span class="pre">b[i]</span></tt> (similar to <tt class="docutils literal"><span class="pre">diagm(b)*A</span></tt>), returning a new array.</p>
<p>Note: for large <tt class="docutils literal"><span class="pre">A</span></tt>, <tt class="docutils literal"><span class="pre">scale</span></tt> can be much faster than <tt class="docutils literal"><span class="pre">A</span> <span class="pre">.*</span> <span class="pre">b</span></tt> or
<tt class="docutils literal"><span class="pre">b</span> <span class="pre">.*</span> <span class="pre">A</span></tt>, due to the use of BLAS.</p>
</dd></dl>

<dl class="function">
<dt id="Base.scale!">
<tt class="descname">scale!</tt><big>(</big><em>A</em>, <em>b</em><big>)</big><a class="headerlink" href="#Base.scale!" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt>
<tt class="descname">scale!</tt><big>(</big><em>b</em>, <em>A</em><big>)</big></dt>
<dd><p>Scale an array <tt class="docutils literal"><span class="pre">A</span></tt> by a scalar <tt class="docutils literal"><span class="pre">b</span></tt>, similar to <a class="reference internal" href="#Base.scale" title="Base.scale"><tt class="xref jl jl-func docutils literal"><span class="pre">scale()</span></tt></a> but
overwriting <tt class="docutils literal"><span class="pre">A</span></tt> in-place.</p>
<p>If <tt class="docutils literal"><span class="pre">A</span></tt> is a matrix and <tt class="docutils literal"><span class="pre">b</span></tt> is a vector, then <tt class="docutils literal"><span class="pre">scale!(A,b)</span></tt>
scales each column <tt class="docutils literal"><span class="pre">i</span></tt> of <tt class="docutils literal"><span class="pre">A</span></tt> by <tt class="docutils literal"><span class="pre">b[i]</span></tt> (similar to
<tt class="docutils literal"><span class="pre">A*diagm(b)</span></tt>), while <tt class="docutils literal"><span class="pre">scale!(b,A)</span></tt> scales each row <tt class="docutils literal"><span class="pre">i</span></tt> of
<tt class="docutils literal"><span class="pre">A</span></tt> by <tt class="docutils literal"><span class="pre">b[i]</span></tt> (similar to <tt class="docutils literal"><span class="pre">diagm(b)*A</span></tt>), again operating in-place
on <tt class="docutils literal"><span class="pre">A</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.Tridiagonal">
<tt class="descname">Tridiagonal</tt><big>(</big><em>dl</em>, <em>d</em>, <em>du</em><big>)</big><a class="headerlink" href="#Base.Tridiagonal" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a tridiagonal matrix from the lower diagonal, diagonal, and upper diagonal, respectively.  The result is of type <tt class="docutils literal"><span class="pre">Tridiagonal</span></tt> and provides efficient specialized linear solvers, but may be converted into a regular matrix with <a class="reference internal" href="../arrays/#Base.full" title="Base.full"><tt class="xref jl jl-func docutils literal"><span class="pre">full()</span></tt></a>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.Bidiagonal">
<tt class="descname">Bidiagonal</tt><big>(</big><em>dv</em>, <em>ev</em>, <em>isupper</em><big>)</big><a class="headerlink" href="#Base.Bidiagonal" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs an upper (<tt class="docutils literal"><span class="pre">isupper=true</span></tt>) or lower (<tt class="docutils literal"><span class="pre">isupper=false</span></tt>) bidiagonal matrix
using the given diagonal (<tt class="docutils literal"><span class="pre">dv</span></tt>) and off-diagonal (<tt class="docutils literal"><span class="pre">ev</span></tt>) vectors.  The result is of type <tt class="docutils literal"><span class="pre">Bidiagonal</span></tt> and provides efficient specialized linear solvers, but may be converted into a regular matrix with <a class="reference internal" href="../arrays/#Base.full" title="Base.full"><tt class="xref jl jl-func docutils literal"><span class="pre">full()</span></tt></a>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.SymTridiagonal">
<tt class="descname">SymTridiagonal</tt><big>(</big><em>d</em>, <em>du</em><big>)</big><a class="headerlink" href="#Base.SymTridiagonal" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a real symmetric tridiagonal matrix from the diagonal and upper diagonal, respectively. The result is of type <tt class="docutils literal"><span class="pre">SymTridiagonal</span></tt> and provides efficient specialized eigensolvers, but may be converted into a regular matrix with <a class="reference internal" href="../arrays/#Base.full" title="Base.full"><tt class="xref jl jl-func docutils literal"><span class="pre">full()</span></tt></a>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.Woodbury">
<tt class="descname">Woodbury</tt><big>(</big><em>A</em>, <em>U</em>, <em>C</em>, <em>V</em><big>)</big><a class="headerlink" href="#Base.Woodbury" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a matrix in a form suitable for applying the Woodbury matrix identity.</p>
</dd></dl>

<dl class="function">
<dt id="Base.rank">
<tt class="descname">rank</tt><big>(</big><em>M</em><big>)</big><a class="headerlink" href="#Base.rank" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the rank of a matrix.</p>
</dd></dl>

<dl class="function">
<dt id="Base.norm">
<tt class="descname">norm</tt><big>(</big><em>A</em><span class="optional">[</span>, <em>p</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#Base.norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the <tt class="docutils literal"><span class="pre">p</span></tt>-norm of a vector or the operator norm of a matrix <tt class="docutils literal"><span class="pre">A</span></tt>, defaulting to the <tt class="docutils literal"><span class="pre">p=2</span></tt>-norm.</p>
<p>For vectors, <tt class="docutils literal"><span class="pre">p</span></tt> can assume any numeric value (even though not all values produce a mathematically valid vector norm). In particular, <tt class="docutils literal"><span class="pre">norm(A,</span> <span class="pre">Inf)</span></tt> returns the largest value in <tt class="docutils literal"><span class="pre">abs(A)</span></tt>, whereas <tt class="docutils literal"><span class="pre">norm(A,</span> <span class="pre">-Inf)</span></tt> returns the smallest.</p>
<p>For matrices, valid values of <tt class="docutils literal"><span class="pre">p</span></tt> are <tt class="docutils literal"><span class="pre">1</span></tt>, <tt class="docutils literal"><span class="pre">2</span></tt>, or <tt class="docutils literal"><span class="pre">Inf</span></tt>. (Note that for sparse matrices, <tt class="docutils literal"><span class="pre">p=2</span></tt> is currently not implemented.) Use <a class="reference internal" href="#Base.vecnorm" title="Base.vecnorm"><tt class="xref jl jl-func docutils literal"><span class="pre">vecnorm()</span></tt></a> to compute the Frobenius norm.</p>
</dd></dl>

<dl class="function">
<dt id="Base.vecnorm">
<tt class="descname">vecnorm</tt><big>(</big><em>A</em><span class="optional">[</span>, <em>p</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#Base.vecnorm" title="Permalink to this definition">¶</a></dt>
<dd><p>For any iterable container <tt class="docutils literal"><span class="pre">A</span></tt> (including arrays of any dimension)
of numbers, compute the <tt class="docutils literal"><span class="pre">p</span></tt>-norm (defaulting to <tt class="docutils literal"><span class="pre">p=2</span></tt>) as if <tt class="docutils literal"><span class="pre">A</span></tt>
were a vector of the corresponding length.</p>
<p>For example, if <tt class="docutils literal"><span class="pre">A</span></tt> is a matrix and <tt class="docutils literal"><span class="pre">p=2</span></tt>, then this is equivalent
to the Frobenius norm.</p>
</dd></dl>

<dl class="function">
<dt id="Base.cond">
<tt class="descname">cond</tt><big>(</big><em>M</em><span class="optional">[</span>, <em>p</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#Base.cond" title="Permalink to this definition">¶</a></dt>
<dd><p>Condition number of the matrix <tt class="docutils literal"><span class="pre">M</span></tt>, computed using the operator <tt class="docutils literal"><span class="pre">p</span></tt>-norm. Valid values for <tt class="docutils literal"><span class="pre">p</span></tt> are <tt class="docutils literal"><span class="pre">1</span></tt>, <tt class="docutils literal"><span class="pre">2</span></tt> (default), or <tt class="docutils literal"><span class="pre">Inf</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.condskeel">
<tt class="descname">condskeel</tt><big>(</big><em>M</em><span class="optional">[</span>, <em>x</em>, <em>p</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#Base.condskeel" title="Permalink to this definition">¶</a></dt>
<dd><div class="math">
\[\begin{split}\kappa_S(M, p) &amp; = \left\Vert \left\vert M \right\vert \left\vert M^{-1} \right\vert  \right\Vert_p \\
\kappa_S(M, x, p) &amp; = \left\Vert \left\vert M \right\vert \left\vert M^{-1} \right\vert \left\vert x \right\vert \right\Vert_p\end{split}\]</div>
<p>Skeel condition number <span class="math">\(\kappa_S\)</span> of the matrix <tt class="docutils literal"><span class="pre">M</span></tt>, optionally with respect to the vector <tt class="docutils literal"><span class="pre">x</span></tt>, as computed using the operator <tt class="docutils literal"><span class="pre">p</span></tt>-norm. <tt class="docutils literal"><span class="pre">p</span></tt> is <tt class="docutils literal"><span class="pre">Inf</span></tt> by default, if not provided. Valid values for <tt class="docutils literal"><span class="pre">p</span></tt> are <tt class="docutils literal"><span class="pre">1</span></tt>, <tt class="docutils literal"><span class="pre">2</span></tt>, or <tt class="docutils literal"><span class="pre">Inf</span></tt>.</p>
<p>This quantity is also known in the literature as the Bauer condition number, relative condition number, or componentwise relative condition number.</p>
</dd></dl>

<dl class="function">
<dt id="Base.trace">
<tt class="descname">trace</tt><big>(</big><em>M</em><big>)</big><a class="headerlink" href="#Base.trace" title="Permalink to this definition">¶</a></dt>
<dd><p>Matrix trace</p>
</dd></dl>

<dl class="function">
<dt id="Base.det">
<tt class="descname">det</tt><big>(</big><em>M</em><big>)</big><a class="headerlink" href="#Base.det" title="Permalink to this definition">¶</a></dt>
<dd><p>Matrix determinant</p>
</dd></dl>

<dl class="function">
<dt id="Base.logdet">
<tt class="descname">logdet</tt><big>(</big><em>M</em><big>)</big><a class="headerlink" href="#Base.logdet" title="Permalink to this definition">¶</a></dt>
<dd><p>Log of matrix determinant. Equivalent to <tt class="docutils literal"><span class="pre">log(det(M))</span></tt>, but may provide increased accuracy and/or speed.</p>
</dd></dl>

<dl class="function">
<dt id="Base.inv">
<tt class="descname">inv</tt><big>(</big><em>M</em><big>)</big><a class="headerlink" href="#Base.inv" title="Permalink to this definition">¶</a></dt>
<dd><p>Matrix inverse</p>
</dd></dl>

<dl class="function">
<dt id="Base.pinv">
<tt class="descname">pinv</tt><big>(</big><em>M</em><big>)</big><a class="headerlink" href="#Base.pinv" title="Permalink to this definition">¶</a></dt>
<dd><p>Moore-Penrose pseudoinverse</p>
</dd></dl>

<dl class="function">
<dt id="Base.null">
<tt class="descname">null</tt><big>(</big><em>M</em><big>)</big><a class="headerlink" href="#Base.null" title="Permalink to this definition">¶</a></dt>
<dd><p>Basis for nullspace of <tt class="docutils literal"><span class="pre">M</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.repmat">
<tt class="descname">repmat</tt><big>(</big><em>A</em>, <em>n</em>, <em>m</em><big>)</big><a class="headerlink" href="#Base.repmat" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a matrix by repeating the given matrix <tt class="docutils literal"><span class="pre">n</span></tt> times in dimension 1 and <tt class="docutils literal"><span class="pre">m</span></tt> times in dimension 2.</p>
</dd></dl>

<dl class="function">
<dt id="Base.repeat">
<tt class="descname">repeat</tt><big>(</big><em>A</em>, <em>inner = Int[]</em>, <em>outer = Int[]</em><big>)</big><a class="headerlink" href="#Base.repeat" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct an array by repeating the entries of <tt class="docutils literal"><span class="pre">A</span></tt>. The i-th element of <tt class="docutils literal"><span class="pre">inner</span></tt> specifies the number of times that the individual entries of the i-th dimension of <tt class="docutils literal"><span class="pre">A</span></tt> should be repeated. The i-th element of <tt class="docutils literal"><span class="pre">outer</span></tt> specifies the number of times that a slice along the i-th dimension of <tt class="docutils literal"><span class="pre">A</span></tt> should be repeated.</p>
</dd></dl>

<dl class="function">
<dt id="Base.kron">
<tt class="descname">kron</tt><big>(</big><em>A</em>, <em>B</em><big>)</big><a class="headerlink" href="#Base.kron" title="Permalink to this definition">¶</a></dt>
<dd><p>Kronecker tensor product of two vectors or two matrices.</p>
</dd></dl>

<dl class="function">
<dt id="Base.blkdiag">
<tt class="descname">blkdiag</tt><big>(</big><em>A...</em><big>)</big><a class="headerlink" href="#Base.blkdiag" title="Permalink to this definition">¶</a></dt>
<dd><p>Concatenate matrices block-diagonally. Currently only implemented for sparse matrices.</p>
</dd></dl>

<dl class="function">
<dt id="Base.linreg">
<tt class="descname">linreg</tt><big>(</big><em>x</em>, <em>y</em><big>)</big> &rarr; [a; b]<a class="headerlink" href="#Base.linreg" title="Permalink to this definition">¶</a></dt>
<dd><p>Linear Regression. Returns <tt class="docutils literal"><span class="pre">a</span></tt> and <tt class="docutils literal"><span class="pre">b</span></tt> such that <tt class="docutils literal"><span class="pre">a+b*x</span></tt> is the closest line to the given points <tt class="docutils literal"><span class="pre">(x,y)</span></tt>. In other words, this function determines parameters <tt class="docutils literal"><span class="pre">[a,</span> <span class="pre">b]</span></tt> that minimize the squared error between <tt class="docutils literal"><span class="pre">y</span></tt> and <tt class="docutils literal"><span class="pre">a+b*x</span></tt>.</p>
<p><strong>Example</strong>:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="n">PyPlot</span><span class="p">;</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">float</span><span class="p">([</span><span class="mi">1</span><span class="p">:</span><span class="mi">12</span><span class="p">])</span>
<span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="mf">5.5</span><span class="p">;</span> <span class="mf">6.3</span><span class="p">;</span> <span class="mf">7.6</span><span class="p">;</span> <span class="mf">8.8</span><span class="p">;</span> <span class="mf">10.9</span><span class="p">;</span> <span class="mf">11.79</span><span class="p">;</span> <span class="mf">13.48</span><span class="p">;</span> <span class="mf">15.02</span><span class="p">;</span> <span class="mf">17.77</span><span class="p">;</span> <span class="mf">20.81</span><span class="p">;</span> <span class="mf">22.0</span><span class="p">;</span> <span class="mf">22.99</span><span class="p">]</span>
<span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">linreg</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="c"># Linear regression</span>
<span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s">&quot;o&quot;</span><span class="p">)</span> <span class="c"># Plot (x,y) points</span>
<span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">[</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="o">*</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="n">x</span><span class="p">])</span> <span class="c"># Plot the line determined by the linear regression</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt>
<tt class="descname">linreg</tt><big>(</big><em>x</em>, <em>y</em>, <em>w</em><big>)</big></dt>
<dd><p>Weighted least-squares linear regression.</p>
</dd></dl>

<dl class="function">
<dt id="Base.expm">
<tt class="descname">expm</tt><big>(</big><em>A</em><big>)</big><a class="headerlink" href="#Base.expm" title="Permalink to this definition">¶</a></dt>
<dd><p>Matrix exponential.</p>
</dd></dl>

<dl class="function">
<dt id="Base.lyap">
<tt class="descname">lyap</tt><big>(</big><em>A</em>, <em>C</em><big>)</big><a class="headerlink" href="#Base.lyap" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the solution <tt class="docutils literal"><span class="pre">X</span></tt> to the continuous Lyapunov equation <tt class="docutils literal"><span class="pre">AX</span> <span class="pre">+</span> <span class="pre">XA'</span> <span class="pre">+</span> <span class="pre">C</span> <span class="pre">=</span> <span class="pre">0</span></tt>, where no eigenvalue of <tt class="docutils literal"><span class="pre">A</span></tt> has a zero real part and no two eigenvalues are negative complex conjugates of each other.</p>
</dd></dl>

<dl class="function">
<dt id="Base.sylvester">
<tt class="descname">sylvester</tt><big>(</big><em>A</em>, <em>B</em>, <em>C</em><big>)</big><a class="headerlink" href="#Base.sylvester" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the solution <tt class="docutils literal"><span class="pre">X</span></tt> to the Sylvester equation <tt class="docutils literal"><span class="pre">AX</span> <span class="pre">+</span> <span class="pre">XB</span> <span class="pre">+</span> <span class="pre">C</span> <span class="pre">=</span> <span class="pre">0</span></tt>, where <tt class="docutils literal"><span class="pre">A</span></tt>, <tt class="docutils literal"><span class="pre">B</span></tt> and <tt class="docutils literal"><span class="pre">C</span></tt> have compatible dimensions and <tt class="docutils literal"><span class="pre">A</span></tt> and <tt class="docutils literal"><span class="pre">-B</span></tt> have no eigenvalues with equal real part.</p>
</dd></dl>

<dl class="function">
<dt id="Base.issym">
<tt class="descname">issym</tt><big>(</big><em>A</em><big>)</big> &rarr; Bool<a class="headerlink" href="#Base.issym" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether a matrix is symmetric.</p>
</dd></dl>

<dl class="function">
<dt id="Base.isposdef">
<tt class="descname">isposdef</tt><big>(</big><em>A</em><big>)</big> &rarr; Bool<a class="headerlink" href="#Base.isposdef" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether a matrix is positive definite.</p>
</dd></dl>

<dl class="function">
<dt id="Base.isposdef!">
<tt class="descname">isposdef!</tt><big>(</big><em>A</em><big>)</big> &rarr; Bool<a class="headerlink" href="#Base.isposdef!" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether a matrix is positive definite, overwriting <tt class="docutils literal"><span class="pre">A</span></tt> in the processes.</p>
</dd></dl>

<dl class="function">
<dt id="Base.istril">
<tt class="descname">istril</tt><big>(</big><em>A</em><big>)</big> &rarr; Bool<a class="headerlink" href="#Base.istril" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether a matrix is lower triangular.</p>
</dd></dl>

<dl class="function">
<dt id="Base.istriu">
<tt class="descname">istriu</tt><big>(</big><em>A</em><big>)</big> &rarr; Bool<a class="headerlink" href="#Base.istriu" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether a matrix is upper triangular.</p>
</dd></dl>

<dl class="function">
<dt id="Base.ishermitian">
<tt class="descname">ishermitian</tt><big>(</big><em>A</em><big>)</big> &rarr; Bool<a class="headerlink" href="#Base.ishermitian" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether a matrix is Hermitian.</p>
</dd></dl>

<dl class="function">
<dt id="Base.transpose">
<tt class="descname">transpose</tt><big>(</big><em>A</em><big>)</big><a class="headerlink" href="#Base.transpose" title="Permalink to this definition">¶</a></dt>
<dd><p>The transposition operator (<tt class="docutils literal"><span class="pre">.'</span></tt>).</p>
</dd></dl>

<dl class="function">
<dt id="Base.ctranspose">
<tt class="descname">ctranspose</tt><big>(</big><em>A</em><big>)</big><a class="headerlink" href="#Base.ctranspose" title="Permalink to this definition">¶</a></dt>
<dd><p>The conjugate transposition operator (<tt class="docutils literal"><span class="pre">'</span></tt>).</p>
</dd></dl>

<dl class="function">
<dt id="Base.eigs">
<tt class="descname">eigs</tt><big>(</big><em>A</em>, <span class="optional">[</span><em>B</em>, <span class="optional">]</span><em>; nev=6</em>, <em>which=&quot;LM&quot;</em>, <em>tol=0.0</em>, <em>maxiter=1000</em>, <em>sigma=nothing</em>, <em>ritzvec=true</em>, <em>v0=zeros((0</em>, <em>))) -&gt; (d</em>, <span class="optional">[</span><em>v</em>, <span class="optional">]</span><em>nconv</em>, <em>niter</em>, <em>nmult</em>, <em>resid</em><big>)</big><a class="headerlink" href="#Base.eigs" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">eigs</span></tt> computes eigenvalues <tt class="docutils literal"><span class="pre">d</span></tt> of <tt class="docutils literal"><span class="pre">A</span></tt> using Lanczos or Arnoldi iterations for real symmetric or general nonsymmetric matrices respectively. If <tt class="docutils literal"><span class="pre">B</span></tt> is provided, the generalized eigen-problem is solved.  The following keyword arguments are supported:</dt>
<dd><ul class="first last">
<li><p class="first"><tt class="docutils literal"><span class="pre">nev</span></tt>: Number of eigenvalues</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">ncv</span></tt>: Number of Krylov vectors used in the computation; should satisfy <tt class="docutils literal"><span class="pre">nev+1</span> <span class="pre">&lt;=</span> <span class="pre">ncv</span> <span class="pre">&lt;=</span> <span class="pre">n</span></tt> for real symmetric problems and <tt class="docutils literal"><span class="pre">nev+2</span> <span class="pre">&lt;=</span> <span class="pre">ncv</span> <span class="pre">&lt;=</span> <span class="pre">n</span></tt> for other problems; default is <tt class="docutils literal"><span class="pre">ncv</span> <span class="pre">=</span> <span class="pre">max(20,2*nev+1)</span></tt>.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">which</span></tt>: type of eigenvalues to compute. See the note below.</p>
<table border="1" class="docutils">
<colgroup>
<col width="7%" />
<col width="93%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">which</span></tt></td>
<td>type of eigenvalues</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">:LM</span></tt></td>
<td>eigenvalues of largest magnitude (default)</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">:SM</span></tt></td>
<td>eigenvalues of smallest magnitude</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">:LR</span></tt></td>
<td>eigenvalues of largest real part</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">:SR</span></tt></td>
<td>eigenvalues of smallest real part</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">:LI</span></tt></td>
<td>eigenvalues of largest imaginary part (nonsymmetric or complex <tt class="docutils literal"><span class="pre">A</span></tt> only)</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">:SI</span></tt></td>
<td>eigenvalues of smallest imaginary part (nonsymmetric or complex <tt class="docutils literal"><span class="pre">A</span></tt> only)</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">:BE</span></tt></td>
<td>compute half of the eigenvalues from each end of the spectrum, biased in favor of the high end. (real symmetric <tt class="docutils literal"><span class="pre">A</span></tt> only)</td>
</tr>
</tbody>
</table>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">tol</span></tt>: tolerance (<span class="math">\(tol \le 0.0\)</span> defaults to <tt class="docutils literal"><span class="pre">DLAMCH('EPS')</span></tt>)</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">maxiter</span></tt>: Maximum number of iterations (default = 300)</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">sigma</span></tt>: Specifies the level shift used in inverse iteration. If <tt class="docutils literal"><span class="pre">nothing</span></tt> (default), defaults to ordinary (forward) iterations. Otherwise, find eigenvalues close to <tt class="docutils literal"><span class="pre">sigma</span></tt> using shift and invert iterations.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">ritzvec</span></tt>: Returns the Ritz vectors <tt class="docutils literal"><span class="pre">v</span></tt> (eigenvectors) if <tt class="docutils literal"><span class="pre">true</span></tt></p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">v0</span></tt>: starting vector from which to start the iterations</p>
</li>
</ul>
</dd>
</dl>
<p><tt class="docutils literal"><span class="pre">eigs</span></tt> returns the <tt class="docutils literal"><span class="pre">nev</span></tt> requested eigenvalues in <tt class="docutils literal"><span class="pre">d</span></tt>, the corresponding Ritz vectors <tt class="docutils literal"><span class="pre">v</span></tt> (only if <tt class="docutils literal"><span class="pre">ritzvec=true</span></tt>), the number of converged eigenvalues <tt class="docutils literal"><span class="pre">nconv</span></tt>, the number of iterations <tt class="docutils literal"><span class="pre">niter</span></tt> and the number of matrix vector multiplications <tt class="docutils literal"><span class="pre">nmult</span></tt>, as well as the final residual vector <tt class="docutils literal"><span class="pre">resid</span></tt>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>The <tt class="docutils literal"><span class="pre">sigma</span></tt> and <tt class="docutils literal"><span class="pre">which</span></tt> keywords interact: the description of eigenvalues searched for by <tt class="docutils literal"><span class="pre">which</span></tt> do _not_ necessarily refer to the eigenvalues of <tt class="docutils literal"><span class="pre">A</span></tt>, but rather the linear operator constructed by the specification of the iteration mode implied by <tt class="docutils literal"><span class="pre">sigma</span></tt>.</p>
<table border="1" class="last docutils">
<colgroup>
<col width="18%" />
<col width="41%" />
<col width="41%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">sigma</span></tt></td>
<td>iteration mode</td>
<td><tt class="docutils literal"><span class="pre">which</span></tt> refers to eigenvalues of</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">nothing</span></tt></td>
<td>ordinary (forward)</td>
<td><span class="math">\(A\)</span></td>
</tr>
<tr class="row-odd"><td>real or complex</td>
<td>inverse with level shift <tt class="docutils literal"><span class="pre">sigma</span></tt></td>
<td><span class="math">\((A - \sigma I )^{-1}\)</span></td>
</tr>
</tbody>
</table>
</div>
</dd></dl>

<dl class="function">
<dt id="Base.peakflops">
<tt class="descname">peakflops</tt><big>(</big><em>n; parallel=false</em><big>)</big><a class="headerlink" href="#Base.peakflops" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="docutils literal"><span class="pre">peakflops</span></tt> computes the peak flop rate of the computer by using double precision <a class="reference internal" href="#Base.LinAlg.BLAS.gemm!" title="Base.LinAlg.BLAS.gemm!"><tt class="xref jl jl-func docutils literal"><span class="pre">Base.LinAlg.BLAS.gemm!()</span></tt></a>. By default, if no arguments are specified, it multiplies a matrix of size <tt class="docutils literal"><span class="pre">n</span> <span class="pre">x</span> <span class="pre">n</span></tt>, where <tt class="docutils literal"><span class="pre">n</span> <span class="pre">=</span> <span class="pre">2000</span></tt>. If the underlying BLAS is using multiple threads, higher flop rates are realized. The number of BLAS threads can be set with <tt class="docutils literal"><span class="pre">blas_set_num_threads(n)</span></tt>.</p>
<p>If the keyword argument <tt class="docutils literal"><span class="pre">parallel</span></tt> is set to <tt class="docutils literal"><span class="pre">true</span></tt>, <tt class="docutils literal"><span class="pre">peakflops</span></tt> is run in parallel on all the worker processors. The flop rate of the entire parallel computer is returned. When running in parallel, only 1 BLAS thread is used. The argument <tt class="docutils literal"><span class="pre">n</span></tt> still refers to the size of the problem that is solved on each processor.</p>
</dd></dl>

</div>
<div class="section" id="module-Base.LinAlg.BLAS">
<span id="blas-functions"></span><h2>BLAS Functions<a class="headerlink" href="#module-Base.LinAlg.BLAS" title="Permalink to this headline">¶</a></h2>
<p>This module provides wrappers for some of the BLAS functions for
linear algebra.  Those BLAS functions that overwrite one of the input
arrays have names ending in <tt class="docutils literal"><span class="pre">'!'</span></tt>.</p>
<p>Usually a function has 4 methods defined, one each for <tt class="docutils literal"><span class="pre">Float64</span></tt>,
<tt class="docutils literal"><span class="pre">Float32</span></tt>, <tt class="docutils literal"><span class="pre">Complex128</span></tt> and <tt class="docutils literal"><span class="pre">Complex64</span></tt> arrays.</p>
<dl class="function">
<dt id="Base.LinAlg.BLAS.dot">
<tt class="descname">dot</tt><big>(</big><em>n</em>, <em>X</em>, <em>incx</em>, <em>Y</em>, <em>incy</em><big>)</big><a class="headerlink" href="#Base.LinAlg.BLAS.dot" title="Permalink to this definition">¶</a></dt>
<dd><p>Dot product of two vectors consisting of <tt class="docutils literal"><span class="pre">n</span></tt> elements of array
<tt class="docutils literal"><span class="pre">X</span></tt> with stride <tt class="docutils literal"><span class="pre">incx</span></tt> and <tt class="docutils literal"><span class="pre">n</span></tt> elements of array <tt class="docutils literal"><span class="pre">Y</span></tt> with
stride <tt class="docutils literal"><span class="pre">incy</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.dotu">
<tt class="descname">dotu</tt><big>(</big><em>n</em>, <em>X</em>, <em>incx</em>, <em>Y</em>, <em>incy</em><big>)</big><a class="headerlink" href="#Base.LinAlg.BLAS.dotu" title="Permalink to this definition">¶</a></dt>
<dd><p>Dot function for two complex vectors.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.dotc">
<tt class="descname">dotc</tt><big>(</big><em>n</em>, <em>X</em>, <em>incx</em>, <em>U</em>, <em>incy</em><big>)</big><a class="headerlink" href="#Base.LinAlg.BLAS.dotc" title="Permalink to this definition">¶</a></dt>
<dd><p>Dot function for two complex vectors conjugating the first vector.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.blascopy!">
<tt class="descname">blascopy!</tt><big>(</big><em>n</em>, <em>X</em>, <em>incx</em>, <em>Y</em>, <em>incy</em><big>)</big><a class="headerlink" href="#Base.LinAlg.BLAS.blascopy!" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy <tt class="docutils literal"><span class="pre">n</span></tt> elements of array <tt class="docutils literal"><span class="pre">X</span></tt> with stride <tt class="docutils literal"><span class="pre">incx</span></tt> to array
<tt class="docutils literal"><span class="pre">Y</span></tt> with stride <tt class="docutils literal"><span class="pre">incy</span></tt>.  Returns <tt class="docutils literal"><span class="pre">Y</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.nrm2">
<tt class="descname">nrm2</tt><big>(</big><em>n</em>, <em>X</em>, <em>incx</em><big>)</big><a class="headerlink" href="#Base.LinAlg.BLAS.nrm2" title="Permalink to this definition">¶</a></dt>
<dd><p>2-norm of a vector consisting of <tt class="docutils literal"><span class="pre">n</span></tt> elements of array <tt class="docutils literal"><span class="pre">X</span></tt> with
stride <tt class="docutils literal"><span class="pre">incx</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.asum">
<tt class="descname">asum</tt><big>(</big><em>n</em>, <em>X</em>, <em>incx</em><big>)</big><a class="headerlink" href="#Base.LinAlg.BLAS.asum" title="Permalink to this definition">¶</a></dt>
<dd><p>sum of the absolute values of the first <tt class="docutils literal"><span class="pre">n</span></tt> elements of array <tt class="docutils literal"><span class="pre">X</span></tt> with
stride <tt class="docutils literal"><span class="pre">incx</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.axpy!">
<tt class="descname">axpy!</tt><big>(</big><em>n</em>, <em>a</em>, <em>X</em>, <em>incx</em>, <em>Y</em>, <em>incy</em><big>)</big><a class="headerlink" href="#Base.LinAlg.BLAS.axpy!" title="Permalink to this definition">¶</a></dt>
<dd><p>Overwrite <tt class="docutils literal"><span class="pre">Y</span></tt> with <tt class="docutils literal"><span class="pre">a*X</span> <span class="pre">+</span> <span class="pre">Y</span></tt>.  Returns <tt class="docutils literal"><span class="pre">Y</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.scal!">
<tt class="descname">scal!</tt><big>(</big><em>n</em>, <em>a</em>, <em>X</em>, <em>incx</em><big>)</big><a class="headerlink" href="#Base.LinAlg.BLAS.scal!" title="Permalink to this definition">¶</a></dt>
<dd><p>Overwrite <tt class="docutils literal"><span class="pre">X</span></tt> with <tt class="docutils literal"><span class="pre">a*X</span></tt>.  Returns <tt class="docutils literal"><span class="pre">X</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.scal">
<tt class="descname">scal</tt><big>(</big><em>n</em>, <em>a</em>, <em>X</em>, <em>incx</em><big>)</big><a class="headerlink" href="#Base.LinAlg.BLAS.scal" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <tt class="docutils literal"><span class="pre">a*X</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.syrk!">
<tt class="descname">syrk!</tt><big>(</big><em>uplo</em>, <em>trans</em>, <em>alpha</em>, <em>A</em>, <em>beta</em>, <em>C</em><big>)</big><a class="headerlink" href="#Base.LinAlg.BLAS.syrk!" title="Permalink to this definition">¶</a></dt>
<dd><p>Rank-k update of the symmetric matrix <tt class="docutils literal"><span class="pre">C</span></tt> as <tt class="docutils literal"><span class="pre">alpha*A*A.'</span> <span class="pre">+</span>
<span class="pre">beta*C</span></tt> or <tt class="docutils literal"><span class="pre">alpha*A.'*A</span> <span class="pre">+</span> <span class="pre">beta*C</span></tt> according to whether <tt class="docutils literal"><span class="pre">trans</span></tt>
is &#8216;N&#8217; or &#8216;T&#8217;.  When <tt class="docutils literal"><span class="pre">uplo</span></tt> is &#8216;U&#8217; the upper triangle of <tt class="docutils literal"><span class="pre">C</span></tt> is
updated (&#8216;L&#8217; for lower triangle).  Returns <tt class="docutils literal"><span class="pre">C</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.syrk">
<tt class="descname">syrk</tt><big>(</big><em>uplo</em>, <em>trans</em>, <em>alpha</em>, <em>A</em><big>)</big><a class="headerlink" href="#Base.LinAlg.BLAS.syrk" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns either the upper triangle or the lower triangle, according
to <tt class="docutils literal"><span class="pre">uplo</span></tt> (&#8216;U&#8217; or &#8216;L&#8217;), of <tt class="docutils literal"><span class="pre">alpha*A*A.'</span></tt> or <tt class="docutils literal"><span class="pre">alpha*A.'*A</span></tt>,
according to <tt class="docutils literal"><span class="pre">trans</span></tt> (&#8216;N&#8217; or &#8216;T&#8217;).</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.herk!">
<tt class="descname">herk!</tt><big>(</big><em>uplo</em>, <em>trans</em>, <em>alpha</em>, <em>A</em>, <em>beta</em>, <em>C</em><big>)</big><a class="headerlink" href="#Base.LinAlg.BLAS.herk!" title="Permalink to this definition">¶</a></dt>
<dd><p>Methods for complex arrays only.  Rank-k update of the Hermitian
matrix <tt class="docutils literal"><span class="pre">C</span></tt> as <tt class="docutils literal"><span class="pre">alpha*A*A'</span> <span class="pre">+</span> <span class="pre">beta*C</span></tt> or <tt class="docutils literal"><span class="pre">alpha*A'*A</span> <span class="pre">+</span> <span class="pre">beta*C</span></tt>
according to whether <tt class="docutils literal"><span class="pre">trans</span></tt> is &#8216;N&#8217; or &#8216;T&#8217;.  When <tt class="docutils literal"><span class="pre">uplo</span></tt> is &#8216;U&#8217;
the upper triangle of <tt class="docutils literal"><span class="pre">C</span></tt> is updated (&#8216;L&#8217; for lower triangle).
Returns <tt class="docutils literal"><span class="pre">C</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.herk">
<tt class="descname">herk</tt><big>(</big><em>uplo</em>, <em>trans</em>, <em>alpha</em>, <em>A</em><big>)</big><a class="headerlink" href="#Base.LinAlg.BLAS.herk" title="Permalink to this definition">¶</a></dt>
<dd><p>Methods for complex arrays only.  Returns either the upper triangle
or the lower triangle, according to <tt class="docutils literal"><span class="pre">uplo</span></tt> (&#8216;U&#8217; or &#8216;L&#8217;), of
<tt class="docutils literal"><span class="pre">alpha*A*A'</span></tt> or <tt class="docutils literal"><span class="pre">alpha*A'*A</span></tt>, according to <tt class="docutils literal"><span class="pre">trans</span></tt> (&#8216;N&#8217; or &#8216;T&#8217;).</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.gbmv!">
<tt class="descname">gbmv!</tt><big>(</big><em>trans</em>, <em>m</em>, <em>kl</em>, <em>ku</em>, <em>alpha</em>, <em>A</em>, <em>x</em>, <em>beta</em>, <em>y</em><big>)</big><a class="headerlink" href="#Base.LinAlg.BLAS.gbmv!" title="Permalink to this definition">¶</a></dt>
<dd><p>Update vector <tt class="docutils literal"><span class="pre">y</span></tt> as <tt class="docutils literal"><span class="pre">alpha*A*x</span> <span class="pre">+</span> <span class="pre">beta*y</span></tt> or <tt class="docutils literal"><span class="pre">alpha*A'*x</span> <span class="pre">+</span>
<span class="pre">beta*y</span></tt> according to <tt class="docutils literal"><span class="pre">trans</span></tt> (&#8216;N&#8217; or &#8216;T&#8217;).  The matrix <tt class="docutils literal"><span class="pre">A</span></tt> is
a general band matrix of dimension <tt class="docutils literal"><span class="pre">m</span></tt> by <tt class="docutils literal"><span class="pre">size(A,2)</span></tt> with
<tt class="docutils literal"><span class="pre">kl</span></tt> sub-diagonals and <tt class="docutils literal"><span class="pre">ku</span></tt> super-diagonals. Returns the
updated <tt class="docutils literal"><span class="pre">y</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.gbmv">
<tt class="descname">gbmv</tt><big>(</big><em>trans</em>, <em>m</em>, <em>kl</em>, <em>ku</em>, <em>alpha</em>, <em>A</em>, <em>x</em>, <em>beta</em>, <em>y</em><big>)</big><a class="headerlink" href="#Base.LinAlg.BLAS.gbmv" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <tt class="docutils literal"><span class="pre">alpha*A*x</span></tt> or <tt class="docutils literal"><span class="pre">alpha*A'*x</span></tt> according to <tt class="docutils literal"><span class="pre">trans</span></tt> (&#8216;N&#8217;
or &#8216;T&#8217;). The matrix <tt class="docutils literal"><span class="pre">A</span></tt> is a general band matrix of dimension
<tt class="docutils literal"><span class="pre">m</span></tt> by <tt class="docutils literal"><span class="pre">size(A,2)</span></tt> with <tt class="docutils literal"><span class="pre">kl</span></tt> sub-diagonals and
<tt class="docutils literal"><span class="pre">ku</span></tt> super-diagonals.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.sbmv!">
<tt class="descname">sbmv!</tt><big>(</big><em>uplo</em>, <em>k</em>, <em>alpha</em>, <em>A</em>, <em>x</em>, <em>beta</em>, <em>y</em><big>)</big><a class="headerlink" href="#Base.LinAlg.BLAS.sbmv!" title="Permalink to this definition">¶</a></dt>
<dd><p>Update vector <tt class="docutils literal"><span class="pre">y</span></tt> as <tt class="docutils literal"><span class="pre">alpha*A*x</span> <span class="pre">+</span> <span class="pre">beta*y</span></tt> where <tt class="docutils literal"><span class="pre">A</span></tt> is a
a symmetric band matrix of order <tt class="docutils literal"><span class="pre">size(A,2)</span></tt> with
<tt class="docutils literal"><span class="pre">k</span></tt> super-diagonals stored in the argument <tt class="docutils literal"><span class="pre">A</span></tt>.  The storage
layout for <tt class="docutils literal"><span class="pre">A</span></tt> is described the reference BLAS module, level-2
BLAS at <a class="reference external" href="http://www.netlib.org/lapack/explore-html/">http://www.netlib.org/lapack/explore-html/</a>.</p>
<p>Returns the updated <tt class="docutils literal"><span class="pre">y</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.sbmv">
<tt class="descname">sbmv</tt><big>(</big><em>uplo</em>, <em>k</em>, <em>alpha</em>, <em>A</em>, <em>x</em><big>)</big><a class="headerlink" href="#Base.LinAlg.BLAS.sbmv" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <tt class="docutils literal"><span class="pre">alpha*A*x</span></tt> where <tt class="docutils literal"><span class="pre">A</span></tt> is a symmetric band matrix of
order <tt class="docutils literal"><span class="pre">size(A,2)</span></tt> with <tt class="docutils literal"><span class="pre">k</span></tt> super-diagonals stored in the
argument <tt class="docutils literal"><span class="pre">A</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt>
<tt class="descname">sbmv</tt><big>(</big><em>uplo</em>, <em>k</em>, <em>A</em>, <em>x</em><big>)</big></dt>
<dd><p>Returns <tt class="docutils literal"><span class="pre">A*x</span></tt> where <tt class="docutils literal"><span class="pre">A</span></tt> is a symmetric band matrix of
order <tt class="docutils literal"><span class="pre">size(A,2)</span></tt> with <tt class="docutils literal"><span class="pre">k</span></tt> super-diagonals stored in the
argument <tt class="docutils literal"><span class="pre">A</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.gemm!">
<tt class="descname">gemm!</tt><big>(</big><em>tA</em>, <em>tB</em>, <em>alpha</em>, <em>A</em>, <em>B</em>, <em>beta</em>, <em>C</em><big>)</big><a class="headerlink" href="#Base.LinAlg.BLAS.gemm!" title="Permalink to this definition">¶</a></dt>
<dd><p>Update <tt class="docutils literal"><span class="pre">C</span></tt> as <tt class="docutils literal"><span class="pre">alpha*A*B</span> <span class="pre">+</span> <span class="pre">beta*C</span></tt> or the other three variants
according to <tt class="docutils literal"><span class="pre">tA</span></tt> (transpose <tt class="docutils literal"><span class="pre">A</span></tt>) and <tt class="docutils literal"><span class="pre">tB</span></tt>.  Returns the
updated <tt class="docutils literal"><span class="pre">C</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.gemm">
<tt class="descname">gemm</tt><big>(</big><em>tA</em>, <em>tB</em>, <em>alpha</em>, <em>A</em>, <em>B</em><big>)</big><a class="headerlink" href="#Base.LinAlg.BLAS.gemm" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <tt class="docutils literal"><span class="pre">alpha*A*B</span></tt> or the other three variants
according to <tt class="docutils literal"><span class="pre">tA</span></tt> (transpose <tt class="docutils literal"><span class="pre">A</span></tt>) and <tt class="docutils literal"><span class="pre">tB</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt>
<tt class="descname">gemm</tt><big>(</big><em>tA</em>, <em>tB</em>, <em>A</em>, <em>B</em><big>)</big></dt>
<dd><p>Returns <tt class="docutils literal"><span class="pre">A*B</span></tt> or the other three variants
according to <tt class="docutils literal"><span class="pre">tA</span></tt> (transpose <tt class="docutils literal"><span class="pre">A</span></tt>) and <tt class="docutils literal"><span class="pre">tB</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.gemv!">
<tt class="descname">gemv!</tt><big>(</big><em>tA</em>, <em>alpha</em>, <em>A</em>, <em>x</em>, <em>beta</em>, <em>y</em><big>)</big><a class="headerlink" href="#Base.LinAlg.BLAS.gemv!" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the vector <tt class="docutils literal"><span class="pre">y</span></tt> as <tt class="docutils literal"><span class="pre">alpha*A*x</span> <span class="pre">+</span> <span class="pre">beta*y</span></tt> or
<tt class="docutils literal"><span class="pre">alpha*A'x</span> <span class="pre">+</span> <span class="pre">beta*y</span></tt> according to <tt class="docutils literal"><span class="pre">tA</span></tt> (transpose <tt class="docutils literal"><span class="pre">A</span></tt>).
Returns the updated <tt class="docutils literal"><span class="pre">y</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.gemv">
<tt class="descname">gemv</tt><big>(</big><em>tA</em>, <em>alpha</em>, <em>A</em>, <em>x</em><big>)</big><a class="headerlink" href="#Base.LinAlg.BLAS.gemv" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <tt class="docutils literal"><span class="pre">alpha*A*x</span></tt> or <tt class="docutils literal"><span class="pre">alpha*A'x</span></tt> according to <tt class="docutils literal"><span class="pre">tA</span></tt>
(transpose <tt class="docutils literal"><span class="pre">A</span></tt>).</p>
</dd></dl>

<dl class="function">
<dt>
<tt class="descname">gemv</tt><big>(</big><em>tA</em>, <em>A</em>, <em>x</em><big>)</big></dt>
<dd><p>Returns <tt class="docutils literal"><span class="pre">A*x</span></tt> or <tt class="docutils literal"><span class="pre">A'x</span></tt> according to <tt class="docutils literal"><span class="pre">tA</span></tt> (transpose <tt class="docutils literal"><span class="pre">A</span></tt>).</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.symm!">
<tt class="descname">symm!</tt><big>(</big><em>side</em>, <em>ul</em>, <em>alpha</em>, <em>A</em>, <em>B</em>, <em>beta</em>, <em>C</em><big>)</big><a class="headerlink" href="#Base.LinAlg.BLAS.symm!" title="Permalink to this definition">¶</a></dt>
<dd><p>Update <tt class="docutils literal"><span class="pre">C</span></tt> as <tt class="docutils literal"><span class="pre">alpha*A*B</span> <span class="pre">+</span> <span class="pre">beta*C</span></tt> or <tt class="docutils literal"><span class="pre">alpha*B*A</span> <span class="pre">+</span> <span class="pre">beta*C</span></tt>
according to <tt class="docutils literal"><span class="pre">side</span></tt>. <tt class="docutils literal"><span class="pre">A</span></tt> is assumed to be symmetric.  Only the
<tt class="docutils literal"><span class="pre">ul</span></tt> triangle of <tt class="docutils literal"><span class="pre">A</span></tt> is used.  Returns the updated <tt class="docutils literal"><span class="pre">C</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.symm">
<tt class="descname">symm</tt><big>(</big><em>side</em>, <em>ul</em>, <em>alpha</em>, <em>A</em>, <em>B</em><big>)</big><a class="headerlink" href="#Base.LinAlg.BLAS.symm" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <tt class="docutils literal"><span class="pre">alpha*A*B</span></tt> or <tt class="docutils literal"><span class="pre">alpha*B*A</span></tt> according to <tt class="docutils literal"><span class="pre">side</span></tt>.
<tt class="docutils literal"><span class="pre">A</span></tt> is assumed to be symmetric.  Only the <tt class="docutils literal"><span class="pre">ul</span></tt> triangle of
<tt class="docutils literal"><span class="pre">A</span></tt> is used.</p>
</dd></dl>

<dl class="function">
<dt>
<tt class="descname">symm</tt><big>(</big><em>side</em>, <em>ul</em>, <em>A</em>, <em>B</em><big>)</big></dt>
<dd><p>Returns <tt class="docutils literal"><span class="pre">A*B</span></tt> or <tt class="docutils literal"><span class="pre">B*A</span></tt> according to <tt class="docutils literal"><span class="pre">side</span></tt>.  <tt class="docutils literal"><span class="pre">A</span></tt> is assumed
to be symmetric.  Only the <tt class="docutils literal"><span class="pre">ul</span></tt> triangle of <tt class="docutils literal"><span class="pre">A</span></tt> is used.</p>
</dd></dl>

<dl class="function">
<dt>
<tt class="descname">symm</tt><big>(</big><em>tA</em>, <em>tB</em>, <em>alpha</em>, <em>A</em>, <em>B</em><big>)</big></dt>
<dd><p>Returns <tt class="docutils literal"><span class="pre">alpha*A*B</span></tt> or the other three variants
according to <tt class="docutils literal"><span class="pre">tA</span></tt> (transpose <tt class="docutils literal"><span class="pre">A</span></tt>) and <tt class="docutils literal"><span class="pre">tB</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.symv!">
<tt class="descname">symv!</tt><big>(</big><em>ul</em>, <em>alpha</em>, <em>A</em>, <em>x</em>, <em>beta</em>, <em>y</em><big>)</big><a class="headerlink" href="#Base.LinAlg.BLAS.symv!" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the vector <tt class="docutils literal"><span class="pre">y</span></tt> as <tt class="docutils literal"><span class="pre">alpha*A*x</span> <span class="pre">+</span> <span class="pre">beta*y</span></tt>. <tt class="docutils literal"><span class="pre">A</span></tt> is assumed
to be symmetric.  Only the <tt class="docutils literal"><span class="pre">ul</span></tt> triangle of <tt class="docutils literal"><span class="pre">A</span></tt> is used.
Returns the updated <tt class="docutils literal"><span class="pre">y</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.symv">
<tt class="descname">symv</tt><big>(</big><em>ul</em>, <em>alpha</em>, <em>A</em>, <em>x</em><big>)</big><a class="headerlink" href="#Base.LinAlg.BLAS.symv" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <tt class="docutils literal"><span class="pre">alpha*A*x</span></tt>. <tt class="docutils literal"><span class="pre">A</span></tt> is assumed to be symmetric.  Only the
<tt class="docutils literal"><span class="pre">ul</span></tt> triangle of <tt class="docutils literal"><span class="pre">A</span></tt> is used.</p>
</dd></dl>

<dl class="function">
<dt>
<tt class="descname">symv</tt><big>(</big><em>ul</em>, <em>A</em>, <em>x</em><big>)</big></dt>
<dd><p>Returns <tt class="docutils literal"><span class="pre">A*x</span></tt>.  <tt class="docutils literal"><span class="pre">A</span></tt> is assumed to be symmetric.  Only the
<tt class="docutils literal"><span class="pre">ul</span></tt> triangle of <tt class="docutils literal"><span class="pre">A</span></tt> is used.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.trmm!">
<tt class="descname">trmm!</tt><big>(</big><em>side</em>, <em>ul</em>, <em>tA</em>, <em>dA</em>, <em>alpha</em>, <em>A</em>, <em>B</em><big>)</big><a class="headerlink" href="#Base.LinAlg.BLAS.trmm!" title="Permalink to this definition">¶</a></dt>
<dd><p>Update <tt class="docutils literal"><span class="pre">B</span></tt> as <tt class="docutils literal"><span class="pre">alpha*A*B</span></tt> or one of the other three variants
determined by <tt class="docutils literal"><span class="pre">side</span></tt> (A on left or right) and <tt class="docutils literal"><span class="pre">tA</span></tt> (transpose A).
Only the <tt class="docutils literal"><span class="pre">ul</span></tt> triangle of <tt class="docutils literal"><span class="pre">A</span></tt> is used.  <tt class="docutils literal"><span class="pre">dA</span></tt> indicates if
<tt class="docutils literal"><span class="pre">A</span></tt> is unit-triangular (the diagonal is assumed to be all ones).
Returns the updated <tt class="docutils literal"><span class="pre">B</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.trmm">
<tt class="descname">trmm</tt><big>(</big><em>side</em>, <em>ul</em>, <em>tA</em>, <em>dA</em>, <em>alpha</em>, <em>A</em>, <em>B</em><big>)</big><a class="headerlink" href="#Base.LinAlg.BLAS.trmm" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <tt class="docutils literal"><span class="pre">alpha*A*B</span></tt> or one of the other three variants
determined by <tt class="docutils literal"><span class="pre">side</span></tt> (A on left or right) and <tt class="docutils literal"><span class="pre">tA</span></tt> (transpose A).
Only the <tt class="docutils literal"><span class="pre">ul</span></tt> triangle of <tt class="docutils literal"><span class="pre">A</span></tt> is used.  <tt class="docutils literal"><span class="pre">dA</span></tt> indicates if
<tt class="docutils literal"><span class="pre">A</span></tt> is unit-triangular (the diagonal is assumed to be all ones).</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.trsm!">
<tt class="descname">trsm!</tt><big>(</big><em>side</em>, <em>ul</em>, <em>tA</em>, <em>dA</em>, <em>alpha</em>, <em>A</em>, <em>B</em><big>)</big><a class="headerlink" href="#Base.LinAlg.BLAS.trsm!" title="Permalink to this definition">¶</a></dt>
<dd><p>Overwrite <tt class="docutils literal"><span class="pre">B</span></tt> with the solution to <tt class="docutils literal"><span class="pre">A*X</span> <span class="pre">=</span> <span class="pre">alpha*B</span></tt> or one of
the other three variants determined by <tt class="docutils literal"><span class="pre">side</span></tt> (A on left or
right of <tt class="docutils literal"><span class="pre">X</span></tt>) and <tt class="docutils literal"><span class="pre">tA</span></tt> (transpose A). Only the <tt class="docutils literal"><span class="pre">ul</span></tt> triangle
of <tt class="docutils literal"><span class="pre">A</span></tt> is used.  <tt class="docutils literal"><span class="pre">dA</span></tt> indicates if <tt class="docutils literal"><span class="pre">A</span></tt> is unit-triangular
(the diagonal is assumed to be all ones).  Returns the updated <tt class="docutils literal"><span class="pre">B</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.trsm">
<tt class="descname">trsm</tt><big>(</big><em>side</em>, <em>ul</em>, <em>tA</em>, <em>dA</em>, <em>alpha</em>, <em>A</em>, <em>B</em><big>)</big><a class="headerlink" href="#Base.LinAlg.BLAS.trsm" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the solution to <tt class="docutils literal"><span class="pre">A*X</span> <span class="pre">=</span> <span class="pre">alpha*B</span></tt> or one of
the other three variants determined by <tt class="docutils literal"><span class="pre">side</span></tt> (A on left or
right of <tt class="docutils literal"><span class="pre">X</span></tt>) and <tt class="docutils literal"><span class="pre">tA</span></tt> (transpose A). Only the <tt class="docutils literal"><span class="pre">ul</span></tt> triangle
of <tt class="docutils literal"><span class="pre">A</span></tt> is used.  <tt class="docutils literal"><span class="pre">dA</span></tt> indicates if <tt class="docutils literal"><span class="pre">A</span></tt> is unit-triangular
(the diagonal is assumed to be all ones).</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.trmv!">
<tt class="descname">trmv!</tt><big>(</big><em>side</em>, <em>ul</em>, <em>tA</em>, <em>dA</em>, <em>alpha</em>, <em>A</em>, <em>b</em><big>)</big><a class="headerlink" href="#Base.LinAlg.BLAS.trmv!" title="Permalink to this definition">¶</a></dt>
<dd><p>Update <tt class="docutils literal"><span class="pre">b</span></tt> as <tt class="docutils literal"><span class="pre">alpha*A*b</span></tt> or one of the other three variants
determined by <tt class="docutils literal"><span class="pre">side</span></tt> (A on left or right) and <tt class="docutils literal"><span class="pre">tA</span></tt> (transpose A).
Only the <tt class="docutils literal"><span class="pre">ul</span></tt> triangle of <tt class="docutils literal"><span class="pre">A</span></tt> is used.  <tt class="docutils literal"><span class="pre">dA</span></tt> indicates if
<tt class="docutils literal"><span class="pre">A</span></tt> is unit-triangular (the diagonal is assumed to be all ones).
Returns the updated <tt class="docutils literal"><span class="pre">b</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.trmv">
<tt class="descname">trmv</tt><big>(</big><em>side</em>, <em>ul</em>, <em>tA</em>, <em>dA</em>, <em>alpha</em>, <em>A</em>, <em>b</em><big>)</big><a class="headerlink" href="#Base.LinAlg.BLAS.trmv" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <tt class="docutils literal"><span class="pre">alpha*A*b</span></tt> or one of the other three variants
determined by <tt class="docutils literal"><span class="pre">side</span></tt> (A on left or right) and <tt class="docutils literal"><span class="pre">tA</span></tt> (transpose A).
Only the <tt class="docutils literal"><span class="pre">ul</span></tt> triangle of <tt class="docutils literal"><span class="pre">A</span></tt> is used.  <tt class="docutils literal"><span class="pre">dA</span></tt> indicates if
<tt class="docutils literal"><span class="pre">A</span></tt> is unit-triangular (the diagonal is assumed to be all ones).</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.trsv!">
<tt class="descname">trsv!</tt><big>(</big><em>ul</em>, <em>tA</em>, <em>dA</em>, <em>A</em>, <em>b</em><big>)</big><a class="headerlink" href="#Base.LinAlg.BLAS.trsv!" title="Permalink to this definition">¶</a></dt>
<dd><p>Overwrite <tt class="docutils literal"><span class="pre">b</span></tt> with the solution to <tt class="docutils literal"><span class="pre">A*x</span> <span class="pre">=</span> <span class="pre">b</span></tt> or one of the other two
variants determined by <tt class="docutils literal"><span class="pre">tA</span></tt> (transpose A) and <tt class="docutils literal"><span class="pre">ul</span></tt> (triangle of <tt class="docutils literal"><span class="pre">A</span></tt>
used).  <tt class="docutils literal"><span class="pre">dA</span></tt> indicates if <tt class="docutils literal"><span class="pre">A</span></tt> is unit-triangular (the diagonal is assumed
to be all ones).  Returns the updated <tt class="docutils literal"><span class="pre">b</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.trsv">
<tt class="descname">trsv</tt><big>(</big><em>ul</em>, <em>tA</em>, <em>dA</em>, <em>A</em>, <em>b</em><big>)</big><a class="headerlink" href="#Base.LinAlg.BLAS.trsv" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the solution to <tt class="docutils literal"><span class="pre">A*x</span> <span class="pre">=</span> <span class="pre">b</span></tt> or one of the other two variants
determined by <tt class="docutils literal"><span class="pre">tA</span></tt> (transpose A) and <tt class="docutils literal"><span class="pre">ul</span></tt> (triangle of <tt class="docutils literal"><span class="pre">A</span></tt> is used.)
<tt class="docutils literal"><span class="pre">dA</span></tt> indicates if <tt class="docutils literal"><span class="pre">A</span></tt> is unit-triangular (the diagonal is assumed to be
all ones).</p>
</dd></dl>

<dl class="function">
<dt id="Base.LinAlg.BLAS.blas_set_num_threads">
<tt class="descname">blas_set_num_threads</tt><big>(</big><em>n</em><big>)</big><a class="headerlink" href="#Base.LinAlg.BLAS.blas_set_num_threads" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the number of threads the BLAS library should use.</p>
</dd></dl>

</div>
</div>


          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../constants/" class="btn btn-neutral float-right" title="Constants">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../parallel/" class="btn btn-neutral" title="Tasks and Parallel Computing"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
    </p>
  </div>

  <a href="https://github.com/snide/sphinx_rtd_theme">Sphinx theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>
</footer>
        </div>
      </div>

    </section>

  </div>
  

  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'0.3.13-pre',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>
      <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>