

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Multi-dimensional Arrays &mdash; Julia Language 0.3.13-pre documentation</title>
  

  
  

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/julia.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../../_static/julia.css" type="text/css" />
  
    <link rel="top" title="Julia Language 0.3.13-pre documentation" href="../../"/>
        <link rel="next" title="Linear algebra" href="../linear-algebra/"/>
        <link rel="prev" title="Metaprogramming" href="../metaprogramming/"/> 

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div style="text-align:center; background-color:pink; padding:5px 0; font-size:14px; height:30px;">
    This is document is for an old version of Julia.
    Please checkout the
    <a href="https://docs.julialang.org/en/stable/"
       style="color: #2980B9;">
      current stable release
    </a>.
  </div>

  <div class="wy-grid-for-nav" style="top: 30px;">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        <a href="http://julialang.org/"><img src="../../_static/julia-logo.svg" class="logo"></a>
        <!--
        <a href="../../" class="fa fa-home"> Julia Language</a>
        -->
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search/" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
        
            <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../introduction/">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../getting-started/">Getting Started</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../getting-started/#resources">Resources</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../variables/">Variables</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../variables/#allowed-variable-names">Allowed Variable Names</a></li>
<li class="toctree-l2"><a class="reference internal" href="../variables/#stylistic-conventions">Stylistic Conventions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../integers-and-floating-point-numbers/">Integers and Floating-Point Numbers</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../integers-and-floating-point-numbers/#integers">Integers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../integers-and-floating-point-numbers/#floating-point-numbers">Floating-Point Numbers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../integers-and-floating-point-numbers/#arbitrary-precision-arithmetic">Arbitrary Precision Arithmetic</a></li>
<li class="toctree-l2"><a class="reference internal" href="../integers-and-floating-point-numbers/#numeric-literal-coefficients">Numeric Literal Coefficients</a></li>
<li class="toctree-l2"><a class="reference internal" href="../integers-and-floating-point-numbers/#literal-zero-and-one">Literal zero and one</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../mathematical-operations/">Mathematical Operations and Elementary Functions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../mathematical-operations/#arithmetic-operators">Arithmetic Operators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical-operations/#bitwise-operators">Bitwise Operators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical-operations/#updating-operators">Updating operators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical-operations/#numeric-comparisons">Numeric Comparisons</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical-operations/#elementary-functions">Elementary Functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../complex-and-rational-numbers/">Complex and Rational Numbers</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../complex-and-rational-numbers/#complex-numbers">Complex Numbers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../complex-and-rational-numbers/#rational-numbers">Rational Numbers</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../strings/">Strings</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../strings/#characters">Characters</a></li>
<li class="toctree-l2"><a class="reference internal" href="../strings/#string-basics"><tt class="docutils literal"><span class="pre">String</span></tt> Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../strings/#unicode-and-utf-8">Unicode and UTF-8</a></li>
<li class="toctree-l2"><a class="reference internal" href="../strings/#interpolation">Interpolation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../strings/#common-operations">Common Operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../strings/#non-standard-string-literals">Non-Standard String Literals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../strings/#regular-expressions">Regular Expressions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../strings/#id3">Byte Array Literals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../strings/#version-number-literals">Version Number Literals</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../functions/">Functions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../functions/#argument-passing-behavior">Argument Passing Behavior</a></li>
<li class="toctree-l2"><a class="reference internal" href="../functions/#the-return-keyword">The <tt class="docutils literal"><span class="pre">return</span></tt> Keyword</a></li>
<li class="toctree-l2"><a class="reference internal" href="../functions/#id1">Operators Are Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../functions/#operators-with-special-names">Operators With Special Names</a></li>
<li class="toctree-l2"><a class="reference internal" href="../functions/#anonymous-functions">Anonymous Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../functions/#multiple-return-values">Multiple Return Values</a></li>
<li class="toctree-l2"><a class="reference internal" href="../functions/#varargs-functions">Varargs Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../functions/#optional-arguments">Optional Arguments</a></li>
<li class="toctree-l2"><a class="reference internal" href="../functions/#keyword-arguments">Keyword Arguments</a></li>
<li class="toctree-l2"><a class="reference internal" href="../functions/#evaluation-scope-of-default-values">Evaluation Scope of Default Values</a></li>
<li class="toctree-l2"><a class="reference internal" href="../functions/#do-block-syntax-for-function-arguments">Do-Block Syntax for Function Arguments</a></li>
<li class="toctree-l2"><a class="reference internal" href="../functions/#further-reading">Further Reading</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../control-flow/">Control Flow</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../control-flow/#compound-expressions">Compound Expressions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../control-flow/#conditional-evaluation">Conditional Evaluation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../control-flow/#short-circuit-evaluation">Short-Circuit Evaluation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../control-flow/#repeated-evaluation-loops">Repeated Evaluation: Loops</a></li>
<li class="toctree-l2"><a class="reference internal" href="../control-flow/#exception-handling">Exception Handling</a></li>
<li class="toctree-l2"><a class="reference internal" href="../control-flow/#tasks-aka-coroutines">Tasks (aka Coroutines)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../variables-and-scoping/">Scope of Variables</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../variables-and-scoping/#for-loops-and-comprehensions">For Loops and Comprehensions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../variables-and-scoping/#constants">Constants</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../types/">Types</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../types/#type-declarations">Type Declarations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../types/#abstract-types">Abstract Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../types/#bits-types">Bits Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../types/#composite-types">Composite Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../types/#immutable-composite-types">Immutable Composite Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../types/#declared-types">Declared Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../types/#tuple-types">Tuple Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../types/#type-unions">Type Unions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../types/#man-parametric-types">Parametric Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../types/#type-aliases">Type Aliases</a></li>
<li class="toctree-l2"><a class="reference internal" href="../types/#operations-on-types">Operations on Types</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../methods/">Methods</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../methods/#defining-methods">Defining Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="../methods/#method-ambiguities">Method Ambiguities</a></li>
<li class="toctree-l2"><a class="reference internal" href="../methods/#parametric-methods">Parametric Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="../methods/#note-on-optional-and-keyword-arguments">Note on Optional and keyword Arguments</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../constructors/">Constructors</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../constructors/#outer-constructor-methods">Outer Constructor Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="../constructors/#inner-constructor-methods">Inner Constructor Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="../constructors/#incomplete-initialization">Incomplete Initialization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../constructors/#parametric-constructors">Parametric Constructors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../constructors/#case-study-rational">Case Study: Rational</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../conversion-and-promotion/">Conversion and Promotion</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../conversion-and-promotion/#conversion">Conversion</a></li>
<li class="toctree-l2"><a class="reference internal" href="../conversion-and-promotion/#promotion">Promotion</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../modules/">Modules</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../modules/#summary-of-module-usage">Summary of module usage</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../metaprogramming/">Metaprogramming</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../metaprogramming/#program-representation">Program representation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../metaprogramming/#expressions-and-evaluation">Expressions and evaluation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../metaprogramming/#macros">Macros</a></li>
<li class="toctree-l2"><a class="reference internal" href="../metaprogramming/#code-generation">Code Generation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../metaprogramming/#non-standard-string-literals">Non-Standard String Literals</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="current reference internal" href="">Multi-dimensional Arrays</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#arrays">Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="#sparse-matrices">Sparse Matrices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../linear-algebra/">Linear algebra</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../linear-algebra/#matrix-factorizations">Matrix factorizations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../linear-algebra/#special-matrices">Special matrices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../networking-and-streams/">Networking and Streams</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../networking-and-streams/#basic-stream-i-o">Basic Stream I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../networking-and-streams/#text-i-o">Text I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../networking-and-streams/#working-with-files">Working with Files</a></li>
<li class="toctree-l2"><a class="reference internal" href="../networking-and-streams/#a-simple-tcp-example">A simple TCP example</a></li>
<li class="toctree-l2"><a class="reference internal" href="../networking-and-streams/#resolving-ip-addresses">Resolving IP Addresses</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../parallel-computing/">Parallel Computing</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../parallel-computing/#code-availability-and-loading-packages">Code Availability and Loading Packages</a></li>
<li class="toctree-l2"><a class="reference internal" href="../parallel-computing/#data-movement">Data Movement</a></li>
<li class="toctree-l2"><a class="reference internal" href="../parallel-computing/#parallel-map-and-loops">Parallel Map and Loops</a></li>
<li class="toctree-l2"><a class="reference internal" href="../parallel-computing/#synchronization-with-remote-references">Synchronization With Remote References</a></li>
<li class="toctree-l2"><a class="reference internal" href="../parallel-computing/#scheduling">Scheduling</a></li>
<li class="toctree-l2"><a class="reference internal" href="../parallel-computing/#distributed-arrays">Distributed Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="../parallel-computing/#constructing-distributed-arrays">Constructing Distributed Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="../parallel-computing/#distributed-array-operations">Distributed Array Operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../parallel-computing/#shared-arrays-experimental">Shared Arrays (Experimental)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../parallel-computing/#clustermanagers">ClusterManagers</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../running-external-programs/">Running External Programs</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../running-external-programs/#interpolation">Interpolation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../running-external-programs/#quoting">Quoting</a></li>
<li class="toctree-l2"><a class="reference internal" href="../running-external-programs/#pipelines">Pipelines</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../calling-c-and-fortran-code/">Calling C and Fortran Code</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../calling-c-and-fortran-code/#mapping-c-types-to-julia">Mapping C Types to Julia</a></li>
<li class="toctree-l2"><a class="reference internal" href="../calling-c-and-fortran-code/#accessing-data-through-a-pointer">Accessing Data through a Pointer</a></li>
<li class="toctree-l2"><a class="reference internal" href="../calling-c-and-fortran-code/#passing-pointers-for-modifying-inputs">Passing Pointers for Modifying Inputs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../calling-c-and-fortran-code/#garbage-collection-safety">Garbage Collection Safety</a></li>
<li class="toctree-l2"><a class="reference internal" href="../calling-c-and-fortran-code/#non-constant-function-specifications">Non-constant Function Specifications</a></li>
<li class="toctree-l2"><a class="reference internal" href="../calling-c-and-fortran-code/#indirect-calls">Indirect Calls</a></li>
<li class="toctree-l2"><a class="reference internal" href="../calling-c-and-fortran-code/#calling-convention">Calling Convention</a></li>
<li class="toctree-l2"><a class="reference internal" href="../calling-c-and-fortran-code/#accessing-global-variables">Accessing Global Variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="../calling-c-and-fortran-code/#passing-julia-callback-functions-to-c">Passing Julia Callback Functions to C</a></li>
<li class="toctree-l2"><a class="reference internal" href="../calling-c-and-fortran-code/#c">C++</a></li>
<li class="toctree-l2"><a class="reference internal" href="../calling-c-and-fortran-code/#handling-platform-variations">Handling Platform Variations</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../interacting-with-julia/">Interacting With Julia</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../interacting-with-julia/#the-different-prompt-modes">The different prompt modes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../interacting-with-julia/#key-bindings">Key bindings</a></li>
<li class="toctree-l2"><a class="reference internal" href="../interacting-with-julia/#tab-completion">Tab completion</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../embedding/">Embedding Julia</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../embedding/#high-level-embedding">High-Level Embedding</a></li>
<li class="toctree-l2"><a class="reference internal" href="../embedding/#converting-types">Converting Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../embedding/#calling-julia-functions">Calling Julia Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../embedding/#memory-management">Memory Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="../embedding/#working-with-arrays">Working with Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="../embedding/#exceptions">Exceptions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../packages/">Packages</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../packages/#package-status">Package Status</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/#adding-and-removing-packages">Adding and Removing Packages</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/#installing-unregistered-packages">Installing Unregistered Packages</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/#updating-packages">Updating Packages</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/#checkout-pin-and-free">Checkout, Pin and Free</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../packages/#package-development">Package Development</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../packages/#initial-setup">Initial Setup</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/#making-changes-to-an-existing-package">Making changes to an existing package</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/#creating-a-new-package">Creating a new Package</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/#tagging-package-versions">Tagging Package Versions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/#fixing-package-requirements">Fixing Package Requirements</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/#man-package-requirements">Requirements Specification</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../profile/">Profiling</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../profile/#basic-usage">Basic usage</a></li>
<li class="toctree-l2"><a class="reference internal" href="../profile/#accumulation-and-clearing">Accumulation and clearing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../profile/#options-for-controlling-the-display-of-profile-results">Options for controlling the display of profile results</a></li>
<li class="toctree-l2"><a class="reference internal" href="../profile/#configuration">Configuration</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../profile/#memory-allocation-analysis">Memory allocation analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../performance-tips/">Performance Tips</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../performance-tips/#avoid-global-variables">Avoid global variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="../performance-tips/#measure-performance-with-time-and-pay-attention-to-memory-allocation">Measure performance with <tt class="docutils literal"><span class="pre">&#64;time</span></tt> and pay attention to memory allocation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../performance-tips/#tools">Tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="../performance-tips/#avoid-containers-with-abstract-type-parameters">Avoid containers with abstract type parameters</a></li>
<li class="toctree-l2"><a class="reference internal" href="../performance-tips/#type-declarations">Type declarations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../performance-tips/#break-functions-into-multiple-definitions">Break functions into multiple definitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../performance-tips/#write-type-stable-functions">Write &#8220;type-stable&#8221; functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../performance-tips/#avoid-changing-the-type-of-a-variable">Avoid changing the type of a variable</a></li>
<li class="toctree-l2"><a class="reference internal" href="../performance-tips/#separate-kernel-functions">Separate kernel functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../performance-tips/#access-arrays-in-memory-order-along-columns">Access arrays in memory order, along columns</a></li>
<li class="toctree-l2"><a class="reference internal" href="../performance-tips/#pre-allocating-outputs">Pre-allocating outputs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../performance-tips/#avoid-string-interpolation-for-i-o">Avoid string interpolation for I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../performance-tips/#optimize-network-i-o-during-parallel-execution">Optimize network I/O during parallel execution</a></li>
<li class="toctree-l2"><a class="reference internal" href="../performance-tips/#fix-deprecation-warnings">Fix deprecation warnings</a></li>
<li class="toctree-l2"><a class="reference internal" href="../performance-tips/#tweaks">Tweaks</a></li>
<li class="toctree-l2"><a class="reference internal" href="../performance-tips/#performance-annotations">Performance Annotations</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../workflow-tips/">Workflow Tips</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../workflow-tips/#repl-based-workflow">REPL-based workflow</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflow-tips/#browser-based-workflow">Browser-based workflow</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../style-guide/">Style Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#write-functions-not-just-scripts">Write functions, not just scripts</a></li>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#avoid-writing-overly-specific-types">Avoid writing overly-specific types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#handle-excess-argument-diversity-in-the-caller">Handle excess argument diversity in the caller</a></li>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#append-to-names-of-functions-that-modify-their-arguments">Append <cite>!</cite> to names of functions that modify their arguments</a></li>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#avoid-strange-type-unions">Avoid strange type Unions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#try-to-avoid-nullable-fields">Try to avoid nullable fields</a></li>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#avoid-elaborate-container-types">Avoid elaborate container types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#use-naming-conventions-consistent-with-julia-s-base">Use naming conventions consistent with Julia&#8217;s <tt class="docutils literal"><span class="pre">base/</span></tt></a></li>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#don-t-overuse-try-catch">Don&#8217;t overuse try-catch</a></li>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#don-t-parenthesize-conditions">Don&#8217;t parenthesize conditions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#don-t-overuse">Don&#8217;t overuse ...</a></li>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#don-t-use-unnecessary-static-parameters">Don&#8217;t use unnecessary static parameters</a></li>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#avoid-confusion-about-whether-something-is-an-instance-or-a-type">Avoid confusion about whether something is an instance or a type</a></li>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#don-t-overuse-macros">Don&#8217;t overuse macros</a></li>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#don-t-expose-unsafe-operations-at-the-interface-level">Don&#8217;t expose unsafe operations at the interface level</a></li>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#don-t-overload-methods-of-base-container-types">Don&#8217;t overload methods of base container types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#be-careful-with-type-equality">Be careful with type equality</a></li>
<li class="toctree-l2"><a class="reference internal" href="../style-guide/#do-not-write-x-f-x">Do not write <tt class="docutils literal"><span class="pre">x-&gt;f(x)</span></tt></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../faq/">Frequently Asked Questions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../faq/#sessions-and-the-repl">Sessions and the REPL</a></li>
<li class="toctree-l2"><a class="reference internal" href="../faq/#functions">Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../faq/#types-type-declarations-and-constructors">Types, type declarations, and constructors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../faq/#nothingness-and-missing-values">Nothingness and missing values</a></li>
<li class="toctree-l2"><a class="reference internal" href="../faq/#memory">Memory</a></li>
<li class="toctree-l2"><a class="reference internal" href="../faq/#julia-releases">Julia Releases</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../noteworthy-differences/">Noteworthy Differences from other Languages</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../noteworthy-differences/#noteworthy-differences-from-matlab">Noteworthy differences from MATLAB</a></li>
<li class="toctree-l2"><a class="reference internal" href="../noteworthy-differences/#noteworthy-differences-from-r">Noteworthy differences from R</a></li>
<li class="toctree-l2"><a class="reference internal" href="../noteworthy-differences/#noteworthy-differences-from-python">Noteworthy differences from Python</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../unicode-input/">Unicode Input</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/base/">Essentials</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/base/#introduction">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/base/#getting-around">Getting Around</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/base/#all-objects">All Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/base/#types">Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/base/#generic-functions">Generic Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/base/#syntax">Syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/base/#system">System</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/base/#errors">Errors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/base/#events">Events</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/base/#reflection">Reflection</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/base/#internals">Internals</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/collections/">Collections and Data Structures</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/collections/#iteration">Iteration</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/collections/#general-collections">General Collections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/collections/#iterable-collections">Iterable Collections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/collections/#indexable-collections">Indexable Collections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/collections/#associative-collections">Associative Collections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/collections/#set-like-collections">Set-Like Collections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/collections/#dequeues">Dequeues</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/collections/#priorityqueue">PriorityQueue</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/collections/#heap-functions">Heap Functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/math/">Mathematics</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/math/#mathematical-operators">Mathematical Operators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/math/#mathematical-functions">Mathematical Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/math/#statistics">Statistics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/math/#signal-processing">Signal Processing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/math/#numerical-integration">Numerical Integration</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/numbers/">Numbers</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/numbers/#standard-numeric-types">Standard Numeric Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/numbers/#data-formats">Data Formats</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/numbers/#id1">Numbers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/numbers/#bigfloats">BigFloats</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/numbers/#random-numbers">Random Numbers</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/strings/">Strings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/arrays/">Arrays</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/arrays/#basic-functions">Basic functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/arrays/#constructors">Constructors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/arrays/#mathematical-operators-and-functions">Mathematical operators and functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/arrays/#indexing-assignment-and-concatenation">Indexing, Assignment, and Concatenation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/arrays/#array-functions">Array functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/arrays/#combinatorics">Combinatorics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/arrays/#bitarrays">BitArrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/arrays/#sparse-matrices">Sparse Matrices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/parallel/">Tasks and Parallel Computing</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/parallel/#tasks">Tasks</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/parallel/#general-parallel-computing-support">General Parallel Computing Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/parallel/#distributed-arrays">Distributed Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/parallel/#shared-arrays-experimental-unix-only-feature">Shared Arrays (Experimental, UNIX-only feature)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/linalg/">Linear Algebra</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/linalg/#module-Base.LinAlg">Standard Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/linalg/#module-Base.LinAlg.BLAS">BLAS Functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/constants/">Constants</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/file/">Filesystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/io-network/">I/O and Network</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/io-network/#general-i-o">General I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/io-network/#network-i-o">Network I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/io-network/#text-i-o">Text I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/io-network/#multimedia-i-o">Multimedia I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/io-network/#memory-mapped-i-o">Memory-mapped I/O</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/punctuation/">Punctuation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/sort/">Sorting and Related Functions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/sort/#sorting-functions">Sorting Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/sort/#order-related-functions">Order-Related Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/sort/#sorting-algorithms">Sorting Algorithms</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/pkg/">Package Manager Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/collections/">Collections and Data Structures</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/collections/#iteration">Iteration</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/collections/#general-collections">General Collections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/collections/#iterable-collections">Iterable Collections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/collections/#indexable-collections">Indexable Collections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/collections/#associative-collections">Associative Collections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/collections/#set-like-collections">Set-Like Collections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/collections/#dequeues">Dequeues</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/collections/#priorityqueue">PriorityQueue</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/collections/#heap-functions">Heap Functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/graphics/">Graphics</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/graphics/#geometry">Geometry</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/test/">Unit and Functional Testing</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/test/#overview">Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/test/#handlers">Handlers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/test/#macros">Macros</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stdlib/test/#functions">Functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/test/#testing-base-julia">Testing Base Julia</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/c/">C Interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../stdlib/profile/">Profiling</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../devdocs/reflection/">Reflection and introspection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../devdocs/julia/">Documentation of Julia&#8217;s Internals</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/cartesian/">Base.Cartesian</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/sysimg/">System Image Building</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../devdocs/C/">Developing/debugging Julia&#8217;s C code</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/backtraces/">Reporting and analyzing crashes (segfaults)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devdocs/debuggingtips/">gdb debugging tips</a></li>
</ul>
</li>
</ul>

        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../">Julia Language</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../">Docs</a> &raquo;</li>
      
    <li>Multi-dimensional Arrays</li>
      <li class="wy-breadcrumbs-aside">
        
          <a href="../../_sources/manual/arrays.txt" rel="nofollow"> View page source</a>
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document">
            
  <div class="section" id="multi-dimensional-arrays">
<span id="man-arrays"></span><h1>Multi-dimensional Arrays<a class="headerlink" href="#multi-dimensional-arrays" title="Permalink to this headline">¶</a></h1>
<p>Julia, like most technical computing languages, provides a first-class
array implementation. Most technical computing languages pay a lot of
attention to their array implementation at the expense of other
containers. Julia does not treat arrays in any special way. The array
library is implemented almost completely in Julia itself, and derives
its performance from the compiler, just like any other code written in
Julia.</p>
<p>An array is a collection of objects stored in a multi-dimensional
grid.  In the most general case, an array may contain objects of type
<tt class="docutils literal"><span class="pre">Any</span></tt>.  For most computational purposes, arrays should contain
objects of a more specific type, such as <tt class="docutils literal"><span class="pre">Float64</span></tt> or <tt class="docutils literal"><span class="pre">Int32</span></tt>.</p>
<p>In general, unlike many other technical computing languages, Julia does
not expect programs to be written in a vectorized style for performance.
Julia&#8217;s compiler uses type inference and generates optimized code for
scalar array indexing, allowing programs to be written in a style that
is convenient and readable, without sacrificing performance, and using
less memory at times.</p>
<p>In Julia, all arguments to functions are passed by reference. Some
technical computing languages pass arrays by value, and this is
convenient in many cases. In Julia, modifications made to input arrays
within a function will be visible in the parent function. The entire
Julia array library ensures that inputs are not modified by library
functions. User code, if it needs to exhibit similar behavior, should
take care to create a copy of inputs that it may modify.</p>
<div class="section" id="arrays">
<h2>Arrays<a class="headerlink" href="#arrays" title="Permalink to this headline">¶</a></h2>
<div class="section" id="basic-functions">
<h3>Basic Functions<a class="headerlink" href="#basic-functions" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<colgroup>
<col width="26%" />
<col width="74%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Function</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><a class="reference internal" href="../../stdlib/collections/#Base.eltype" title="Base.eltype"><tt class="xref jl jl-func docutils literal"><span class="pre">eltype(A)</span></tt></a></td>
<td>the type of the elements contained in A</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="../../stdlib/strings/#length" title="length"><tt class="xref jl jl-func docutils literal"><span class="pre">length(A)</span></tt></a></td>
<td>the number of elements in A</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="../../stdlib/arrays/#Base.ndims" title="Base.ndims"><tt class="xref jl jl-func docutils literal"><span class="pre">ndims(A)</span></tt></a></td>
<td>the number of dimensions of A</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="../../stdlib/arrays/#Base.size" title="Base.size"><tt class="xref jl jl-func docutils literal"><span class="pre">size(A)</span></tt></a></td>
<td>a tuple containing the dimensions of A</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="../../stdlib/arrays/#Base.size" title="Base.size"><tt class="xref jl jl-func docutils literal"><span class="pre">size(A,n)</span></tt></a></td>
<td>the size of A in a particular dimension</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="../../stdlib/arrays/#Base.stride" title="Base.stride"><tt class="xref jl jl-func docutils literal"><span class="pre">stride(A,k)</span></tt></a></td>
<td>the stride (linear index distance between adjacent elements) along dimension k</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="../../stdlib/arrays/#Base.strides" title="Base.strides"><tt class="xref jl jl-func docutils literal"><span class="pre">strides(A)</span></tt></a></td>
<td>a tuple of the strides in each dimension</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="construction-and-initialization">
<h3>Construction and Initialization<a class="headerlink" href="#construction-and-initialization" title="Permalink to this headline">¶</a></h3>
<p>Many functions for constructing and initializing arrays are provided. In
the following list of such functions, calls with a <tt class="docutils literal"><span class="pre">dims...</span></tt> argument
can either take a single tuple of dimension sizes or a series of
dimension sizes passed as a variable number of arguments.</p>
<table border="1" class="docutils">
<colgroup>
<col width="43%" />
<col width="58%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Function</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><a class="reference internal" href="../../stdlib/arrays/#Base.Array" title="Base.Array"><tt class="xref jl jl-func docutils literal"><span class="pre">Array(type,</span> <span class="pre">dims...)</span></tt></a></td>
<td>an uninitialized dense array</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="../../stdlib/arrays/#Base.cell" title="Base.cell"><tt class="xref jl jl-func docutils literal"><span class="pre">cell(dims...)</span></tt></a></td>
<td>an uninitialized cell array (heterogeneous array)</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="../../stdlib/arrays/#Base.zeros" title="Base.zeros"><tt class="xref jl jl-func docutils literal"><span class="pre">zeros(type,</span> <span class="pre">dims...)</span></tt></a></td>
<td>an array of all zeros of specified type, defaults to <tt class="docutils literal"><span class="pre">Float64</span></tt> if
<tt class="docutils literal"><span class="pre">type</span></tt> not specified</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="../../stdlib/arrays/#Base.zeros" title="Base.zeros"><tt class="xref jl jl-func docutils literal"><span class="pre">zeros(A)</span></tt></a></td>
<td>an array of all zeros of same element type and shape of <tt class="docutils literal"><span class="pre">A</span></tt></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="../../stdlib/arrays/#Base.ones" title="Base.ones"><tt class="xref jl jl-func docutils literal"><span class="pre">ones(type,</span> <span class="pre">dims...)</span></tt></a></td>
<td>an array of all ones of specified type, defaults to <tt class="docutils literal"><span class="pre">Float64</span></tt> if
<tt class="docutils literal"><span class="pre">type</span></tt> not specified</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="../../stdlib/arrays/#Base.ones" title="Base.ones"><tt class="xref jl jl-func docutils literal"><span class="pre">ones(A)</span></tt></a></td>
<td>an array of all ones of same element type and shape of <tt class="docutils literal"><span class="pre">A</span></tt></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="../../stdlib/arrays/#Base.trues" title="Base.trues"><tt class="xref jl jl-func docutils literal"><span class="pre">trues(dims...)</span></tt></a></td>
<td>a <tt class="docutils literal"><span class="pre">Bool</span></tt> array with all values <tt class="docutils literal"><span class="pre">true</span></tt></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="../../stdlib/arrays/#Base.falses" title="Base.falses"><tt class="xref jl jl-func docutils literal"><span class="pre">falses(dims...)</span></tt></a></td>
<td>a <tt class="docutils literal"><span class="pre">Bool</span></tt> array with all values <tt class="docutils literal"><span class="pre">false</span></tt></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="../../stdlib/arrays/#Base.reshape" title="Base.reshape"><tt class="xref jl jl-func docutils literal"><span class="pre">reshape(A,</span> <span class="pre">dims...)</span></tt></a></td>
<td>an array with the same data as the given array, but with
different dimensions.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="../../stdlib/base/#Base.copy" title="Base.copy"><tt class="xref jl jl-func docutils literal"><span class="pre">copy(A)</span></tt></a></td>
<td>copy <tt class="docutils literal"><span class="pre">A</span></tt></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="../../stdlib/base/#Base.deepcopy" title="Base.deepcopy"><tt class="xref jl jl-func docutils literal"><span class="pre">deepcopy(A)</span></tt></a></td>
<td>copy <tt class="docutils literal"><span class="pre">A</span></tt>, recursively copying its elements</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="../../stdlib/arrays/#Base.similar" title="Base.similar"><tt class="xref jl jl-func docutils literal"><span class="pre">similar(A,</span> <span class="pre">element_type,</span> <span class="pre">dims...)</span></tt></a></td>
<td>an uninitialized array of the same type as the given array
(dense, sparse, etc.), but with the specified element type and
dimensions. The second and third arguments are both optional,
defaulting to the element type and dimensions of <tt class="docutils literal"><span class="pre">A</span></tt> if omitted.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="../../stdlib/arrays/#Base.reinterpret" title="Base.reinterpret"><tt class="xref jl jl-func docutils literal"><span class="pre">reinterpret(type,</span> <span class="pre">A)</span></tt></a></td>
<td>an array with the same binary data as the given array, but with the
specified element type</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="../../stdlib/numbers/#Base.rand" title="Base.rand"><tt class="xref jl jl-func docutils literal"><span class="pre">rand(dims)</span></tt></a></td>
<td><tt class="docutils literal"><span class="pre">Array</span></tt> of <tt class="docutils literal"><span class="pre">Float64</span></tt>s with random, iid[#]_ and uniformly
distributed values in the half-open interval [0, 1)</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="../../stdlib/numbers/#Base.randn" title="Base.randn"><tt class="xref jl jl-func docutils literal"><span class="pre">randn(dims)</span></tt></a></td>
<td><tt class="docutils literal"><span class="pre">Array</span></tt> of <tt class="docutils literal"><span class="pre">Float64</span></tt>s with random, iid and standard normally
distributed random values</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="../../stdlib/arrays/#Base.eye" title="Base.eye"><tt class="xref jl jl-func docutils literal"><span class="pre">eye(n)</span></tt></a></td>
<td><tt class="docutils literal"><span class="pre">n</span></tt>-by-<tt class="docutils literal"><span class="pre">n</span></tt> identity matrix</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="../../stdlib/arrays/#Base.eye" title="Base.eye"><tt class="xref jl jl-func docutils literal"><span class="pre">eye(m,</span> <span class="pre">n)</span></tt></a></td>
<td><tt class="docutils literal"><span class="pre">m</span></tt>-by-<tt class="docutils literal"><span class="pre">n</span></tt> identity matrix</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="../../stdlib/arrays/#Base.linspace" title="Base.linspace"><tt class="xref jl jl-func docutils literal"><span class="pre">linspace(start,</span> <span class="pre">stop,</span> <span class="pre">n)</span></tt></a></td>
<td>vector of <tt class="docutils literal"><span class="pre">n</span></tt> linearly-spaced elements from <tt class="docutils literal"><span class="pre">start</span></tt> to <tt class="docutils literal"><span class="pre">stop</span></tt></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="../../stdlib/arrays/#Base.fill!" title="Base.fill!"><tt class="xref jl jl-func docutils literal"><span class="pre">fill!(A,</span> <span class="pre">x)</span></tt></a></td>
<td>fill the array <tt class="docutils literal"><span class="pre">A</span></tt> with the value <tt class="docutils literal"><span class="pre">x</span></tt></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="../../stdlib/arrays/#Base.fill" title="Base.fill"><tt class="xref jl jl-func docutils literal"><span class="pre">fill(x,</span> <span class="pre">dims)</span></tt></a></td>
<td>create an array filled with the value <tt class="docutils literal"><span class="pre">x</span></tt></td>
</tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>iid</em>, independently and identically distributed.</td></tr>
</tbody>
</table>
</div>
<div class="section" id="concatenation">
<h3>Concatenation<a class="headerlink" href="#concatenation" title="Permalink to this headline">¶</a></h3>
<p>Arrays can be constructed and also concatenated using the following
functions:</p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="67%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Function</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><a class="reference internal" href="../../stdlib/arrays/#Base.cat" title="Base.cat"><tt class="xref jl jl-func docutils literal"><span class="pre">cat(k,</span> <span class="pre">A...)</span></tt></a></td>
<td>concatenate input n-d arrays along the dimension <tt class="docutils literal"><span class="pre">k</span></tt></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="../../stdlib/arrays/#Base.vcat" title="Base.vcat"><tt class="xref jl jl-func docutils literal"><span class="pre">vcat(A...)</span></tt></a></td>
<td>shorthand for <tt class="docutils literal"><span class="pre">cat(1,</span> <span class="pre">A...)</span></tt></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="../../stdlib/arrays/#Base.hcat" title="Base.hcat"><tt class="xref jl jl-func docutils literal"><span class="pre">hcat(A...)</span></tt></a></td>
<td>shorthand for <tt class="docutils literal"><span class="pre">cat(2,</span> <span class="pre">A...)</span></tt></td>
</tr>
</tbody>
</table>
<p>Scalar values passed to these functions are treated as 1-element arrays.</p>
<p>The concatenation functions are used so often that they have special syntax:</p>
<table border="1" class="docutils">
<colgroup>
<col width="59%" />
<col width="41%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Expression</th>
<th class="head">Calls</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">[A</span> <span class="pre">B</span> <span class="pre">C</span> <span class="pre">...]</span></tt></td>
<td><a class="reference internal" href="../../stdlib/arrays/#Base.hcat" title="Base.hcat"><tt class="xref jl jl-func docutils literal"><span class="pre">hcat()</span></tt></a></td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">[A,</span> <span class="pre">B,</span> <span class="pre">C,</span> <span class="pre">...]</span></tt></td>
<td><a class="reference internal" href="../../stdlib/arrays/#Base.vcat" title="Base.vcat"><tt class="xref jl jl-func docutils literal"><span class="pre">vcat()</span></tt></a></td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">[A</span> <span class="pre">B;</span> <span class="pre">C</span> <span class="pre">D;</span> <span class="pre">...]</span></tt></td>
<td><a class="reference internal" href="../../stdlib/arrays/#Base.hvcat" title="Base.hvcat"><tt class="xref jl jl-func docutils literal"><span class="pre">hvcat()</span></tt></a></td>
</tr>
</tbody>
</table>
<p><a class="reference internal" href="../../stdlib/arrays/#Base.hvcat" title="Base.hvcat"><tt class="xref jl jl-func docutils literal"><span class="pre">hvcat()</span></tt></a> concatenates in both dimension 1 (with semicolons) and dimension 2
(with spaces).</p>
</div>
<div class="section" id="typed-array-initializers">
<h3>Typed array initializers<a class="headerlink" href="#typed-array-initializers" title="Permalink to this headline">¶</a></h3>
<p>An array with a specific element type can be constructed using the syntax
<tt class="docutils literal"><span class="pre">T[A,</span> <span class="pre">B,</span> <span class="pre">C,</span> <span class="pre">...]</span></tt>. This will construct a 1-d array with element type
<tt class="docutils literal"><span class="pre">T</span></tt>, initialized to contain elements <tt class="docutils literal"><span class="pre">A</span></tt>, <tt class="docutils literal"><span class="pre">B</span></tt>, <tt class="docutils literal"><span class="pre">C</span></tt>, etc.</p>
<p>Special syntax is available for constructing arrays with element type
<tt class="docutils literal"><span class="pre">Any</span></tt>:</p>
<table border="1" class="docutils">
<colgroup>
<col width="40%" />
<col width="60%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Expression</th>
<th class="head">Yields</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">{A</span> <span class="pre">B</span> <span class="pre">C</span> <span class="pre">...}</span></tt></td>
<td>A 1xN <tt class="docutils literal"><span class="pre">Any</span></tt> array</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">{A,</span> <span class="pre">B,</span> <span class="pre">C,</span> <span class="pre">...}</span></tt></td>
<td>A 1-d <tt class="docutils literal"><span class="pre">Any</span></tt> array (vector)</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">{A</span> <span class="pre">B;</span> <span class="pre">C</span> <span class="pre">D;</span> <span class="pre">...}</span></tt></td>
<td>A 2-d <tt class="docutils literal"><span class="pre">Any</span></tt> array</td>
</tr>
</tbody>
</table>
<p>Note that this form does not do any concatenation; each argument becomes
an element of the resulting array.</p>
</div>
<div class="section" id="comprehensions">
<span id="id2"></span><h3>Comprehensions<a class="headerlink" href="#comprehensions" title="Permalink to this headline">¶</a></h3>
<p>Comprehensions provide a general and powerful way to construct arrays.
Comprehension syntax is similar to set construction notation in
mathematics:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">=</span> <span class="p">[</span> <span class="n">F</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="o">...</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span><span class="o">=</span><span class="n">rx</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">ry</span><span class="p">,</span> <span class="o">...</span> <span class="p">]</span>
</pre></div>
</div>
<p>The meaning of this form is that <tt class="docutils literal"><span class="pre">F(x,y,...)</span></tt> is evaluated with the
variables <tt class="docutils literal"><span class="pre">x</span></tt>, <tt class="docutils literal"><span class="pre">y</span></tt>, etc. taking on each value in their given list of
values. Values can be specified as any iterable object, but will
commonly be ranges like <tt class="docutils literal"><span class="pre">1:n</span></tt> or <tt class="docutils literal"><span class="pre">2:(n-1)</span></tt>, or explicit arrays of
values like <tt class="docutils literal"><span class="pre">[1.2,</span> <span class="pre">3.4,</span> <span class="pre">5.7]</span></tt>. The result is an N-d dense array with
dimensions that are the concatenation of the dimensions of the variable
ranges <tt class="docutils literal"><span class="pre">rx</span></tt>, <tt class="docutils literal"><span class="pre">ry</span></tt>, etc. and each <tt class="docutils literal"><span class="pre">F(x,y,...)</span></tt> evaluation returns a
scalar.</p>
<p>The following example computes a weighted average of the current element
and its left and right neighbor along a 1-d grid. :</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="kd">const</span> <span class="n">x</span> <span class="o">=</span> <span class="n">rand</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
<span class="mi">8</span><span class="o">-</span><span class="n">element</span> <span class="kt">Array</span><span class="p">{</span><span class="kt">Float64</span><span class="p">,</span><span class="mi">1</span><span class="p">}</span><span class="o">:</span>
 <span class="mf">0.843025</span>
 <span class="mf">0.869052</span>
 <span class="mf">0.365105</span>
 <span class="mf">0.699456</span>
 <span class="mf">0.977653</span>
 <span class="mf">0.994953</span>
 <span class="mf">0.41084</span>
 <span class="mf">0.809411</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="p">[</span> <span class="mf">0.25</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.25</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="o">=</span><span class="mi">2</span><span class="o">:</span><span class="n">length</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span> <span class="p">]</span>
<span class="mi">6</span><span class="o">-</span><span class="n">element</span> <span class="kt">Array</span><span class="p">{</span><span class="kt">Float64</span><span class="p">,</span><span class="mi">1</span><span class="p">}</span><span class="o">:</span>
 <span class="mf">0.736559</span>
 <span class="mf">0.57468</span>
 <span class="mf">0.685417</span>
 <span class="mf">0.912429</span>
 <span class="mf">0.8446</span>
 <span class="mf">0.656511</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In the above example, <tt class="docutils literal"><span class="pre">x</span></tt> is declared as constant because type
inference in Julia does not work as well on non-constant global
variables.</p>
</div>
<p>The resulting array type is inferred from the expression; in order to control
the type explicitly, the type can be prepended to the comprehension. For example,
in the above example we could have avoided declaring <tt class="docutils literal"><span class="pre">x</span></tt> as constant, and ensured
that the result is of type <tt class="docutils literal"><span class="pre">Float64</span></tt> by writing:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="kt">Float64</span><span class="p">[</span> <span class="mf">0.25</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.25</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="o">=</span><span class="mi">2</span><span class="o">:</span><span class="n">length</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span> <span class="p">]</span>
</pre></div>
</div>
<p>Using curly brackets instead of square brackets is a shorthand notation for an
array of type <tt class="docutils literal"><span class="pre">Any</span></tt>:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="p">{</span> <span class="n">i</span><span class="o">/</span><span class="mi">2</span> <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">:</span><span class="mi">3</span> <span class="p">}</span>
<span class="mi">3</span><span class="o">-</span><span class="n">element</span> <span class="kt">Array</span><span class="p">{</span><span class="kt">Any</span><span class="p">,</span><span class="mi">1</span><span class="p">}</span><span class="o">:</span>
 <span class="mf">0.5</span>
 <span class="mf">1.0</span>
 <span class="mf">1.5</span>
</pre></div>
</div>
</div>
<div class="section" id="indexing">
<span id="man-array-indexing"></span><h3>Indexing<a class="headerlink" href="#indexing" title="Permalink to this headline">¶</a></h3>
<p>The general syntax for indexing into an n-dimensional array A is:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">X</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">I_1</span><span class="p">,</span> <span class="n">I_2</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">I_n</span><span class="p">]</span>
</pre></div>
</div>
<p>where each I_k may be:</p>
<ol class="arabic simple">
<li>A scalar value</li>
<li>A <tt class="docutils literal"><span class="pre">Range</span></tt> of the form <tt class="docutils literal"><span class="pre">:</span></tt>, <tt class="docutils literal"><span class="pre">a:b</span></tt>, or <tt class="docutils literal"><span class="pre">a:b:c</span></tt></li>
<li>An arbitrary integer vector, including the empty vector <tt class="docutils literal"><span class="pre">[]</span></tt></li>
<li>A boolean vector</li>
</ol>
<p>The result X generally has dimensions
<tt class="docutils literal"><span class="pre">(length(I_1),</span> <span class="pre">length(I_2),</span> <span class="pre">...,</span> <span class="pre">length(I_n))</span></tt>, with location
<tt class="docutils literal"><span class="pre">(i_1,</span> <span class="pre">i_2,</span> <span class="pre">...,</span> <span class="pre">i_n)</span></tt> of X containing the value
<tt class="docutils literal"><span class="pre">A[I_1[i_1],</span> <span class="pre">I_2[i_2],</span> <span class="pre">...,</span> <span class="pre">I_n[i_n]]</span></tt>. Trailing dimensions indexed with
scalars are dropped. For example, the dimensions of <tt class="docutils literal"><span class="pre">A[I,</span> <span class="pre">1]</span></tt> will be
<tt class="docutils literal"><span class="pre">(length(I),)</span></tt>. Boolean vectors are first transformed with <tt class="docutils literal"><span class="pre">find</span></tt>; the size of
a dimension indexed by a boolean vector will be the number of true values in the vector.</p>
<p>Indexing syntax is equivalent to a call to <tt class="docutils literal"><span class="pre">getindex</span></tt>:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">X</span> <span class="o">=</span> <span class="n">getindex</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">I_1</span><span class="p">,</span> <span class="n">I_2</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">I_n</span><span class="p">)</span>
</pre></div>
</div>
<p>Example:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="o">:</span><span class="mi">16</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="mi">4</span><span class="n">x4</span> <span class="kt">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">2</span><span class="p">}</span><span class="o">:</span>
 <span class="mi">1</span>  <span class="mi">5</span>   <span class="mi">9</span>  <span class="mi">13</span>
 <span class="mi">2</span>  <span class="mi">6</span>  <span class="mi">10</span>  <span class="mi">14</span>
 <span class="mi">3</span>  <span class="mi">7</span>  <span class="mi">11</span>  <span class="mi">15</span>
 <span class="mi">4</span>  <span class="mi">8</span>  <span class="mi">12</span>  <span class="mi">16</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="o">:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="o">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="mi">2</span><span class="n">x2</span> <span class="kt">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">2</span><span class="p">}</span><span class="o">:</span>
 <span class="mi">6</span>  <span class="mi">10</span>
 <span class="mi">7</span>  <span class="mi">11</span>
</pre></div>
</div>
<p>Empty ranges of the form <tt class="docutils literal"><span class="pre">n:n-1</span></tt> are sometimes used to indicate the inter-index
location between <tt class="docutils literal"><span class="pre">n-1</span></tt> and <tt class="docutils literal"><span class="pre">n</span></tt>.  For example, the <a class="reference internal" href="../../stdlib/sort/#Base.searchsorted" title="Base.searchsorted"><tt class="xref jl jl-func docutils literal"><span class="pre">searchsorted()</span></tt></a> function uses
this convention to indicate the insertion point of a value not found in a sorted
array:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">];</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">searchsorted</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="mi">3</span><span class="o">:</span><span class="mi">2</span>
</pre></div>
</div>
</div>
<div class="section" id="assignment">
<h3>Assignment<a class="headerlink" href="#assignment" title="Permalink to this headline">¶</a></h3>
<p>The general syntax for assigning values in an n-dimensional array A is:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">A</span><span class="p">[</span><span class="n">I_1</span><span class="p">,</span> <span class="n">I_2</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">I_n</span><span class="p">]</span> <span class="o">=</span> <span class="n">X</span>
</pre></div>
</div>
<p>where each I_k may be:</p>
<ol class="arabic simple">
<li>A scalar value</li>
<li>A <tt class="docutils literal"><span class="pre">Range</span></tt> of the form <tt class="docutils literal"><span class="pre">:</span></tt>, <tt class="docutils literal"><span class="pre">a:b</span></tt>, or <tt class="docutils literal"><span class="pre">a:b:c</span></tt></li>
<li>An arbitrary integer vector, including the empty vector <tt class="docutils literal"><span class="pre">[]</span></tt></li>
<li>A boolean vector</li>
</ol>
<p>If <tt class="docutils literal"><span class="pre">X</span></tt> is an array, its size must be <tt class="docutils literal"><span class="pre">(length(I_1),</span> <span class="pre">length(I_2),</span> <span class="pre">...,</span> <span class="pre">length(I_n))</span></tt>,
and the value in location <tt class="docutils literal"><span class="pre">i_1,</span> <span class="pre">i_2,</span> <span class="pre">...,</span> <span class="pre">i_n</span></tt> of <tt class="docutils literal"><span class="pre">A</span></tt> is overwritten with
the value <tt class="docutils literal"><span class="pre">X[I_1[i_1],</span> <span class="pre">I_2[i_2],</span> <span class="pre">...,</span> <span class="pre">I_n[i_n]]</span></tt>. If <tt class="docutils literal"><span class="pre">X</span></tt> is not an array, its
value is written to all referenced locations of <tt class="docutils literal"><span class="pre">A</span></tt>.</p>
<p>A boolean vector used as an index behaves as in <a class="reference internal" href="../../stdlib/collections/#Base.getindex" title="Base.getindex"><tt class="xref jl jl-func docutils literal"><span class="pre">getindex()</span></tt></a> (it is first transformed
with <a class="reference internal" href="../../stdlib/arrays/#Base.find" title="Base.find"><tt class="xref jl jl-func docutils literal"><span class="pre">find()</span></tt></a>).</p>
<p>Index assignment syntax is equivalent to a call to <a class="reference internal" href="../../stdlib/collections/#Base.setindex!" title="Base.setindex!"><tt class="xref jl jl-func docutils literal"><span class="pre">setindex!()</span></tt></a>:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">setindex!</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">I_1</span><span class="p">,</span> <span class="n">I_2</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">I_n</span><span class="p">)</span>
</pre></div>
</div>
<p>Example:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="o">:</span><span class="mi">9</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="mi">3</span><span class="n">x3</span> <span class="kt">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">2</span><span class="p">}</span><span class="o">:</span>
 <span class="mi">1</span>  <span class="mi">4</span>  <span class="mi">7</span>
 <span class="mi">2</span>  <span class="mi">5</span>  <span class="mi">8</span>
 <span class="mi">3</span>  <span class="mi">6</span>  <span class="mi">9</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="o">:</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="o">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="o">-</span><span class="mi">1</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">x</span>
<span class="mi">3</span><span class="n">x3</span> <span class="kt">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">2</span><span class="p">}</span><span class="o">:</span>
 <span class="mi">1</span>  <span class="o">-</span><span class="mi">1</span>  <span class="o">-</span><span class="mi">1</span>
 <span class="mi">2</span>  <span class="o">-</span><span class="mi">1</span>  <span class="o">-</span><span class="mi">1</span>
 <span class="mi">3</span>   <span class="mi">6</span>   <span class="mi">9</span>
</pre></div>
</div>
</div>
<div class="section" id="vectorized-operators-and-functions">
<h3>Vectorized Operators and Functions<a class="headerlink" href="#vectorized-operators-and-functions" title="Permalink to this headline">¶</a></h3>
<p>The following operators are supported for arrays. The dot version of a binary
operator should be used for elementwise operations.</p>
<ol class="arabic simple">
<li>Unary arithmetic — <tt class="docutils literal"><span class="pre">-</span></tt>, <tt class="docutils literal"><span class="pre">+</span></tt>, <tt class="docutils literal"><span class="pre">!</span></tt></li>
<li>Binary arithmetic — <tt class="docutils literal"><span class="pre">+</span></tt>, <tt class="docutils literal"><span class="pre">-</span></tt>, <tt class="docutils literal"><span class="pre">*</span></tt>, <tt class="docutils literal"><span class="pre">.*</span></tt>, <tt class="docutils literal"><span class="pre">/</span></tt>, <tt class="docutils literal"><span class="pre">./</span></tt>,
<tt class="docutils literal"><span class="pre">\</span></tt>, <tt class="docutils literal"><span class="pre">.\</span></tt>, <tt class="docutils literal"><span class="pre">^</span></tt>, <tt class="docutils literal"><span class="pre">.^</span></tt>, <tt class="docutils literal"><span class="pre">div</span></tt>, <tt class="docutils literal"><span class="pre">mod</span></tt></li>
<li>Comparison — <tt class="docutils literal"><span class="pre">.==</span></tt>, <tt class="docutils literal"><span class="pre">.!=</span></tt>, <tt class="docutils literal"><span class="pre">.&lt;</span></tt>, <tt class="docutils literal"><span class="pre">.&lt;=</span></tt>, <tt class="docutils literal"><span class="pre">.&gt;</span></tt>, <tt class="docutils literal"><span class="pre">.&gt;=</span></tt></li>
<li>Unary Boolean or bitwise — <tt class="docutils literal"><span class="pre">~</span></tt></li>
<li>Binary Boolean or bitwise — <tt class="docutils literal"><span class="pre">&amp;</span></tt>, <tt class="docutils literal"><span class="pre">|</span></tt>, <tt class="docutils literal"><span class="pre">$</span></tt></li>
</ol>
<p>Some operators without dots operate elementwise anyway when one argument is a
scalar. These operators are <tt class="docutils literal"><span class="pre">*</span></tt>, <tt class="docutils literal"><span class="pre">+</span></tt>, <tt class="docutils literal"><span class="pre">-</span></tt>, and the bitwise operators. The
operators <tt class="docutils literal"><span class="pre">/</span></tt> and <tt class="docutils literal"><span class="pre">\</span></tt> operate elementwise when the denominator is a scalar.</p>
<p>Note that comparisons such as <tt class="docutils literal"><span class="pre">==</span></tt> operate on whole arrays, giving a single
boolean answer. Use dot operators for elementwise comparisons.</p>
<p>The following built-in functions are also vectorized, whereby the functions act
elementwise:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">abs</span> <span class="n">abs2</span> <span class="n">angle</span> <span class="n">cbrt</span>
<span class="n">airy</span> <span class="n">airyai</span> <span class="n">airyaiprime</span> <span class="n">airybi</span> <span class="n">airybiprime</span> <span class="n">airyprime</span>
<span class="n">acos</span> <span class="n">acosh</span> <span class="n">asin</span> <span class="n">asinh</span> <span class="n">atan</span> <span class="n">atan2</span> <span class="n">atanh</span>
<span class="n">acsc</span> <span class="n">acsch</span> <span class="n">asec</span> <span class="n">asech</span> <span class="n">acot</span> <span class="n">acoth</span>
<span class="n">cos</span>  <span class="n">cospi</span> <span class="n">cosh</span>  <span class="n">sin</span>  <span class="n">sinpi</span> <span class="n">sinh</span>  <span class="n">tan</span>  <span class="n">tanh</span>  <span class="n">sinc</span>  <span class="n">cosc</span>
<span class="n">csc</span>  <span class="n">csch</span>  <span class="n">sec</span>  <span class="n">sech</span>  <span class="n">cot</span>  <span class="n">coth</span>
<span class="n">acosd</span> <span class="n">asind</span> <span class="n">atand</span> <span class="n">asecd</span> <span class="n">acscd</span> <span class="n">acotd</span>
<span class="n">cosd</span>  <span class="n">sind</span>  <span class="n">tand</span>  <span class="n">secd</span>  <span class="n">cscd</span>  <span class="n">cotd</span>
<span class="n">besselh</span> <span class="n">besseli</span> <span class="n">besselj</span> <span class="n">besselj0</span> <span class="n">besselj1</span> <span class="n">besselk</span> <span class="n">bessely</span> <span class="n">bessely0</span> <span class="n">bessely1</span>
<span class="n">exp</span>  <span class="n">erf</span>  <span class="n">erfc</span>  <span class="n">erfinv</span> <span class="n">erfcinv</span> <span class="n">exp2</span>  <span class="n">expm1</span>
<span class="n">beta</span> <span class="n">dawson</span> <span class="n">digamma</span> <span class="n">erfcx</span> <span class="n">erfi</span>
<span class="n">exponent</span> <span class="n">eta</span> <span class="n">zeta</span> <span class="n">gamma</span>
<span class="n">hankelh1</span> <span class="n">hankelh2</span>
 <span class="n">ceil</span>  <span class="n">floor</span>  <span class="n">round</span>  <span class="n">trunc</span>
<span class="n">iceil</span> <span class="n">ifloor</span> <span class="n">iround</span> <span class="n">itrunc</span>
<span class="n">isfinite</span> <span class="n">isinf</span> <span class="n">isnan</span>
<span class="n">lbeta</span> <span class="n">lfact</span> <span class="n">lgamma</span>
<span class="n">log</span> <span class="n">log10</span> <span class="n">log1p</span> <span class="n">log2</span>
<span class="n">copysign</span> <span class="n">max</span> <span class="n">min</span> <span class="n">significand</span>
<span class="n">sqrt</span> <span class="n">hypot</span>
</pre></div>
</div>
<p>Note that there is a difference between <a class="reference internal" href="../../stdlib/math/#Base.min" title="Base.min"><tt class="xref jl jl-func docutils literal"><span class="pre">min()</span></tt></a> and <a class="reference internal" href="../../stdlib/math/#Base.max" title="Base.max"><tt class="xref jl jl-func docutils literal"><span class="pre">max()</span></tt></a>, which operate
elementwise over multiple array arguments, and <a class="reference internal" href="../../stdlib/collections/#Base.minimum" title="Base.minimum"><tt class="xref jl jl-func docutils literal"><span class="pre">minimum()</span></tt></a> and <a class="reference internal" href="../../stdlib/collections/#Base.maximum" title="Base.maximum"><tt class="xref jl jl-func docutils literal"><span class="pre">maximum()</span></tt></a>, which
find the smallest and largest values within an array.</p>
<p>Julia provides the <tt class="xref jl jl-func docutils literal"><span class="pre">&#64;vectorize_1arg()</span></tt> and <tt class="xref jl jl-func docutils literal"><span class="pre">&#64;vectorize_2arg()</span></tt>
macros to automatically vectorize any function of one or two arguments
respectively.  Each of these takes two arguments, namely the <tt class="docutils literal"><span class="pre">Type</span></tt> of
argument (which is usually chosen to be the most general possible) and
the name of the function to vectorize. Here is a simple example:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">square</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="n">x</span><span class="o">^</span><span class="mi">2</span>
<span class="n">square</span> <span class="p">(</span><span class="n">generic</span> <span class="k">function</span> <span class="n">with</span> <span class="mi">1</span> <span class="n">method</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nd">@vectorize_1arg</span> <span class="kt">Number</span> <span class="n">square</span>
<span class="n">square</span> <span class="p">(</span><span class="n">generic</span> <span class="k">function</span> <span class="n">with</span> <span class="mi">4</span> <span class="n">methods</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">methods</span><span class="p">(</span><span class="n">square</span><span class="p">)</span>
<span class="c"># 4 methods for generic function &quot;square&quot;:</span>
<span class="n">square</span><span class="p">{</span><span class="n">T</span><span class="o">&lt;:</span><span class="kt">Number</span><span class="p">}(</span><span class="o">::</span><span class="kt">AbstractArray</span><span class="p">{</span><span class="n">T</span><span class="o">&lt;:</span><span class="kt">Number</span><span class="p">,</span><span class="mi">1</span><span class="p">})</span> <span class="n">at</span> <span class="n">operators</span><span class="o">.</span><span class="n">jl</span><span class="o">:</span><span class="mi">359</span>
<span class="n">square</span><span class="p">{</span><span class="n">T</span><span class="o">&lt;:</span><span class="kt">Number</span><span class="p">}(</span><span class="o">::</span><span class="kt">AbstractArray</span><span class="p">{</span><span class="n">T</span><span class="o">&lt;:</span><span class="kt">Number</span><span class="p">,</span><span class="mi">2</span><span class="p">})</span> <span class="n">at</span> <span class="n">operators</span><span class="o">.</span><span class="n">jl</span><span class="o">:</span><span class="mi">360</span>
<span class="n">square</span><span class="p">{</span><span class="n">T</span><span class="o">&lt;:</span><span class="kt">Number</span><span class="p">}(</span><span class="o">::</span><span class="kt">AbstractArray</span><span class="p">{</span><span class="n">T</span><span class="o">&lt;:</span><span class="kt">Number</span><span class="p">,</span><span class="n">N</span><span class="p">})</span> <span class="n">at</span> <span class="n">operators</span><span class="o">.</span><span class="n">jl</span><span class="o">:</span><span class="mi">362</span>
<span class="n">square</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="n">at</span> <span class="n">none</span><span class="o">:</span><span class="mi">1</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">square</span><span class="p">([</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">4</span><span class="p">;</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span><span class="p">])</span>
<span class="mi">2</span><span class="n">x3</span> <span class="kt">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">2</span><span class="p">}</span><span class="o">:</span>
  <span class="mi">1</span>   <span class="mi">4</span>  <span class="mi">16</span>
 <span class="mi">25</span>  <span class="mi">36</span>  <span class="mi">49</span>
</pre></div>
</div>
</div>
<div class="section" id="broadcasting">
<h3>Broadcasting<a class="headerlink" href="#broadcasting" title="Permalink to this headline">¶</a></h3>
<p>It is sometimes useful to perform element-by-element binary operations
on arrays of different sizes, such as adding a vector to each column
of a matrix.  An inefficient way to do this would be to replicate the
vector to the size of the matrix:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">rand</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span> <span class="n">A</span> <span class="o">=</span> <span class="n">rand</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">repmat</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span><span class="o">+</span><span class="n">A</span>
<span class="mi">2</span><span class="n">x3</span> <span class="kt">Array</span><span class="p">{</span><span class="kt">Float64</span><span class="p">,</span><span class="mi">2</span><span class="p">}</span><span class="o">:</span>
 <span class="mf">1.20813</span>  <span class="mf">1.82068</span>  <span class="mf">1.25387</span>
 <span class="mf">1.56851</span>  <span class="mf">1.86401</span>  <span class="mf">1.67846</span>
</pre></div>
</div>
<p>This is wasteful when dimensions get large, so Julia offers
<a class="reference internal" href="../../stdlib/arrays/#Base.broadcast" title="Base.broadcast"><tt class="xref jl jl-func docutils literal"><span class="pre">broadcast()</span></tt></a>, which expands singleton dimensions in
array arguments to match the corresponding dimension in the other
array without using extra memory, and applies the given
function elementwise:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">broadcast</span><span class="p">(</span><span class="o">+</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">A</span><span class="p">)</span>
<span class="mi">2</span><span class="n">x3</span> <span class="kt">Array</span><span class="p">{</span><span class="kt">Float64</span><span class="p">,</span><span class="mi">2</span><span class="p">}</span><span class="o">:</span>
 <span class="mf">1.20813</span>  <span class="mf">1.82068</span>  <span class="mf">1.25387</span>
 <span class="mf">1.56851</span>  <span class="mf">1.86401</span>  <span class="mf">1.67846</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">rand</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="mi">1</span><span class="n">x2</span> <span class="kt">Array</span><span class="p">{</span><span class="kt">Float64</span><span class="p">,</span><span class="mi">2</span><span class="p">}</span><span class="o">:</span>
 <span class="mf">0.867535</span>  <span class="mf">0.00457906</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">broadcast</span><span class="p">(</span><span class="o">+</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="mi">2</span><span class="n">x2</span> <span class="kt">Array</span><span class="p">{</span><span class="kt">Float64</span><span class="p">,</span><span class="mi">2</span><span class="p">}</span><span class="o">:</span>
 <span class="mf">1.71056</span>  <span class="mf">0.847604</span>
 <span class="mf">1.73659</span>  <span class="mf">0.873631</span>
</pre></div>
</div>
<p>Elementwise operators such as <tt class="docutils literal"><span class="pre">.+</span></tt> and <tt class="docutils literal"><span class="pre">.*</span></tt> perform broadcasting if necessary. There is also a <a class="reference internal" href="../../stdlib/arrays/#Base.broadcast!" title="Base.broadcast!"><tt class="xref jl jl-func docutils literal"><span class="pre">broadcast!()</span></tt></a> function to specify an explicit destination, and <a class="reference internal" href="../../stdlib/arrays/#Base.broadcast_getindex" title="Base.broadcast_getindex"><tt class="xref jl jl-func docutils literal"><span class="pre">broadcast_getindex()</span></tt></a> and <a class="reference internal" href="../../stdlib/arrays/#Base.broadcast_setindex!" title="Base.broadcast_setindex!"><tt class="xref jl jl-func docutils literal"><span class="pre">broadcast_setindex!()</span></tt></a> that broadcast the indices before indexing.</p>
</div>
<div class="section" id="implementation">
<h3>Implementation<a class="headerlink" href="#implementation" title="Permalink to this headline">¶</a></h3>
<p>The base array type in Julia is the abstract type
<tt class="docutils literal"><span class="pre">AbstractArray{T,N}</span></tt>. It is parametrized by the number of dimensions
<tt class="docutils literal"><span class="pre">N</span></tt> and the element type <tt class="docutils literal"><span class="pre">T</span></tt>. <tt class="docutils literal"><span class="pre">AbstractVector</span></tt> and
<tt class="docutils literal"><span class="pre">AbstractMatrix</span></tt> are aliases for the 1-d and 2-d cases. Operations on
<tt class="docutils literal"><span class="pre">AbstractArray</span></tt> objects are defined using higher level operators and
functions, in a way that is independent of the underlying storage.
These operations generally work correctly as a fallback for any
specific array implementation.</p>
<p>The <tt class="docutils literal"><span class="pre">AbstractArray</span></tt> type includes anything vaguely array-like, and
implementations of it might be quite different from conventional
arrays. For example, elements might be computed on request rather than
stored.  However, any concrete <tt class="docutils literal"><span class="pre">AbstractArray{T,N}</span></tt> type should
generally implement at least <a class="reference internal" href="../../stdlib/arrays/#Base.size" title="Base.size"><tt class="xref jl jl-func docutils literal"><span class="pre">size(A)</span></tt></a> (returing an <tt class="docutils literal"><span class="pre">Int</span></tt> tuple),
<a class="reference internal" href="../../stdlib/collections/#Base.getindex" title="Base.getindex"><tt class="xref jl jl-func docutils literal"><span class="pre">getindex(A,i)</span></tt></a> and <a class="reference internal" href="../../stdlib/collections/#Base.getindex" title="Base.getindex"><tt class="xref jl jl-func docutils literal"><span class="pre">getindex(A,i1,...,iN)</span></tt></a>;
mutable arrays should also implement <a class="reference internal" href="../../stdlib/collections/#Base.setindex!" title="Base.setindex!"><tt class="xref jl jl-func docutils literal"><span class="pre">setindex!()</span></tt></a>.  It
is recommended that these operations have nearly constant time complexity,
or technically Õ(1) complexity, as otherwise some array functions may
be unexpectedly slow.   Concrete types should also typically provide
a <a class="reference internal" href="../../stdlib/arrays/#Base.similar" title="Base.similar"><tt class="xref jl jl-func docutils literal"><span class="pre">similar(A,T=eltype(A),dims=size(A))</span></tt></a> method, which is used to allocate
a similar array for <a class="reference internal" href="../../stdlib/base/#Base.copy" title="Base.copy"><tt class="xref jl jl-func docutils literal"><span class="pre">copy()</span></tt></a> and other out-of-place operations.
No matter how an <tt class="docutils literal"><span class="pre">AbstractArray{T,N}</span></tt> is represented internally,
<tt class="docutils literal"><span class="pre">T</span></tt> is the type of object returned by <em>integer</em> indexing (<tt class="docutils literal"><span class="pre">A[1,</span>
<span class="pre">...,</span> <span class="pre">1]</span></tt>, when <tt class="docutils literal"><span class="pre">A</span></tt> is not empty) and <tt class="docutils literal"><span class="pre">N</span></tt> should be the length of
the tuple returned by <a class="reference internal" href="../../stdlib/arrays/#Base.size" title="Base.size"><tt class="xref jl jl-func docutils literal"><span class="pre">size()</span></tt></a>.</p>
<p><tt class="docutils literal"><span class="pre">DenseArray</span></tt> is an abstract subtype of <tt class="docutils literal"><span class="pre">AbstractArray</span></tt> intended
to include all arrays that are laid out at regular offsets in memory,
and which can therefore be passed to external C and Fortran functions
expecting this memory layout.  Subtypes should provide a method
<a class="reference internal" href="../../stdlib/arrays/#Base.stride" title="Base.stride"><tt class="xref jl jl-func docutils literal"><span class="pre">stride(A,k)</span></tt></a> that returns the &#8220;stride&#8221; of dimension <tt class="docutils literal"><span class="pre">k</span></tt>:
increasing the index of dimension <tt class="docutils literal"><span class="pre">k</span></tt> by <tt class="docutils literal"><span class="pre">1</span></tt> should increase the
index <tt class="docutils literal"><span class="pre">i</span></tt> of <a class="reference internal" href="../../stdlib/collections/#Base.getindex" title="Base.getindex"><tt class="xref jl jl-func docutils literal"><span class="pre">getindex(A,i)</span></tt></a> by <a class="reference internal" href="../../stdlib/arrays/#Base.stride" title="Base.stride"><tt class="xref jl jl-func docutils literal"><span class="pre">stride(A,k)</span></tt></a>.  If a
pointer conversion method <a class="reference internal" href="../../stdlib/base/#Base.convert" title="Base.convert"><tt class="xref jl jl-func docutils literal"><span class="pre">convert(Ptr{T},</span> <span class="pre">A)</span></tt></a> is provided, the
memory layout should correspond in the same way to these strides.</p>
<p>The <tt class="docutils literal"><span class="pre">Array{T,N}</span></tt> type is a specific instance of <tt class="docutils literal"><span class="pre">DenseArray</span></tt>
where elements are stored in column-major order (see additional notes in
<a class="reference internal" href="../performance-tips/#man-performance-tips"><em>Performance Tips</em></a>). <tt class="docutils literal"><span class="pre">Vector</span></tt> and <tt class="docutils literal"><span class="pre">Matrix</span></tt> are aliases for
the 1-d and 2-d cases. Specific operations such as scalar indexing,
assignment, and a few other basic storage-specific operations are all
that have to be implemented for <tt class="docutils literal"><span class="pre">Array</span></tt>, so that the rest of the array
library can be implemented in a generic manner.</p>
<p><tt class="docutils literal"><span class="pre">SubArray</span></tt> is a specialization of <tt class="docutils literal"><span class="pre">AbstractArray</span></tt> that performs
indexing by reference rather than by copying. A <tt class="docutils literal"><span class="pre">SubArray</span></tt> is created
with the <a class="reference internal" href="../../stdlib/arrays/#Base.sub" title="Base.sub"><tt class="xref jl jl-func docutils literal"><span class="pre">sub()</span></tt></a> function, which is called the same way as <a class="reference internal" href="../../stdlib/collections/#Base.getindex" title="Base.getindex"><tt class="xref jl jl-func docutils literal"><span class="pre">getindex()</span></tt></a> (with
an array and a series of index arguments). The result of <a class="reference internal" href="../../stdlib/arrays/#Base.sub" title="Base.sub"><tt class="xref jl jl-func docutils literal"><span class="pre">sub()</span></tt></a> looks
the same as the result of <a class="reference internal" href="../../stdlib/collections/#Base.getindex" title="Base.getindex"><tt class="xref jl jl-func docutils literal"><span class="pre">getindex()</span></tt></a>, except the data is left in place.
<a class="reference internal" href="../../stdlib/arrays/#Base.sub" title="Base.sub"><tt class="xref jl jl-func docutils literal"><span class="pre">sub()</span></tt></a> stores the input index vectors in a <tt class="docutils literal"><span class="pre">SubArray</span></tt> object, which
can later be used to index the original array indirectly.</p>
<p><tt class="docutils literal"><span class="pre">StridedVector</span></tt> and <tt class="docutils literal"><span class="pre">StridedMatrix</span></tt> are convenient aliases defined
to make it possible for Julia to call a wider range of BLAS and LAPACK
functions by passing them either <tt class="docutils literal"><span class="pre">Array</span></tt> or <tt class="docutils literal"><span class="pre">SubArray</span></tt> objects, and
thus saving inefficiencies from memory allocation and copying.</p>
<p>The following example computes the QR decomposition of a small section
of a larger array, without creating any temporaries, and by calling the
appropriate LAPACK function with the right leading dimension size and
stride parameters.</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">rand</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span>
<span class="mi">10</span><span class="n">x10</span> <span class="kt">Array</span><span class="p">{</span><span class="kt">Float64</span><span class="p">,</span><span class="mi">2</span><span class="p">}</span><span class="o">:</span>
 <span class="mf">0.561255</span>   <span class="mf">0.226678</span>   <span class="mf">0.203391</span>  <span class="mf">0.308912</span>   <span class="n">…</span>  <span class="mf">0.750307</span>  <span class="mf">0.235023</span>   <span class="mf">0.217964</span>
 <span class="mf">0.718915</span>   <span class="mf">0.537192</span>   <span class="mf">0.556946</span>  <span class="mf">0.996234</span>      <span class="mf">0.666232</span>  <span class="mf">0.509423</span>   <span class="mf">0.660788</span>
 <span class="mf">0.493501</span>   <span class="mf">0.0565622</span>  <span class="mf">0.118392</span>  <span class="mf">0.493498</span>      <span class="mf">0.262048</span>  <span class="mf">0.940693</span>   <span class="mf">0.252965</span>
 <span class="mf">0.0470779</span>  <span class="mf">0.736979</span>   <span class="mf">0.264822</span>  <span class="mf">0.228787</span>      <span class="mf">0.161441</span>  <span class="mf">0.897023</span>   <span class="mf">0.567641</span>
 <span class="mf">0.343935</span>   <span class="mf">0.32327</span>    <span class="mf">0.795673</span>  <span class="mf">0.452242</span>      <span class="mf">0.468819</span>  <span class="mf">0.628507</span>   <span class="mf">0.511528</span>
 <span class="mf">0.935597</span>   <span class="mf">0.991511</span>   <span class="mf">0.571297</span>  <span class="mf">0.74485</span>    <span class="n">…</span>  <span class="mf">0.84589</span>   <span class="mf">0.178834</span>   <span class="mf">0.284413</span>
 <span class="mf">0.160706</span>   <span class="mf">0.672252</span>   <span class="mf">0.133158</span>  <span class="mf">0.65554</span>       <span class="mf">0.371826</span>  <span class="mf">0.770628</span>   <span class="mf">0.0531208</span>
 <span class="mf">0.306617</span>   <span class="mf">0.836126</span>   <span class="mf">0.301198</span>  <span class="mf">0.0224702</span>     <span class="mf">0.39344</span>   <span class="mf">0.0370205</span>  <span class="mf">0.536062</span>
 <span class="mf">0.890947</span>   <span class="mf">0.168877</span>   <span class="mf">0.32002</span>   <span class="mf">0.486136</span>      <span class="mf">0.096078</span>  <span class="mf">0.172048</span>   <span class="mf">0.77672</span>
 <span class="mf">0.507762</span>   <span class="mf">0.573567</span>   <span class="mf">0.220124</span>  <span class="mf">0.165816</span>      <span class="mf">0.211049</span>  <span class="mf">0.433277</span>   <span class="mf">0.539476</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">sub</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">2</span><span class="o">:</span><span class="mi">2</span><span class="o">:</span><span class="mi">8</span><span class="p">,</span><span class="mi">2</span><span class="o">:</span><span class="mi">2</span><span class="o">:</span><span class="mi">4</span><span class="p">)</span>
<span class="mi">4</span><span class="n">x2</span> <span class="kt">SubArray</span><span class="p">{</span><span class="kt">Float64</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="kt">Array</span><span class="p">{</span><span class="kt">Float64</span><span class="p">,</span><span class="mi">2</span><span class="p">},(</span><span class="kt">StepRange</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="kt">Int64</span><span class="p">},</span><span class="kt">StepRange</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="kt">Int64</span><span class="p">})}</span><span class="o">:</span>
 <span class="mf">0.537192</span>  <span class="mf">0.996234</span>
 <span class="mf">0.736979</span>  <span class="mf">0.228787</span>
 <span class="mf">0.991511</span>  <span class="mf">0.74485</span>
 <span class="mf">0.836126</span>  <span class="mf">0.0224702</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">r</span><span class="p">)</span> <span class="o">=</span> <span class="n">qr</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">q</span>
<span class="mi">4</span><span class="n">x2</span> <span class="kt">Array</span><span class="p">{</span><span class="kt">Float64</span><span class="p">,</span><span class="mi">2</span><span class="p">}</span><span class="o">:</span>
 <span class="o">-</span><span class="mf">0.338809</span>   <span class="mf">0.78934</span>
 <span class="o">-</span><span class="mf">0.464815</span>  <span class="o">-</span><span class="mf">0.230274</span>
 <span class="o">-</span><span class="mf">0.625349</span>   <span class="mf">0.194538</span>
 <span class="o">-</span><span class="mf">0.527347</span>  <span class="o">-</span><span class="mf">0.534856</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">r</span>
<span class="mi">2</span><span class="n">x2</span> <span class="kt">Array</span><span class="p">{</span><span class="kt">Float64</span><span class="p">,</span><span class="mi">2</span><span class="p">}</span><span class="o">:</span>
 <span class="o">-</span><span class="mf">1.58553</span>  <span class="o">-</span><span class="mf">0.921517</span>
  <span class="mf">0.0</span>       <span class="mf">0.866567</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="sparse-matrices">
<h2>Sparse Matrices<a class="headerlink" href="#sparse-matrices" title="Permalink to this headline">¶</a></h2>
<p><a class="reference external" href="http://en.wikipedia.org/wiki/Sparse_matrix">Sparse matrices</a> are
matrices that contain enough zeros that storing them in a special data
structure leads to savings in space and execution time. Sparse
matrices may be used when operations on the sparse representation of a
matrix lead to considerable gains in either time or space when
compared to performing the same operations on a dense matrix.</p>
<div class="section" id="compressed-sparse-column-csc-storage">
<h3>Compressed Sparse Column (CSC) Storage<a class="headerlink" href="#compressed-sparse-column-csc-storage" title="Permalink to this headline">¶</a></h3>
<p>In Julia, sparse matrices are stored in the <a class="reference external" href="http://en.wikipedia.org/wiki/Sparse_matrix#Compressed_sparse_column_.28CSC_or_CCS.29">Compressed Sparse Column
(CSC) format</a>.
Julia sparse matrices have the type <tt class="docutils literal"><span class="pre">SparseMatrixCSC{Tv,Ti}</span></tt>, where <tt class="docutils literal"><span class="pre">Tv</span></tt>
is the type of the nonzero values, and <tt class="docutils literal"><span class="pre">Ti</span></tt> is the integer type for
storing column pointers and row indices.:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="k">type</span> <span class="kt">SparseMatrixCSC</span><span class="p">{</span><span class="n">Tv</span><span class="p">,</span><span class="n">Ti</span><span class="o">&lt;:</span><span class="kt">Integer</span><span class="p">}</span> <span class="o">&lt;:</span> <span class="kt">AbstractSparseMatrix</span><span class="p">{</span><span class="n">Tv</span><span class="p">,</span><span class="n">Ti</span><span class="p">}</span>
    <span class="n">m</span><span class="o">::</span><span class="kt">Int</span>                  <span class="c"># Number of rows</span>
    <span class="n">n</span><span class="o">::</span><span class="kt">Int</span>                  <span class="c"># Number of columns</span>
    <span class="n">colptr</span><span class="o">::</span><span class="kt">Vector</span><span class="p">{</span><span class="n">Ti</span><span class="p">}</span>      <span class="c"># Column i is in colptr[i]:(colptr[i+1]-1)</span>
    <span class="n">rowval</span><span class="o">::</span><span class="kt">Vector</span><span class="p">{</span><span class="n">Ti</span><span class="p">}</span>      <span class="c"># Row values of nonzeros</span>
    <span class="n">nzval</span><span class="o">::</span><span class="kt">Vector</span><span class="p">{</span><span class="n">Tv</span><span class="p">}</span>       <span class="c"># Nonzero values</span>
<span class="k">end</span>
</pre></div>
</div>
<p>The compressed sparse column storage makes it easy and quick to access
the elements in the column of a sparse matrix, whereas accessing the
sparse matrix by rows is considerably slower. Operations such as
insertion of nonzero values one at a time in the CSC structure tend to
be slow. This is because all elements of the sparse matrix that are
beyond the point of insertion have to be moved one place over.</p>
<p>All operations on sparse matrices are carefully implemented to exploit
the CSC data structure for performance, and to avoid expensive operations.</p>
<p>If you have data in CSC format from a different application or library,
and wish to import it in Julia, make sure that you use 1-based indexing.
The row indices in every column need to be sorted. If your <cite>SparseMatrixCSC</cite>
object contains unsorted row indices, one quick way to sort them is by
doing a double transpose.</p>
<p>In some applications, it is convenient to store explicit zero values
in a <cite>SparseMatrixCSC</cite>. These <em>are</em> accepted by functions in <tt class="docutils literal"><span class="pre">Base</span></tt>
(but there is no guarantee that they will be preserved in mutating
operations).  Such explicitly stored zeros are treated as structural
nonzeros by many routines.  The <a class="reference internal" href="../../stdlib/arrays/#Base.nnz" title="Base.nnz"><tt class="xref jl jl-func docutils literal"><span class="pre">nnz()</span></tt></a> function returns the number of
elements explicitly stored in the sparse data structure,
including structural nonzeros. In order to count the exact number of actual
values that are nonzero, use <a class="reference internal" href="../../stdlib/arrays/#Base.countnz" title="Base.countnz"><tt class="xref jl jl-func docutils literal"><span class="pre">countnz()</span></tt></a>, which inspects every stored
element of a sparse matrix.</p>
</div>
<div class="section" id="sparse-matrix-constructors">
<h3>Sparse matrix constructors<a class="headerlink" href="#sparse-matrix-constructors" title="Permalink to this headline">¶</a></h3>
<p>The simplest way to create sparse matrices is to use functions
equivalent to the <a class="reference internal" href="../../stdlib/arrays/#Base.zeros" title="Base.zeros"><tt class="xref jl jl-func docutils literal"><span class="pre">zeros()</span></tt></a> and <a class="reference internal" href="../../stdlib/arrays/#Base.eye" title="Base.eye"><tt class="xref jl jl-func docutils literal"><span class="pre">eye()</span></tt></a> functions that Julia provides
for working with dense matrices. To produce sparse matrices instead,
you can use the same names with an <tt class="docutils literal"><span class="pre">sp</span></tt> prefix:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">spzeros</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
<span class="mi">3</span><span class="n">x5</span> <span class="n">sparse</span> <span class="n">matrix</span> <span class="n">with</span> <span class="mi">0</span> <span class="kt">Float64</span> <span class="n">entries</span><span class="o">:</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">speye</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
<span class="mi">3</span><span class="n">x5</span> <span class="n">sparse</span> <span class="n">matrix</span> <span class="n">with</span> <span class="mi">3</span> <span class="kt">Float64</span> <span class="n">entries</span><span class="o">:</span>
        <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>  <span class="o">=</span>  <span class="mf">1.0</span>
        <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>  <span class="o">=</span>  <span class="mf">1.0</span>
        <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>  <span class="o">=</span>  <span class="mf">1.0</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="../../stdlib/arrays/#Base.sparse" title="Base.sparse"><tt class="xref jl jl-func docutils literal"><span class="pre">sparse()</span></tt></a> function is often a handy way to construct sparse
matrices. It takes as its input a vector <tt class="docutils literal"><span class="pre">I</span></tt> of row indices, a
vector <tt class="docutils literal"><span class="pre">J</span></tt> of column indices, and a vector <tt class="docutils literal"><span class="pre">V</span></tt> of nonzero
values. <tt class="docutils literal"><span class="pre">sparse(I,J,V)</span></tt> constructs a sparse matrix such that
<tt class="docutils literal"><span class="pre">S[I[k],</span> <span class="pre">J[k]]</span> <span class="pre">=</span> <span class="pre">V[k]</span></tt>.</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="nb">I</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">];</span> <span class="n">J</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">9</span><span class="p">];</span> <span class="n">V</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">S</span> <span class="o">=</span> <span class="n">sparse</span><span class="p">(</span><span class="nb">I</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">V</span><span class="p">)</span>
<span class="mi">5</span><span class="n">x18</span> <span class="n">sparse</span> <span class="n">matrix</span> <span class="n">with</span> <span class="mi">4</span> <span class="kt">Int64</span> <span class="n">entries</span><span class="o">:</span>
        <span class="p">[</span><span class="mi">1</span> <span class="p">,</span>  <span class="mi">4</span><span class="p">]</span>  <span class="o">=</span>  <span class="mi">1</span>
        <span class="p">[</span><span class="mi">4</span> <span class="p">,</span>  <span class="mi">7</span><span class="p">]</span>  <span class="o">=</span>  <span class="mi">2</span>
        <span class="p">[</span><span class="mi">5</span> <span class="p">,</span>  <span class="mi">9</span><span class="p">]</span>  <span class="o">=</span>  <span class="mi">3</span>
        <span class="p">[</span><span class="mi">3</span> <span class="p">,</span> <span class="mi">18</span><span class="p">]</span>  <span class="o">=</span>  <span class="o">-</span><span class="mi">5</span>
</pre></div>
</div>
<p>The inverse of the <a class="reference internal" href="../../stdlib/arrays/#Base.sparse" title="Base.sparse"><tt class="xref jl jl-func docutils literal"><span class="pre">sparse()</span></tt></a> function is <a class="reference internal" href="../../stdlib/arrays/#Base.findn" title="Base.findn"><tt class="xref jl jl-func docutils literal"><span class="pre">findn()</span></tt></a>, which
retrieves the inputs used to create the sparse matrix.</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">findn</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
<span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">18</span><span class="p">])</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">findnz</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
<span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">18</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">5</span><span class="p">])</span>
</pre></div>
</div>
<p>Another way to create sparse matrices is to convert a dense matrix
into a sparse matrix using the <a class="reference internal" href="../../stdlib/arrays/#Base.sparse" title="Base.sparse"><tt class="xref jl jl-func docutils literal"><span class="pre">sparse()</span></tt></a> function:</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">sparse</span><span class="p">(</span><span class="n">eye</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="mi">5</span><span class="n">x5</span> <span class="n">sparse</span> <span class="n">matrix</span> <span class="n">with</span> <span class="mi">5</span> <span class="kt">Float64</span> <span class="n">entries</span><span class="o">:</span>
        <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>  <span class="o">=</span>  <span class="mf">1.0</span>
        <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>  <span class="o">=</span>  <span class="mf">1.0</span>
        <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>  <span class="o">=</span>  <span class="mf">1.0</span>
        <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>  <span class="o">=</span>  <span class="mf">1.0</span>
        <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>  <span class="o">=</span>  <span class="mf">1.0</span>
</pre></div>
</div>
<p>You can go in the other direction using the <a class="reference internal" href="../../stdlib/arrays/#Base.full" title="Base.full"><tt class="xref jl jl-func docutils literal"><span class="pre">full()</span></tt></a> function. The
<a class="reference internal" href="../../stdlib/arrays/#Base.issparse" title="Base.issparse"><tt class="xref jl jl-func docutils literal"><span class="pre">issparse()</span></tt></a> function can be used to query if a matrix is sparse.</p>
<div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span> <span class="n">issparse</span><span class="p">(</span><span class="n">speye</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="kc">true</span>
</pre></div>
</div>
</div>
<div class="section" id="sparse-matrix-operations">
<h3>Sparse matrix operations<a class="headerlink" href="#sparse-matrix-operations" title="Permalink to this headline">¶</a></h3>
<p>Arithmetic operations on sparse matrices also work as they do on dense
matrices. Indexing of, assignment into, and concatenation of sparse
matrices work in the same way as dense matrices. Indexing operations,
especially assignment, are expensive, when carried out one element at
a time. In many cases it may be better to convert the sparse matrix
into <tt class="docutils literal"><span class="pre">(I,J,V)</span></tt> format using <a class="reference internal" href="../../stdlib/arrays/#Base.findnz" title="Base.findnz"><tt class="xref jl jl-func docutils literal"><span class="pre">findnz()</span></tt></a>, manipulate the non-zeroes or
the structure in the dense vectors <tt class="docutils literal"><span class="pre">(I,J,V)</span></tt>, and then reconstruct
the sparse matrix.</p>
</div>
<div class="section" id="correspondence-of-dense-and-sparse-methods">
<h3>Correspondence of dense and sparse methods<a class="headerlink" href="#correspondence-of-dense-and-sparse-methods" title="Permalink to this headline">¶</a></h3>
<p>The following table gives a correspondence between built-in methods on sparse
matrices and their corresponding methods on dense matrix types. In general,
methods that generate sparse matrices differ from their dense counterparts in
that the resulting matrix follows the same sparsity pattern as a given sparse
matrix <tt class="docutils literal"><span class="pre">S</span></tt>, or that the resulting sparse matrix has density <tt class="docutils literal"><span class="pre">d</span></tt>, i.e. each
matrix element has a probability <tt class="docutils literal"><span class="pre">d</span></tt> of being non-zero.</p>
<p>Details can be found in the <a class="reference internal" href="../../stdlib/arrays/#stdlib-sparse"><em>Sparse Matrices</em></a> section of the standard library
reference.</p>
<table border="1" class="docutils">
<colgroup>
<col width="34%" />
<col width="29%" />
<col width="37%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Sparse</td>
<td>Dense</td>
<td>Description</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="../../stdlib/arrays/#Base.spzeros" title="Base.spzeros"><tt class="xref jl jl-func docutils literal"><span class="pre">spzeros(m,n)</span></tt></a></td>
<td><a class="reference internal" href="../../stdlib/arrays/#Base.zeros" title="Base.zeros"><tt class="xref jl jl-func docutils literal"><span class="pre">zeros(m,n)</span></tt></a></td>
<td>Creates a <em>m</em>-by-<em>n</em> matrix of zeros.
(<a class="reference internal" href="../../stdlib/arrays/#Base.spzeros" title="Base.spzeros"><tt class="xref jl jl-func docutils literal"><span class="pre">spzeros(m,n)</span></tt></a> is empty.)</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="../../stdlib/arrays/#Base.spones" title="Base.spones"><tt class="xref jl jl-func docutils literal"><span class="pre">spones(S)</span></tt></a></td>
<td><a class="reference internal" href="../../stdlib/arrays/#Base.ones" title="Base.ones"><tt class="xref jl jl-func docutils literal"><span class="pre">ones(m,n)</span></tt></a></td>
<td>Creates a matrix filled with ones.
Unlike the dense version, <a class="reference internal" href="../../stdlib/arrays/#Base.spones" title="Base.spones"><tt class="xref jl jl-func docutils literal"><span class="pre">spones()</span></tt></a>
has the same sparsity pattern as <em>S</em>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="../../stdlib/arrays/#Base.speye" title="Base.speye"><tt class="xref jl jl-func docutils literal"><span class="pre">speye(n)</span></tt></a></td>
<td><a class="reference internal" href="../../stdlib/arrays/#Base.eye" title="Base.eye"><tt class="xref jl jl-func docutils literal"><span class="pre">eye(n)</span></tt></a></td>
<td>Creates a <em>n</em>-by-<em>n</em> identity matrix.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="../../stdlib/arrays/#Base.full" title="Base.full"><tt class="xref jl jl-func docutils literal"><span class="pre">full(S)</span></tt></a></td>
<td><a class="reference internal" href="../../stdlib/arrays/#Base.sparse" title="Base.sparse"><tt class="xref jl jl-func docutils literal"><span class="pre">sparse(A)</span></tt></a></td>
<td>Interconverts between dense
and sparse formats.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="../../stdlib/arrays/#Base.sprand" title="Base.sprand"><tt class="xref jl jl-func docutils literal"><span class="pre">sprand(m,n,d)</span></tt></a></td>
<td><a class="reference internal" href="../../stdlib/numbers/#Base.rand" title="Base.rand"><tt class="xref jl jl-func docutils literal"><span class="pre">rand(m,n)</span></tt></a></td>
<td>Creates a <em>m</em>-by-<em>n</em> random matrix (of
density <em>d</em>) with iid non-zero elements
distributed uniformly on the
half-open interval [0, 1).</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="../../stdlib/arrays/#Base.sprandn" title="Base.sprandn"><tt class="xref jl jl-func docutils literal"><span class="pre">sprandn(m,n,d)</span></tt></a></td>
<td><a class="reference internal" href="../../stdlib/numbers/#Base.randn" title="Base.randn"><tt class="xref jl jl-func docutils literal"><span class="pre">randn(m,n)</span></tt></a></td>
<td>Creates a <em>m</em>-by-<em>n</em> random matrix (of
density <em>d</em>) with iid non-zero elements
distributed according to the standard
normal (Gaussian) distribution.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="../../stdlib/arrays/#Base.sprandn" title="Base.sprandn"><tt class="xref jl jl-func docutils literal"><span class="pre">sprandn(m,n,d,X)</span></tt></a></td>
<td><a class="reference internal" href="../../stdlib/numbers/#Base.randn" title="Base.randn"><tt class="xref jl jl-func docutils literal"><span class="pre">randn(m,n,X)</span></tt></a></td>
<td>Creates a <em>m</em>-by-<em>n</em> random matrix (of
density <em>d</em>) with iid non-zero elements
distributed according to the <em>X</em>
distribution. (Requires the
<tt class="docutils literal"><span class="pre">Distributions</span></tt> package.)</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="../../stdlib/arrays/#Base.sprandbool" title="Base.sprandbool"><tt class="xref jl jl-func docutils literal"><span class="pre">sprandbool(m,n,d)</span></tt></a></td>
<td><a class="reference internal" href="../../stdlib/numbers/#Base.randbool" title="Base.randbool"><tt class="xref jl jl-func docutils literal"><span class="pre">randbool(m,n)</span></tt></a></td>
<td>Creates a <em>m</em>-by-<em>n</em> random matrix (of
density <em>d</em>) with non-zero  <tt class="docutils literal"><span class="pre">Bool</span></tt>
elements with probability <em>d</em> (<em>d</em> =0.5
for <a class="reference internal" href="../../stdlib/numbers/#Base.randbool" title="Base.randbool"><tt class="xref jl jl-func docutils literal"><span class="pre">randbool()</span></tt></a>.)</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>


          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../linear-algebra/" class="btn btn-neutral float-right" title="Linear algebra">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../metaprogramming/" class="btn btn-neutral" title="Metaprogramming"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
    </p>
  </div>

  <a href="https://github.com/snide/sphinx_rtd_theme">Sphinx theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>
</footer>
        </div>
      </div>

    </section>

  </div>
  

  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'0.3.13-pre',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>
      <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>