<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Mathematical Operations and Elementary Functions · The Julia Language</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-28835595-6', 'auto');
ga('send', 'pageview');
</script><link rel="canonical" href="https://docs.julialang.org/en/stable/manual/mathematical-operations/index.html"/><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../../assets/julia-manual.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../../index.html"><img class="logo" src="../../assets/logo.png" alt="The Julia Language logo"/></a><h1>The Julia Language</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../getting-started/">Getting Started</a></li><li><a class="toctext" href="../variables/">Variables</a></li><li><a class="toctext" href="../integers-and-floating-point-numbers/">Integers and Floating-Point Numbers</a></li><li class="current"><a class="toctext" href>Mathematical Operations and Elementary Functions</a><ul class="internal"><li><a class="toctext" href="#Arithmetic-Operators-1">Arithmetic Operators</a></li><li><a class="toctext" href="#Bitwise-Operators-1">Bitwise Operators</a></li><li><a class="toctext" href="#Updating-operators-1">Updating operators</a></li><li><a class="toctext" href="#man-dot-operators-1">Vectorized &quot;dot&quot; operators</a></li><li><a class="toctext" href="#Numeric-Comparisons-1">Numeric Comparisons</a></li><li><a class="toctext" href="#Operator-Precedence-and-Associativity-1">Operator Precedence and Associativity</a></li><li><a class="toctext" href="#Numerical-Conversions-1">Numerical Conversions</a></li></ul></li><li><a class="toctext" href="../complex-and-rational-numbers/">Complex and Rational Numbers</a></li><li><a class="toctext" href="../strings/">Strings</a></li><li><a class="toctext" href="../functions/">Functions</a></li><li><a class="toctext" href="../control-flow/">Control Flow</a></li><li><a class="toctext" href="../variables-and-scoping/">Scope of Variables</a></li><li><a class="toctext" href="../types/">Types</a></li><li><a class="toctext" href="../methods/">Methods</a></li><li><a class="toctext" href="../constructors/">Constructors</a></li><li><a class="toctext" href="../conversion-and-promotion/">Conversion and Promotion</a></li><li><a class="toctext" href="../interfaces/">Interfaces</a></li><li><a class="toctext" href="../modules/">Modules</a></li><li><a class="toctext" href="../documentation/">Documentation</a></li><li><a class="toctext" href="../metaprogramming/">Metaprogramming</a></li><li><a class="toctext" href="../arrays/">Multi-dimensional Arrays</a></li><li><a class="toctext" href="../missing/">Missing Values</a></li><li><a class="toctext" href="../networking-and-streams/">Networking and Streams</a></li><li><a class="toctext" href="../parallel-computing/">Parallel Computing</a></li><li><a class="toctext" href="../running-external-programs/">Running External Programs</a></li><li><a class="toctext" href="../calling-c-and-fortran-code/">Calling C and Fortran Code</a></li><li><a class="toctext" href="../handling-operating-system-variation/">Handling Operating System Variation</a></li><li><a class="toctext" href="../environment-variables/">Environment Variables</a></li><li><a class="toctext" href="../embedding/">Embedding Julia</a></li><li><a class="toctext" href="../code-loading/">Code Loading</a></li><li><a class="toctext" href="../profile/">Profiling</a></li><li><a class="toctext" href="../stacktraces/">Stack Traces</a></li><li><a class="toctext" href="../performance-tips/">Performance Tips</a></li><li><a class="toctext" href="../workflow-tips/">Workflow Tips</a></li><li><a class="toctext" href="../style-guide/">Style Guide</a></li><li><a class="toctext" href="../faq/">Frequently Asked Questions</a></li><li><a class="toctext" href="../noteworthy-differences/">Noteworthy Differences from other Languages</a></li><li><a class="toctext" href="../unicode-input/">Unicode Input</a></li></ul></li><li><span class="toctext">Base</span><ul><li><a class="toctext" href="../../base/base/">Essentials</a></li><li><a class="toctext" href="../../base/collections/">Collections and Data Structures</a></li><li><a class="toctext" href="../../base/math/">Mathematics</a></li><li><a class="toctext" href="../../base/numbers/">Numbers</a></li><li><a class="toctext" href="../../base/strings/">Strings</a></li><li><a class="toctext" href="../../base/arrays/">Arrays</a></li><li><a class="toctext" href="../../base/parallel/">Tasks</a></li><li><a class="toctext" href="../../base/multi-threading/">Multi-Threading</a></li><li><a class="toctext" href="../../base/constants/">Constants</a></li><li><a class="toctext" href="../../base/file/">Filesystem</a></li><li><a class="toctext" href="../../base/io-network/">I/O and Network</a></li><li><a class="toctext" href="../../base/punctuation/">Punctuation</a></li><li><a class="toctext" href="../../base/sort/">Sorting and Related Functions</a></li><li><a class="toctext" href="../../base/iterators/">Iteration utilities</a></li><li><a class="toctext" href="../../base/c/">C Interface</a></li><li><a class="toctext" href="../../base/libc/">C Standard Library</a></li><li><a class="toctext" href="../../base/stacktraces/">StackTraces</a></li><li><a class="toctext" href="../../base/simd-types/">SIMD Support</a></li></ul></li><li><span class="toctext">Standard Library</span><ul><li><a class="toctext" href="../../stdlib/Base64/">Base64</a></li><li><a class="toctext" href="../../stdlib/CRC32c/">CRC32c</a></li><li><a class="toctext" href="../../stdlib/Dates/">Dates</a></li><li><a class="toctext" href="../../stdlib/DelimitedFiles/">Delimited Files</a></li><li><a class="toctext" href="../../stdlib/Distributed/">Distributed Computing</a></li><li><a class="toctext" href="../../stdlib/FileWatching/">File Events</a></li><li><a class="toctext" href="../../stdlib/InteractiveUtils/">Interactive Utilities</a></li><li><a class="toctext" href="../../stdlib/LibGit2/">LibGit2</a></li><li><a class="toctext" href="../../stdlib/Libdl/">Dynamic Linker</a></li><li><a class="toctext" href="../../stdlib/LinearAlgebra/">Linear Algebra</a></li><li><a class="toctext" href="../../stdlib/Logging/">Logging</a></li><li><a class="toctext" href="../../stdlib/Markdown/">Markdown</a></li><li><a class="toctext" href="../../stdlib/Mmap/">Memory-mapped I/O</a></li><li><a class="toctext" href="../../stdlib/Pkg/">Pkg</a></li><li><a class="toctext" href="../../stdlib/Printf/">Printf</a></li><li><a class="toctext" href="../../stdlib/Profile/">Profiling</a></li><li><a class="toctext" href="../../stdlib/REPL/">The Julia REPL</a></li><li><a class="toctext" href="../../stdlib/Random/">Random Numbers</a></li><li><a class="toctext" href="../../stdlib/SHA/">SHA</a></li><li><a class="toctext" href="../../stdlib/Serialization/">Serialization</a></li><li><a class="toctext" href="../../stdlib/SharedArrays/">Shared Arrays</a></li><li><a class="toctext" href="../../stdlib/Sockets/">Sockets</a></li><li><a class="toctext" href="../../stdlib/SparseArrays/">Sparse Arrays</a></li><li><a class="toctext" href="../../stdlib/Statistics/">Statistics</a></li><li><a class="toctext" href="../../stdlib/Test/">Unit Testing</a></li><li><a class="toctext" href="../../stdlib/UUIDs/">UUIDs</a></li><li><a class="toctext" href="../../stdlib/Unicode/">Unicode</a></li></ul></li><li><span class="toctext">Developer Documentation</span><ul><li><a class="toctext" href="../../devdocs/reflection/">Reflection and introspection</a></li><li><span class="toctext">Documentation of Julia&#39;s Internals</span><ul><li><a class="toctext" href="../../devdocs/init/">Initialization of the Julia runtime</a></li><li><a class="toctext" href="../../devdocs/ast/">Julia ASTs</a></li><li><a class="toctext" href="../../devdocs/types/">More about types</a></li><li><a class="toctext" href="../../devdocs/object/">Memory layout of Julia Objects</a></li><li><a class="toctext" href="../../devdocs/eval/">Eval of Julia code</a></li><li><a class="toctext" href="../../devdocs/callconv/">Calling Conventions</a></li><li><a class="toctext" href="../../devdocs/compiler/">High-level Overview of the Native-Code Generation Process</a></li><li><a class="toctext" href="../../devdocs/functions/">Julia Functions</a></li><li><a class="toctext" href="../../devdocs/cartesian/">Base.Cartesian</a></li><li><a class="toctext" href="../../devdocs/meta/">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="../../devdocs/subarrays/">SubArrays</a></li><li><a class="toctext" href="../../devdocs/isbitsunionarrays/">isbits Union Optimizations</a></li><li><a class="toctext" href="../../devdocs/sysimg/">System Image Building</a></li><li><a class="toctext" href="../../devdocs/llvm/">Working with LLVM</a></li><li><a class="toctext" href="../../devdocs/stdio/">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="../../devdocs/boundscheck/">Bounds checking</a></li><li><a class="toctext" href="../../devdocs/locks/">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="../../devdocs/offset-arrays/">Arrays with custom indices</a></li><li><a class="toctext" href="../../devdocs/require/">Module loading</a></li><li><a class="toctext" href="../../devdocs/inference/">Inference</a></li></ul></li><li><span class="toctext">Developing/debugging Julia&#39;s C code</span><ul><li><a class="toctext" href="../../devdocs/backtraces/">Reporting and analyzing crashes (segfaults)</a></li><li><a class="toctext" href="../../devdocs/debuggingtips/">gdb debugging tips</a></li><li><a class="toctext" href="../../devdocs/valgrind/">Using Valgrind with Julia</a></li><li><a class="toctext" href="../../devdocs/sanitizers/">Sanitizer support</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href>Mathematical Operations and Elementary Functions</a></li></ul><a class="edit-page" href="https://github.com/fredrikekre/julia/blob/master/doc/src/manual/mathematical-operations.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Mathematical Operations and Elementary Functions</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Mathematical-Operations-and-Elementary-Functions-1" href="#Mathematical-Operations-and-Elementary-Functions-1">Mathematical Operations and Elementary Functions</a></h1><p>Julia provides a complete collection of basic arithmetic and bitwise operators across all of its numeric primitive types, as well as providing portable, efficient implementations of a comprehensive collection of standard mathematical functions.</p><h2><a class="nav-anchor" id="Arithmetic-Operators-1" href="#Arithmetic-Operators-1">Arithmetic Operators</a></h2><p>The following <a href="https://en.wikipedia.org/wiki/Arithmetic#Arithmetic_operations">arithmetic operators</a> are supported on all primitive numeric types:</p><table><tr><th>Expression</th><th>Name</th><th>Description</th></tr><tr><td><code>+x</code></td><td>unary plus</td><td>the identity operation</td></tr><tr><td><code>-x</code></td><td>unary minus</td><td>maps values to their additive inverses</td></tr><tr><td><code>x + y</code></td><td>binary plus</td><td>performs addition</td></tr><tr><td><code>x - y</code></td><td>binary minus</td><td>performs subtraction</td></tr><tr><td><code>x * y</code></td><td>times</td><td>performs multiplication</td></tr><tr><td><code>x / y</code></td><td>divide</td><td>performs division</td></tr><tr><td><code>x ÷ y</code></td><td>integer divide</td><td>x / y, truncated to an integer</td></tr><tr><td><code>x \ y</code></td><td>inverse divide</td><td>equivalent to <code>y / x</code></td></tr><tr><td><code>x ^ y</code></td><td>power</td><td>raises <code>x</code> to the <code>y</code>th power</td></tr><tr><td><code>x % y</code></td><td>remainder</td><td>equivalent to <code>rem(x,y)</code></td></tr></table><p>as well as the negation on <a href="../../base/numbers/#Core.Bool"><code>Bool</code></a> types:</p><table><tr><th>Expression</th><th>Name</th><th>Description</th></tr><tr><td><code>!x</code></td><td>negation</td><td>changes <code>true</code> to <code>false</code> and vice versa</td></tr></table><p>Julia&#39;s promotion system makes arithmetic operations on mixtures of argument types &quot;just work&quot; naturally and automatically. See <a href="../conversion-and-promotion/#conversion-and-promotion-1">Conversion and Promotion</a> for details of the promotion system.</p><p>Here are some simple examples using arithmetic operators:</p><pre><code class="language-julia-repl">julia&gt; 1 + 2 + 3
6

julia&gt; 1 - 2
-1

julia&gt; 3*2/12
0.5</code></pre><p>(By convention, we tend to space operators more tightly if they get applied before other nearby operators. For instance, we would generally write <code>-x + 2</code> to reflect that first <code>x</code> gets negated, and then <code>2</code> is added to that result.)</p><h2><a class="nav-anchor" id="Bitwise-Operators-1" href="#Bitwise-Operators-1">Bitwise Operators</a></h2><p>The following <a href="https://en.wikipedia.org/wiki/Bitwise_operation#Bitwise_operators">bitwise operators</a> are supported on all primitive integer types:</p><table><tr><th>Expression</th><th>Name</th></tr><tr><td><code>~x</code></td><td>bitwise not</td></tr><tr><td><code>x &amp; y</code></td><td>bitwise and</td></tr><tr><td><code>x | y</code></td><td>bitwise or</td></tr><tr><td><code>x ⊻ y</code></td><td>bitwise xor (exclusive or)</td></tr><tr><td><code>x &gt;&gt;&gt; y</code></td><td><a href="https://en.wikipedia.org/wiki/Logical_shift">logical shift</a> right</td></tr><tr><td><code>x &gt;&gt; y</code></td><td><a href="https://en.wikipedia.org/wiki/Arithmetic_shift">arithmetic shift</a> right</td></tr><tr><td><code>x &lt;&lt; y</code></td><td>logical/arithmetic shift left</td></tr></table><p>Here are some examples with bitwise operators:</p><pre><code class="language-julia-repl">julia&gt; ~123
-124

julia&gt; 123 &amp; 234
106

julia&gt; 123 | 234
251

julia&gt; 123 ⊻ 234
145

julia&gt; xor(123, 234)
145

julia&gt; ~UInt32(123)
0xffffff84

julia&gt; ~UInt8(123)
0x84</code></pre><h2><a class="nav-anchor" id="Updating-operators-1" href="#Updating-operators-1">Updating operators</a></h2><p>Every binary arithmetic and bitwise operator also has an updating version that assigns the result of the operation back into its left operand. The updating version of the binary operator is formed by placing a <code>=</code> immediately after the operator. For example, writing <code>x += 3</code> is equivalent to writing <code>x = x + 3</code>:</p><pre><code class="language-julia-repl">julia&gt; x = 1
1

julia&gt; x += 3
4

julia&gt; x
4</code></pre><p>The updating versions of all the binary arithmetic and bitwise operators are:</p><pre><code class="language-none">+=  -=  *=  /=  \=  ÷=  %=  ^=  &amp;=  |=  ⊻=  &gt;&gt;&gt;=  &gt;&gt;=  &lt;&lt;=</code></pre><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>An updating operator rebinds the variable on the left-hand side. As a result, the type of the variable may change.</p><pre><code class="language-julia-repl">julia&gt; x = 0x01; typeof(x)
UInt8

julia&gt; x *= 2 # Same as x = x * 2
2

julia&gt; typeof(x)
Int64</code></pre></div></div><h2><a class="nav-anchor" id="man-dot-operators-1" href="#man-dot-operators-1">Vectorized &quot;dot&quot; operators</a></h2><p>For <em>every</em> binary operation like <code>^</code>, there is a corresponding &quot;dot&quot; operation <code>.^</code> that is <em>automatically</em> defined to perform <code>^</code> element-by-element on arrays. For example, <code>[1,2,3] ^ 3</code> is not defined, since there is no standard mathematical meaning to &quot;cubing&quot; a (non-square) array, but <code>[1,2,3] .^ 3</code> is defined as computing the elementwise (or &quot;vectorized&quot;) result <code>[1^3, 2^3, 3^3]</code>.  Similarly for unary operators like <code>!</code> or <code>√</code>, there is a corresponding <code>.√</code> that applies the operator elementwise.</p><pre><code class="language-julia-repl">julia&gt; [1,2,3] .^ 3
3-element Array{Int64,1}:
  1
  8
 27</code></pre><p>More specifically, <code>a .^ b</code> is parsed as the <a href="../functions/#man-vectorized-1">&quot;dot&quot; call</a> <code>(^).(a,b)</code>, which performs a <a href="../arrays/#Broadcasting-1">broadcast</a> operation: it can combine arrays and scalars, arrays of the same size (performing the operation elementwise), and even arrays of different shapes (e.g. combining row and column vectors to produce a matrix). Moreover, like all vectorized &quot;dot calls,&quot; these &quot;dot operators&quot; are <em>fusing</em>. For example, if you compute <code>2 .* A.^2 .+ sin.(A)</code> (or equivalently <code>@. 2A^2 + sin(A)</code>, using the <a href="../../base/arrays/#Base.Broadcast.@__dot__"><code>@.</code></a> macro) for an array <code>A</code>, it performs a <em>single</em> loop over <code>A</code>, computing <code>2a^2 + sin(a)</code> for each element of <code>A</code>. In particular, nested dot calls like <code>f.(g.(x))</code> are fused, and &quot;adjacent&quot; binary operators like <code>x .+ 3 .* x.^2</code> are equivalent to nested dot calls <code>(+).(x, (*).(3, (^).(x, 2)))</code>.</p><p>Furthermore, &quot;dotted&quot; updating operators like <code>a .+= b</code> (or <code>@. a += b</code>) are parsed as <code>a .= a .+ b</code>, where <code>.=</code> is a fused <em>in-place</em> assignment operation (see the <a href="../functions/#man-vectorized-1">dot syntax documentation</a>).</p><p>Note the dot syntax is also applicable to user-defined operators. For example, if you define <code>⊗(A,B) = kron(A,B)</code> to give a convenient infix syntax <code>A ⊗ B</code> for Kronecker products (<a href="../../stdlib/LinearAlgebra/#Base.kron"><code>kron</code></a>), then <code>[A,B] .⊗ [C,D]</code> will compute <code>[A⊗C, B⊗D]</code> with no additional coding.</p><p>Combining dot operators with numeric literals can be ambiguous. For example, it is not clear whether <code>1.+x</code> means <code>1. + x</code> or <code>1 .+ x</code>. Therefore this syntax is disallowed, and spaces must be used around the operator in such cases.</p><h2><a class="nav-anchor" id="Numeric-Comparisons-1" href="#Numeric-Comparisons-1">Numeric Comparisons</a></h2><p>Standard comparison operations are defined for all the primitive numeric types:</p><table><tr><th>Operator</th><th>Name</th></tr><tr><td><a href="../../base/math/#Base.:=="><code>==</code></a></td><td>equality</td></tr><tr><td><a href="../../base/math/#Base.:!="><code>!=</code></a>, <a href="../../base/math/#Base.:!="><code>≠</code></a></td><td>inequality</td></tr><tr><td><a href="../../base/math/#Base.:&lt;"><code>&lt;</code></a></td><td>less than</td></tr><tr><td><a href="../../base/math/#Base.:&lt;="><code>&lt;=</code></a>, <a href="../../base/math/#Base.:&lt;="><code>≤</code></a></td><td>less than or equal to</td></tr><tr><td><a href="../../base/math/#Base.:&gt;"><code>&gt;</code></a></td><td>greater than</td></tr><tr><td><a href="../../base/math/#Base.:&gt;="><code>&gt;=</code></a>, <a href="../../base/math/#Base.:&gt;="><code>≥</code></a></td><td>greater than or equal to</td></tr></table><p>Here are some simple examples:</p><pre><code class="language-julia-repl">julia&gt; 1 == 1
true

julia&gt; 1 == 2
false

julia&gt; 1 != 2
true

julia&gt; 1 == 1.0
true

julia&gt; 1 &lt; 2
true

julia&gt; 1.0 &gt; 3
false

julia&gt; 1 &gt;= 1.0
true

julia&gt; -1 &lt;= 1
true

julia&gt; -1 &lt;= -1
true

julia&gt; -1 &lt;= -2
false

julia&gt; 3 &lt; -0.5
false</code></pre><p>Integers are compared in the standard manner – by comparison of bits. Floating-point numbers are compared according to the <a href="https://en.wikipedia.org/wiki/IEEE_754-2008">IEEE 754 standard</a>:</p><ul><li>Finite numbers are ordered in the usual manner.</li><li>Positive zero is equal but not greater than negative zero.</li><li><code>Inf</code> is equal to itself and greater than everything else except <code>NaN</code>.</li><li><code>-Inf</code> is equal to itself and less then everything else except <code>NaN</code>.</li><li><code>NaN</code> is not equal to, not less than, and not greater than anything, including itself.</li></ul><p>The last point is potentially surprising and thus worth noting:</p><pre><code class="language-julia-repl">julia&gt; NaN == NaN
false

julia&gt; NaN != NaN
true

julia&gt; NaN &lt; NaN
false

julia&gt; NaN &gt; NaN
false</code></pre><p>and can cause especial headaches with <a href="../arrays/#man-multi-dim-arrays-1">arrays</a>:</p><pre><code class="language-julia-repl">julia&gt; [1 NaN] == [1 NaN]
false</code></pre><p>Julia provides additional functions to test numbers for special values, which can be useful in situations like hash key comparisons:</p><table><tr><th>Function</th><th>Tests if</th></tr><tr><td><a href="../../base/base/#Base.isequal"><code>isequal(x, y)</code></a></td><td><code>x</code> and <code>y</code> are identical</td></tr><tr><td><a href="../../base/numbers/#Base.isfinite"><code>isfinite(x)</code></a></td><td><code>x</code> is a finite number</td></tr><tr><td><a href="../../base/numbers/#Base.isinf"><code>isinf(x)</code></a></td><td><code>x</code> is infinite</td></tr><tr><td><a href="../../base/numbers/#Base.isnan"><code>isnan(x)</code></a></td><td><code>x</code> is not a number</td></tr></table><p><a href="../../base/base/#Base.isequal"><code>isequal</code></a> considers <code>NaN</code>s equal to each other:</p><pre><code class="language-julia-repl">julia&gt; isequal(NaN, NaN)
true

julia&gt; isequal([1 NaN], [1 NaN])
true

julia&gt; isequal(NaN, NaN32)
true</code></pre><p><code>isequal</code> can also be used to distinguish signed zeros:</p><pre><code class="language-julia-repl">julia&gt; -0.0 == 0.0
true

julia&gt; isequal(-0.0, 0.0)
false</code></pre><p>Mixed-type comparisons between signed integers, unsigned integers, and floats can be tricky. A great deal of care has been taken to ensure that Julia does them correctly.</p><p>For other types, <code>isequal</code> defaults to calling <a href="../../base/math/#Base.:=="><code>==</code></a>, so if you want to define equality for your own types then you only need to add a <a href="../../base/math/#Base.:=="><code>==</code></a> method.  If you define your own equality function, you should probably define a corresponding <a href="../../base/base/#Base.hash"><code>hash</code></a> method to ensure that <code>isequal(x,y)</code> implies <code>hash(x) == hash(y)</code>.</p><h3><a class="nav-anchor" id="Chaining-comparisons-1" href="#Chaining-comparisons-1">Chaining comparisons</a></h3><p>Unlike most languages, with the <a href="https://en.wikipedia.org/wiki/Python_syntax_and_semantics#Comparison_operators">notable exception of Python</a>, comparisons can be arbitrarily chained:</p><pre><code class="language-julia-repl">julia&gt; 1 &lt; 2 &lt;= 2 &lt; 3 == 3 &gt; 2 &gt;= 1 == 1 &lt; 3 != 5
true</code></pre><p>Chaining comparisons is often quite convenient in numerical code. Chained comparisons use the <code>&amp;&amp;</code> operator for scalar comparisons, and the <a href="../../base/math/#Base.:&amp;"><code>&amp;</code></a> operator for elementwise comparisons, which allows them to work on arrays. For example, <code>0 .&lt; A .&lt; 1</code> gives a boolean array whose entries are true where the corresponding elements of <code>A</code> are between 0 and 1.</p><p>Note the evaluation behavior of chained comparisons:</p><pre><code class="language-julia-repl">julia&gt; v(x) = (println(x); x)
v (generic function with 1 method)

julia&gt; v(1) &lt; v(2) &lt;= v(3)
2
1
3
true

julia&gt; v(1) &gt; v(2) &lt;= v(3)
2
1
false</code></pre><p>The middle expression is only evaluated once, rather than twice as it would be if the expression were written as <code>v(1) &lt; v(2) &amp;&amp; v(2) &lt;= v(3)</code>. However, the order of evaluations in a chained comparison is undefined. It is strongly recommended not to use expressions with side effects (such as printing) in chained comparisons. If side effects are required, the short-circuit <code>&amp;&amp;</code> operator should be used explicitly (see <a href="../control-flow/#Short-Circuit-Evaluation-1">Short-Circuit Evaluation</a>).</p><h3><a class="nav-anchor" id="Elementary-Functions-1" href="#Elementary-Functions-1">Elementary Functions</a></h3><p>Julia provides a comprehensive collection of mathematical functions and operators. These mathematical operations are defined over as broad a class of numerical values as permit sensible definitions, including integers, floating-point numbers, rationals, and complex numbers, wherever such definitions make sense.</p><p>Moreover, these functions (like any Julia function) can be applied in &quot;vectorized&quot; fashion to arrays and other collections with the <a href="../functions/#man-vectorized-1">dot syntax</a> <code>f.(A)</code>, e.g. <code>sin.(A)</code> will compute the sine of each element of an array <code>A</code>.</p><h2><a class="nav-anchor" id="Operator-Precedence-and-Associativity-1" href="#Operator-Precedence-and-Associativity-1">Operator Precedence and Associativity</a></h2><p>Julia applies the following order and associativity of operations, from highest precedence to lowest:</p><table><tr><th>Category</th><th>Operators</th><th>Associativity</th></tr><tr><td>Syntax</td><td><code>.</code> followed by <code>::</code></td><td>Left</td></tr><tr><td>Exponentiation</td><td><code>^</code></td><td>Right</td></tr><tr><td>Unary</td><td><code>+ - √</code></td><td>Right<a href="#footnote-1">[1]</a></td></tr><tr><td>Bitshifts</td><td><code>&lt;&lt; &gt;&gt; &gt;&gt;&gt;</code></td><td>Left</td></tr><tr><td>Fractions</td><td><code>//</code></td><td>Left</td></tr><tr><td>Multiplication</td><td><code>* / % &amp; \ ÷</code></td><td>Left<a href="#footnote-2">[2]</a></td></tr><tr><td>Addition</td><td><code>+ - | ⊻</code></td><td>Left<a href="#footnote-2">[2]</a></td></tr><tr><td>Syntax</td><td><code>: ..</code></td><td>Left</td></tr><tr><td>Syntax</td><td><code>|&gt;</code></td><td>Left</td></tr><tr><td>Syntax</td><td><code>&lt;|</code></td><td>Right</td></tr><tr><td>Comparisons</td><td><code>&gt; &lt; &gt;= &lt;= == === != !== &lt;:</code></td><td>Non-associative</td></tr><tr><td>Control flow</td><td><code>&amp;&amp;</code> followed by <code>||</code> followed by <code>?</code></td><td>Right</td></tr><tr><td>Pair</td><td><code>=&gt;</code></td><td>Right</td></tr><tr><td>Assignments</td><td><code>= += -= *= /= //= \= ^= ÷= %= |= &amp;= ⊻= &lt;&lt;= &gt;&gt;= &gt;&gt;&gt;=</code></td><td>Right</td></tr></table><div class="footnote" id="footnote-1"><a href="#footnote-1"><strong>[1]</strong></a><p>The unary operators <code>+</code> and <code>-</code> require explicit parentheses around their argument to disambiguate them from the operator <code>++</code>, etc. Other compositions of unary operators are parsed with right-associativity, e. g., <code>√√-a</code> as <code>√(√(-a))</code>.</p></div><div class="footnote" id="footnote-2"><a href="#footnote-2"><strong>[2]</strong></a><p>The operators <code>+</code>, <code>++</code> and <code>*</code> are non-associative. <code>a + b + c</code> is parsed as <code>+(a, b, c)</code> not <code>+(+(a, b), c)</code>. However, the fallback methods for <code>+(a, b, c, d...)</code> and <code>*(a, b, c, d...)</code> both default to left-associative evaluation.</p></div><p>For a complete list of <em>every</em> Julia operator&#39;s precedence, see the top of this file: <a href="https://github.com/JuliaLang/julia/blob/master/src/julia-parser.scm"><code>src/julia-parser.scm</code></a></p><p>You can also find the numerical precedence for any given operator via the built-in function <code>Base.operator_precedence</code>, where higher numbers take precedence:</p><pre><code class="language-julia-repl">julia&gt; Base.operator_precedence(:+), Base.operator_precedence(:*), Base.operator_precedence(:.)
(11, 13, 17)

julia&gt; Base.operator_precedence(:sin), Base.operator_precedence(:+=), Base.operator_precedence(:(=))  # (Note the necessary parens on `:(=)`)
(0, 1, 1)</code></pre><p>A symbol representing the operator associativity can also be found by calling the built-in function <code>Base.operator_associativity</code>:</p><pre><code class="language-julia-repl">julia&gt; Base.operator_associativity(:-), Base.operator_associativity(:+), Base.operator_associativity(:^)
(:left, :none, :right)

julia&gt; Base.operator_associativity(:⊗), Base.operator_associativity(:sin), Base.operator_associativity(:→)
(:left, :none, :right)</code></pre><p>Note that symbols such as <code>:sin</code> return precedence <code>0</code>. This value represents invalid operators and not operators of lowest precedence. Similarly, such operators are assigned associativity <code>:none</code>.</p><h2><a class="nav-anchor" id="Numerical-Conversions-1" href="#Numerical-Conversions-1">Numerical Conversions</a></h2><p>Julia supports three forms of numerical conversion, which differ in their handling of inexact conversions.</p><ul><li><p>The notation <code>T(x)</code> or <code>convert(T,x)</code> converts <code>x</code> to a value of type <code>T</code>.</p><ul><li>If <code>T</code> is a floating-point type, the result is the nearest representable value, which could be positive or negative infinity.</li><li>If <code>T</code> is an integer type, an <code>InexactError</code> is raised if <code>x</code> is not representable by <code>T</code>.</li></ul></li><li><p><code>x % T</code> converts an integer <code>x</code> to a value of integer type <code>T</code> congruent to <code>x</code> modulo <code>2^n</code>, where <code>n</code> is the number of bits in <code>T</code>. In other words, the binary representation is truncated to fit.</p></li><li><p>The <a href="#Rounding-functions-1">Rounding functions</a> take a type <code>T</code> as an optional argument. For example, <code>round(Int,x)</code> is a shorthand for <code>Int(round(x))</code>.</p></li></ul><p>The following examples show the different forms.</p><pre><code class="language-julia-repl">julia&gt; Int8(127)
127

julia&gt; Int8(128)
ERROR: InexactError: trunc(Int8, 128)
Stacktrace:
[...]

julia&gt; Int8(127.0)
127

julia&gt; Int8(3.14)
ERROR: InexactError: Int8(Int8, 3.14)
Stacktrace:
[...]

julia&gt; Int8(128.0)
ERROR: InexactError: Int8(Int8, 128.0)
Stacktrace:
[...]

julia&gt; 127 % Int8
127

julia&gt; 128 % Int8
-128

julia&gt; round(Int8,127.4)
127

julia&gt; round(Int8,127.6)
ERROR: InexactError: trunc(Int8, 128.0)
Stacktrace:
[...]</code></pre><p>See <a href="../conversion-and-promotion/#conversion-and-promotion-1">Conversion and Promotion</a> for how to define your own conversions and promotions.</p><h3><a class="nav-anchor" id="Rounding-functions-1" href="#Rounding-functions-1">Rounding functions</a></h3><table><tr><th>Function</th><th>Description</th><th>Return type</th></tr><tr><td><a href="../../stdlib/Dates/#Base.round-Tuple{TimeType,Period,RoundingMode{:NearestTiesUp}}"><code>round(x)</code></a></td><td>round <code>x</code> to the nearest integer</td><td><code>typeof(x)</code></td></tr><tr><td><a href="../../stdlib/Dates/#Base.round-Tuple{TimeType,Period,RoundingMode{:NearestTiesUp}}"><code>round(T, x)</code></a></td><td>round <code>x</code> to the nearest integer</td><td><code>T</code></td></tr><tr><td><a href="../../stdlib/Dates/#Base.floor-Tuple{TimeType,Period}"><code>floor(x)</code></a></td><td>round <code>x</code> towards <code>-Inf</code></td><td><code>typeof(x)</code></td></tr><tr><td><a href="../../stdlib/Dates/#Base.floor-Tuple{TimeType,Period}"><code>floor(T, x)</code></a></td><td>round <code>x</code> towards <code>-Inf</code></td><td><code>T</code></td></tr><tr><td><a href="../../stdlib/Dates/#Base.ceil-Tuple{TimeType,Period}"><code>ceil(x)</code></a></td><td>round <code>x</code> towards <code>+Inf</code></td><td><code>typeof(x)</code></td></tr><tr><td><a href="../../stdlib/Dates/#Base.ceil-Tuple{TimeType,Period}"><code>ceil(T, x)</code></a></td><td>round <code>x</code> towards <code>+Inf</code></td><td><code>T</code></td></tr><tr><td><a href="../../stdlib/Dates/#Base.trunc-Tuple{TimeType,Type{Period}}"><code>trunc(x)</code></a></td><td>round <code>x</code> towards zero</td><td><code>typeof(x)</code></td></tr><tr><td><a href="../../stdlib/Dates/#Base.trunc-Tuple{TimeType,Type{Period}}"><code>trunc(T, x)</code></a></td><td>round <code>x</code> towards zero</td><td><code>T</code></td></tr></table><h3><a class="nav-anchor" id="Division-functions-1" href="#Division-functions-1">Division functions</a></h3><table><tr><th>Function</th><th>Description</th></tr><tr><td><a href="../../base/math/#Base.div"><code>div(x,y)</code></a>, <code>x÷y</code></td><td>truncated division; quotient rounded towards zero</td></tr><tr><td><a href="../../base/math/#Base.fld"><code>fld(x,y)</code></a></td><td>floored division; quotient rounded towards <code>-Inf</code></td></tr><tr><td><a href="../../base/math/#Base.cld"><code>cld(x,y)</code></a></td><td>ceiling division; quotient rounded towards <code>+Inf</code></td></tr><tr><td><a href="../../base/math/#Base.rem"><code>rem(x,y)</code></a></td><td>remainder; satisfies <code>x == div(x,y)*y + rem(x,y)</code>; sign matches <code>x</code></td></tr><tr><td><a href="../../base/math/#Base.mod"><code>mod(x,y)</code></a></td><td>modulus; satisfies <code>x == fld(x,y)*y + mod(x,y)</code>; sign matches <code>y</code></td></tr><tr><td><a href="../../base/math/#Base.mod1"><code>mod1(x,y)</code></a></td><td><code>mod</code> with offset 1; returns <code>r∈(0,y]</code> for <code>y&gt;0</code> or <code>r∈[y,0)</code> for <code>y&lt;0</code>, where <code>mod(r, y) == mod(x, y)</code></td></tr><tr><td><a href="../../base/math/#Base.Math.mod2pi"><code>mod2pi(x)</code></a></td><td>modulus with respect to 2pi;  <code>0 &lt;= mod2pi(x)    &lt; 2pi</code></td></tr><tr><td><a href="../../base/math/#Base.divrem"><code>divrem(x,y)</code></a></td><td>returns <code>(div(x,y),rem(x,y))</code></td></tr><tr><td><a href="../../base/math/#Base.fldmod"><code>fldmod(x,y)</code></a></td><td>returns <code>(fld(x,y),mod(x,y))</code></td></tr><tr><td><a href="../../base/math/#Base.gcd"><code>gcd(x,y...)</code></a></td><td>greatest positive common divisor of <code>x</code>, <code>y</code>,...</td></tr><tr><td><a href="../../base/math/#Base.lcm"><code>lcm(x,y...)</code></a></td><td>least positive common multiple of <code>x</code>, <code>y</code>,...</td></tr></table><h3><a class="nav-anchor" id="Sign-and-absolute-value-functions-1" href="#Sign-and-absolute-value-functions-1">Sign and absolute value functions</a></h3><table><tr><th>Function</th><th>Description</th></tr><tr><td><a href="../../base/math/#Base.abs"><code>abs(x)</code></a></td><td>a positive value with the magnitude of <code>x</code></td></tr><tr><td><a href="../../base/math/#Base.abs2"><code>abs2(x)</code></a></td><td>the squared magnitude of <code>x</code></td></tr><tr><td><a href="../../base/math/#Base.sign"><code>sign(x)</code></a></td><td>indicates the sign of <code>x</code>, returning -1, 0, or +1</td></tr><tr><td><a href="../../base/math/#Base.signbit"><code>signbit(x)</code></a></td><td>indicates whether the sign bit is on (true) or off (false)</td></tr><tr><td><a href="../../base/math/#Base.copysign"><code>copysign(x,y)</code></a></td><td>a value with the magnitude of <code>x</code> and the sign of <code>y</code></td></tr><tr><td><a href="../../base/math/#Base.flipsign"><code>flipsign(x,y)</code></a></td><td>a value with the magnitude of <code>x</code> and the sign of <code>x*y</code></td></tr></table><h3><a class="nav-anchor" id="Powers,-logs-and-roots-1" href="#Powers,-logs-and-roots-1">Powers, logs and roots</a></h3><table><tr><th>Function</th><th>Description</th></tr><tr><td><a href="../../base/math/#Base.sqrt-Tuple{Real}"><code>sqrt(x)</code></a>, <code>√x</code></td><td>square root of <code>x</code></td></tr><tr><td><a href="../../base/math/#Base.Math.cbrt"><code>cbrt(x)</code></a>, <code>∛x</code></td><td>cube root of <code>x</code></td></tr><tr><td><a href="../../base/math/#Base.Math.hypot"><code>hypot(x,y)</code></a></td><td>hypotenuse of right-angled triangle with other sides of length <code>x</code> and <code>y</code></td></tr><tr><td><a href="../../base/math/#Base.exp-Tuple{Float64}"><code>exp(x)</code></a></td><td>natural exponential function at <code>x</code></td></tr><tr><td><a href="../../base/math/#Base.expm1"><code>expm1(x)</code></a></td><td>accurate <code>exp(x)-1</code> for <code>x</code> near zero</td></tr><tr><td><a href="../../base/math/#Base.Math.ldexp"><code>ldexp(x,n)</code></a></td><td><code>x*2^n</code> computed efficiently for integer values of <code>n</code></td></tr><tr><td><a href="../../base/math/#Base.log-Tuple{Number}"><code>log(x)</code></a></td><td>natural logarithm of <code>x</code></td></tr><tr><td><a href="../../base/math/#Base.log-Tuple{Number}"><code>log(b,x)</code></a></td><td>base <code>b</code> logarithm of <code>x</code></td></tr><tr><td><a href="../../base/math/#Base.log2"><code>log2(x)</code></a></td><td>base 2 logarithm of <code>x</code></td></tr><tr><td><a href="../../base/math/#Base.log10"><code>log10(x)</code></a></td><td>base 10 logarithm of <code>x</code></td></tr><tr><td><a href="../../base/math/#Base.log1p"><code>log1p(x)</code></a></td><td>accurate <code>log(1+x)</code> for <code>x</code> near zero</td></tr><tr><td><a href="../../base/numbers/#Base.Math.exponent"><code>exponent(x)</code></a></td><td>binary exponent of <code>x</code></td></tr><tr><td><a href="../../base/numbers/#Base.Math.significand"><code>significand(x)</code></a></td><td>binary significand (a.k.a. mantissa) of a floating-point number <code>x</code></td></tr></table><p>For an overview of why functions like <a href="../../base/math/#Base.Math.hypot"><code>hypot</code></a>, <a href="../../base/math/#Base.expm1"><code>expm1</code></a>, and <a href="../../base/math/#Base.log1p"><code>log1p</code></a> are necessary and useful, see John D. Cook&#39;s excellent pair of blog posts on the subject: <a href="https://www.johndcook.com/blog/2010/06/07/math-library-functions-that-seem-unnecessary/">expm1, log1p, erfc</a>, and <a href="https://www.johndcook.com/blog/2010/06/02/whats-so-hard-about-finding-a-hypotenuse/">hypot</a>.</p><h3><a class="nav-anchor" id="Trigonometric-and-hyperbolic-functions-1" href="#Trigonometric-and-hyperbolic-functions-1">Trigonometric and hyperbolic functions</a></h3><p>All the standard trigonometric and hyperbolic functions are also defined:</p><pre><code class="language-none">sin    cos    tan    cot    sec    csc
sinh   cosh   tanh   coth   sech   csch
asin   acos   atan   acot   asec   acsc
asinh  acosh  atanh  acoth  asech  acsch
sinc   cosc</code></pre><p>These are all single-argument functions, with <a href="../../base/math/#Base.atan-Tuple{Number}"><code>atan</code></a> also accepting two arguments corresponding to a traditional <a href="https://en.wikipedia.org/wiki/Atan2"><code>atan2</code></a> function.</p><p>Additionally, <a href="../../base/math/#Base.Math.sinpi"><code>sinpi(x)</code></a> and <a href="../../base/math/#Base.Math.cospi"><code>cospi(x)</code></a> are provided for more accurate computations of <a href="../../base/math/#Base.sin-Tuple{Number}"><code>sin(pi*x)</code></a> and <a href="../../base/math/#Base.cos-Tuple{Number}"><code>cos(pi*x)</code></a> respectively.</p><p>In order to compute trigonometric functions with degrees instead of radians, suffix the function with <code>d</code>. For example, <a href="../../base/math/#Base.Math.sind"><code>sind(x)</code></a> computes the sine of <code>x</code> where <code>x</code> is specified in degrees. The complete list of trigonometric functions with degree variants is:</p><pre><code class="language-none">sind   cosd   tand   cotd   secd   cscd
asind  acosd  atand  acotd  asecd  acscd</code></pre><h3><a class="nav-anchor" id="Special-functions-1" href="#Special-functions-1">Special functions</a></h3><p>Many other special mathematical functions are provided by the package <a href="https://github.com/JuliaMath/SpecialFunctions.jl">SpecialFunctions.jl</a>.</p><footer><hr/><a class="previous" href="../integers-and-floating-point-numbers/"><span class="direction">Previous</span><span class="title">Integers and Floating-Point Numbers</span></a><a class="next" href="../complex-and-rational-numbers/"><span class="direction">Next</span><span class="title">Complex and Rational Numbers</span></a></footer></article></body></html>
