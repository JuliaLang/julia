<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>I/O and Network · The Julia Language</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-28835595-6', 'auto');
ga('send', 'pageview');
</script><link rel="canonical" href="https://docs.julialang.org/en/stable/stdlib/io-network/index.html"/><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../../assets/julia-manual.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../../index.html"><img class="logo" src="../../assets/logo.png" alt="The Julia Language logo"/></a><h1>The Julia Language</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../../manual/introduction/">Introduction</a></li><li><a class="toctext" href="../../manual/getting-started/">Getting Started</a></li><li><a class="toctext" href="../../manual/variables/">Variables</a></li><li><a class="toctext" href="../../manual/integers-and-floating-point-numbers/">Integers and Floating-Point Numbers</a></li><li><a class="toctext" href="../../manual/mathematical-operations/">Mathematical Operations and Elementary Functions</a></li><li><a class="toctext" href="../../manual/complex-and-rational-numbers/">Complex and Rational Numbers</a></li><li><a class="toctext" href="../../manual/strings/">Strings</a></li><li><a class="toctext" href="../../manual/functions/">Functions</a></li><li><a class="toctext" href="../../manual/control-flow/">Control Flow</a></li><li><a class="toctext" href="../../manual/variables-and-scoping/">Scope of Variables</a></li><li><a class="toctext" href="../../manual/types/">Types</a></li><li><a class="toctext" href="../../manual/methods/">Methods</a></li><li><a class="toctext" href="../../manual/constructors/">Constructors</a></li><li><a class="toctext" href="../../manual/conversion-and-promotion/">Conversion and Promotion</a></li><li><a class="toctext" href="../../manual/interfaces/">Interfaces</a></li><li><a class="toctext" href="../../manual/modules/">Modules</a></li><li><a class="toctext" href="../../manual/documentation/">Documentation</a></li><li><a class="toctext" href="../../manual/metaprogramming/">Metaprogramming</a></li><li><a class="toctext" href="../../manual/arrays/">Multi-dimensional Arrays</a></li><li><a class="toctext" href="../../manual/linear-algebra/">Linear algebra</a></li><li><a class="toctext" href="../../manual/networking-and-streams/">Networking and Streams</a></li><li><a class="toctext" href="../../manual/parallel-computing/">Parallel Computing</a></li><li><a class="toctext" href="../../manual/dates/">Date and DateTime</a></li><li><a class="toctext" href="../../manual/interacting-with-julia/">Interacting With Julia</a></li><li><a class="toctext" href="../../manual/running-external-programs/">Running External Programs</a></li><li><a class="toctext" href="../../manual/calling-c-and-fortran-code/">Calling C and Fortran Code</a></li><li><a class="toctext" href="../../manual/handling-operating-system-variation/">Handling Operating System Variation</a></li><li><a class="toctext" href="../../manual/environment-variables/">Environment Variables</a></li><li><a class="toctext" href="../../manual/embedding/">Embedding Julia</a></li><li><a class="toctext" href="../../manual/packages/">Packages</a></li><li><a class="toctext" href="../../manual/profile/">Profiling</a></li><li><a class="toctext" href="../../manual/stacktraces/">Stack Traces</a></li><li><a class="toctext" href="../../manual/performance-tips/">Performance Tips</a></li><li><a class="toctext" href="../../manual/workflow-tips/">Workflow Tips</a></li><li><a class="toctext" href="../../manual/style-guide/">Style Guide</a></li><li><a class="toctext" href="../../manual/faq/">Frequently Asked Questions</a></li><li><a class="toctext" href="../../manual/noteworthy-differences/">Noteworthy Differences from other Languages</a></li><li><a class="toctext" href="../../manual/unicode-input/">Unicode Input</a></li></ul></li><li><span class="toctext">Standard Library</span><ul><li><a class="toctext" href="../base/">Essentials</a></li><li><a class="toctext" href="../collections/">Collections and Data Structures</a></li><li><a class="toctext" href="../math/">Mathematics</a></li><li><a class="toctext" href="../numbers/">Numbers</a></li><li><a class="toctext" href="../strings/">Strings</a></li><li><a class="toctext" href="../arrays/">Arrays</a></li><li><a class="toctext" href="../parallel/">Tasks and Parallel Computing</a></li><li><a class="toctext" href="../linalg/">Linear Algebra</a></li><li><a class="toctext" href="../constants/">Constants</a></li><li><a class="toctext" href="../file/">Filesystem</a></li><li class="current"><a class="toctext" href>I/O and Network</a><ul class="internal"><li><a class="toctext" href="#General-I/O-1">General I/O</a></li><li><a class="toctext" href="#Text-I/O-1">Text I/O</a></li><li><a class="toctext" href="#Multimedia-I/O-1">Multimedia I/O</a></li><li><a class="toctext" href="#Memory-mapped-I/O-1">Memory-mapped I/O</a></li><li><a class="toctext" href="#Network-I/O-1">Network I/O</a></li></ul></li><li><a class="toctext" href="../punctuation/">Punctuation</a></li><li><a class="toctext" href="../sort/">Sorting and Related Functions</a></li><li><a class="toctext" href="../pkg/">Package Manager Functions</a></li><li><a class="toctext" href="../dates/">Dates and Time</a></li><li><a class="toctext" href="../iterators/">Iteration utilities</a></li><li><a class="toctext" href="../test/">Unit Testing</a></li><li><a class="toctext" href="../c/">C Interface</a></li><li><a class="toctext" href="../libc/">C Standard Library</a></li><li><a class="toctext" href="../libdl/">Dynamic Linker</a></li><li><a class="toctext" href="../profile/">Profiling</a></li><li><a class="toctext" href="../stacktraces/">StackTraces</a></li><li><a class="toctext" href="../simd-types/">SIMD Support</a></li></ul></li><li><span class="toctext">Developer Documentation</span><ul><li><a class="toctext" href="../../devdocs/reflection/">Reflection and introspection</a></li><li><span class="toctext">Documentation of Julia&#39;s Internals</span><ul><li><a class="toctext" href="../../devdocs/init/">Initialization of the Julia runtime</a></li><li><a class="toctext" href="../../devdocs/ast/">Julia ASTs</a></li><li><a class="toctext" href="../../devdocs/types/">More about types</a></li><li><a class="toctext" href="../../devdocs/object/">Memory layout of Julia Objects</a></li><li><a class="toctext" href="../../devdocs/eval/">Eval of Julia code</a></li><li><a class="toctext" href="../../devdocs/callconv/">Calling Conventions</a></li><li><a class="toctext" href="../../devdocs/compiler/">High-level Overview of the Native-Code Generation Process</a></li><li><a class="toctext" href="../../devdocs/functions/">Julia Functions</a></li><li><a class="toctext" href="../../devdocs/cartesian/">Base.Cartesian</a></li><li><a class="toctext" href="../../devdocs/meta/">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="../../devdocs/subarrays/">SubArrays</a></li><li><a class="toctext" href="../../devdocs/sysimg/">System Image Building</a></li><li><a class="toctext" href="../../devdocs/llvm/">Working with LLVM</a></li><li><a class="toctext" href="../../devdocs/stdio/">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="../../devdocs/boundscheck/">Bounds checking</a></li><li><a class="toctext" href="../../devdocs/locks/">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="../../devdocs/offset-arrays/">Arrays with custom indices</a></li><li><a class="toctext" href="../../devdocs/libgit2/">Base.LibGit2</a></li><li><a class="toctext" href="../../devdocs/require/">Module loading</a></li></ul></li><li><span class="toctext">Developing/debugging Julia&#39;s C code</span><ul><li><a class="toctext" href="../../devdocs/backtraces/">Reporting and analyzing crashes (segfaults)</a></li><li><a class="toctext" href="../../devdocs/debuggingtips/">gdb debugging tips</a></li><li><a class="toctext" href="../../devdocs/valgrind/">Using Valgrind with Julia</a></li><li><a class="toctext" href="../../devdocs/sanitizers/">Sanitizer support</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Standard Library</li><li><a href>I/O and Network</a></li></ul><a class="edit-page" href="https://github.com/JuliaLang/julia/blob/master/doc/src/stdlib/io-network.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>I/O and Network</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="I/O-and-Network-1" href="#I/O-and-Network-1">I/O and Network</a></h1><h2><a class="nav-anchor" id="General-I/O-1" href="#General-I/O-1">General I/O</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.STDOUT" href="#Base.STDOUT"><code>Base.STDOUT</code></a> — <span class="docstring-category">Constant</span>.</div><div><pre><code class="language-none">STDOUT</code></pre><p>Global variable referring to the standard out stream.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/libuv.jl#L114-L118">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.STDERR" href="#Base.STDERR"><code>Base.STDERR</code></a> — <span class="docstring-category">Constant</span>.</div><div><pre><code class="language-none">STDERR</code></pre><p>Global variable referring to the standard error stream.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/libuv.jl#L121-L125">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.STDIN" href="#Base.STDIN"><code>Base.STDIN</code></a> — <span class="docstring-category">Constant</span>.</div><div><pre><code class="language-none">STDIN</code></pre><p>Global variable referring to the standard input stream.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/libuv.jl#L107-L111">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.open" href="#Base.open"><code>Base.open</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">open(filename::AbstractString, [read::Bool, write::Bool, create::Bool, truncate::Bool, append::Bool]) -&gt; IOStream</code></pre><p>Open a file in a mode specified by five boolean arguments. The default is to open files for reading only. Returns a stream for accessing the file.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/iostream.jl#L96-L101">source</a><div><pre><code class="language-none">open(filename::AbstractString, [mode::AbstractString]) -&gt; IOStream</code></pre><p>Alternate syntax for open, where a string-based mode specifier is used instead of the five booleans. The values of <code>mode</code> correspond to those from <code>fopen(3)</code> or Perl <code>open</code>, and are equivalent to setting the following boolean groups:</p><table><tr><th>Mode</th><th>Description</th></tr><tr><td>r</td><td>read</td></tr><tr><td>r+</td><td>read, write</td></tr><tr><td>w</td><td>write, create, truncate</td></tr><tr><td>w+</td><td>read, write, create, truncate</td></tr><tr><td>a</td><td>write, create, append</td></tr><tr><td>a+</td><td>read, write, create, append</td></tr></table></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/iostream.jl#L115-L130">source</a><div><pre><code class="language-none">open(f::Function, args...)</code></pre><p>Apply the function <code>f</code> to the result of <code>open(args...)</code> and close the resulting file descriptor upon completion.</p><p><strong>Example</strong>: <code>open(readstring, &quot;file.txt&quot;)</code></p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/iostream.jl#L141-L148">source</a><div><pre><code class="language-none">open(command, mode::AbstractString=&quot;r&quot;, stdio=DevNull)</code></pre><p>Start running <code>command</code> asynchronously, and return a tuple <code>(stream,process)</code>.  If <code>mode</code> is <code>&quot;r&quot;</code>, then <code>stream</code> reads from the process&#39;s standard output and <code>stdio</code> optionally specifies the process&#39;s standard input stream.  If <code>mode</code> is <code>&quot;w&quot;</code>, then <code>stream</code> writes to the process&#39;s standard input and <code>stdio</code> optionally specifies the process&#39;s standard output stream.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/process.jl#L565-L573">source</a><div><pre><code class="language-none">open(f::Function, command, mode::AbstractString=&quot;r&quot;, stdio=DevNull)</code></pre><p>Similar to <code>open(command, mode, stdio)</code>, but calls <code>f(stream)</code> on the resulting read or write stream, then closes the stream and waits for the process to complete.  Returns the value returned by <code>f</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/process.jl#L591-L597">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.IOBuffer" href="#Base.IOBuffer"><code>Base.IOBuffer</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">IOBuffer([data,],[readable::Bool=true, writable::Bool=true, [maxsize::Int=typemax(Int)]])</code></pre><p>Create an <code>IOBuffer</code>, which may optionally operate on a pre-existing array. If the readable/writable arguments are given, they restrict whether or not the buffer may be read from or written to respectively. The last argument optionally specifies a size beyond which the buffer may not be grown.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/iobuffer.jl#L34-L41">source</a><div><pre><code class="language-none">IOBuffer() -&gt; IOBuffer</code></pre><p>Create an in-memory I/O stream.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/iobuffer.jl#L51-L55">source</a><div><pre><code class="language-none">IOBuffer(size::Int)</code></pre><p>Create a fixed size IOBuffer. The buffer will not grow dynamically.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/iobuffer.jl#L58-L62">source</a><div><pre><code class="language-none">IOBuffer(string::String)</code></pre><p>Create a read-only <code>IOBuffer</code> on the data underlying the given string.</p><pre><code class="language-julia-repl">julia&gt; io = IOBuffer(&quot;Haho&quot;);

julia&gt; String(take!(io))
&quot;Haho&quot;

julia&gt; String(take!(io))
&quot;Haho&quot;</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/strings/io.jl#L152-L166">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.take!-Tuple{Base.AbstractIOBuffer}" href="#Base.take!-Tuple{Base.AbstractIOBuffer}"><code>Base.take!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">take!(b::IOBuffer)</code></pre><p>Obtain the contents of an <code>IOBuffer</code> as an array, without copying. Afterwards, the <code>IOBuffer</code> is reset to its initial state.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/iobuffer.jl#L266-L271">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.fdio" href="#Base.fdio"><code>Base.fdio</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">fdio([name::AbstractString, ]fd::Integer[, own::Bool=false]) -&gt; IOStream</code></pre><p>Create an <code>IOStream</code> object from an integer file descriptor. If <code>own</code> is <code>true</code>, closing this object will close the underlying descriptor. By default, an <code>IOStream</code> is closed when it is garbage collected. <code>name</code> allows you to associate the descriptor with a named file.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/iostream.jl#L80-L86">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.flush" href="#Base.flush"><code>Base.flush</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">flush(stream)</code></pre><p>Commit all currently buffered writes to the given stream.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/io.jl#L641-L645">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.close" href="#Base.close"><code>Base.close</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">close(stream)</code></pre><p>Close an I/O stream. Performs a <a href="#Base.flush"><code>flush</code></a> first.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/io.jl#L22-L26">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.write" href="#Base.write"><code>Base.write</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">write(stream::IO, x)
write(filename::AbstractString, x)</code></pre><p>Write the canonical binary representation of a value to the given I/O stream or file. Returns the number of bytes written into the stream.</p><p>You can write multiple values with the same <code>write</code> call. i.e. the following are equivalent:</p><pre><code class="language-none">write(stream, x, y...)
write(stream, x) + write(stream, y...)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/io.jl#L52-L63">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.read" href="#Base.read"><code>Base.read</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">read(filename::AbstractString, args...)</code></pre><p>Open a file and read its contents. <code>args</code> is passed to <code>read</code>: this is equivalent to <code>open(io-&gt;read(io, args...), filename)</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/io.jl#L154-L159">source</a><div><pre><code class="language-none">read(stream::IO, T, dims)</code></pre><p>Read a series of values of type <code>T</code> from <code>stream</code>, in canonical binary representation. <code>dims</code> is either a tuple or a series of integer arguments specifying the size of the <code>Array{T}</code> to return.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/io.jl#L377-L383">source</a><div><pre><code class="language-none">read(s::IO, nb=typemax(Int))</code></pre><p>Read at most <code>nb</code> bytes from <code>s</code>, returning a <code>Vector{UInt8}</code> of the bytes read.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/io.jl#L520-L524">source</a><div><pre><code class="language-none">read(s::IOStream, nb::Integer; all=true)</code></pre><p>Read at most <code>nb</code> bytes from <code>s</code>, returning a <code>Vector{UInt8}</code> of the bytes read.</p><p>If <code>all</code> is <code>true</code> (the default), this function will block repeatedly trying to read all requested bytes, until an error or end-of-file occurs. If <code>all</code> is <code>false</code>, at most one <code>read</code> call is performed, and the amount of data returned is device-dependent. Note that not all stream types support the <code>all</code> option.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/iostream.jl#L295-L304">source</a><div><pre><code class="language-none">read(stream::IO, T)</code></pre><p>Read a single value of type <code>T</code> from <code>stream</code>, in canonical binary representation.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/docs/helpdb/Base.jl#L1482-L1486">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.read!" href="#Base.read!"><code>Base.read!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">read!(stream::IO, array::Union{Array, BitArray})
read!(filename::AbstractString, array::Union{Array, BitArray})</code></pre><p>Read binary data from an I/O stream or file, filling in <code>array</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/docs/helpdb/Base.jl#L39-L44">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.readbytes!" href="#Base.readbytes!"><code>Base.readbytes!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">readbytes!(stream::IO, b::AbstractVector{UInt8}, nb=length(b))</code></pre><p>Read at most <code>nb</code> bytes from <code>stream</code> into <code>b</code>, returning the number of bytes read. The size of <code>b</code> will be increased if needed (i.e. if <code>nb</code> is greater than <code>length(b)</code> and enough bytes could be read), but it will never be decreased.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/io.jl#L495-L501">source</a><div><pre><code class="language-none">readbytes!(stream::IOStream, b::AbstractVector{UInt8}, nb=length(b); all::Bool=true)</code></pre><p>Read at most <code>nb</code> bytes from <code>stream</code> into <code>b</code>, returning the number of bytes read. The size of <code>b</code> will be increased if needed (i.e. if <code>nb</code> is greater than <code>length(b)</code> and enough bytes could be read), but it will never be decreased.</p><p>See <a href="#Base.read"><code>read</code></a> for a description of the <code>all</code> option.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/iostream.jl#L268-L276">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.unsafe_read" href="#Base.unsafe_read"><code>Base.unsafe_read</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">unsafe_read(io::IO, ref, nbytes::UInt)</code></pre><p>Copy <code>nbytes</code> from the <code>IO</code> stream object into <code>ref</code> (converted to a pointer).</p><p>It is recommended that subtypes <code>T&lt;:IO</code> override the following method signature to provide more efficient implementations: <code>unsafe_read(s::T, p::Ptr{UInt8}, n::UInt)</code></p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/io.jl#L86-L94">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.unsafe_write" href="#Base.unsafe_write"><code>Base.unsafe_write</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">unsafe_write(io::IO, ref, nbytes::UInt)</code></pre><p>Copy <code>nbytes</code> from <code>ref</code> (converted to a pointer) into the <code>IO</code> object.</p><p>It is recommended that subtypes <code>T&lt;:IO</code> override the following method signature to provide more efficient implementations: <code>unsafe_write(s::T, p::Ptr{UInt8}, n::UInt)</code></p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/io.jl#L69-L77">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.position" href="#Base.position"><code>Base.position</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">position(s)</code></pre><p>Get the current position of a stream.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/docs/helpdb/Base.jl#L1224-L1228">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.seek" href="#Base.seek"><code>Base.seek</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">seek(s, pos)</code></pre><p>Seek a stream to the given position.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/docs/helpdb/Base.jl#L1057-L1061">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.seekstart" href="#Base.seekstart"><code>Base.seekstart</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">seekstart(s)</code></pre><p>Seek a stream to its beginning.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/docs/helpdb/Base.jl#L1691-L1695">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.seekend" href="#Base.seekend"><code>Base.seekend</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">seekend(s)</code></pre><p>Seek a stream to its end.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/docs/helpdb/Base.jl#L2654-L2658">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.skip" href="#Base.skip"><code>Base.skip</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">skip(s, offset)</code></pre><p>Seek a stream relative to the current position.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/docs/helpdb/Base.jl#L785-L789">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.mark" href="#Base.mark"><code>Base.mark</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">mark(s)</code></pre><p>Add a mark at the current position of stream <code>s</code>. Returns the marked position.</p><p>See also <a href="#Base.unmark"><code>unmark</code></a>, <a href="#Base.reset"><code>reset</code></a>, <a href="#Base.ismarked"><code>ismarked</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/io.jl#L589-L595">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.unmark" href="#Base.unmark"><code>Base.unmark</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">unmark(s)</code></pre><p>Remove a mark from stream <code>s</code>. Returns <code>true</code> if the stream was marked, <code>false</code> otherwise.</p><p>See also <a href="#Base.mark"><code>mark</code></a>, <a href="#Base.reset"><code>reset</code></a>, <a href="#Base.ismarked"><code>ismarked</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/io.jl#L600-L606">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.reset" href="#Base.reset"><code>Base.reset</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">reset(s)</code></pre><p>Reset a stream <code>s</code> to a previously marked position, and remove the mark. Returns the previously marked position. Throws an error if the stream is not marked.</p><p>See also <a href="#Base.mark"><code>mark</code></a>, <a href="#Base.unmark"><code>unmark</code></a>, <a href="#Base.ismarked"><code>ismarked</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/io.jl#L613-L620">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.ismarked" href="#Base.ismarked"><code>Base.ismarked</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">ismarked(s)</code></pre><p>Returns <code>true</code> if stream <code>s</code> is marked.</p><p>See also <a href="#Base.mark"><code>mark</code></a>, <a href="#Base.unmark"><code>unmark</code></a>, <a href="#Base.reset"><code>reset</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/io.jl#L629-L635">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.eof" href="#Base.eof"><code>Base.eof</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">eof(stream) -&gt; Bool</code></pre><p>Tests whether an I/O stream is at end-of-file. If the stream is not yet exhausted, this function will block to wait for more data if necessary, and then return <code>false</code>. Therefore it is always safe to read one byte after seeing <code>eof</code> return <code>false</code>. <code>eof</code> will return <code>false</code> as long as buffered data is still available, even if the remote end of a connection is closed.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/io.jl#L137-L145">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isreadonly" href="#Base.isreadonly"><code>Base.isreadonly</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">isreadonly(stream) -&gt; Bool</code></pre><p>Determine whether a stream is read-only.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/io.jl#L275-L279">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.iswritable" href="#Base.iswritable"><code>Base.iswritable</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">iswritable(io) -&gt; Bool</code></pre><p>Returns <code>true</code> if the specified IO object is writable (if that can be determined).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/io.jl#L43-L47">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isreadable" href="#Base.isreadable"><code>Base.isreadable</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">isreadable(io) -&gt; Bool</code></pre><p>Returns <code>true</code> if the specified IO object is readable (if that can be determined).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/io.jl#L36-L40">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isopen" href="#Base.isopen"><code>Base.isopen</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">isopen(object) -&gt; Bool</code></pre><p>Determine whether an object - such as a stream, timer, or mmap – is not yet closed. Once an object is closed, it will never produce a new event. However, a closed stream may still have data to read in its buffer, use <a href="#Base.eof"><code>eof</code></a> to check for the ability to read data. Use <a href="#Base.Filesystem.poll_fd"><code>poll_fd</code></a> to be notified when a stream might be writable or readable.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/io.jl#L12-L19">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Serializer.serialize" href="#Base.Serializer.serialize"><code>Base.Serializer.serialize</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">serialize(stream, value)</code></pre><p>Write an arbitrary value to a stream in an opaque format, such that it can be read back by <a href="#Base.Serializer.deserialize"><code>deserialize</code></a>. The read-back value will be as identical as possible to the original. In general, this process will not work if the reading and writing are done by different versions of Julia, or an instance of Julia with a different system image. <code>Ptr</code> values are serialized as all-zero bit patterns (<code>NULL</code>).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/docs/helpdb/Base.jl#L990-L998">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Serializer.deserialize" href="#Base.Serializer.deserialize"><code>Base.Serializer.deserialize</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">deserialize(stream)</code></pre><p>Read a value written by <a href="#Base.Serializer.serialize"><code>serialize</code></a>. <code>deserialize</code> assumes the binary data read from <code>stream</code> is correct and has been serialized by a compatible implementation of <a href="#Base.Serializer.serialize"><code>serialize</code></a>. It has been designed with simplicity and performance as a goal and does not validate the data read. Malformed data can result in process termination. The caller has to ensure the integrity and correctness of data read from <code>stream</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/docs/helpdb/Base.jl#L1997-L2005">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Grisu.print_shortest" href="#Base.Grisu.print_shortest"><code>Base.Grisu.print_shortest</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">print_shortest(io, x)</code></pre><p>Print the shortest possible representation, with the minimum number of consecutive non-zero digits, of number <code>x</code>, ensuring that it would parse to the exact same number.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/docs/helpdb/Base.jl#L572-L577">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.fd" href="#Base.fd"><code>Base.fd</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">fd(stream)</code></pre><p>Returns the file descriptor backing the stream or file. Note that this function only applies to synchronous <code>File</code>&#39;s and <code>IOStream</code>&#39;s not to any of the asynchronous streams.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/docs/helpdb/Base.jl#L420-L425">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.redirect_stdout" href="#Base.redirect_stdout"><code>Base.redirect_stdout</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">redirect_stdout([stream]) -&gt; (rd, wr)</code></pre><p>Create a pipe to which all C and Julia level <a href="#Base.STDOUT"><code>STDOUT</code></a> output will be redirected. Returns a tuple <code>(rd, wr)</code> representing the pipe ends. Data written to <a href="#Base.STDOUT"><code>STDOUT</code></a> may now be read from the <code>rd</code> end of the pipe. The <code>wr</code> end is given for convenience in case the old <a href="#Base.STDOUT"><code>STDOUT</code></a> object was cached by the user and needs to be replaced elsewhere.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p><code>stream</code> must be a <code>TTY</code>, a <code>Pipe</code>, or a <code>TCPSocket</code>.</p></div></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/stream.jl#L1042-L1055">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.redirect_stdout-Tuple{Function,Any}" href="#Base.redirect_stdout-Tuple{Function,Any}"><code>Base.redirect_stdout</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">redirect_stdout(f::Function, stream)</code></pre><p>Run the function <code>f</code> while redirecting <a href="#Base.STDOUT"><code>STDOUT</code></a> to <code>stream</code>. Upon completion, <a href="#Base.STDOUT"><code>STDOUT</code></a> is restored to its prior setting.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p><code>stream</code> must be a <code>TTY</code>, a <code>Pipe</code>, or a <code>TCPSocket</code>.</p></div></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/stream.jl#L1094-L1102">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.redirect_stderr" href="#Base.redirect_stderr"><code>Base.redirect_stderr</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">redirect_stderr([stream]) -&gt; (rd, wr)</code></pre><p>Like <a href="#Base.redirect_stdout"><code>redirect_stdout</code></a>, but for <a href="#Base.STDERR"><code>STDERR</code></a>.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p><code>stream</code> must be a <code>TTY</code>, a <code>Pipe</code>, or a <code>TCPSocket</code>.</p></div></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/stream.jl#L1058-L1065">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.redirect_stderr-Tuple{Function,Any}" href="#Base.redirect_stderr-Tuple{Function,Any}"><code>Base.redirect_stderr</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">redirect_stderr(f::Function, stream)</code></pre><p>Run the function <code>f</code> while redirecting <a href="#Base.STDERR"><code>STDERR</code></a> to <code>stream</code>. Upon completion, <a href="#Base.STDERR"><code>STDERR</code></a> is restored to its prior setting.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p><code>stream</code> must be a <code>TTY</code>, a <code>Pipe</code>, or a <code>TCPSocket</code>.</p></div></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/stream.jl#L1105-L1113">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.redirect_stdin" href="#Base.redirect_stdin"><code>Base.redirect_stdin</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">redirect_stdin([stream]) -&gt; (rd, wr)</code></pre><p>Like <a href="#Base.redirect_stdout"><code>redirect_stdout</code></a>, but for <a href="#Base.STDIN"><code>STDIN</code></a>. Note that the order of the return tuple is still <code>(rd, wr)</code>, i.e. data to be read from <a href="#Base.STDIN"><code>STDIN</code></a> may be written to <code>wr</code>.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p><code>stream</code> must be a <code>TTY</code>, a <code>Pipe</code>, or a <code>TCPSocket</code>.</p></div></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/stream.jl#L1068-L1077">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.redirect_stdin-Tuple{Function,Any}" href="#Base.redirect_stdin-Tuple{Function,Any}"><code>Base.redirect_stdin</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">redirect_stdin(f::Function, stream)</code></pre><p>Run the function <code>f</code> while redirecting <a href="#Base.STDIN"><code>STDIN</code></a> to <code>stream</code>. Upon completion, <a href="#Base.STDIN"><code>STDIN</code></a> is restored to its prior setting.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p><code>stream</code> must be a <code>TTY</code>, a <code>Pipe</code>, or a <code>TCPSocket</code>.</p></div></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/stream.jl#L1116-L1124">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.readchomp" href="#Base.readchomp"><code>Base.readchomp</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">readchomp(x)</code></pre><p>Read the entirety of <code>x</code> as a string and remove a single trailing newline. Equivalent to <code>chomp!(readstring(x))</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/io.jl#L485-L490">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.truncate" href="#Base.truncate"><code>Base.truncate</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">truncate(file,n)</code></pre><p>Resize the file or buffer given by the first argument to exactly <code>n</code> bytes, filling previously unallocated space with &#39;\0&#39; if the file or buffer is grown.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/docs/helpdb/Base.jl#L615-L620">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.skipchars" href="#Base.skipchars"><code>Base.skipchars</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">skipchars(stream, predicate; linecomment::Char)</code></pre><p>Advance the stream until before the first character for which <code>predicate</code> returns <code>false</code>. For example <code>skipchars(stream, isspace)</code> will skip all whitespace. If keyword argument <code>linecomment</code> is specified, characters from that character through the end of a line will also be skipped.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/docs/helpdb/Base.jl#L2494-L2501">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.DataFmt.countlines" href="#Base.DataFmt.countlines"><code>Base.DataFmt.countlines</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">countlines(io::IO, eol::Char=&#39;\n&#39;)</code></pre><p>Read <code>io</code> until the end of the stream/file and count the number of lines. To specify a file pass the filename as the first argument. EOL markers other than <code>&#39;\n&#39;</code> are supported by passing them as the second argument.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/datafmt.jl#L20-L26">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.PipeBuffer" href="#Base.PipeBuffer"><code>Base.PipeBuffer</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">PipeBuffer(data::Vector{UInt8}=UInt8[],[maxsize::Int=typemax(Int)])</code></pre><p>An <a href="#Base.IOBuffer"><code>IOBuffer</code></a> that allows reading and performs writes by appending. Seeking and truncating are not supported. See <a href="#Base.IOBuffer"><code>IOBuffer</code></a> for the available constructors. If <code>data</code> is given, creates a <code>PipeBuffer</code> to operate on a data vector, optionally specifying a size beyond which the underlying <code>Array</code> may not be grown.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/iobuffer.jl#L67-L75">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.readavailable" href="#Base.readavailable"><code>Base.readavailable</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">readavailable(stream)</code></pre><p>Read all available data on the stream, blocking the task only if no data is available. The result is a <code>Vector{UInt8,1}</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/docs/helpdb/Base.jl#L2138-L2143">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.IOContext" href="#Base.IOContext"><code>Base.IOContext</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">IOContext</code></pre><p><code>IOContext</code> provides a mechanism for passing output configuration settings among <a href="#Base.show-Tuple{Any}"><code>show</code></a> methods.</p><p>In short, it is an immutable dictionary that is a subclass of <code>IO</code>. It supports standard dictionary operations such as <a href="../arrays/#Base.getindex-Tuple{Type,Vararg{Any,N} where N}"><code>getindex</code></a>, and can also be used as an I/O stream.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/show.jl#L5-L12">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.IOContext-Tuple{IO,Pair}" href="#Base.IOContext-Tuple{IO,Pair}"><code>Base.IOContext</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">IOContext(io::IO, KV::Pair)</code></pre><p>Create an <code>IOContext</code> that wraps a given stream, adding the specified <code>key=&gt;value</code> pair to the properties of that stream (note that <code>io</code> can itself be an <code>IOContext</code>).</p><ul><li><p>use <code>(key =&gt; value) in dict</code> to see if this particular combination is in the properties set</p></li><li><p>use <code>get(dict, key, default)</code> to retrieve the most recent value for a particular key</p></li></ul><p>The following properties are in common use:</p><ul><li><p><code>:compact</code>: Boolean specifying that small values should be printed more compactly, e.g. that numbers should be printed with fewer digits. This is set when printing array elements.</p></li><li><p><code>:limit</code>: Boolean specifying that containers should be truncated, e.g. showing <code>…</code> in place of most elements.</p></li><li><p><code>:displaysize</code>: A <code>Tuple{Int,Int}</code> giving the size in rows and columns to use for text output. This can be used to override the display size for called functions, but to get the size of the screen use the <code>displaysize</code> function.</p></li></ul><pre><code class="language-julia-repl">julia&gt; function f(io::IO)
           if get(io, :short, false)
               print(io, &quot;short&quot;)
           else
               print(io, &quot;loooooong&quot;)
           end
       end
f (generic function with 1 method)

julia&gt; f(STDOUT)
loooooong
julia&gt; f(IOContext(STDOUT, :short =&gt; true))
short</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/show.jl#L54-L89">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.IOContext-Tuple{IO,IOContext}" href="#Base.IOContext-Tuple{IO,IOContext}"><code>Base.IOContext</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">IOContext(io::IO, context::IOContext)</code></pre><p>Create an <code>IOContext</code> that wraps an alternate <code>IO</code> but inherits the properties of <code>context</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/show.jl#L47-L51">source</a></section><h2><a class="nav-anchor" id="Text-I/O-1" href="#Text-I/O-1">Text I/O</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.show-Tuple{Any}" href="#Base.show-Tuple{Any}"><code>Base.show</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">show(x)</code></pre><p>Write an informative text representation of a value to the current output stream. New types should overload <code>show(io, x)</code> where the first argument is a stream. The representation used by <code>show</code> generally includes Julia-specific formatting and type information.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/docs/helpdb/Base.jl#L1853-L1859">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.showcompact" href="#Base.showcompact"><code>Base.showcompact</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">showcompact(x)</code></pre><p>Show a compact representation of a value.</p><p>This is used for printing array elements without repeating type information (which would be redundant with that printed once for the whole array), and without line breaks inside the representation of an element.</p><p>To offer a compact representation different from its standard one, a custom type should test <code>get(io, :compact, false)</code> in its normal <code>show</code> method.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/docs/helpdb/Base.jl#L822-L833">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.showall" href="#Base.showall"><code>Base.showall</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">showall(x)</code></pre><p>Similar to <a href="#Base.show-Tuple{Any}"><code>show</code></a>, except shows all elements of arrays.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/docs/helpdb/Base.jl#L2095-L2099">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.summary" href="#Base.summary"><code>Base.summary</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">summary(x)</code></pre><p>Return a string giving a brief description of a value. By default returns <code>string(typeof(x))</code>, e.g. <a href="../numbers/#Core.Int64"><code>Int64</code></a>.</p><p>For arrays, returns a string of size and type info, e.g. <code>10-element Array{Int64,1}</code>.</p><pre><code class="language-julia-repl">julia&gt; summary(1)
&quot;Int64&quot;

julia&gt; summary(zeros(2))
&quot;2-element Array{Float64,1}&quot;</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/show.jl#L1544-L1560">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.print" href="#Base.print"><code>Base.print</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">print(io::IO, x)</code></pre><p>Write to <code>io</code> (or to the default output stream <a href="#Base.STDOUT"><code>STDOUT</code></a> if <code>io</code> is not given) a canonical (un-decorated) text representation of a value if there is one, otherwise call <a href="#Base.show-Tuple{Any}"><code>show</code></a>. The representation used by <code>print</code> includes minimal formatting and tries to avoid Julia-specific details.</p><pre><code class="language-julia-repl">julia&gt; print(&quot;Hello World!&quot;)
Hello World!
julia&gt; io = IOBuffer();

julia&gt; print(io, &quot;Hello World!&quot;)

julia&gt; String(take!(io))
&quot;Hello World!&quot;</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/strings/io.jl#L6-L25">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.println" href="#Base.println"><code>Base.println</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">println(io::IO, xs...)</code></pre><p>Print (using <a href="#Base.print"><code>print</code></a>) <code>xs</code> followed by a newline. If <code>io</code> is not supplied, prints to <a href="#Base.STDOUT"><code>STDOUT</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/strings/io.jl#L48-L53">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.print_with_color" href="#Base.print_with_color"><code>Base.print_with_color</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">print_with_color(color::Union{Symbol, Int}, [io], xs...; bold::Bool = false)</code></pre><p>Print <code>xs</code> in a color specified as a symbol.</p><p><code>color</code> may take any of the values <code>:normal</code>, <code>:default</code>, <code>:bold</code>, <code>:black</code>, <code>:blue</code>, <code>:cyan</code>, <code>:green</code>, <code>:light_black</code>, <code>:light_blue</code>, <code>:light_cyan</code>, <code>:light_green</code>, <code>:light_magenta</code>, <code>:light_red</code>, <code>:light_yellow</code>, <code>:magenta</code>, <code>:nothing</code>, <code>:red</code>, <code>:white</code>, or  <code>:yellow</code> or an integer between 0 and 255 inclusive. Note that not all terminals support 256 colors. If the keyword <code>bold</code> is given as <code>true</code>, the result will be printed in bold.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/util.jl#L408-L416">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.info" href="#Base.info"><code>Base.info</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">info([io, ] msg..., [prefix=&quot;INFO: &quot;])</code></pre><p>Display an informational message. Argument <code>msg</code> is a string describing the information to be displayed. The <code>prefix</code> keyword argument can be used to override the default prepending of <code>msg</code>.</p><pre><code class="language-julia-repl">julia&gt; info(&quot;hello world&quot;)
INFO: hello world

julia&gt; info(&quot;hello world&quot;; prefix=&quot;MY INFO: &quot;)
MY INFO: hello world</code></pre><p>See also <a href="#Base.logging"><code>logging</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/util.jl#L508-L525">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.warn" href="#Base.warn"><code>Base.warn</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">warn([io, ] msg..., [prefix=&quot;WARNING: &quot;, once=false, key=nothing, bt=nothing, filename=nothing, lineno::Int=0])</code></pre><p>Display a warning. Argument <code>msg</code> is a string describing the warning to be displayed.  Set <code>once</code> to true and specify a <code>key</code> to only display <code>msg</code> the first time <code>warn</code> is called.  If <code>bt</code> is not <code>nothing</code> a backtrace is displayed. If <code>filename</code> is not <code>nothing</code> both it and <code>lineno</code> are displayed.</p><p>See also <a href="#Base.logging"><code>logging</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/util.jl#L543-L552">source</a><div><pre><code class="language-none">warn(msg)</code></pre><p>Display a warning. Argument <code>msg</code> is a string describing the warning to be displayed.</p><pre><code class="language-julia-repl">julia&gt; warn(&quot;Beep Beep&quot;)
WARNING: Beep Beep</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/util.jl#L579-L588">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.logging" href="#Base.logging"><code>Base.logging</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">logging(io [, m [, f]][; kind=:all])
logging([; kind=:all])</code></pre><p>Stream output of informational, warning, and/or error messages to <code>io</code>, overriding what was otherwise specified.  Optionally, divert stream only for module <code>m</code>, or specifically function <code>f</code> within <code>m</code>.  <code>kind</code> can be <code>:all</code> (the default), <code>:info</code>, <code>:warn</code>, or <code>:error</code>.  See <code>Base.log_{info,warn,error}_to</code> for the current set of redirections.  Call <code>logging</code> with no arguments (or just the <code>kind</code>) to reset everything.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/util.jl#L482-L492">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Printf.@printf" href="#Base.Printf.@printf"><code>Base.Printf.@printf</code></a> — <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@printf([io::IOStream], &quot;%Fmt&quot;, args...)</code></pre><p>Print <code>args</code> using C <code>printf()</code> style format specification string, with some caveats: <code>Inf</code> and <code>NaN</code> are printed consistently as <code>Inf</code> and <code>NaN</code> for flags <code>%a</code>, <code>%A</code>, <code>%e</code>, <code>%E</code>, <code>%f</code>, <code>%F</code>, <code>%g</code>, and <code>%G</code>. Furthermore, if a floating point number is equally close to the numeric values of two possible output strings, the output string further away from zero is chosen.</p><p>Optionally, an <code>IOStream</code> may be passed as the first argument to redirect output.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; @printf(&quot;%f %F %f %F\n&quot;, Inf, Inf, NaN, NaN)
Inf Inf NaN NaN


julia&gt; @printf &quot;%.0f %.1f %f\n&quot; 0.5 0.025 -0.0078125
1 0.0 -0.007813</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/printf.jl#L1196-L1218">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Printf.@sprintf" href="#Base.Printf.@sprintf"><code>Base.Printf.@sprintf</code></a> — <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@sprintf(&quot;%Fmt&quot;, args...)</code></pre><p>Return <code>@printf</code> formatted output as string.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; s = @sprintf &quot;this is a %s %15.1f&quot; &quot;test&quot; 34.567;

julia&gt; println(s)
this is a test            34.6</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/printf.jl#L1229-L1242">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.sprint" href="#Base.sprint"><code>Base.sprint</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">sprint(f::Function, args...)</code></pre><p>Call the given function with an I/O stream and the supplied extra arguments. Everything written to this I/O stream is returned as a string.</p><pre><code class="language-julia-repl">julia&gt; sprint(showcompact, 66.66666)
&quot;66.6667&quot;</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/strings/io.jl#L71-L81">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.showerror" href="#Base.showerror"><code>Base.showerror</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">showerror(io, e)</code></pre><p>Show a descriptive representation of an exception object.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/docs/helpdb/Base.jl#L1754-L1758">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.dump" href="#Base.dump"><code>Base.dump</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">dump(x)</code></pre><p>Show every part of the representation of a value.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/docs/helpdb/Base.jl#L530-L534">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.readstring" href="#Base.readstring"><code>Base.readstring</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">readstring(stream::IO)
readstring(filename::AbstractString)</code></pre><p>Read the entire contents of an I/O stream or a file as a string. The text is assumed to be encoded in UTF-8.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/io.jl#L533-L539">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.readline" href="#Base.readline"><code>Base.readline</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">readline(stream::IO=STDIN; chomp::Bool=true)
readline(filename::AbstractString; chomp::Bool=true)</code></pre><p>Read a single line of text from the given I/O stream or file (defaults to <code>STDIN</code>). When reading from a file, the text is assumed to be encoded in UTF-8. Lines in the input end with <code>&#39;\n&#39;</code> or <code>&quot;\r\n&quot;</code> or the end of an input stream. When <code>chomp</code> is true (as it is by default), these trailing newline characters are removed from the line before it is returned. When <code>chomp</code> is false, they are returned as part of the line.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/io.jl#L172-L182">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.readuntil" href="#Base.readuntil"><code>Base.readuntil</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">readuntil(stream::IO, delim)
readuntil(filename::AbstractString, delim)</code></pre><p>Read a string from an I/O stream or a file, up to and including the given delimiter byte. The text is assumed to be encoded in UTF-8.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/io.jl#L163-L169">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.readlines" href="#Base.readlines"><code>Base.readlines</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">readlines(stream::IO=STDIN; chomp::Bool=true)
readlines(filename::AbstractString; chomp::Bool=true)</code></pre><p>Read all lines of an I/O stream or a file as a vector of strings. Behavior is equivalent to saving the result of reading <code>readline</code> repeatedly with the same arguments and saving the resulting lines as a vector of strings.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/io.jl#L201-L208">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.eachline" href="#Base.eachline"><code>Base.eachline</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">eachline(stream::IO=STDIN; chomp::Bool=true)
eachline(filename::AbstractString; chomp::Bool=true)</code></pre><p>Create an iterable <code>EachLine</code> object that will yield each line from an I/O stream or a file. Iteration calls <code>readline</code> on the stream argument repeatedly with <code>chomp</code> passed through, determining whether trailing end-of-line characters are removed. When called with a file name, the file is opened once at the beginning of iteration and closed at the end. If iteration is interrupted, the file will be closed when the <code>EachLine</code> object is garbage collected.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/io.jl#L554-L564">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.DataFmt.readdlm-Tuple{Any,Char,Type,Char}" href="#Base.DataFmt.readdlm-Tuple{Any,Char,Type,Char}"><code>Base.DataFmt.readdlm</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">readdlm(source, delim::Char, T::Type, eol::Char; header=false, skipstart=0, skipblanks=true, use_mmap, quotes=true, dims, comments=true, comment_char=&#39;#&#39;)</code></pre><p>Read a matrix from the source where each line (separated by <code>eol</code>) gives one row, with elements separated by the given delimiter. The source can be a text file, stream or byte array. Memory mapped files can be used by passing the byte array representation of the mapped segment as source.</p><p>If <code>T</code> is a numeric type, the result is an array of that type, with any non-numeric elements as <code>NaN</code> for floating-point types, or zero. Other useful values of <code>T</code> include <code>String</code>, <code>AbstractString</code>, and <code>Any</code>.</p><p>If <code>header</code> is <code>true</code>, the first row of data will be read as header and the tuple <code>(data_cells, header_cells)</code> is returned instead of only <code>data_cells</code>.</p><p>Specifying <code>skipstart</code> will ignore the corresponding number of initial lines from the input.</p><p>If <code>skipblanks</code> is <code>true</code>, blank lines in the input will be ignored.</p><p>If <code>use_mmap</code> is <code>true</code>, the file specified by <code>source</code> is memory mapped for potential speedups. Default is <code>true</code> except on Windows. On Windows, you may want to specify <code>true</code> if the file is large, and is only read once and not written to.</p><p>If <code>quotes</code> is <code>true</code>, columns enclosed within double-quote (&quot;) characters are allowed to contain new lines and column delimiters. Double-quote characters within a quoted field must be escaped with another double-quote.  Specifying <code>dims</code> as a tuple of the expected rows and columns (including header, if any) may speed up reading of large files.  If <code>comments</code> is <code>true</code>, lines beginning with <code>comment_char</code> and text following <code>comment_char</code> in any line are ignored.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/datafmt.jl#L84-L113">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.DataFmt.readdlm-Tuple{Any,Char,Char}" href="#Base.DataFmt.readdlm-Tuple{Any,Char,Char}"><code>Base.DataFmt.readdlm</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">readdlm(source, delim::Char, eol::Char; options...)</code></pre><p>If all data is numeric, the result will be a numeric array. If some elements cannot be parsed as numbers, a heterogeneous array of numbers and strings is returned.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/datafmt.jl#L75-L80">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.DataFmt.readdlm-Tuple{Any,Char,Type}" href="#Base.DataFmt.readdlm-Tuple{Any,Char,Type}"><code>Base.DataFmt.readdlm</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">readdlm(source, delim::Char, T::Type; options...)</code></pre><p>The end of line delimiter is taken as <code>\n</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/datafmt.jl#L49-L53">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.DataFmt.readdlm-Tuple{Any,Char}" href="#Base.DataFmt.readdlm-Tuple{Any,Char}"><code>Base.DataFmt.readdlm</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">readdlm(source, delim::Char; options...)</code></pre><p>The end of line delimiter is taken as <code>\n</code>. If all data is numeric, the result will be a numeric array. If some elements cannot be parsed as numbers, a heterogeneous array of numbers and strings is returned.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/datafmt.jl#L66-L72">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.DataFmt.readdlm-Tuple{Any,Type}" href="#Base.DataFmt.readdlm-Tuple{Any,Type}"><code>Base.DataFmt.readdlm</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">readdlm(source, T::Type; options...)</code></pre><p>The columns are assumed to be separated by one or more whitespaces. The end of line delimiter is taken as <code>\n</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/datafmt.jl#L41-L46">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.DataFmt.readdlm-Tuple{Any}" href="#Base.DataFmt.readdlm-Tuple{Any}"><code>Base.DataFmt.readdlm</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">readdlm(source; options...)</code></pre><p>The columns are assumed to be separated by one or more whitespaces. The end of line delimiter is taken as <code>\n</code>. If all data is numeric, the result will be a numeric array. If some elements cannot be parsed as numbers, a heterogeneous array of numbers and strings is returned.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/datafmt.jl#L56-L63">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.DataFmt.writedlm" href="#Base.DataFmt.writedlm"><code>Base.DataFmt.writedlm</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">writedlm(f, A, delim=&#39;\t&#39;; opts)</code></pre><p>Write <code>A</code> (a vector, matrix, or an iterable collection of iterable rows) as text to <code>f</code> (either a filename string or an <code>IO</code> stream) using the given delimiter <code>delim</code> (which defaults to tab, but can be any printable Julia object, typically a <code>Char</code> or <code>AbstractString</code>).</p><p>For example, two vectors <code>x</code> and <code>y</code> of the same length can be written as two columns of tab-delimited text to <code>f</code> by either <code>writedlm(f, [x y])</code> or by <code>writedlm(f, zip(x, y))</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/datafmt.jl#L687-L697">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.DataFmt.readcsv" href="#Base.DataFmt.readcsv"><code>Base.DataFmt.readcsv</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">readcsv(source, [T::Type]; options...)</code></pre><p>Equivalent to <a href="#Base.DataFmt.readdlm-Tuple{Any,Char,Type,Char}"><code>readdlm</code></a> with <code>delim</code> set to comma, and type optionally defined by <code>T</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/docs/helpdb/Base.jl#L1768-L1772">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.DataFmt.writecsv" href="#Base.DataFmt.writecsv"><code>Base.DataFmt.writecsv</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">writecsv(filename, A; opts)</code></pre><p>Equivalent to <a href="#Base.DataFmt.writedlm"><code>writedlm</code></a> with <code>delim</code> set to comma.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/datafmt.jl#L700-L704">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Base64.Base64EncodePipe" href="#Base.Base64.Base64EncodePipe"><code>Base.Base64.Base64EncodePipe</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Base64EncodePipe(ostream)</code></pre><p>Returns a new write-only I/O stream, which converts any bytes written to it into base64-encoded ASCII bytes written to <code>ostream</code>. Calling <a href="#Base.close"><code>close</code></a> on the <code>Base64EncodePipe</code> stream is necessary to complete the encoding (but does not close <code>ostream</code>).</p><pre><code class="language-julia-repl">julia&gt; io = IOBuffer();

julia&gt; iob64_encode = Base64EncodePipe(io);

julia&gt; write(iob64_encode, &quot;Hello!&quot;)
6

julia&gt; close(iob64_encode);

julia&gt; str = String(take!(io))
&quot;SGVsbG8h&quot;

julia&gt; String(base64decode(str))
&quot;Hello!&quot;</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/base64.jl#L17-L41">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Base64.Base64DecodePipe" href="#Base.Base64.Base64DecodePipe"><code>Base.Base64.Base64DecodePipe</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Base64DecodePipe(istream)</code></pre><p>Returns a new read-only I/O stream, which decodes base64-encoded data read from <code>istream</code>.</p><pre><code class="language-julia-repl">julia&gt; io = IOBuffer();

julia&gt; iob64_decode = Base64DecodePipe(io);

julia&gt; write(io, &quot;SGVsbG8h&quot;)
8

julia&gt; seekstart(io);

julia&gt; String(read(iob64_decode))
&quot;Hello!&quot;</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/base64.jl#L205-L223">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Base64.base64encode" href="#Base.Base64.base64encode"><code>Base.Base64.base64encode</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">base64encode(writefunc, args...)
base64encode(args...)</code></pre><p>Given a <a href="#Base.write"><code>write</code></a>-like function <code>writefunc</code>, which takes an I/O stream as its first argument, <code>base64encode(writefunc, args...)</code> calls <code>writefunc</code> to write <code>args...</code> to a base64-encoded string, and returns the string. <code>base64encode(args...)</code> is equivalent to <code>base64encode(write, args...)</code>: it converts its arguments into bytes using the standard <a href="#Base.write"><code>write</code></a> functions and returns the base64-encoded string.</p><p>See also <a href="#Base.Base64.base64decode"><code>base64decode</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/base64.jl#L182-L193">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Base64.base64decode" href="#Base.Base64.base64decode"><code>Base.Base64.base64decode</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">base64decode(string)</code></pre><p>Decodes the base64-encoded <code>string</code> and returns a <code>Vector{UInt8}</code> of the decoded bytes.</p><p>See also <a href="#Base.Base64.base64encode"><code>base64encode</code></a></p><pre><code class="language-julia-repl">julia&gt; b = base64decode(&quot;SGVsbG8h&quot;)
6-element Array{UInt8,1}:
 0x48
 0x65
 0x6c
 0x6c
 0x6f
 0x21

julia&gt; String(b)
&quot;Hello!&quot;</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/base64.jl#L257-L277">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.displaysize" href="#Base.displaysize"><code>Base.displaysize</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">displaysize(io) -&gt; (lines, columns)</code></pre><p>Return the nominal size of the screen that may be used for rendering output to this io object</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/stream.jl#L351-L353">source</a></section><h2><a class="nav-anchor" id="Multimedia-I/O-1" href="#Multimedia-I/O-1">Multimedia I/O</a></h2><p>Just as text output is performed by <a href="#Base.print"><code>print</code></a> and user-defined types can indicate their textual representation by overloading <a href="#Base.show-Tuple{Any}"><code>show</code></a>, Julia provides a standardized mechanism for rich multimedia output (such as images, formatted text, or even audio and video), consisting of three parts:</p><ul><li><p>A function <a href="#Base.Multimedia.display"><code>display(x)</code></a> to request the richest available multimedia display of a Julia object <code>x</code> (with a plain-text fallback).</p></li><li><p>Overloading <a href="#Base.show-Tuple{Any}"><code>show</code></a> allows one to indicate arbitrary multimedia representations (keyed by standard MIME types) of user-defined types.</p></li><li><p>Multimedia-capable display backends may be registered by subclassing a generic <code>Display</code> type and pushing them onto a stack of display backends via <a href="#Base.Multimedia.pushdisplay"><code>pushdisplay</code></a>.</p></li></ul><p>The base Julia runtime provides only plain-text display, but richer displays may be enabled by loading external modules or by using graphical Julia environments (such as the IPython-based IJulia notebook).</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Multimedia.display" href="#Base.Multimedia.display"><code>Base.Multimedia.display</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">display(x)
display(d::Display, x)
display(mime, x)
display(d::Display, mime, x)</code></pre><p>Display <code>x</code> using the topmost applicable display in the display stack, typically using the richest supported multimedia output for <code>x</code>, with plain-text <a href="#Base.STDOUT"><code>STDOUT</code></a> output as a fallback. The <code>display(d, x)</code> variant attempts to display <code>x</code> on the given display <code>d</code> only, throwing a <code>MethodError</code> if <code>d</code> cannot display objects of this type.</p><p>There are also two variants with a <code>mime</code> argument (a MIME type string, such as <code>&quot;image/png&quot;</code>), which attempt to display <code>x</code> using the requested MIME type <em>only</em>, throwing a <code>MethodError</code> if this type is not supported by either the display(s) or by <code>x</code>. With these variants, one can also supply the &quot;raw&quot; data in the requested MIME type by passing <code>x::AbstractString</code> (for MIME types with text-based storage, such as text/html or application/postscript) or <code>x::Vector{UInt8}</code> (for binary MIME types).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/docs/helpdb/Base.jl#L544-L561">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Multimedia.redisplay" href="#Base.Multimedia.redisplay"><code>Base.Multimedia.redisplay</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">redisplay(x)
redisplay(d::Display, x)
redisplay(mime, x)
redisplay(d::Display, mime, x)</code></pre><p>By default, the <code>redisplay</code> functions simply call <a href="#Base.Multimedia.display"><code>display</code></a>. However, some display backends may override <code>redisplay</code> to modify an existing display of <code>x</code> (if any). Using <code>redisplay</code> is also a hint to the backend that <code>x</code> may be redisplayed several times, and the backend may choose to defer the display until (for example) the next interactive prompt.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/docs/helpdb/Base.jl#L480-L492">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Multimedia.displayable" href="#Base.Multimedia.displayable"><code>Base.Multimedia.displayable</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">displayable(mime) -&gt; Bool
displayable(d::Display, mime) -&gt; Bool</code></pre><p>Returns a boolean value indicating whether the given <code>mime</code> type (string) is displayable by any of the displays in the current display stack, or specifically by the display <code>d</code> in the second variant.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/multimedia.jl#L128-L135">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.show-Tuple{Any,Any,Any}" href="#Base.show-Tuple{Any,Any,Any}"><code>Base.show</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">show(stream, mime, x)</code></pre><p>The <code>display</code> functions ultimately call <code>show</code> in order to write an object <code>x</code> as a given <code>mime</code> type to a given I/O <code>stream</code> (usually a memory buffer), if possible. In order to provide a rich multimedia representation of a user-defined type <code>T</code>, it is only necessary to define a new <code>show</code> method for <code>T</code>, via: <code>show(stream, ::MIME&quot;mime&quot;, x::T) = ...</code>, where <code>mime</code> is a MIME-type string and the function body calls <code>write</code> (or similar) to write that representation of <code>x</code> to <code>stream</code>. (Note that the <code>MIME&quot;&quot;</code> notation only supports literal strings; to construct <code>MIME</code> types in a more flexible manner use <code>MIME{Symbol(&quot;&quot;)}</code>.)</p><p>For example, if you define a <code>MyImage</code> type and know how to write it to a PNG file, you could define a function <code>show(stream, ::MIME&quot;image/png&quot;, x::MyImage) = ...</code> to allow your images to be displayed on any PNG-capable <code>Display</code> (such as IJulia). As usual, be sure to <code>import Base.show</code> in order to add new methods to the built-in Julia function <code>show</code>.</p><p>The default MIME type is <code>MIME&quot;text/plain&quot;</code>. There is a fallback definition for <code>text/plain</code> output that calls <code>show</code> with 2 arguments. Therefore, this case should be handled by defining a 2-argument <code>show(stream::IO, x::MyType)</code> method.</p><p>Technically, the <code>MIME&quot;mime&quot;</code> macro defines a singleton type for the given <code>mime</code> string, which allows us to exploit Julia&#39;s dispatch mechanisms in determining how to display objects of any given type.</p><p>The first argument to <code>show</code> can be an <a href="#Base.IOContext"><code>IOContext</code></a> specifying output format properties. See <a href="#Base.IOContext"><code>IOContext</code></a> for details.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/docs/helpdb/Base.jl#L1705-L1733">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Multimedia.mimewritable" href="#Base.Multimedia.mimewritable"><code>Base.Multimedia.mimewritable</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">mimewritable(mime, x)</code></pre><p>Returns a boolean value indicating whether or not the object <code>x</code> can be written as the given <code>mime</code> type. (By default, this is determined automatically by the existence of the corresponding <a href="#Base.show-Tuple{Any}"><code>show</code></a> method for <code>typeof(x)</code>.)</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/multimedia.jl#L28-L34">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Multimedia.reprmime" href="#Base.Multimedia.reprmime"><code>Base.Multimedia.reprmime</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">reprmime(mime, x)</code></pre><p>Returns an <code>AbstractString</code> or <code>Vector{UInt8}</code> containing the representation of <code>x</code> in the requested <code>mime</code> type, as written by <code>show</code> (throwing a <code>MethodError</code> if no appropriate <code>show</code> is available). An <code>AbstractString</code> is returned for MIME types with textual representations (such as <code>&quot;text/html&quot;</code> or <code>&quot;application/postscript&quot;</code>), whereas binary data is returned as <code>Vector{UInt8}</code>. (The function <code>istextmime(mime)</code> returns whether or not Julia treats a given <code>mime</code> type as text.)</p><p>As a special case, if <code>x</code> is an <code>AbstractString</code> (for textual MIME types) or a <code>Vector{UInt8}</code> (for binary MIME types), the <code>reprmime</code> function assumes that <code>x</code> is already in the requested <code>mime</code> format and simply returns <code>x</code>. This special case does not apply to the <code>&quot;text/plain&quot;</code> MIME type. This is useful so that raw data can be passed to <code>display(m::MIME, x)</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/multimedia.jl#L44-L60">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Multimedia.stringmime" href="#Base.Multimedia.stringmime"><code>Base.Multimedia.stringmime</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">stringmime(mime, x)</code></pre><p>Returns an <code>AbstractString</code> containing the representation of <code>x</code> in the requested <code>mime</code> type. This is similar to <a href="#Base.Multimedia.reprmime"><code>reprmime</code></a> except that binary data is base64-encoded as an ASCII string.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/multimedia.jl#L76-L82">source</a></section><p>As mentioned above, one can also define new display backends. For example, a module that can display PNG images in a window can register this capability with Julia, so that calling <a href="#Base.Multimedia.display"><code>display(x)</code></a> on types with PNG representations will automatically display the image using the module&#39;s window.</p><p>In order to define a new display backend, one should first create a subtype <code>D</code> of the abstract class <code>Display</code>.  Then, for each MIME type (<code>mime</code> string) that can be displayed on <code>D</code>, one should define a function <code>display(d::D, ::MIME&quot;mime&quot;, x) = ...</code> that displays <code>x</code> as that MIME type, usually by calling <a href="#Base.Multimedia.reprmime"><code>reprmime(mime, x)</code></a>.  A <code>MethodError</code> should be thrown if <code>x</code> cannot be displayed as that MIME type; this is automatic if one calls <a href="#Base.Multimedia.reprmime"><code>reprmime</code></a>. Finally, one should define a function <code>display(d::D, x)</code> that queries <a href="#Base.Multimedia.mimewritable"><code>mimewritable(mime, x)</code></a> for the <code>mime</code> types supported by <code>D</code> and displays the &quot;best&quot; one; a <code>MethodError</code> should be thrown if no supported MIME types are found for <code>x</code>.  Similarly, some subtypes may wish to override <a href="#Base.Multimedia.redisplay"><code>redisplay(d::D, ...)</code></a>. (Again, one should <code>import Base.display</code> to add new methods to <code>display</code>.) The return values of these functions are up to the implementation (since in some cases it may be useful to return a display &quot;handle&quot; of some type).  The display functions for <code>D</code> can then be called directly, but they can also be invoked automatically from <a href="#Base.Multimedia.display"><code>display(x)</code></a> simply by pushing a new display onto the display-backend stack with:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Multimedia.pushdisplay" href="#Base.Multimedia.pushdisplay"><code>Base.Multimedia.pushdisplay</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">pushdisplay(d::Display)</code></pre><p>Pushes a new display <code>d</code> on top of the global display-backend stack. Calling <code>display(x)</code> or <code>display(mime, x)</code> will display <code>x</code> on the topmost compatible backend in the stack (i.e., the topmost backend that does not throw a <code>MethodError</code>).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/docs/helpdb/Base.jl#L1657-L1663">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Multimedia.popdisplay" href="#Base.Multimedia.popdisplay"><code>Base.Multimedia.popdisplay</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">popdisplay()
popdisplay(d::Display)</code></pre><p>Pop the topmost backend off of the display-backend stack, or the topmost copy of <code>d</code> in the second variant.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/docs/helpdb/Base.jl#L1064-L1070">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Multimedia.TextDisplay" href="#Base.Multimedia.TextDisplay"><code>Base.Multimedia.TextDisplay</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">TextDisplay(io::IO)</code></pre><p>Returns a <code>TextDisplay &lt;: Display</code>, which displays any object as the text/plain MIME type (by default), writing the text representation to the given I/O stream. (This is how objects are printed in the Julia REPL.)</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/multimedia.jl#L141-L147">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Multimedia.istextmime" href="#Base.Multimedia.istextmime"><code>Base.Multimedia.istextmime</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">istextmime(m::MIME)</code></pre><p>Determine whether a MIME type is text data. MIME types are assumed to be binary data except for a set of types known to be text data (possibly Unicode).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/multimedia.jl#L88-L93">source</a></section><h2><a class="nav-anchor" id="Memory-mapped-I/O-1" href="#Memory-mapped-I/O-1">Memory-mapped I/O</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Mmap.Anonymous" href="#Base.Mmap.Anonymous"><code>Base.Mmap.Anonymous</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Mmap.Anonymous(name, readonly, create)</code></pre><p>Create an <code>IO</code>-like object for creating zeroed-out mmapped-memory that is not tied to a file for use in <code>Mmap.mmap</code>. Used by <code>SharedArray</code> for creating shared memory arrays.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/docs/helpdb/Base.jl#L672-L677">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Mmap.mmap-Tuple{Any,Type,Any,Any}" href="#Base.Mmap.mmap-Tuple{Any,Type,Any,Any}"><code>Base.Mmap.mmap</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">Mmap.mmap(io::Union{IOStream,AbstractString,Mmap.AnonymousMmap}[, type::Type{Array{T,N}}, dims, offset]; grow::Bool=true, shared::Bool=true)
       Mmap.mmap(type::Type{Array{T,N}}, dims)</code></pre><p>Create an <code>Array</code> whose values are linked to a file, using memory-mapping. This provides a convenient way of working with data too large to fit in the computer&#39;s memory.</p><p>The type is an <code>Array{T,N}</code> with a bits-type element of <code>T</code> and dimension <code>N</code> that determines how the bytes of the array are interpreted. Note that the file must be stored in binary format, and no format conversions are possible (this is a limitation of operating systems, not Julia).</p><p><code>dims</code> is a tuple or single <a href="../numbers/#Core.Integer"><code>Integer</code></a> specifying the size or length of the array.</p><p>The file is passed via the stream argument, either as an open <code>IOStream</code> or filename string. When you initialize the stream, use <code>&quot;r&quot;</code> for a &quot;read-only&quot; array, and <code>&quot;w+&quot;</code> to create a new array used to write values to disk.</p><p>If no <code>type</code> argument is specified, the default is <code>Vector{UInt8}</code>.</p><p>Optionally, you can specify an offset (in bytes) if, for example, you want to skip over a header in the file. The default value for the offset is the current stream position for an <code>IOStream</code>.</p><p>The <code>grow</code> keyword argument specifies whether the disk file should be grown to accommodate the requested size of array (if the total file size is &lt; requested array size). Write privileges are required to grow the file.</p><p>The <code>shared</code> keyword argument specifies whether the resulting <code>Array</code> and changes made to it will be visible to other processes mapping the same file.</p><p>For example, the following code</p><pre><code class="language-julia"># Create a file for mmapping
# (you could alternatively use mmap to do this step, too)
A = rand(1:20, 5, 30)
s = open(&quot;/tmp/mmap.bin&quot;, &quot;w+&quot;)
# We&#39;ll write the dimensions of the array as the first two Ints in the file
write(s, size(A,1))
write(s, size(A,2))
# Now write the data
write(s, A)
close(s)

# Test by reading it back in
s = open(&quot;/tmp/mmap.bin&quot;)   # default is read-only
m = read(s, Int)
n = read(s, Int)
A2 = Mmap.mmap(s, Matrix{Int}, (m,n))</code></pre><p>creates a <code>m</code>-by-<code>n</code> <code>Matrix{Int}</code>, linked to the file associated with stream <code>s</code>.</p><p>A more portable file would need to encode the word size – 32 bit or 64 bit – and endianness information in the header. In practice, consider encoding binary data using standard formats like HDF5 (which can be used with memory-mapping).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/docs/helpdb/Base.jl#L240-L297">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Mmap.mmap-Tuple{Any,BitArray,Any,Any}" href="#Base.Mmap.mmap-Tuple{Any,BitArray,Any,Any}"><code>Base.Mmap.mmap</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">Mmap.mmap(io, BitArray, [dims, offset])</code></pre><p>Create a <code>BitArray</code> whose values are linked to a file, using memory-mapping; it has the same purpose, works in the same way, and has the same arguments, as <a href="#Base.Mmap.mmap-Tuple{Any,Type,Any,Any}"><code>mmap</code></a>, but the byte representation is different.</p><p><strong>Example</strong>: <code>B = Mmap.mmap(s, BitArray, (25,30000))</code></p><p>This would create a 25-by-30000 <code>BitArray</code>, linked to the file associated with stream <code>s</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/docs/helpdb/Base.jl#L300-L310">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Mmap.sync!" href="#Base.Mmap.sync!"><code>Base.Mmap.sync!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">Mmap.sync!(array)</code></pre><p>Forces synchronization between the in-memory version of a memory-mapped <code>Array</code> or <code>BitArray</code> and the on-disk version.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/docs/helpdb/Base.jl#L1454-L1459">source</a></section><h2><a class="nav-anchor" id="Network-I/O-1" href="#Network-I/O-1">Network I/O</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.connect-Tuple{TCPSocket,Integer}" href="#Base.connect-Tuple{TCPSocket,Integer}"><code>Base.connect</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">connect([host], port::Integer) -&gt; TCPSocket</code></pre><p>Connect to the host <code>host</code> on port <code>port</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/socket.jl#L732-L736">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.connect-Tuple{AbstractString}" href="#Base.connect-Tuple{AbstractString}"><code>Base.connect</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">connect(path::AbstractString) -&gt; PipeEndpoint</code></pre><p>Connect to the named pipe / UNIX domain socket at <code>path</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/stream.jl#L990-L994">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.listen-Tuple{Any}" href="#Base.listen-Tuple{Any}"><code>Base.listen</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">listen([addr, ]port::Integer; backlog::Integer=BACKLOG_DEFAULT) -&gt; TCPServer</code></pre><p>Listen on port on the address specified by <code>addr</code>. By default this listens on <code>localhost</code> only. To listen on all interfaces pass <code>IPv4(0)</code> or <code>IPv6(0)</code> as appropriate. <code>backlog</code> determines how many connections can be pending (not having called <a href="#Base.accept"><code>accept</code></a>) before the server will begin to reject them. The default value of <code>backlog</code> is 511.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/socket.jl#L760-L769">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.listen-Tuple{AbstractString}" href="#Base.listen-Tuple{AbstractString}"><code>Base.listen</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">listen(path::AbstractString) -&gt; PipeServer</code></pre><p>Create and listen on a named pipe / UNIX domain socket.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/stream.jl#L961-L965">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.getaddrinfo" href="#Base.getaddrinfo"><code>Base.getaddrinfo</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">getaddrinfo(host::AbstractString) -&gt; IPAddr</code></pre><p>Gets the IP address of the <code>host</code> (may have to do a DNS lookup)</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/socket.jl#L634-L638">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.getsockname" href="#Base.getsockname"><code>Base.getsockname</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">getsockname(sock::Union{TCPServer, TCPSocket}) -&gt; (IPAddr, UInt16)</code></pre><p>Get the IP address and the port that the given <code>TCPSocket</code> is connected to (or bound to, in the case of <code>TCPServer</code>).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/socket.jl#L845-L850">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.IPv4" href="#Base.IPv4"><code>Base.IPv4</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">IPv4(host::Integer) -&gt; IPv4</code></pre><p>Returns an IPv4 object from ip address <code>host</code> formatted as an <a href="../numbers/#Core.Integer"><code>Integer</code></a>.</p><pre><code class="language-julia-repl">julia&gt; IPv4(3223256218)
ip&quot;192.30.252.154&quot;</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/socket.jl#L24-L33">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.IPv6" href="#Base.IPv6"><code>Base.IPv6</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">IPv6(host::Integer) -&gt; IPv6</code></pre><p>Returns an IPv6 object from ip address <code>host</code> formatted as an <a href="../numbers/#Core.Integer"><code>Integer</code></a>.</p><pre><code class="language-julia-repl">julia&gt; IPv6(3223256218)
ip&quot;::c01e:fc9a&quot;</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/socket.jl#L76-L85">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.nb_available" href="#Base.nb_available"><code>Base.nb_available</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">nb_available(stream)</code></pre><p>Returns the number of bytes available for reading before a read from this stream or buffer will block.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/io.jl#L130-L134">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.accept" href="#Base.accept"><code>Base.accept</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">accept(server[,client])</code></pre><p>Accepts a connection on the given server and returns a connection to the client. An uninitialized client stream may be provided, in which case it will be used instead of creating a new stream.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/docs/helpdb/Base.jl#L663-L669">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.listenany" href="#Base.listenany"><code>Base.listenany</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">listenany([host::IPAddr,] port_hint) -&gt; (UInt16, TCPServer)</code></pre><p>Create a <code>TCPServer</code> on any port, using hint as a starting point. Returns a tuple of the actual port that the server was created on and the server itself.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/socket.jl#L818-L823">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Filesystem.poll_fd" href="#Base.Filesystem.poll_fd"><code>Base.Filesystem.poll_fd</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">poll_fd(fd, timeout_s::Real=-1; readable=false, writable=false)</code></pre><p>Monitor a file descriptor <code>fd</code> for changes in the read or write availability, and with a timeout given by <code>timeout_s</code> seconds.</p><p>The keyword arguments determine which of read and/or write status should be monitored; at least one of them must be set to <code>true</code>.</p><p>The returned value is an object with boolean fields <code>readable</code>, <code>writable</code>, and <code>timedout</code>, giving the result of the polling.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/poll.jl#L434-L445">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Filesystem.poll_file" href="#Base.Filesystem.poll_file"><code>Base.Filesystem.poll_file</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">poll_file(path::AbstractString, interval_s::Real=5.007, timeout_s::Real=-1) -&gt; (previous::StatStruct, current::StatStruct)</code></pre><p>Monitor a file for changes by polling every <code>interval_s</code> seconds until a change occurs or <code>timeout_s</code> seconds have elapsed. The <code>interval_s</code> should be a long period; the default is 5.007 seconds.</p><p>Returns a pair of <code>StatStruct</code> objects <code>(previous, current)</code> when a change is detected.</p><p>To determine when a file was modified, compare <code>mtime(prev) != mtime(current)</code> to detect notification of changes. However, using <a href="#Base.Filesystem.watch_file"><code>watch_file</code></a> for this operation is preferred, since it is more reliable and efficient, although in some situations it may not be available.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/poll.jl#L514-L526">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Filesystem.watch_file" href="#Base.Filesystem.watch_file"><code>Base.Filesystem.watch_file</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">watch_file(path::AbstractString, timeout_s::Real=-1)</code></pre><p>Watch file or directory <code>path</code> for changes until a change occurs or <code>timeout_s</code> seconds have elapsed.</p><p>The returned value is an object with boolean fields <code>changed</code>, <code>renamed</code>, and <code>timedout</code>, giving the result of watching the file.</p><p>This behavior of this function varies slightly across platforms. See <a href="https://nodejs.org/api/fs.html#fs_caveats">https://nodejs.org/api/fs.html#fs_caveats</a> for more detailed information.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/poll.jl#L474-L485">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.bind" href="#Base.bind"><code>Base.bind</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">bind(socket::Union{UDPSocket, TCPSocket}, host::IPAddr, port::Integer; ipv6only=false, reuseaddr=false, kws...)</code></pre><p>Bind <code>socket</code> to the given <code>host:port</code>. Note that <code>0.0.0.0</code> will listen on all devices.</p><ul><li><p>The <code>ipv6only</code> parameter disables dual stack mode. If <code>ipv6only=true</code>, only an IPv6 stack is created.</p></li><li><p>If <code>reuseaddr=true</code>, multiple threads or processes can bind to the same address without error if they all set <code>reuseaddr=true</code>, but only the last to bind will receive any traffic.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/socket.jl#L415-L423">source</a><div><pre><code class="language-none">bind(chnl::Channel, task::Task)</code></pre><p>Associates the lifetime of <code>chnl</code> with a task. Channel <code>chnl</code> is automatically closed when the task terminates. Any uncaught exception in the task is propagated to all waiters on <code>chnl</code>.</p><p>The <code>chnl</code> object can be explicitly closed independent of task termination. Terminating tasks have no effect on already closed Channel objects.</p><p>When a channel is bound to multiple tasks, the first task to terminate will close the channel. When multiple channels are bound to the same task, termination of the task will close all of the bound channels.</p><pre><code class="language-julia-repl">julia&gt; c = Channel(0);

julia&gt; task = @schedule foreach(i-&gt;put!(c, i), 1:4);

julia&gt; bind(c,task);

julia&gt; for i in c
           @show i
       end;
i = 1
i = 2
i = 3
i = 4

julia&gt; isopen(c)
false</code></pre><pre><code class="language-julia-repl">julia&gt; c = Channel(0);

julia&gt; task = @schedule (put!(c,1);error(&quot;foo&quot;));

julia&gt; bind(c,task);

julia&gt; take!(c)
1

julia&gt; put!(c,1);
ERROR: foo
Stacktrace:
 [1] check_channel_state(::Channel{Any}) at ./channels.jl:131
 [2] put!(::Channel{Any}, ::Int64) at ./channels.jl:261</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/channels.jl#L151-L200">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.send" href="#Base.send"><code>Base.send</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">send(socket::UDPSocket, host, port::Integer, msg)</code></pre><p>Send <code>msg</code> over <code>socket</code> to <code>host:port</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/socket.jl#L551-L555">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.recv" href="#Base.recv"><code>Base.recv</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">recv(socket::UDPSocket)</code></pre><p>Read a UDP packet from the specified socket, and return the bytes received. This call blocks.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/socket.jl#L480-L484">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.recvfrom" href="#Base.recvfrom"><code>Base.recvfrom</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">recvfrom(socket::UDPSocket) -&gt; (address, data)</code></pre><p>Read a UDP packet from the specified socket, returning a tuple of <code>(address, data)</code>, where <code>address</code> will be either IPv4 or IPv6 as appropriate.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/socket.jl#L490-L495">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.setopt" href="#Base.setopt"><code>Base.setopt</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">setopt(sock::UDPSocket; multicast_loop = nothing, multicast_ttl=nothing, enable_broadcast=nothing, ttl=nothing)</code></pre><p>Set UDP socket options.</p><ul><li><p><code>multicast_loop</code>: loopback for multicast packets (default: <code>true</code>).</p></li><li><p><code>multicast_ttl</code>: TTL for multicast packets (default: <code>nothing</code>).</p></li><li><p><code>enable_broadcast</code>: flag must be set to <code>true</code> if socket will be used for broadcast messages, or else the UDP system will return an access error (default: <code>false</code>).</p></li><li><p><code>ttl</code>: Time-to-live of packets sent on the socket (default: <code>nothing</code>).</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/socket.jl#L451-L461">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.ntoh" href="#Base.ntoh"><code>Base.ntoh</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">ntoh(x)</code></pre><p>Converts the endianness of a value from Network byte order (big-endian) to that used by the Host.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/io.jl#L246-L250">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.hton" href="#Base.hton"><code>Base.hton</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">hton(x)</code></pre><p>Converts the endianness of a value from that used by the Host to Network byte order (big-endian).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/io.jl#L253-L257">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.ltoh" href="#Base.ltoh"><code>Base.ltoh</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">ltoh(x)</code></pre><p>Converts the endianness of a value from Little-endian to that used by the Host.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/io.jl#L260-L264">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.htol" href="#Base.htol"><code>Base.htol</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">htol(x)</code></pre><p>Converts the endianness of a value from that used by the Host to Little-endian.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/io.jl#L267-L271">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.ENDIAN_BOM" href="#Base.ENDIAN_BOM"><code>Base.ENDIAN_BOM</code></a> — <span class="docstring-category">Constant</span>.</div><div><pre><code class="language-none">ENDIAN_BOM</code></pre><p>The 32-bit byte-order-mark indicates the native byte order of the host machine. Little-endian machines will contain the value <code>0x04030201</code>. Big-endian machines will contain the value <code>0x01020304</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d55cadc350d426a95fd967121ba77494d08364c8/base/io.jl#L237-L243">source</a></section><footer><hr/><a class="previous" href="../file/"><span class="direction">Previous</span><span class="title">Filesystem</span></a><a class="next" href="../punctuation/"><span class="direction">Next</span><span class="title">Punctuation</span></a></footer></article></body></html>
