<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Linear Algebra Â· The Julia Language</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-28835595-6', 'auto');
ga('send', 'pageview');
</script><link rel="canonical" href="https://docs.julialang.org/en/v1/stdlib/LinearAlgebra/index.html"/><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../../assets/julia-manual.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../../index.html"><img class="logo" src="../../assets/logo.png" alt="The Julia Language logo"/></a><h1>The Julia Language</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../../manual/getting-started/">Getting Started</a></li><li><a class="toctext" href="../../manual/variables/">Variables</a></li><li><a class="toctext" href="../../manual/integers-and-floating-point-numbers/">Integers and Floating-Point Numbers</a></li><li><a class="toctext" href="../../manual/mathematical-operations/">Mathematical Operations and Elementary Functions</a></li><li><a class="toctext" href="../../manual/complex-and-rational-numbers/">Complex and Rational Numbers</a></li><li><a class="toctext" href="../../manual/strings/">Strings</a></li><li><a class="toctext" href="../../manual/functions/">Functions</a></li><li><a class="toctext" href="../../manual/control-flow/">Control Flow</a></li><li><a class="toctext" href="../../manual/variables-and-scoping/">Scope of Variables</a></li><li><a class="toctext" href="../../manual/types/">Types</a></li><li><a class="toctext" href="../../manual/methods/">Methods</a></li><li><a class="toctext" href="../../manual/constructors/">Constructors</a></li><li><a class="toctext" href="../../manual/conversion-and-promotion/">Conversion and Promotion</a></li><li><a class="toctext" href="../../manual/interfaces/">Interfaces</a></li><li><a class="toctext" href="../../manual/modules/">Modules</a></li><li><a class="toctext" href="../../manual/documentation/">Documentation</a></li><li><a class="toctext" href="../../manual/metaprogramming/">Metaprogramming</a></li><li><a class="toctext" href="../../manual/arrays/">Multi-dimensional Arrays</a></li><li><a class="toctext" href="../../manual/missing/">Missing Values</a></li><li><a class="toctext" href="../../manual/networking-and-streams/">Networking and Streams</a></li><li><a class="toctext" href="../../manual/parallel-computing/">Parallel Computing</a></li><li><a class="toctext" href="../../manual/running-external-programs/">Running External Programs</a></li><li><a class="toctext" href="../../manual/calling-c-and-fortran-code/">Calling C and Fortran Code</a></li><li><a class="toctext" href="../../manual/handling-operating-system-variation/">Handling Operating System Variation</a></li><li><a class="toctext" href="../../manual/environment-variables/">Environment Variables</a></li><li><a class="toctext" href="../../manual/embedding/">Embedding Julia</a></li><li><a class="toctext" href="../../manual/code-loading/">Code Loading</a></li><li><a class="toctext" href="../../manual/profile/">Profiling</a></li><li><a class="toctext" href="../../manual/stacktraces/">Stack Traces</a></li><li><a class="toctext" href="../../manual/performance-tips/">Performance Tips</a></li><li><a class="toctext" href="../../manual/workflow-tips/">Workflow Tips</a></li><li><a class="toctext" href="../../manual/style-guide/">Style Guide</a></li><li><a class="toctext" href="../../manual/faq/">Frequently Asked Questions</a></li><li><a class="toctext" href="../../manual/noteworthy-differences/">Noteworthy Differences from other Languages</a></li><li><a class="toctext" href="../../manual/unicode-input/">Unicode Input</a></li></ul></li><li><span class="toctext">Base</span><ul><li><a class="toctext" href="../../base/base/">Essentials</a></li><li><a class="toctext" href="../../base/collections/">Collections and Data Structures</a></li><li><a class="toctext" href="../../base/math/">Mathematics</a></li><li><a class="toctext" href="../../base/numbers/">Numbers</a></li><li><a class="toctext" href="../../base/strings/">Strings</a></li><li><a class="toctext" href="../../base/arrays/">Arrays</a></li><li><a class="toctext" href="../../base/parallel/">Tasks</a></li><li><a class="toctext" href="../../base/multi-threading/">Multi-Threading</a></li><li><a class="toctext" href="../../base/constants/">Constants</a></li><li><a class="toctext" href="../../base/file/">Filesystem</a></li><li><a class="toctext" href="../../base/io-network/">I/O and Network</a></li><li><a class="toctext" href="../../base/punctuation/">Punctuation</a></li><li><a class="toctext" href="../../base/sort/">Sorting and Related Functions</a></li><li><a class="toctext" href="../../base/iterators/">Iteration utilities</a></li><li><a class="toctext" href="../../base/c/">C Interface</a></li><li><a class="toctext" href="../../base/libc/">C Standard Library</a></li><li><a class="toctext" href="../../base/stacktraces/">StackTraces</a></li><li><a class="toctext" href="../../base/simd-types/">SIMD Support</a></li></ul></li><li><span class="toctext">Standard Library</span><ul><li><a class="toctext" href="../Base64/">Base64</a></li><li><a class="toctext" href="../CRC32c/">CRC32c</a></li><li><a class="toctext" href="../Dates/">Dates</a></li><li><a class="toctext" href="../DelimitedFiles/">Delimited Files</a></li><li><a class="toctext" href="../Distributed/">Distributed Computing</a></li><li><a class="toctext" href="../FileWatching/">File Events</a></li><li><a class="toctext" href="../InteractiveUtils/">Interactive Utilities</a></li><li><a class="toctext" href="../LibGit2/">LibGit2</a></li><li><a class="toctext" href="../Libdl/">Dynamic Linker</a></li><li class="current"><a class="toctext" href>Linear Algebra</a><ul class="internal"><li><a class="toctext" href="#Special-matrices-1">Special matrices</a></li><li><a class="toctext" href="#man-linalg-factorizations-1">Matrix factorizations</a></li><li><a class="toctext" href="#Standard-Functions-1">Standard Functions</a></li><li><a class="toctext" href="#Low-level-matrix-operations-1">Low-level matrix operations</a></li><li><a class="toctext" href="#BLAS-Functions-1">BLAS Functions</a></li><li><a class="toctext" href="#LAPACK-Functions-1">LAPACK Functions</a></li></ul></li><li><a class="toctext" href="../Logging/">Logging</a></li><li><a class="toctext" href="../Markdown/">Markdown</a></li><li><a class="toctext" href="../Mmap/">Memory-mapped I/O</a></li><li><a class="toctext" href="../Pkg/">Pkg</a></li><li><a class="toctext" href="../Printf/">Printf</a></li><li><a class="toctext" href="../Profile/">Profiling</a></li><li><a class="toctext" href="../REPL/">The Julia REPL</a></li><li><a class="toctext" href="../Random/">Random Numbers</a></li><li><a class="toctext" href="../SHA/">SHA</a></li><li><a class="toctext" href="../Serialization/">Serialization</a></li><li><a class="toctext" href="../SharedArrays/">Shared Arrays</a></li><li><a class="toctext" href="../Sockets/">Sockets</a></li><li><a class="toctext" href="../SparseArrays/">Sparse Arrays</a></li><li><a class="toctext" href="../Statistics/">Statistics</a></li><li><a class="toctext" href="../Test/">Unit Testing</a></li><li><a class="toctext" href="../UUIDs/">UUIDs</a></li><li><a class="toctext" href="../Unicode/">Unicode</a></li></ul></li><li><span class="toctext">Developer Documentation</span><ul><li><a class="toctext" href="../../devdocs/reflection/">Reflection and introspection</a></li><li><span class="toctext">Documentation of Julia&#39;s Internals</span><ul><li><a class="toctext" href="../../devdocs/init/">Initialization of the Julia runtime</a></li><li><a class="toctext" href="../../devdocs/ast/">Julia ASTs</a></li><li><a class="toctext" href="../../devdocs/types/">More about types</a></li><li><a class="toctext" href="../../devdocs/object/">Memory layout of Julia Objects</a></li><li><a class="toctext" href="../../devdocs/eval/">Eval of Julia code</a></li><li><a class="toctext" href="../../devdocs/callconv/">Calling Conventions</a></li><li><a class="toctext" href="../../devdocs/compiler/">High-level Overview of the Native-Code Generation Process</a></li><li><a class="toctext" href="../../devdocs/functions/">Julia Functions</a></li><li><a class="toctext" href="../../devdocs/cartesian/">Base.Cartesian</a></li><li><a class="toctext" href="../../devdocs/meta/">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="../../devdocs/subarrays/">SubArrays</a></li><li><a class="toctext" href="../../devdocs/isbitsunionarrays/">isbits Union Optimizations</a></li><li><a class="toctext" href="../../devdocs/sysimg/">System Image Building</a></li><li><a class="toctext" href="../../devdocs/llvm/">Working with LLVM</a></li><li><a class="toctext" href="../../devdocs/stdio/">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="../../devdocs/boundscheck/">Bounds checking</a></li><li><a class="toctext" href="../../devdocs/locks/">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="../../devdocs/offset-arrays/">Arrays with custom indices</a></li><li><a class="toctext" href="../../devdocs/require/">Module loading</a></li><li><a class="toctext" href="../../devdocs/inference/">Inference</a></li></ul></li><li><span class="toctext">Developing/debugging Julia&#39;s C code</span><ul><li><a class="toctext" href="../../devdocs/backtraces/">Reporting and analyzing crashes (segfaults)</a></li><li><a class="toctext" href="../../devdocs/debuggingtips/">gdb debugging tips</a></li><li><a class="toctext" href="../../devdocs/valgrind/">Using Valgrind with Julia</a></li><li><a class="toctext" href="../../devdocs/sanitizers/">Sanitizer support</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Standard Library</li><li><a href>Linear Algebra</a></li></ul><a class="edit-page" href="https://github.com/JuliaLang/julia/blob/master/stdlib/LinearAlgebra/docs/src/index.md"><span class="fa">ï</span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Linear Algebra</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Linear-Algebra-1" href="#Linear-Algebra-1">Linear Algebra</a></h1><p>In addition to (and as part of) its support for multi-dimensional arrays, Julia provides native implementations of many common and useful linear algebra operations. Basic operations, such as <a href="#LinearAlgebra.tr"><code>tr</code></a>, <a href="#LinearAlgebra.det"><code>det</code></a>, and <a href="../../base/math/#Base.inv-Tuple{Number}"><code>inv</code></a> are all supported:</p><pre><code class="language-julia-repl">julia&gt; A = [1 2 3; 4 1 6; 7 8 1]
3Ã3 Array{Int64,2}:
 1  2  3
 4  1  6
 7  8  1

julia&gt; tr(A)
3

julia&gt; det(A)
104.0

julia&gt; inv(A)
3Ã3 Array{Float64,2}:
 -0.451923   0.211538    0.0865385
  0.365385  -0.192308    0.0576923
  0.240385   0.0576923  -0.0673077</code></pre><p>As well as other useful operations, such as finding eigenvalues or eigenvectors:</p><pre><code class="language-julia-repl">julia&gt; A = [-4. -17.; 2. 2.]
2Ã2 Array{Float64,2}:
 -4.0  -17.0
  2.0    2.0

julia&gt; eigvals(A)
2-element Array{Complex{Float64},1}:
 -1.0 + 5.0im
 -1.0 - 5.0im

julia&gt; eigvecs(A)
2Ã2 Array{Complex{Float64},2}:
  0.945905+0.0im        0.945905-0.0im
 -0.166924-0.278207im  -0.166924+0.278207im</code></pre><p>In addition, Julia provides many <a href="#man-linalg-factorizations-1">factorizations</a> which can be used to speed up problems such as linear solve or matrix exponentiation by pre-factorizing a matrix into a form more amenable (for performance or memory reasons) to the problem. See the documentation on <a href="#LinearAlgebra.factorize"><code>factorize</code></a> for more information. As an example:</p><pre><code class="language-julia-repl">julia&gt; A = [1.5 2 -4; 3 -1 -6; -10 2.3 4]
3Ã3 Array{Float64,2}:
   1.5   2.0  -4.0
   3.0  -1.0  -6.0
 -10.0   2.3   4.0

julia&gt; factorize(A)
LU{Float64,Array{Float64,2}}
L factor:
3Ã3 Array{Float64,2}:
  1.0    0.0       0.0
 -0.15   1.0       0.0
 -0.3   -0.132196  1.0
U factor:
3Ã3 Array{Float64,2}:
 -10.0  2.3     4.0
   0.0  2.345  -3.4
   0.0  0.0    -5.24947</code></pre><p>Since <code>A</code> is not Hermitian, symmetric, triangular, tridiagonal, or bidiagonal, an LU factorization may be the best we can do. Compare with:</p><pre><code class="language-julia-repl">julia&gt; B = [1.5 2 -4; 2 -1 -3; -4 -3 5]
3Ã3 Array{Float64,2}:
  1.5   2.0  -4.0
  2.0  -1.0  -3.0
 -4.0  -3.0   5.0

julia&gt; factorize(B)
BunchKaufman{Float64,Array{Float64,2}}
D factor:
3Ã3 Tridiagonal{Float64,Array{Float64,1}}:
 -1.64286   0.0   â
  0.0      -2.8  0.0
   â        0.0  5.0
U factor:
3Ã3 UnitUpperTriangular{Float64,Array{Float64,2}}:
 1.0  0.142857  -0.8
  â   1.0       -0.6
  â    â         1.0
permutation:
3-element Array{Int64,1}:
 1
 2
 3</code></pre><p>Here, Julia was able to detect that <code>B</code> is in fact symmetric, and used a more appropriate factorization. Often it&#39;s possible to write more efficient code for a matrix that is known to have certain properties e.g. it is symmetric, or tridiagonal. Julia provides some special types so that you can &quot;tag&quot; matrices as having these properties. For instance:</p><pre><code class="language-julia-repl">julia&gt; B = [1.5 2 -4; 2 -1 -3; -4 -3 5]
3Ã3 Array{Float64,2}:
  1.5   2.0  -4.0
  2.0  -1.0  -3.0
 -4.0  -3.0   5.0

julia&gt; sB = Symmetric(B)
3Ã3 Symmetric{Float64,Array{Float64,2}}:
  1.5   2.0  -4.0
  2.0  -1.0  -3.0
 -4.0  -3.0   5.0</code></pre><p><code>sB</code> has been tagged as a matrix that&#39;s (real) symmetric, so for later operations we might perform on it, such as eigenfactorization or computing matrix-vector products, efficiencies can be found by only referencing half of it. For example:</p><pre><code class="language-julia-repl">julia&gt; B = [1.5 2 -4; 2 -1 -3; -4 -3 5]
3Ã3 Array{Float64,2}:
  1.5   2.0  -4.0
  2.0  -1.0  -3.0
 -4.0  -3.0   5.0

julia&gt; sB = Symmetric(B)
3Ã3 Symmetric{Float64,Array{Float64,2}}:
  1.5   2.0  -4.0
  2.0  -1.0  -3.0
 -4.0  -3.0   5.0

julia&gt; x = [1; 2; 3]
3-element Array{Int64,1}:
 1
 2
 3

julia&gt; sB\x
3-element Array{Float64,1}:
 -1.7391304347826084
 -1.1086956521739126
 -1.4565217391304346</code></pre><p>The <code>\</code> operation here performs the linear solution. The left-division operator is pretty powerful and it&#39;s easy to write compact, readable code that is flexible enough to solve all sorts of systems of linear equations.</p><h2><a class="nav-anchor" id="Special-matrices-1" href="#Special-matrices-1">Special matrices</a></h2><p><a href="http://www2.imm.dtu.dk/pubdb/views/publication_details.php?id=3274">Matrices with special symmetries and structures</a> arise often in linear algebra and are frequently associated with various matrix factorizations. Julia features a rich collection of special matrix types, which allow for fast computation with specialized routines that are specially developed for particular matrix types.</p><p>The following tables summarize the types of special matrices that have been implemented in Julia, as well as whether hooks to various optimized methods for them in LAPACK are available.</p><table><tr><th>Type</th><th>Description</th></tr><tr><td><a href="#LinearAlgebra.Symmetric"><code>Symmetric</code></a></td><td><a href="https://en.wikipedia.org/wiki/Symmetric_matrix">Symmetric matrix</a></td></tr><tr><td><a href="#LinearAlgebra.Hermitian"><code>Hermitian</code></a></td><td><a href="https://en.wikipedia.org/wiki/Hermitian_matrix">Hermitian matrix</a></td></tr><tr><td><a href="#LinearAlgebra.UpperTriangular"><code>UpperTriangular</code></a></td><td>Upper <a href="https://en.wikipedia.org/wiki/Triangular_matrix">triangular matrix</a></td></tr><tr><td><a href="#LinearAlgebra.LowerTriangular"><code>LowerTriangular</code></a></td><td>Lower <a href="https://en.wikipedia.org/wiki/Triangular_matrix">triangular matrix</a></td></tr><tr><td><a href="#LinearAlgebra.Tridiagonal"><code>Tridiagonal</code></a></td><td><a href="https://en.wikipedia.org/wiki/Tridiagonal_matrix">Tridiagonal matrix</a></td></tr><tr><td><a href="#LinearAlgebra.SymTridiagonal"><code>SymTridiagonal</code></a></td><td>Symmetric tridiagonal matrix</td></tr><tr><td><a href="#LinearAlgebra.Bidiagonal"><code>Bidiagonal</code></a></td><td>Upper/lower <a href="https://en.wikipedia.org/wiki/Bidiagonal_matrix">bidiagonal matrix</a></td></tr><tr><td><a href="#LinearAlgebra.Diagonal"><code>Diagonal</code></a></td><td><a href="https://en.wikipedia.org/wiki/Diagonal_matrix">Diagonal matrix</a></td></tr><tr><td><a href="#LinearAlgebra.UniformScaling"><code>UniformScaling</code></a></td><td><a href="https://en.wikipedia.org/wiki/Uniform_scaling">Uniform scaling operator</a></td></tr></table><h3><a class="nav-anchor" id="Elementary-operations-1" href="#Elementary-operations-1">Elementary operations</a></h3><table><tr><th>Matrix type</th><th><code>+</code></th><th><code>-</code></th><th><code>*</code></th><th><code>\</code></th><th>Other functions with optimized methods</th></tr><tr><td><a href="#LinearAlgebra.Symmetric"><code>Symmetric</code></a></td><td></td><td></td><td></td><td>MV</td><td><a href="../../base/math/#Base.inv-Tuple{Number}"><code>inv</code></a>, <a href="../../base/math/#Base.sqrt-Tuple{Real}"><code>sqrt</code></a>, <a href="../../base/math/#Base.exp-Tuple{Float64}"><code>exp</code></a></td></tr><tr><td><a href="#LinearAlgebra.Hermitian"><code>Hermitian</code></a></td><td></td><td></td><td></td><td>MV</td><td><a href="../../base/math/#Base.inv-Tuple{Number}"><code>inv</code></a>, <a href="../../base/math/#Base.sqrt-Tuple{Real}"><code>sqrt</code></a>, <a href="../../base/math/#Base.exp-Tuple{Float64}"><code>exp</code></a></td></tr><tr><td><a href="#LinearAlgebra.UpperTriangular"><code>UpperTriangular</code></a></td><td></td><td></td><td>MV</td><td>MV</td><td><a href="../../base/math/#Base.inv-Tuple{Number}"><code>inv</code></a>, <a href="#LinearAlgebra.det"><code>det</code></a></td></tr><tr><td><a href="#LinearAlgebra.LowerTriangular"><code>LowerTriangular</code></a></td><td></td><td></td><td>MV</td><td>MV</td><td><a href="../../base/math/#Base.inv-Tuple{Number}"><code>inv</code></a>, <a href="#LinearAlgebra.det"><code>det</code></a></td></tr><tr><td><a href="#LinearAlgebra.SymTridiagonal"><code>SymTridiagonal</code></a></td><td>M</td><td>M</td><td>MS</td><td>MV</td><td><a href="#LinearAlgebra.eigmax"><code>eigmax</code></a>, <a href="#LinearAlgebra.eigmin"><code>eigmin</code></a></td></tr><tr><td><a href="#LinearAlgebra.Tridiagonal"><code>Tridiagonal</code></a></td><td>M</td><td>M</td><td>MS</td><td>MV</td><td></td></tr><tr><td><a href="#LinearAlgebra.Bidiagonal"><code>Bidiagonal</code></a></td><td>M</td><td>M</td><td>MS</td><td>MV</td><td></td></tr><tr><td><a href="#LinearAlgebra.Diagonal"><code>Diagonal</code></a></td><td>M</td><td>M</td><td>MV</td><td>MV</td><td><a href="../../base/math/#Base.inv-Tuple{Number}"><code>inv</code></a>, <a href="#LinearAlgebra.det"><code>det</code></a>, <a href="#LinearAlgebra.logdet"><code>logdet</code></a>, <a href="../../base/math/#Base.:/"><code>/</code></a></td></tr><tr><td><a href="#LinearAlgebra.UniformScaling"><code>UniformScaling</code></a></td><td>M</td><td>M</td><td>MVS</td><td>MVS</td><td><a href="../../base/math/#Base.:/"><code>/</code></a></td></tr></table><p>Legend:</p><table><tr><th>Key</th><th>Description</th></tr><tr><td>M (matrix)</td><td>An optimized method for matrix-matrix operations is available</td></tr><tr><td>V (vector)</td><td>An optimized method for matrix-vector operations is available</td></tr><tr><td>S (scalar)</td><td>An optimized method for matrix-scalar operations is available</td></tr></table><h3><a class="nav-anchor" id="Matrix-factorizations-1" href="#Matrix-factorizations-1">Matrix factorizations</a></h3><table><tr><th>Matrix type</th><th>LAPACK</th><th><a href="#LinearAlgebra.eigen"><code>eigen</code></a></th><th><a href="#LinearAlgebra.eigvals"><code>eigvals</code></a></th><th><a href="#LinearAlgebra.eigvecs"><code>eigvecs</code></a></th><th><a href="#LinearAlgebra.svd"><code>svd</code></a></th><th><a href="#LinearAlgebra.svdvals"><code>svdvals</code></a></th></tr><tr><td><a href="#LinearAlgebra.Symmetric"><code>Symmetric</code></a></td><td>SY</td><td></td><td>ARI</td><td></td><td></td><td></td></tr><tr><td><a href="#LinearAlgebra.Hermitian"><code>Hermitian</code></a></td><td>HE</td><td></td><td>ARI</td><td></td><td></td><td></td></tr><tr><td><a href="#LinearAlgebra.UpperTriangular"><code>UpperTriangular</code></a></td><td>TR</td><td>A</td><td>A</td><td>A</td><td></td><td></td></tr><tr><td><a href="#LinearAlgebra.LowerTriangular"><code>LowerTriangular</code></a></td><td>TR</td><td>A</td><td>A</td><td>A</td><td></td><td></td></tr><tr><td><a href="#LinearAlgebra.SymTridiagonal"><code>SymTridiagonal</code></a></td><td>ST</td><td>A</td><td>ARI</td><td>AV</td><td></td><td></td></tr><tr><td><a href="#LinearAlgebra.Tridiagonal"><code>Tridiagonal</code></a></td><td>GT</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td><a href="#LinearAlgebra.Bidiagonal"><code>Bidiagonal</code></a></td><td>BD</td><td></td><td></td><td></td><td>A</td><td>A</td></tr><tr><td><a href="#LinearAlgebra.Diagonal"><code>Diagonal</code></a></td><td>DI</td><td></td><td>A</td><td></td><td></td><td></td></tr></table><p>Legend:</p><table><tr><th>Key</th><th>Description</th><th>Example</th></tr><tr><td>A (all)</td><td>An optimized method to find all the characteristic values and/or vectors is available</td><td>e.g. <code>eigvals(M)</code></td></tr><tr><td>R (range)</td><td>An optimized method to find the <code>il</code>th through the <code>ih</code>th characteristic values are available</td><td><code>eigvals(M, il, ih)</code></td></tr><tr><td>I (interval)</td><td>An optimized method to find the characteristic values in the interval [<code>vl</code>, <code>vh</code>] is available</td><td><code>eigvals(M, vl, vh)</code></td></tr><tr><td>V (vectors)</td><td>An optimized method to find the characteristic vectors corresponding to the characteristic values <code>x=[x1, x2,...]</code> is available</td><td><code>eigvecs(M, x)</code></td></tr></table><h3><a class="nav-anchor" id="The-uniform-scaling-operator-1" href="#The-uniform-scaling-operator-1">The uniform scaling operator</a></h3><p>A <a href="#LinearAlgebra.UniformScaling"><code>UniformScaling</code></a> operator represents a scalar times the identity operator, <code>Î»*I</code>. The identity operator <code>I</code> is defined as a constant and is an instance of <code>UniformScaling</code>. The size of these operators are generic and match the other matrix in the binary operations <a href="../../base/math/#Base.:+"><code>+</code></a>, <a href="../../base/math/#Base.:--Tuple{Any}"><code>-</code></a>, <a href="../../base/strings/#Base.:*-Tuple{Union{AbstractChar, AbstractString},Vararg{Union{AbstractChar, AbstractString},N} where N}"><code>*</code></a> and <a href="../../base/math/#Base.:\\-Tuple{Any,Any}"><code>\</code></a>. For <code>A+I</code> and <code>A-I</code> this means that <code>A</code> must be square. Multiplication with the identity operator <code>I</code> is a noop (except for checking that the scaling factor is one) and therefore almost without overhead.</p><p>To see the <code>UniformScaling</code> operator in action:</p><pre><code class="language-julia-repl">julia&gt; U = UniformScaling(2);

julia&gt; a = [1 2; 3 4]
2Ã2 Array{Int64,2}:
 1  2
 3  4

julia&gt; a + U
2Ã2 Array{Int64,2}:
 3  2
 3  6

julia&gt; a * U
2Ã2 Array{Int64,2}:
 2  4
 6  8

julia&gt; [a U]
2Ã4 Array{Int64,2}:
 1  2  2  0
 3  4  0  2

julia&gt; b = [1 2 3; 4 5 6]
2Ã3 Array{Int64,2}:
 1  2  3
 4  5  6

julia&gt; b - U
ERROR: DimensionMismatch(&quot;matrix is not square: dimensions are (2, 3)&quot;)
Stacktrace:
[...]</code></pre><h2><a class="nav-anchor" id="man-linalg-factorizations-1" href="#man-linalg-factorizations-1">Matrix factorizations</a></h2><p><a href="https://en.wikipedia.org/wiki/Matrix_decomposition">Matrix factorizations (a.k.a. matrix decompositions)</a> compute the factorization of a matrix into a product of matrices, and are one of the central concepts in linear algebra.</p><p>The following table summarizes the types of matrix factorizations that have been implemented in Julia. Details of their associated methods can be found in the <a href="#Standard-Functions-1">Standard Functions</a> section of the Linear Algebra documentation.</p><table><tr><th>Type</th><th>Description</th></tr><tr><td><code>Cholesky</code></td><td><a href="https://en.wikipedia.org/wiki/Cholesky_decomposition">Cholesky factorization</a></td></tr><tr><td><code>CholeskyPivoted</code></td><td><a href="https://en.wikipedia.org/wiki/Pivot_element">Pivoted</a> Cholesky factorization</td></tr><tr><td><code>LU</code></td><td><a href="https://en.wikipedia.org/wiki/LU_decomposition">LU factorization</a></td></tr><tr><td><code>LUTridiagonal</code></td><td>LU factorization for <a href="#LinearAlgebra.Tridiagonal"><code>Tridiagonal</code></a> matrices</td></tr><tr><td><code>QR</code></td><td><a href="https://en.wikipedia.org/wiki/QR_decomposition">QR factorization</a></td></tr><tr><td><code>QRCompactWY</code></td><td>Compact WY form of the QR factorization</td></tr><tr><td><code>QRPivoted</code></td><td>Pivoted <a href="https://en.wikipedia.org/wiki/QR_decomposition">QR factorization</a></td></tr><tr><td><code>Hessenberg</code></td><td><a href="http://mathworld.wolfram.com/HessenbergDecomposition.html">Hessenberg decomposition</a></td></tr><tr><td><code>Eigen</code></td><td><a href="https://en.wikipedia.org/wiki/Eigendecomposition_(matrix)">Spectral decomposition</a></td></tr><tr><td><code>SVD</code></td><td><a href="https://en.wikipedia.org/wiki/Singular_value_decomposition">Singular value decomposition</a></td></tr><tr><td><code>GeneralizedSVD</code></td><td><a href="https://en.wikipedia.org/wiki/Generalized_singular_value_decomposition#Higher_order_version">Generalized SVD</a></td></tr></table><h2><a class="nav-anchor" id="Standard-Functions-1" href="#Standard-Functions-1">Standard Functions</a></h2><p>Linear algebra functions in Julia are largely implemented by calling functions from <a href="http://www.netlib.org/lapack/">LAPACK</a>.  Sparse factorizations call functions from <a href="http://faculty.cse.tamu.edu/davis/suitesparse.html">SuiteSparse</a>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:*-Tuple{AbstractArray{T,2} where T,AbstractArray{T,2} where T}" href="#Base.:*-Tuple{AbstractArray{T,2} where T,AbstractArray{T,2} where T}"><code>Base.:*</code></a> â <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">*(A::AbstractMatrix, B::AbstractMatrix)</code></pre><p>Matrix multiplication.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; [1 1; 0 1] * [1 0; 1 1]
2Ã2 Array{Int64,2}:
 2  1
 1  1</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/matmul.jl#L126-L138">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:\\-Tuple{AbstractArray{T,2} where T,Union{AbstractArray{T,1}, AbstractArray{T,2}} where T}" href="#Base.:\\-Tuple{AbstractArray{T,2} where T,Union{AbstractArray{T,1}, AbstractArray{T,2}} where T}"><code>Base.:\</code></a> â <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">\(A, B)</code></pre><p>Matrix division using a polyalgorithm. For input matrices <code>A</code> and <code>B</code>, the result <code>X</code> is such that <code>A*X == B</code> when <code>A</code> is square. The solver that is used depends upon the structure of <code>A</code>.  If <code>A</code> is upper or lower triangular (or diagonal), no factorization of <code>A</code> is required and the system is solved with either forward or backward substitution. For non-triangular square matrices, an LU factorization is used.</p><p>For rectangular <code>A</code> the result is the minimum-norm least squares solution computed by a pivoted QR factorization of <code>A</code> and a rank estimate of <code>A</code> based on the R factor.</p><p>When <code>A</code> is sparse, a similar polyalgorithm is used. For indefinite matrices, the <code>LDLt</code> factorization does not use pivoting during the numerical factorization and therefore the procedure can fail even for invertible matrices.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1 0; 1 -2]; B = [32; -4];

julia&gt; X = A \ B
2-element Array{Float64,1}:
 32.0
 18.0

julia&gt; A * X == B
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/generic.jl#L827-L855">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.dot" href="#LinearAlgebra.dot"><code>LinearAlgebra.dot</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">dot(x, y)
x â y</code></pre><p>For any iterable containers <code>x</code> and <code>y</code> (including arrays of any dimension) of numbers (or any element type for which <code>dot</code> is defined), compute the dot product (or inner product or scalar product), i.e. the sum of <code>dot(x[i],y[i])</code>, as if they were vectors.</p><p><code>x â y</code> (where <code>â</code> can be typed by tab-completing <code>\cdot</code> in the REPL) is a synonym for <code>dot(x, y)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; dot(1:5, 2:6)
70

julia&gt; x = fill(2., (5,5));

julia&gt; y = fill(3., (5,5));

julia&gt; dot(x, y)
150.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/generic.jl#L627-L650">source</a><div><div><pre><code class="language-none">dot(x, y)
x â y</code></pre><p>Compute the dot product between two vectors. For complex vectors, the first vector is conjugated. When the vectors have equal lengths, calling <code>dot</code> is semantically equivalent to <code>sum(dot(vx,vy) for (vx,vy) in zip(x, y))</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; dot([1; 1], [2; 3])
5

julia&gt; dot([im; im], [1; 1])
0 - 2im</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/generic.jl#L682-L698">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.cross" href="#LinearAlgebra.cross"><code>LinearAlgebra.cross</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">cross(x, y)
Ã(x,y)</code></pre><p>Compute the cross product of two 3-vectors.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = [0;1;0]
3-element Array{Int64,1}:
 0
 1
 0

julia&gt; b = [0;0;1]
3-element Array{Int64,1}:
 0
 0
 1

julia&gt; cross(a,b)
3-element Array{Int64,1}:
 1
 0
 0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/generic.jl#L85-L111">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.factorize" href="#LinearAlgebra.factorize"><code>LinearAlgebra.factorize</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">factorize(A)</code></pre><p>Compute a convenient factorization of <code>A</code>, based upon the type of the input matrix. <code>factorize</code> checks <code>A</code> to see if it is symmetric/triangular/etc. if <code>A</code> is passed as a generic matrix. <code>factorize</code> checks every element of <code>A</code> to verify/rule out each property. It will short-circuit as soon as it can rule out symmetry/triangular structure. The return value can be reused for efficient solving of multiple systems. For example: <code>A=factorize(A); x=A\b; y=A\C</code>.</p><table><tr><th>Properties of <code>A</code></th><th>type of factorization</th></tr><tr><td>Positive-definite</td><td>Cholesky (see <a href="#LinearAlgebra.cholesky"><code>cholesky</code></a>)</td></tr><tr><td>Dense Symmetric/Hermitian</td><td>Bunch-Kaufman (see <a href="#LinearAlgebra.bunchkaufman"><code>bunchkaufman</code></a>)</td></tr><tr><td>Sparse Symmetric/Hermitian</td><td>LDLt (see <a href="#LinearAlgebra.ldlt"><code>ldlt</code></a>)</td></tr><tr><td>Triangular</td><td>Triangular</td></tr><tr><td>Diagonal</td><td>Diagonal</td></tr><tr><td>Bidiagonal</td><td>Bidiagonal</td></tr><tr><td>Tridiagonal</td><td>LU (see <a href="#LinearAlgebra.lu"><code>lu</code></a>)</td></tr><tr><td>Symmetric real tridiagonal</td><td>LDLt (see <a href="#LinearAlgebra.ldlt"><code>ldlt</code></a>)</td></tr><tr><td>General square</td><td>LU (see <a href="#LinearAlgebra.lu"><code>lu</code></a>)</td></tr><tr><td>General non-square</td><td>QR (see <a href="#LinearAlgebra.qr"><code>qr</code></a>)</td></tr></table><p>If <code>factorize</code> is called on a Hermitian positive-definite matrix, for instance, then <code>factorize</code> will return a Cholesky factorization.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = Array(Bidiagonal(fill(1.0, (5, 5)), :U))
5Ã5 Array{Float64,2}:
 1.0  1.0  0.0  0.0  0.0
 0.0  1.0  1.0  0.0  0.0
 0.0  0.0  1.0  1.0  0.0
 0.0  0.0  0.0  1.0  1.0
 0.0  0.0  0.0  0.0  1.0

julia&gt; factorize(A) # factorize will check to see that A is already factorized
5Ã5 Bidiagonal{Float64,Array{Float64,1}}:
 1.0  1.0   â    â    â
  â   1.0  1.0   â    â
  â    â   1.0  1.0   â
  â    â    â   1.0  1.0
  â    â    â    â   1.0</code></pre><p>This returns a <code>5Ã5 Bidiagonal{Float64}</code>, which can now be passed to other linear algebra functions (e.g. eigensolvers) which will use specialized methods for <code>Bidiagonal</code> types.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/dense.jl#L1093-L1139">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.Diagonal" href="#LinearAlgebra.Diagonal"><code>LinearAlgebra.Diagonal</code></a> â <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Diagonal(A::AbstractMatrix)</code></pre><p>Construct a matrix from the diagonal of <code>A</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1 2 3; 4 5 6; 7 8 9]
3Ã3 Array{Int64,2}:
 1  2  3
 4  5  6
 7  8  9

julia&gt; Diagonal(A)
3Ã3 Diagonal{Int64,Array{Int64,1}}:
 1  â  â
 â  5  â
 â  â  9</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/diagonal.jl#L16-L35">source</a><div><div><pre><code class="language-none">Diagonal(V::AbstractVector)</code></pre><p>Construct a matrix with <code>V</code> as its diagonal.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; V = [1, 2]
2-element Array{Int64,1}:
 1
 2

julia&gt; Diagonal(V)
2Ã2 Diagonal{Int64,Array{Int64,1}}:
 1  â
 â  2</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/diagonal.jl#L38-L55">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.Bidiagonal" href="#LinearAlgebra.Bidiagonal"><code>LinearAlgebra.Bidiagonal</code></a> â <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Bidiagonal(dv::V, ev::V, uplo::Symbol) where V &lt;: AbstractVector</code></pre><p>Constructs an upper (<code>uplo=:U</code>) or lower (<code>uplo=:L</code>) bidiagonal matrix using the given diagonal (<code>dv</code>) and off-diagonal (<code>ev</code>) vectors. The result is of type <code>Bidiagonal</code> and provides efficient specialized linear solvers, but may be converted into a regular matrix with <a href="../../base/base/#Base.convert"><code>convert(Array, _)</code></a> (or <code>Array(_)</code> for short). The length of <code>ev</code> must be one less than the length of <code>dv</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; dv = [1, 2, 3, 4]
4-element Array{Int64,1}:
 1
 2
 3
 4

julia&gt; ev = [7, 8, 9]
3-element Array{Int64,1}:
 7
 8
 9

julia&gt; Bu = Bidiagonal(dv, ev, :U) # ev is on the first superdiagonal
4Ã4 Bidiagonal{Int64,Array{Int64,1}}:
 1  7  â  â
 â  2  8  â
 â  â  3  9
 â  â  â  4

julia&gt; Bl = Bidiagonal(dv, ev, :L) # ev is on the first subdiagonal
4Ã4 Bidiagonal{Int64,Array{Int64,1}}:
 1  â  â  â
 7  2  â  â
 â  8  3  â
 â  â  9  4</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/bidiag.jl#L25-L63">source</a><div><div><pre><code class="language-none">Bidiagonal(A, uplo::Symbol)</code></pre><p>Construct a <code>Bidiagonal</code> matrix from the main diagonal of <code>A</code> and its first super- (if <code>uplo=:U</code>) or sub-diagonal (if <code>uplo=:L</code>).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1 1 1 1; 2 2 2 2; 3 3 3 3; 4 4 4 4]
4Ã4 Array{Int64,2}:
 1  1  1  1
 2  2  2  2
 3  3  3  3
 4  4  4  4

julia&gt; Bidiagonal(A, :U) # contains the main diagonal and first superdiagonal of A
4Ã4 Bidiagonal{Int64,Array{Int64,1}}:
 1  1  â  â
 â  2  2  â
 â  â  3  3
 â  â  â  4

julia&gt; Bidiagonal(A, :L) # contains the main diagonal and first subdiagonal of A
4Ã4 Bidiagonal{Int64,Array{Int64,1}}:
 1  â  â  â
 2  2  â  â
 â  3  3  â
 â  â  4  4</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/bidiag.jl#L71-L100">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.SymTridiagonal" href="#LinearAlgebra.SymTridiagonal"><code>LinearAlgebra.SymTridiagonal</code></a> â <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">SymTridiagonal(dv::V, ev::V) where V &lt;: AbstractVector</code></pre><p>Construct a symmetric tridiagonal matrix from the diagonal (<code>dv</code>) and first sub/super-diagonal (<code>ev</code>), respectively. The result is of type <code>SymTridiagonal</code> and provides efficient specialized eigensolvers, but may be converted into a regular matrix with <a href="../../base/base/#Base.convert"><code>convert(Array, _)</code></a> (or <code>Array(_)</code> for short).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; dv = [1, 2, 3, 4]
4-element Array{Int64,1}:
 1
 2
 3
 4

julia&gt; ev = [7, 8, 9]
3-element Array{Int64,1}:
 7
 8
 9

julia&gt; SymTridiagonal(dv, ev)
4Ã4 SymTridiagonal{Int64,Array{Int64,1}}:
 1  7  â  â
 7  2  8  â
 â  8  3  9
 â  â  9  4</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/tridiag.jl#L18-L48">source</a><div><div><pre><code class="language-none">SymTridiagonal(A::AbstractMatrix)</code></pre><p>Construct a symmetric tridiagonal matrix from the diagonal and first sub/super-diagonal, of the symmetric matrix <code>A</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1 2 3; 2 4 5; 3 5 6]
3Ã3 Array{Int64,2}:
 1  2  3
 2  4  5
 3  5  6

julia&gt; SymTridiagonal(A)
3Ã3 SymTridiagonal{Int64,Array{Int64,1}}:
 1  2  â
 2  4  5
 â  5  6</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/tridiag.jl#L56-L76">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.Tridiagonal" href="#LinearAlgebra.Tridiagonal"><code>LinearAlgebra.Tridiagonal</code></a> â <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Tridiagonal(dl::V, d::V, du::V) where V &lt;: AbstractVector</code></pre><p>Construct a tridiagonal matrix from the first subdiagonal, diagonal, and first superdiagonal, respectively. The result is of type <code>Tridiagonal</code> and provides efficient specialized linear solvers, but may be converted into a regular matrix with <a href="../../base/base/#Base.convert"><code>convert(Array, _)</code></a> (or <code>Array(_)</code> for short). The lengths of <code>dl</code> and <code>du</code> must be one less than the length of <code>d</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; dl = [1, 2, 3];

julia&gt; du = [4, 5, 6];

julia&gt; d = [7, 8, 9, 0];

julia&gt; Tridiagonal(dl, d, du)
4Ã4 Tridiagonal{Int64,Array{Int64,1}}:
 7  4  â  â
 1  8  5  â
 â  2  9  6
 â  â  3  0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/tridiag.jl#L427-L451">source</a><div><div><pre><code class="language-none">Tridiagonal(A)</code></pre><p>Construct a tridiagonal matrix from the first sub-diagonal, diagonal and first super-diagonal of the matrix <code>A</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1 2 3 4; 1 2 3 4; 1 2 3 4; 1 2 3 4]
4Ã4 Array{Int64,2}:
 1  2  3  4
 1  2  3  4
 1  2  3  4
 1  2  3  4

julia&gt; Tridiagonal(A)
4Ã4 Tridiagonal{Int64,Array{Int64,1}}:
 1  2  â  â
 1  2  3  â
 â  2  3  4
 â  â  3  4</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/tridiag.jl#L458-L480">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.Symmetric" href="#LinearAlgebra.Symmetric"><code>LinearAlgebra.Symmetric</code></a> â <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Symmetric(A, uplo=:U)</code></pre><p>Construct a <code>Symmetric</code> view of the upper (if <code>uplo = :U</code>) or lower (if <code>uplo = :L</code>) triangle of the matrix <code>A</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1 0 2 0 3; 0 4 0 5 0; 6 0 7 0 8; 0 9 0 1 0; 2 0 3 0 4]
5Ã5 Array{Int64,2}:
 1  0  2  0  3
 0  4  0  5  0
 6  0  7  0  8
 0  9  0  1  0
 2  0  3  0  4

julia&gt; Supper = Symmetric(A)
5Ã5 Symmetric{Int64,Array{Int64,2}}:
 1  0  2  0  3
 0  4  0  5  0
 2  0  7  0  8
 0  5  0  1  0
 3  0  8  0  4

julia&gt; Slower = Symmetric(A, :L)
5Ã5 Symmetric{Int64,Array{Int64,2}}:
 1  0  6  0  2
 0  4  0  9  0
 6  0  7  0  3
 0  9  0  1  0
 2  0  3  0  4</code></pre><p>Note that <code>Supper</code> will not be equal to <code>Slower</code> unless <code>A</code> is itself symmetric (e.g. if <code>A == transpose(A)</code>).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/symmetric.jl#L13-L47">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.Hermitian" href="#LinearAlgebra.Hermitian"><code>LinearAlgebra.Hermitian</code></a> â <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Hermitian(A, uplo=:U)</code></pre><p>Construct a <code>Hermitian</code> view of the upper (if <code>uplo = :U</code>) or lower (if <code>uplo = :L</code>) triangle of the matrix <code>A</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1 0 2+2im 0 3-3im; 0 4 0 5 0; 6-6im 0 7 0 8+8im; 0 9 0 1 0; 2+2im 0 3-3im 0 4];

julia&gt; Hupper = Hermitian(A)
5Ã5 Hermitian{Complex{Int64},Array{Complex{Int64},2}}:
 1+0im  0+0im  2+2im  0+0im  3-3im
 0+0im  4+0im  0+0im  5+0im  0+0im
 2-2im  0+0im  7+0im  0+0im  8+8im
 0+0im  5+0im  0+0im  1+0im  0+0im
 3+3im  0+0im  8-8im  0+0im  4+0im

julia&gt; Hlower = Hermitian(A, :L)
5Ã5 Hermitian{Complex{Int64},Array{Complex{Int64},2}}:
 1+0im  0+0im  6+6im  0+0im  2-2im
 0+0im  4+0im  0+0im  9+0im  0+0im
 6-6im  0+0im  7+0im  0+0im  3+3im
 0+0im  9+0im  0+0im  1+0im  0+0im
 2+2im  0+0im  3-3im  0+0im  4+0im</code></pre><p>Note that <code>Hupper</code> will not be equal to <code>Hlower</code> unless <code>A</code> is itself Hermitian (e.g. if <code>A == adjoint(A)</code>).</p><p>All non-real parts of the diagonal will be ignored.</p><pre><code class="language-julia">Hermitian(fill(complex(1,1), 1, 1)) == fill(1, 1, 1)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/symmetric.jl#L88-L122">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.LowerTriangular" href="#LinearAlgebra.LowerTriangular"><code>LinearAlgebra.LowerTriangular</code></a> â <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">LowerTriangular(A::AbstractMatrix)</code></pre><p>Construct a <code>LowerTriangular</code> view of the the matrix <code>A</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1.0 2.0 3.0; 4.0 5.0 6.0; 7.0 8.0 9.0]
3Ã3 Array{Float64,2}:
 1.0  2.0  3.0
 4.0  5.0  6.0
 7.0  8.0  9.0

julia&gt; LowerTriangular(A)
3Ã3 LowerTriangular{Float64,Array{Float64,2}}:
 1.0   â    â
 4.0  5.0   â
 7.0  8.0  9.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/triangular.jl#L58-L77">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.UpperTriangular" href="#LinearAlgebra.UpperTriangular"><code>LinearAlgebra.UpperTriangular</code></a> â <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">UpperTriangular(A::AbstractMatrix)</code></pre><p>Construct an <code>UpperTriangular</code> view of the the matrix <code>A</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1.0 2.0 3.0; 4.0 5.0 6.0; 7.0 8.0 9.0]
3Ã3 Array{Float64,2}:
 1.0  2.0  3.0
 4.0  5.0  6.0
 7.0  8.0  9.0

julia&gt; UpperTriangular(A)
3Ã3 UpperTriangular{Float64,Array{Float64,2}}:
 1.0  2.0  3.0
  â   5.0  6.0
  â    â   9.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/triangular.jl#L79-L98">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.UniformScaling" href="#LinearAlgebra.UniformScaling"><code>LinearAlgebra.UniformScaling</code></a> â <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">UniformScaling{T&lt;:Number}</code></pre><p>Generically sized uniform scaling operator defined as a scalar times the identity operator, <code>Î»*I</code>. See also <a href="#LinearAlgebra.I"><code>I</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; J = UniformScaling(2.)
UniformScaling{Float64}
2.0*I

julia&gt; A = [1. 2.; 3. 4.]
2Ã2 Array{Float64,2}:
 1.0  2.0
 3.0  4.0

julia&gt; J*A
2Ã2 Array{Float64,2}:
 2.0  4.0
 6.0  8.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/uniformscaling.jl#L6-L28">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.lu" href="#LinearAlgebra.lu"><code>LinearAlgebra.lu</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">lu(A, pivot=Val(true); check = true) -&gt; F::LU</code></pre><p>Compute the LU factorization of <code>A</code>.</p><p>When <code>check = true</code>, an error is thrown if the decomposition fails. When <code>check = false</code>, responsibility for checking the decomposition&#39;s validity (via <a href="#LinearAlgebra.issuccess"><code>issuccess</code></a>) lies with the user.</p><p>In most cases, if <code>A</code> is a subtype <code>S</code> of <code>AbstractMatrix{T}</code> with an element type <code>T</code> supporting <code>+</code>, <code>-</code>, <code>*</code> and <code>/</code>, the return type is <code>LU{T,S{T}}</code>. If pivoting is chosen (default) the element type should also support <code>abs</code> and <code>&lt;</code>.</p><p>The individual components of the factorization <code>F</code> can be accessed via <code>getproperty</code>:</p><table><tr><th>Component</th><th>Description</th></tr><tr><td><code>F.L</code></td><td><code>L</code> (lower triangular) part of <code>LU</code></td></tr><tr><td><code>F.U</code></td><td><code>U</code> (upper triangular) part of <code>LU</code></td></tr><tr><td><code>F.p</code></td><td>(right) permutation <code>Vector</code></td></tr><tr><td><code>F.P</code></td><td>(right) permutation <code>Matrix</code></td></tr></table><p>Iterating the factorization produces the components <code>F.L</code>, <code>F.U</code>, and <code>F.p</code>.</p><p>The relationship between <code>F</code> and <code>A</code> is</p><p><code>F.L*F.U == A[F.p, :]</code></p><p><code>F</code> further supports the following functions:</p><table><tr><th>Supported function</th><th><code>LU</code></th><th><code>LU{T,Tridiagonal{T}}</code></th></tr><tr><td><a href="../../base/math/#Base.:/"><code>/</code></a></td><td>â</td><td></td></tr><tr><td><a href="../../base/math/#Base.:\\-Tuple{Any,Any}"><code>\</code></a></td><td>â</td><td>â</td></tr><tr><td><a href="../../base/math/#Base.inv-Tuple{Number}"><code>inv</code></a></td><td>â</td><td>â</td></tr><tr><td><a href="#LinearAlgebra.det"><code>det</code></a></td><td>â</td><td>â</td></tr><tr><td><a href="#LinearAlgebra.logdet"><code>logdet</code></a></td><td>â</td><td>â</td></tr><tr><td><a href="#LinearAlgebra.logabsdet"><code>logabsdet</code></a></td><td>â</td><td>â</td></tr><tr><td><a href="../../base/arrays/#Base.size"><code>size</code></a></td><td>â</td><td>â</td></tr></table><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [4 3; 6 3]
2Ã2 Array{Int64,2}:
 4  3
 6  3

julia&gt; F = lu(A)
LU{Float64,Array{Float64,2}}
L factor:
2Ã2 Array{Float64,2}:
 1.0  0.0
 1.5  1.0
U factor:
2Ã2 Array{Float64,2}:
 4.0   3.0
 0.0  -1.5

julia&gt; F.L * F.U == A[F.p, :]
true

julia&gt; l, u, p = lu(A); # destructuring via iteration

julia&gt; l == F.L &amp;&amp; u == F.U &amp;&amp; p == F.p
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lu.jl#L165-L232">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.lu!" href="#LinearAlgebra.lu!"><code>LinearAlgebra.lu!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">lu!(A, pivot=Val(true); check = true) -&gt; LU</code></pre><p><code>lu!</code> is the same as <a href="#LinearAlgebra.lu"><code>lu</code></a>, but saves space by overwriting the input <code>A</code>, instead of creating a copy. An <a href="../../base/base/#Core.InexactError"><code>InexactError</code></a> exception is thrown if the factorization produces a number not representable by the element type of <code>A</code>, e.g. for integer types.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [4. 3.; 6. 3.]
2Ã2 Array{Float64,2}:
 4.0  3.0
 6.0  3.0

julia&gt; F = lu!(A)
LU{Float64,Array{Float64,2}}
L factor:
2Ã2 Array{Float64,2}:
 1.0       0.0
 0.666667  1.0
U factor:
2Ã2 Array{Float64,2}:
 6.0  3.0
 0.0  1.0

julia&gt; iA = [4 3; 6 3]
2Ã2 Array{Int64,2}:
 4  3
 6  3

julia&gt; lu!(iA)
ERROR: InexactError: Int64(Int64, 0.6666666666666666)
Stacktrace:
[...]</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lu.jl#L49-L85">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.cholesky" href="#LinearAlgebra.cholesky"><code>LinearAlgebra.cholesky</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">cholesky(A, Val(false); check = true) -&gt; Cholesky</code></pre><p>Compute the Cholesky factorization of a dense symmetric positive definite matrix <code>A</code> and return a <code>Cholesky</code> factorization. The matrix <code>A</code> can either be a <a href="#LinearAlgebra.Symmetric"><code>Symmetric</code></a> or <a href="#LinearAlgebra.Hermitian"><code>Hermitian</code></a> <code>StridedMatrix</code> or a <em>perfectly</em> symmetric or Hermitian <code>StridedMatrix</code>. The triangular Cholesky factor can be obtained from the factorization <code>F</code> with: <code>F.L</code> and <code>F.U</code>. The following functions are available for <code>Cholesky</code> objects: <a href="../../base/arrays/#Base.size"><code>size</code></a>, <a href="../../base/math/#Base.:\\-Tuple{Any,Any}"><code>\</code></a>, <a href="../../base/math/#Base.inv-Tuple{Number}"><code>inv</code></a>, <a href="#LinearAlgebra.det"><code>det</code></a>, <a href="#LinearAlgebra.logdet"><code>logdet</code></a> and <a href="#LinearAlgebra.isposdef"><code>isposdef</code></a>.</p><p>When <code>check = true</code>, an error is thrown if the decomposition fails. When <code>check = false</code>, responsibility for checking the decomposition&#39;s validity (via <a href="#LinearAlgebra.issuccess"><code>issuccess</code></a>) lies with the user.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [4. 12. -16.; 12. 37. -43.; -16. -43. 98.]
3Ã3 Array{Float64,2}:
   4.0   12.0  -16.0
  12.0   37.0  -43.0
 -16.0  -43.0   98.0

julia&gt; C = cholesky(A)
Cholesky{Float64,Array{Float64,2}}
U factor:
3Ã3 UpperTriangular{Float64,Array{Float64,2}}:
 2.0  6.0  -8.0
  â   1.0   5.0
  â    â    3.0

julia&gt; C.U
3Ã3 UpperTriangular{Float64,Array{Float64,2}}:
 2.0  6.0  -8.0
  â   1.0   5.0
  â    â    3.0

julia&gt; C.L
3Ã3 LowerTriangular{Float64,Array{Float64,2}}:
  2.0   â    â
  6.0  1.0   â
 -8.0  5.0  3.0

julia&gt; C.L * C.U == A
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/cholesky.jl#L228-L273">source</a><div><div><pre><code class="language-none">cholesky(A, Val(true); tol = 0.0, check = true) -&gt; CholeskyPivoted</code></pre><p>Compute the pivoted Cholesky factorization of a dense symmetric positive semi-definite matrix <code>A</code> and return a <code>CholeskyPivoted</code> factorization. The matrix <code>A</code> can either be a <a href="#LinearAlgebra.Symmetric"><code>Symmetric</code></a> or <a href="#LinearAlgebra.Hermitian"><code>Hermitian</code></a> <code>StridedMatrix</code> or a <em>perfectly</em> symmetric or Hermitian <code>StridedMatrix</code>. The triangular Cholesky factor can be obtained from the factorization <code>F</code> with: <code>F.L</code> and <code>F.U</code>. The following functions are available for <code>PivotedCholesky</code> objects: <a href="../../base/arrays/#Base.size"><code>size</code></a>, <a href="../../base/math/#Base.:\\-Tuple{Any,Any}"><code>\</code></a>, <a href="../../base/math/#Base.inv-Tuple{Number}"><code>inv</code></a>, <a href="#LinearAlgebra.det"><code>det</code></a>, and <a href="#LinearAlgebra.rank"><code>rank</code></a>. The argument <code>tol</code> determines the tolerance for determining the rank. For negative values, the tolerance is the machine precision.</p><p>When <code>check = true</code>, an error is thrown if the decomposition fails. When <code>check = false</code>, responsibility for checking the decomposition&#39;s validity (via <a href="#LinearAlgebra.issuccess"><code>issuccess</code></a>) lies with the user.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/cholesky.jl#L279-L294">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.cholesky!" href="#LinearAlgebra.cholesky!"><code>LinearAlgebra.cholesky!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">cholesky!(A, Val(false); check = true) -&gt; Cholesky</code></pre><p>The same as <a href="#LinearAlgebra.cholesky"><code>cholesky</code></a>, but saves space by overwriting the input <code>A</code>, instead of creating a copy. An <a href="../../base/base/#Core.InexactError"><code>InexactError</code></a> exception is thrown if the factorization produces a number not representable by the element type of <code>A</code>, e.g. for integer types.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1 2; 2 50]
2Ã2 Array{Int64,2}:
 1   2
 2  50

julia&gt; cholesky!(A)
ERROR: InexactError: Int64(Int64, 6.782329983125268)
Stacktrace:
[...]</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/cholesky.jl#L158-L178">source</a><div><div><pre><code class="language-none">cholesky!(A, Val(true); tol = 0.0, check = true) -&gt; CholeskyPivoted</code></pre><p>The same as <a href="#LinearAlgebra.cholesky"><code>cholesky</code></a>, but saves space by overwriting the input <code>A</code>, instead of creating a copy. An <a href="../../base/base/#Core.InexactError"><code>InexactError</code></a> exception is thrown if the factorization produces a number not representable by the element type of <code>A</code>, e.g. for integer types.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/cholesky.jl#L205-L212">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.lowrankupdate" href="#LinearAlgebra.lowrankupdate"><code>LinearAlgebra.lowrankupdate</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">lowrankupdate(C::Cholesky, v::StridedVector) -&gt; CC::Cholesky</code></pre><p>Update a Cholesky factorization <code>C</code> with the vector <code>v</code>. If <code>A = C.U&#39;C.U</code> then <code>CC = cholesky(C.U&#39;C.U + v*v&#39;)</code> but the computation of <code>CC</code> only uses <code>O(n^2)</code> operations.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/cholesky.jl#L603-L609">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.lowrankdowndate" href="#LinearAlgebra.lowrankdowndate"><code>LinearAlgebra.lowrankdowndate</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">lowrankdowndate(C::Cholesky, v::StridedVector) -&gt; CC::Cholesky</code></pre><p>Downdate a Cholesky factorization <code>C</code> with the vector <code>v</code>. If <code>A = C.U&#39;C.U</code> then <code>CC = cholesky(C.U&#39;C.U - v*v&#39;)</code> but the computation of <code>CC</code> only uses <code>O(n^2)</code> operations.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/cholesky.jl#L612-L618">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.lowrankupdate!" href="#LinearAlgebra.lowrankupdate!"><code>LinearAlgebra.lowrankupdate!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">lowrankupdate!(C::Cholesky, v::StridedVector) -&gt; CC::Cholesky</code></pre><p>Update a Cholesky factorization <code>C</code> with the vector <code>v</code>. If <code>A = C.U&#39;C.U</code> then <code>CC = cholesky(C.U&#39;C.U + v*v&#39;)</code> but the computation of <code>CC</code> only uses <code>O(n^2)</code> operations. The input factorization <code>C</code> is updated in place such that on exit <code>C == CC</code>. The vector <code>v</code> is destroyed during the computation.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/cholesky.jl#L504-L511">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.lowrankdowndate!" href="#LinearAlgebra.lowrankdowndate!"><code>LinearAlgebra.lowrankdowndate!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">lowrankdowndate!(C::Cholesky, v::StridedVector) -&gt; CC::Cholesky</code></pre><p>Downdate a Cholesky factorization <code>C</code> with the vector <code>v</code>. If <code>A = C.U&#39;C.U</code> then <code>CC = cholesky(C.U&#39;C.U - v*v&#39;)</code> but the computation of <code>CC</code> only uses <code>O(n^2)</code> operations. The input factorization <code>C</code> is updated in place such that on exit <code>C == CC</code>. The vector <code>v</code> is destroyed during the computation.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/cholesky.jl#L550-L557">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.ldlt" href="#LinearAlgebra.ldlt"><code>LinearAlgebra.ldlt</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ldlt(S::SymTridiagonal) -&gt; LDLt</code></pre><p>Compute an <code>LDLt</code> factorization of the real symmetric tridiagonal matrix <code>S</code> such that <code>S = L*Diagonal(d)*L&#39;</code> where <code>L</code> is a unit lower triangular matrix and <code>d</code> is a vector. The main use of an <code>LDLt</code> factorization <code>F = ldlt(S)</code> is to solve the linear system of equations <code>Sx = b</code> with <code>F\b</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; S = SymTridiagonal([3., 4., 5.], [1., 2.])
3Ã3 SymTridiagonal{Float64,Array{Float64,1}}:
 3.0  1.0   â
 1.0  4.0  2.0
  â   2.0  5.0

julia&gt; ldltS = ldlt(S);

julia&gt; b = [6., 7., 8.];

julia&gt; ldltS \ b
3-element Array{Float64,1}:
 1.7906976744186047
 0.627906976744186
 1.3488372093023255

julia&gt; S \ b
3-element Array{Float64,1}:
 1.7906976744186047
 0.627906976744186
 1.3488372093023255</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/ldlt.jl#L62-L93">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.ldlt!" href="#LinearAlgebra.ldlt!"><code>LinearAlgebra.ldlt!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ldlt!(S::SymTridiagonal) -&gt; LDLt</code></pre><p>Same as <a href="#LinearAlgebra.ldlt"><code>ldlt</code></a>, but saves space by overwriting the input <code>S</code>, instead of creating a copy.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; S = SymTridiagonal([3., 4., 5.], [1., 2.])
3Ã3 SymTridiagonal{Float64,Array{Float64,1}}:
 3.0  1.0   â
 1.0  4.0  2.0
  â   2.0  5.0

julia&gt; ldltS = ldlt!(S);

julia&gt; ldltS === S
false

julia&gt; S
3Ã3 SymTridiagonal{Float64,Array{Float64,1}}:
 3.0       0.333333   â
 0.333333  3.66667   0.545455
  â        0.545455  3.90909</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/ldlt.jl#L26-L50">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.qr" href="#LinearAlgebra.qr"><code>LinearAlgebra.qr</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">qr(A, pivot=Val(false)) -&gt; F</code></pre><p>Compute the QR factorization of the matrix <code>A</code>: an orthogonal (or unitary if <code>A</code> is complex-valued) matrix <code>Q</code>, and an upper triangular matrix <code>R</code> such that</p><div>\[A = Q R\]</div><p>The returned object <code>F</code> stores the factorization in a packed format:</p><ul><li><p>if <code>pivot == Val(true)</code> then <code>F</code> is a <a href="#LinearAlgebra.QRPivoted"><code>QRPivoted</code></a> object,</p></li><li><p>otherwise if the element type of <code>A</code> is a BLAS type (<a href="../../base/numbers/#Core.Float32"><code>Float32</code></a>, <a href="../../base/numbers/#Core.Float64"><code>Float64</code></a>, <code>ComplexF32</code> or <code>ComplexF64</code>), then <code>F</code> is a <a href="#LinearAlgebra.QRCompactWY"><code>QRCompactWY</code></a> object,</p></li><li><p>otherwise <code>F</code> is a <a href="#LinearAlgebra.QR"><code>QR</code></a> object.</p></li></ul><p>The individual components of the decomposition <code>F</code> can be retrieved via property accessors:</p><ul><li><code>F.Q</code>: the orthogonal/unitary matrix <code>Q</code></li><li><code>F.R</code>: the upper triangular matrix <code>R</code></li><li><code>F.p</code>: the permutation vector of the pivot (<a href="#LinearAlgebra.QRPivoted"><code>QRPivoted</code></a> only)</li><li><code>F.P</code>: the permutation matrix of the pivot (<a href="#LinearAlgebra.QRPivoted"><code>QRPivoted</code></a> only)</li></ul><p>Iterating the decomposition produces the components <code>Q</code>, <code>R</code>, and if extant <code>p</code>.</p><p>The following functions are available for the <code>QR</code> objects: <a href="../../base/math/#Base.inv-Tuple{Number}"><code>inv</code></a>, <a href="../../base/arrays/#Base.size"><code>size</code></a>, and <a href="../../base/math/#Base.:\\-Tuple{Any,Any}"><code>\</code></a>. When <code>A</code> is rectangular, <code>\</code> will return a least squares solution and if the solution is not unique, the one with smallest norm is returned.</p><p>Multiplication with respect to either full/square or non-full/square <code>Q</code> is allowed, i.e. both <code>F.Q*F.R</code> and <code>F.Q*A</code> are supported. A <code>Q</code> matrix can be converted into a regular matrix with <a href="../../base/arrays/#Base.Matrix"><code>Matrix</code></a>.  This operation returns the &quot;thin&quot; Q factor, i.e., if <code>A</code> is <code>m</code>Ã<code>n</code> with <code>m&gt;=n</code>, then <code>Matrix(F.Q)</code> yields an <code>m</code>Ã<code>n</code> matrix with orthonormal columns.  To retrieve the &quot;full&quot; Q factor, an <code>m</code>Ã<code>m</code> orthogonal matrix, use <code>F.Q*Matrix(I,m,m)</code>.  If <code>m&lt;=n</code>, then <code>Matrix(F.Q)</code> yields an <code>m</code>Ã<code>m</code> orthogonal matrix.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [3.0 -6.0; 4.0 -8.0; 0.0 1.0]
3Ã2 Array{Float64,2}:
 3.0  -6.0
 4.0  -8.0
 0.0   1.0

julia&gt; F = qr(A)
LinearAlgebra.QRCompactWY{Float64,Array{Float64,2}}
Q factor:
3Ã3 LinearAlgebra.QRCompactWYQ{Float64,Array{Float64,2}}:
 -0.6   0.0   0.8
 -0.8   0.0  -0.6
  0.0  -1.0   0.0
R factor:
2Ã2 Array{Float64,2}:
 -5.0  10.0
  0.0  -1.0

julia&gt; F.Q * F.R == A
true</code></pre><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p><code>qr</code> returns multiple types because LAPACK uses several representations that minimize the memory storage requirements of products of Householder elementary reflectors, so that the <code>Q</code> and <code>R</code> matrices can be stored compactly rather as two separate dense matrices.</p></div></div></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/qr.jl#L291-L359">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.qr!" href="#LinearAlgebra.qr!"><code>LinearAlgebra.qr!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">qr!(A, pivot=Val(false))</code></pre><p><code>qr!</code> is the same as <a href="#LinearAlgebra.qr"><code>qr</code></a> when <code>A</code> is a subtype of <code>StridedMatrix</code>, but saves space by overwriting the input <code>A</code>, instead of creating a copy. An <a href="../../base/base/#Core.InexactError"><code>InexactError</code></a> exception is thrown if the factorization produces a number not representable by the element type of <code>A</code>, e.g. for integer types.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = [1. 2.; 3. 4.]
2Ã2 Array{Float64,2}:
 1.0  2.0
 3.0  4.0

julia&gt; qr!(a)
LinearAlgebra.QRCompactWY{Float64,Array{Float64,2}}
Q factor:
2Ã2 LinearAlgebra.QRCompactWYQ{Float64,Array{Float64,2}}:
 -0.316228  -0.948683
 -0.948683   0.316228
R factor:
2Ã2 Array{Float64,2}:
 -3.16228  -4.42719
  0.0      -0.632456

julia&gt; a = [1 2; 3 4]
2Ã2 Array{Int64,2}:
 1  2
 3  4

julia&gt; qr!(a)
ERROR: InexactError: Int64(Int64, -3.1622776601683795)
Stacktrace:
[...]</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/qr.jl#L248-L284">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.QR" href="#LinearAlgebra.QR"><code>LinearAlgebra.QR</code></a> â <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">QR &lt;: Factorization</code></pre><p>A QR matrix factorization stored in a packed format, typically obtained from <a href="#LinearAlgebra.qr"><code>qr</code></a>. If <span>$A$</span> is an <code>m</code>Ã<code>n</code> matrix, then</p><div>\[A = Q R\]</div><p>where <span>$Q$</span> is an orthogonal/unitary matrix and <span>$R$</span> is upper triangular. The matrix <span>$Q$</span> is stored as a sequence of Householder reflectors <span>$v_i$</span> and coefficients <span>$\tau_i$</span> where:</p><div>\[Q = \prod_{i=1}^{\min(m,n)} (I - \tau_i v_i v_i^T).\]</div><p>Iterating the decomposition produces the components <code>Q</code> and <code>R</code>.</p><p>The object has two fields:</p><ul><li><p><code>factors</code> is an <code>m</code>Ã<code>n</code> matrix.</p><ul><li><p>The upper triangular part contains the elements of <span>$R$</span>, that is <code>R = triu(F.factors)</code> for a <code>QR</code> object <code>F</code>.</p></li><li><p>The subdiagonal part contains the reflectors <span>$v_i$</span> stored in a packed format where <span>$v_i$</span> is the <span>$i$</span>th column of the matrix <code>V = I + tril(F.factors, -1)</code>.</p></li></ul></li><li><p><code>Ï</code> is a vector  of length <code>min(m,n)</code> containing the coefficients <span>$au_i$</span>.</p></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/qr.jl#L4-L36">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.QRCompactWY" href="#LinearAlgebra.QRCompactWY"><code>LinearAlgebra.QRCompactWY</code></a> â <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">QRCompactWY &lt;: Factorization</code></pre><p>A QR matrix factorization stored in a compact blocked format, typically obtained from <a href="#LinearAlgebra.qr"><code>qr</code></a>. If <span>$A$</span> is an <code>m</code>Ã<code>n</code> matrix, then</p><div>\[A = Q R\]</div><p>where <span>$Q$</span> is an orthogonal/unitary matrix and <span>$R$</span> is upper triangular. It is similar to the <a href="#LinearAlgebra.QR"><code>QR</code></a> format except that the orthogonal/unitary matrix <span>$Q$</span> is stored in <em>Compact WY</em> format <a href="#footnote-Schreiber1989">[Schreiber1989]</a>, as a lower trapezoidal matrix <span>$V$</span> and an upper triangular matrix <span>$T$</span> where</p><div>\[Q = \prod_{i=1}^{\min(m,n)} (I - \tau_i v_i v_i^T) = I - V T V^T\]</div><p>such that <span>$v_i$</span> is the <span>$i$</span>th column of <span>$V$</span>, and <span>$au_i$</span> is the <span>$i$</span>th diagonal element of <span>$T$</span>.</p><p>Iterating the decomposition produces the components <code>Q</code> and <code>R</code>.</p><p>The object has two fields:</p><ul><li><p><code>factors</code>, as in the <a href="#LinearAlgebra.QR"><code>QR</code></a> type, is an <code>m</code>Ã<code>n</code> matrix.</p><ul><li><p>The upper triangular part contains the elements of <span>$R$</span>, that is <code>R = triu(F.factors)</code> for a <code>QR</code> object <code>F</code>.</p></li><li><p>The subdiagonal part contains the reflectors <span>$v_i$</span> stored in a packed format such that <code>V = I + tril(F.factors, -1)</code>.</p></li></ul></li><li><p><code>T</code> is a square matrix with <code>min(m,n)</code> columns, whose upper triangular part gives the matrix <span>$T$</span> above (the subdiagonal elements are ignored).</p></li></ul><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>This format should not to be confused with the older <em>WY</em> representation <a href="#footnote-Bischof1987">[Bischof1987]</a>.</p></div></div><div class="footnote" id="footnote-Bischof1987"><a href="#footnote-Bischof1987"><strong>[Bischof1987]</strong></a><p>C Bischof and C Van Loan, &quot;The WY representation for products of Householder matrices&quot;, SIAM J Sci Stat Comput 8 (1987), s2-s13. <a href="https://doi.org/10.1137/0908009">doi:10.1137/0908009</a></p></div><div class="footnote" id="footnote-Schreiber1989"><a href="#footnote-Schreiber1989"><strong>[Schreiber1989]</strong></a><p>R Schreiber and C Van Loan, &quot;A storage-efficient WY representation for products of Householder transformations&quot;, SIAM J Sci Stat Comput 10 (1989), 53-57. <a href="https://doi.org/10.1137/0910005">doi:10.1137/0910005</a></p></div></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/qr.jl#L57-L103">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.QRPivoted" href="#LinearAlgebra.QRPivoted"><code>LinearAlgebra.QRPivoted</code></a> â <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">QRPivoted &lt;: Factorization</code></pre><p>A QR matrix factorization with column pivoting in a packed format, typically obtained from <a href="#LinearAlgebra.qr"><code>qr</code></a>. If <span>$A$</span> is an <code>m</code>Ã<code>n</code> matrix, then</p><div>\[A P = Q R\]</div><p>where <span>$P$</span> is a permutation matrix, <span>$Q$</span> is an orthogonal/unitary matrix and <span>$R$</span> is upper triangular. The matrix <span>$Q$</span> is stored as a sequence of Householder reflectors:</p><div>\[Q = \prod_{i=1}^{\min(m,n)} (I - \tau_i v_i v_i^T).\]</div><p>Iterating the decomposition produces the components <code>Q</code>, <code>R</code>, and <code>p</code>.</p><p>The object has three fields:</p><ul><li><p><code>factors</code> is an <code>m</code>Ã<code>n</code> matrix.</p><ul><li><p>The upper triangular part contains the elements of <span>$R$</span>, that is <code>R = triu(F.factors)</code> for a <code>QR</code> object <code>F</code>.</p></li><li><p>The subdiagonal part contains the reflectors <span>$v_i$</span> stored in a packed format where <span>$v_i$</span> is the <span>$i$</span>th column of the matrix <code>V = I + tril(F.factors, -1)</code>.</p></li></ul></li><li><p><code>Ï</code> is a vector of length <code>min(m,n)</code> containing the coefficients <span>$au_i$</span>.</p></li><li><p><code>jpvt</code> is an integer vector of length <code>n</code> corresponding to the permutation <span>$P$</span>.</p></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/qr.jl#L123-L155">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.lq!" href="#LinearAlgebra.lq!"><code>LinearAlgebra.lq!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">lq!(A) -&gt; LQ</code></pre><p>Compute the LQ factorization of <code>A</code>, using the input matrix as a workspace. See also <a href="#LinearAlgebra.lq"><code>lq</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lq.jl#L32-L37">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.lq" href="#LinearAlgebra.lq"><code>LinearAlgebra.lq</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">lq(A) -&gt; S::LQ</code></pre><p>Compute the LQ decomposition of <code>A</code>. The decomposition&#39;s lower triangular component can be obtained from the <code>LQ</code> object <code>S</code> via <code>S.L</code>, and the orthogonal/unitary component via <code>S.Q</code>, such that <code>A â S.L*S.Q</code>.</p><p>Iterating the decomposition produces the components <code>S.L</code> and <code>S.Q</code>.</p><p>The LQ decomposition is the QR decomposition of <code>transpose(A)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [5. 7.; -2. -4.]
2Ã2 Array{Float64,2}:
  5.0   7.0
 -2.0  -4.0

julia&gt; S = lq(A)
LQ{Float64,Array{Float64,2}} with factors L and Q:
[-8.60233 0.0; 4.41741 -0.697486]
[-0.581238 -0.813733; -0.813733 0.581238]

julia&gt; S.L * S.Q
2Ã2 Array{Float64,2}:
  5.0   7.0
 -2.0  -4.0

julia&gt; l, q = S; # destructuring via iteration

julia&gt; l == S.L &amp;&amp;  q == S.Q
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lq.jl#L39-L72">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.bunchkaufman" href="#LinearAlgebra.bunchkaufman"><code>LinearAlgebra.bunchkaufman</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">bunchkaufman(A, rook::Bool=false; check = true) -&gt; S::BunchKaufman</code></pre><p>Compute the Bunch-Kaufman <a href="#footnote-Bunch1977">[Bunch1977]</a> factorization of a <code>Symmetric</code> or <code>Hermitian</code> matrix <code>A</code> as <span>$P&#39;*U*D*U&#39;*P$</span> or <span>$P&#39;*L*D*L&#39;*P$</span>, depending on which triangle is stored in <code>A</code>, and return a <code>BunchKaufman</code> object. Note that if <code>A</code> is complex symmetric then <code>U&#39;</code> and <code>L&#39;</code> denote the unconjugated transposes, i.e. <code>transpose(U)</code> and <code>transpose(L)</code>.</p><p>Iterating the decomposition produces the components <code>S.D</code>, <code>S.U</code> or <code>S.L</code> as appropriate given <code>S.uplo</code>, and <code>S.p</code>.</p><p>If <code>rook</code> is <code>true</code>, rook pivoting is used. If <code>rook</code> is false, rook pivoting is not used.</p><p>When <code>check = true</code>, an error is thrown if the decomposition fails. When <code>check = false</code>, responsibility for checking the decomposition&#39;s validity (via <a href="#LinearAlgebra.issuccess"><code>issuccess</code></a>) lies with the user.</p><p>The following functions are available for <code>BunchKaufman</code> objects: <a href="../../base/arrays/#Base.size"><code>size</code></a>, <code>\</code>, <a href="../../base/math/#Base.inv-Tuple{Number}"><code>inv</code></a>, <a href="#LinearAlgebra.issymmetric"><code>issymmetric</code></a>, <a href="#LinearAlgebra.ishermitian"><code>ishermitian</code></a>, <a href="../../base/collections/#Base.getindex"><code>getindex</code></a>.</p><div class="footnote" id="footnote-Bunch1977"><a href="#footnote-Bunch1977"><strong>[Bunch1977]</strong></a><p>J R Bunch and L Kaufman, Some stable methods for calculating inertia</p></div><p>and solving symmetric linear systems, Mathematics of Computation 31:137 (1977), 163-179. <a href="http://www.ams.org/journals/mcom/1977-31-137/S0025-5718-1977-0428694-0/">url</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1 2; 2 3]
2Ã2 Array{Int64,2}:
 1  2
 2  3

julia&gt; S = bunchkaufman(A)
BunchKaufman{Float64,Array{Float64,2}}
D factor:
2Ã2 Tridiagonal{Float64,Array{Float64,1}}:
 -0.333333  0.0
  0.0       3.0
U factor:
2Ã2 UnitUpperTriangular{Float64,Array{Float64,2}}:
 1.0  0.666667
  â   1.0
permutation:
2-element Array{Int64,1}:
 1
 2

julia&gt; d, u, p = S; # destructuring via iteration

julia&gt; d == S.D &amp;&amp; u == S.U &amp;&amp; p == S.p
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/bunchkaufman.jl#L59-L113">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.bunchkaufman!" href="#LinearAlgebra.bunchkaufman!"><code>LinearAlgebra.bunchkaufman!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">bunchkaufman!(A, rook::Bool=false; check = true) -&gt; BunchKaufman</code></pre><p><code>bunchkaufman!</code> is the same as <a href="#LinearAlgebra.bunchkaufman"><code>bunchkaufman</code></a>, but saves space by overwriting the input <code>A</code>, instead of creating a copy.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/bunchkaufman.jl#L31-L36">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.eigvals" href="#LinearAlgebra.eigvals"><code>LinearAlgebra.eigvals</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">eigvals(A; permute::Bool=true, scale::Bool=true) -&gt; values</code></pre><p>Return the eigenvalues of <code>A</code>.</p><p>For general non-symmetric matrices it is possible to specify how the matrix is balanced before the eigenvalue calculation. The option <code>permute=true</code> permutes the matrix to become closer to upper triangular, and <code>scale=true</code> scales the matrix by its diagonal elements to make rows and columns more equal in norm. The default is <code>true</code> for both options.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; diag_matrix = [1 0; 0 4]
2Ã2 Array{Int64,2}:
 1  0
 0  4

julia&gt; eigvals(diag_matrix)
2-element Array{Float64,1}:
 1.0
 4.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/eigen.jl#L187-L210">source</a><div><div><p>For a scalar input, <code>eigvals</code> will return a scalar.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; eigvals(-2)
-2</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/eigen.jl#L214-L222">source</a><div><div><pre><code class="language-none">eigvals(A, B) -&gt; values</code></pre><p>Computes the generalized eigenvalues of <code>A</code> and <code>B</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1 0; 0 -1]
2Ã2 Array{Int64,2}:
 1   0
 0  -1

julia&gt; B = [0 1; 1 0]
2Ã2 Array{Int64,2}:
 0  1
 1  0

julia&gt; eigvals(A,B)
2-element Array{Complex{Float64},1}:
 0.0 + 1.0im
 0.0 - 1.0im</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/eigen.jl#L437-L459">source</a><div><div><pre><code class="language-none">eigvals(A::Union{SymTridiagonal, Hermitian, Symmetric}, irange::UnitRange) -&gt; values</code></pre><p>Returns the eigenvalues of <code>A</code>. It is possible to calculate only a subset of the eigenvalues by specifying a <code>UnitRange</code> <code>irange</code> covering indices of the sorted eigenvalues, e.g. the 2nd to 8th eigenvalues.</p><pre><code class="language-julia-repl">julia&gt; A = SymTridiagonal([1.; 2.; 1.], [2.; 3.])
3Ã3 SymTridiagonal{Float64,Array{Float64,1}}:
 1.0  2.0   â
 2.0  2.0  3.0
  â   3.0  1.0

julia&gt; eigvals(A, 2:2)
1-element Array{Float64,1}:
 0.9999999999999996

julia&gt; eigvals(A)
3-element Array{Float64,1}:
 -2.1400549446402604
  1.0000000000000002
  5.140054944640259</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/symmetric.jl#L564-L588">source</a><div><div><pre><code class="language-none">eigvals(A::Union{SymTridiagonal, Hermitian, Symmetric}, vl::Real, vu::Real) -&gt; values</code></pre><p>Returns the eigenvalues of <code>A</code>. It is possible to calculate only a subset of the eigenvalues by specifying a pair <code>vl</code> and <code>vu</code> for the lower and upper boundaries of the eigenvalues.</p><pre><code class="language-julia-repl">julia&gt; A = SymTridiagonal([1.; 2.; 1.], [2.; 3.])
3Ã3 SymTridiagonal{Float64,Array{Float64,1}}:
 1.0  2.0   â
 2.0  2.0  3.0
  â   3.0  1.0

julia&gt; eigvals(A, -1, 2)
1-element Array{Float64,1}:
 1.0000000000000009

julia&gt; eigvals(A)
3-element Array{Float64,1}:
 -2.1400549446402604
  1.0000000000000002
  5.140054944640259</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/symmetric.jl#L604-L627">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.eigvals!" href="#LinearAlgebra.eigvals!"><code>LinearAlgebra.eigvals!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">eigvals!(A; permute::Bool=true, scale::Bool=true) -&gt; values</code></pre><p>Same as <a href="#LinearAlgebra.eigvals"><code>eigvals</code></a>, but saves space by overwriting the input <code>A</code>, instead of creating a copy. The option <code>permute=true</code> permutes the matrix to become closer to upper triangular, and <code>scale=true</code> scales the matrix by its diagonal elements to make rows and columns more equal in norm.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>The input matrix <code>A</code> will not contain its eigenvalues after <code>eigvals!</code> is called on it - <code>A</code> is used as a workspace.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1. 2.; 3. 4.]
2Ã2 Array{Float64,2}:
 1.0  2.0
 3.0  4.0

julia&gt; eigvals!(A)
2-element Array{Float64,1}:
 -0.3722813232690143
  5.372281323269014

julia&gt; A
2Ã2 Array{Float64,2}:
 -0.372281  -1.0
  0.0        5.37228</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/eigen.jl#L144-L173">source</a><div><div><pre><code class="language-none">eigvals!(A, B) -&gt; values</code></pre><p>Same as <a href="#LinearAlgebra.eigvals"><code>eigvals</code></a>, but saves space by overwriting the input <code>A</code> (and <code>B</code>), instead of creating copies.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>The input matrices <code>A</code> and <code>B</code> will not contain their eigenvalues after <code>eigvals!</code> is called. They are used as workspaces.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1. 0.; 0. -1.]
2Ã2 Array{Float64,2}:
 1.0   0.0
 0.0  -1.0

julia&gt; B = [0. 1.; 1. 0.]
2Ã2 Array{Float64,2}:
 0.0  1.0
 1.0  0.0

julia&gt; eigvals!(A, B)
2-element Array{Complex{Float64},1}:
 0.0 + 1.0im
 0.0 - 1.0im

julia&gt; A
2Ã2 Array{Float64,2}:
 -0.0  -1.0
  1.0  -0.0

julia&gt; B
2Ã2 Array{Float64,2}:
 1.0  0.0
 0.0  1.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/eigen.jl#L388-L425">source</a><div><div><pre><code class="language-none">eigvals!(A::Union{SymTridiagonal, Hermitian, Symmetric}, irange::UnitRange) -&gt; values</code></pre><p>Same as <a href="#LinearAlgebra.eigvals"><code>eigvals</code></a>, but saves space by overwriting the input <code>A</code>, instead of creating a copy. <code>irange</code> is a range of eigenvalue <em>indices</em> to search for - for instance, the 2nd to 8th eigenvalues.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/symmetric.jl#L555-L560">source</a><div><div><pre><code class="language-none">eigvals!(A::Union{SymTridiagonal, Hermitian, Symmetric}, vl::Real, vu::Real) -&gt; values</code></pre><p>Same as <a href="#LinearAlgebra.eigvals"><code>eigvals</code></a>, but saves space by overwriting the input <code>A</code>, instead of creating a copy. <code>vl</code> is the lower bound of the interval to search for eigenvalues, and <code>vu</code> is the upper bound.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/symmetric.jl#L595-L600">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.eigmax" href="#LinearAlgebra.eigmax"><code>LinearAlgebra.eigmax</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">eigmax(A; permute::Bool=true, scale::Bool=true)</code></pre><p>Return the largest eigenvalue of <code>A</code>. The option <code>permute=true</code> permutes the matrix to become closer to upper triangular, and <code>scale=true</code> scales the matrix by its diagonal elements to make rows and columns more equal in norm. Note that if the eigenvalues of <code>A</code> are complex, this method will fail, since complex numbers cannot be sorted.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [0 im; -im 0]
2Ã2 Array{Complex{Int64},2}:
 0+0im  0+1im
 0-1im  0+0im

julia&gt; eigmax(A)
1.0

julia&gt; A = [0 im; -1 0]
2Ã2 Array{Complex{Int64},2}:
  0+0im  0+1im
 -1+0im  0+0im

julia&gt; eigmax(A)
ERROR: DomainError with Complex{Int64}[0+0im 0+1im; -1+0im 0+0im]:
`A` cannot have complex eigenvalues.
Stacktrace:
[...]</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/eigen.jl#L225-L257">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.eigmin" href="#LinearAlgebra.eigmin"><code>LinearAlgebra.eigmin</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">eigmin(A; permute::Bool=true, scale::Bool=true)</code></pre><p>Return the smallest eigenvalue of <code>A</code>. The option <code>permute=true</code> permutes the matrix to become closer to upper triangular, and <code>scale=true</code> scales the matrix by its diagonal elements to make rows and columns more equal in norm. Note that if the eigenvalues of <code>A</code> are complex, this method will fail, since complex numbers cannot be sorted.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [0 im; -im 0]
2Ã2 Array{Complex{Int64},2}:
 0+0im  0+1im
 0-1im  0+0im

julia&gt; eigmin(A)
-1.0

julia&gt; A = [0 im; -1 0]
2Ã2 Array{Complex{Int64},2}:
  0+0im  0+1im
 -1+0im  0+0im

julia&gt; eigmin(A)
ERROR: DomainError with Complex{Int64}[0+0im 0+1im; -1+0im 0+0im]:
`A` cannot have complex eigenvalues.
Stacktrace:
[...]</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/eigen.jl#L266-L298">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.eigvecs" href="#LinearAlgebra.eigvecs"><code>LinearAlgebra.eigvecs</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">eigvecs(A::SymTridiagonal[, eigvals]) -&gt; Matrix</code></pre><p>Return a matrix <code>M</code> whose columns are the eigenvectors of <code>A</code>. (The <code>k</code>th eigenvector can be obtained from the slice <code>M[:, k]</code>.)</p><p>If the optional vector of eigenvalues <code>eigvals</code> is specified, <code>eigvecs</code> returns the specific corresponding eigenvectors.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = SymTridiagonal([1.; 2.; 1.], [2.; 3.])
3Ã3 SymTridiagonal{Float64,Array{Float64,1}}:
 1.0  2.0   â
 2.0  2.0  3.0
  â   3.0  1.0

julia&gt; eigvals(A)
3-element Array{Float64,1}:
 -2.1400549446402604
  1.0000000000000002
  5.140054944640259

julia&gt; eigvecs(A)
3Ã3 Array{Float64,2}:
  0.418304  -0.83205      0.364299
 -0.656749  -7.39009e-16  0.754109
  0.627457   0.5547       0.546448

julia&gt; eigvecs(A, [1.])
3Ã1 Array{Float64,2}:
  0.8320502943378438
  4.263514128092366e-17
 -0.5547001962252291</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/tridiag.jl#L233-L268">source</a><div><div><pre><code class="language-none">eigvecs(A; permute::Bool=true, scale::Bool=true) -&gt; Matrix</code></pre><p>Return a matrix <code>M</code> whose columns are the eigenvectors of <code>A</code>. (The <code>k</code>th eigenvector can be obtained from the slice <code>M[:, k]</code>.) The <code>permute</code> and <code>scale</code> keywords are the same as for <a href="#LinearAlgebra.eigen"><code>eigen</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; eigvecs([1.0 0.0 0.0; 0.0 3.0 0.0; 0.0 0.0 18.0])
3Ã3 Array{Float64,2}:
 1.0  0.0  0.0
 0.0  1.0  0.0
 0.0  0.0  1.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/eigen.jl#L122-L137">source</a><div><div><pre><code class="language-none">eigvecs(A, B) -&gt; Matrix</code></pre><p>Return a matrix <code>M</code> whose columns are the generalized eigenvectors of <code>A</code> and <code>B</code>. (The <code>k</code>th eigenvector can be obtained from the slice <code>M[:, k]</code>.)</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1 0; 0 -1]
2Ã2 Array{Int64,2}:
 1   0
 0  -1

julia&gt; B = [0 1; 1 0]
2Ã2 Array{Int64,2}:
 0  1
 1  0

julia&gt; eigvecs(A, B)
2Ã2 Array{Complex{Float64},2}:
  0.0-1.0im   0.0+1.0im
 -1.0-0.0im  -1.0+0.0im</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/eigen.jl#L465-L488">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.eigen" href="#LinearAlgebra.eigen"><code>LinearAlgebra.eigen</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">eigen(A; permute::Bool=true, scale::Bool=true) -&gt; Eigen</code></pre><p>Computes the eigenvalue decomposition of <code>A</code>, returning an <code>Eigen</code> factorization object <code>F</code> which contains the eigenvalues in <code>F.values</code> and the eigenvectors in the columns of the matrix <code>F.vectors</code>. (The <code>k</code>th eigenvector can be obtained from the slice <code>F.vectors[:, k]</code>.)</p><p>Iterating the decomposition produces the components <code>F.values</code> and <code>F.vectors</code>.</p><p>The following functions are available for <code>Eigen</code> objects: <a href="../../base/math/#Base.inv-Tuple{Number}"><code>inv</code></a>, <a href="#LinearAlgebra.det"><code>det</code></a>, and <a href="#LinearAlgebra.isposdef"><code>isposdef</code></a>.</p><p>For general nonsymmetric matrices it is possible to specify how the matrix is balanced before the eigenvector calculation. The option <code>permute=true</code> permutes the matrix to become closer to upper triangular, and <code>scale=true</code> scales the matrix by its diagonal elements to make rows and columns more equal in norm. The default is <code>true</code> for both options.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; F = eigen([1.0 0.0 0.0; 0.0 3.0 0.0; 0.0 0.0 18.0])
Eigen{Float64,Float64,Array{Float64,2},Array{Float64,1}}
eigenvalues:
3-element Array{Float64,1}:
  1.0
  3.0
 18.0
eigenvectors:
3Ã3 Array{Float64,2}:
 1.0  0.0  0.0
 0.0  1.0  0.0
 0.0  0.0  1.0

julia&gt; F.values
3-element Array{Float64,1}:
  1.0
  3.0
 18.0

julia&gt; F.vectors
3Ã3 Array{Float64,2}:
 1.0  0.0  0.0
 0.0  1.0  0.0
 0.0  0.0  1.0

julia&gt; vals, vecs = F; # destructuring via iteration

julia&gt; vals == F.values &amp;&amp; vecs == F.vectors
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/eigen.jl#L66-L114">source</a><div><div><pre><code class="language-none">eigen(A, B) -&gt; GeneralizedEigen</code></pre><p>Computes the generalized eigenvalue decomposition of <code>A</code> and <code>B</code>, returning a <code>GeneralizedEigen</code> factorization object <code>F</code> which contains the generalized eigenvalues in <code>F.values</code> and the generalized eigenvectors in the columns of the matrix <code>F.vectors</code>. (The <code>k</code>th generalized eigenvector can be obtained from the slice <code>F.vectors[:, k]</code>.)</p><p>Iterating the decomposition produces the components <code>F.values</code> and <code>F.vectors</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1 0; 0 -1]
2Ã2 Array{Int64,2}:
 1   0
 0  -1

julia&gt; B = [0 1; 1 0]
2Ã2 Array{Int64,2}:
 0  1
 1  0

julia&gt; F = eigen(A, B);

julia&gt; F.values
2-element Array{Complex{Float64},1}:
 0.0 + 1.0im
 0.0 - 1.0im

julia&gt; F.vectors
2Ã2 Array{Complex{Float64},2}:
  0.0-1.0im   0.0+1.0im
 -1.0-0.0im  -1.0+0.0im

julia&gt; vals, vecs = F; # destructuring via iteration

julia&gt; vals == F.values &amp;&amp; vecs == F.vectors
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/eigen.jl#L341-L380">source</a><div><div><pre><code class="language-none">eigen(A::Union{SymTridiagonal, Hermitian, Symmetric}, irange::UnitRange) -&gt; Eigen</code></pre><p>Computes the eigenvalue decomposition of <code>A</code>, returning an <code>Eigen</code> factorization object <code>F</code> which contains the eigenvalues in <code>F.values</code> and the eigenvectors in the columns of the matrix <code>F.vectors</code>. (The <code>k</code>th eigenvector can be obtained from the slice <code>F.vectors[:, k]</code>.)</p><p>Iterating the decomposition produces the components <code>F.values</code> and <code>F.vectors</code>.</p><p>The following functions are available for <code>Eigen</code> objects: <a href="../../base/math/#Base.inv-Tuple{Number}"><code>inv</code></a>, <a href="#LinearAlgebra.det"><code>det</code></a>, and <a href="#LinearAlgebra.isposdef"><code>isposdef</code></a>.</p><p>The <code>UnitRange</code> <code>irange</code> specifies indices of the sorted eigenvalues to search for.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>If <code>irange</code> is not <code>1:n</code>, where <code>n</code> is the dimension of <code>A</code>, then the returned factorization will be a <em>truncated</em> factorization.</p></div></div></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/symmetric.jl#L497-L513">source</a><div><div><pre><code class="language-none">eigen(A::Union{SymTridiagonal, Hermitian, Symmetric}, vl::Real, vu::Real) -&gt; Eigen</code></pre><p>Computes the eigenvalue decomposition of <code>A</code>, returning an <code>Eigen</code> factorization object <code>F</code> which contains the eigenvalues in <code>F.values</code> and the eigenvectors in the columns of the matrix <code>F.vectors</code>. (The <code>k</code>th eigenvector can be obtained from the slice <code>F.vectors[:, k]</code>.)</p><p>Iterating the decomposition produces the components <code>F.values</code> and <code>F.vectors</code>.</p><p>The following functions are available for <code>Eigen</code> objects: <a href="../../base/math/#Base.inv-Tuple{Number}"><code>inv</code></a>, <a href="#LinearAlgebra.det"><code>det</code></a>, and <a href="#LinearAlgebra.isposdef"><code>isposdef</code></a>.</p><p><code>vl</code> is the lower bound of the window of eigenvalues to search for, and <code>vu</code> is the upper bound.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>If [<code>vl</code>, <code>vu</code>] does not contain all eigenvalues of <code>A</code>, then the returned factorization will be a <em>truncated</em> factorization.</p></div></div></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/symmetric.jl#L523-L539">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.eigen!" href="#LinearAlgebra.eigen!"><code>LinearAlgebra.eigen!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">eigen!(A, [B])</code></pre><p>Same as <a href="#LinearAlgebra.eigen"><code>eigen</code></a>, but saves space by overwriting the input <code>A</code> (and <code>B</code>), instead of creating a copy.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/eigen.jl#L30-L35">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.hessenberg" href="#LinearAlgebra.hessenberg"><code>LinearAlgebra.hessenberg</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">hessenberg(A) -&gt; Hessenberg</code></pre><p>Compute the Hessenberg decomposition of <code>A</code> and return a <code>Hessenberg</code> object. If <code>F</code> is the factorization object, the unitary matrix can be accessed with <code>F.Q</code> and the Hessenberg matrix with <code>F.H</code>. When <code>Q</code> is extracted, the resulting type is the <code>HessenbergQ</code> object, and may be converted to a regular matrix with <a href="../../base/base/#Base.convert"><code>convert(Array, _)</code></a>  (or <code>Array(_)</code> for short).</p><p>Iterating the decomposition produces the factors <code>F.Q</code> and <code>F.H</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [4. 9. 7.; 4. 4. 1.; 4. 3. 2.]
3Ã3 Array{Float64,2}:
 4.0  9.0  7.0
 4.0  4.0  1.0
 4.0  3.0  2.0

julia&gt; F = hessenberg(A);

julia&gt; F.Q * F.H * F.Q&#39;
3Ã3 Array{Float64,2}:
 4.0  9.0  7.0
 4.0  4.0  1.0
 4.0  3.0  2.0

julia&gt; q, h = F; # destructuring via iteration

julia&gt; q == F.Q &amp;&amp; h == F.H
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/hessenberg.jl#L34-L66">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.hessenberg!" href="#LinearAlgebra.hessenberg!"><code>LinearAlgebra.hessenberg!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">hessenberg!(A) -&gt; Hessenberg</code></pre><p><code>hessenberg!</code> is the same as <a href="#LinearAlgebra.hessenberg"><code>hessenberg</code></a>, but saves space by overwriting the input <code>A</code>, instead of creating a copy.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/hessenberg.jl#L24-L29">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.schur!" href="#LinearAlgebra.schur!"><code>LinearAlgebra.schur!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">schur!(A::StridedMatrix) -&gt; F::Schur</code></pre><p>Same as <a href="#LinearAlgebra.schur"><code>schur</code></a> but uses the input argument <code>A</code> as workspace.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [5. 7.; -2. -4.]
2Ã2 Array{Float64,2}:
  5.0   7.0
 -2.0  -4.0

julia&gt; F = schur!(A)
Schur{Float64,Array{Float64,2}}
T factor:
2Ã2 Array{Float64,2}:
 3.0   9.0
 0.0  -2.0
Z factor:
2Ã2 Array{Float64,2}:
  0.961524  0.274721
 -0.274721  0.961524
eigenvalues:
2-element Array{Float64,1}:
  3.0
 -2.0

julia&gt; A
2Ã2 Array{Float64,2}:
 3.0   9.0
 0.0  -2.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/schur.jl#L18-L50">source</a><div><div><pre><code class="language-none">schur!(A::StridedMatrix, B::StridedMatrix) -&gt; F::GeneralizedSchur</code></pre><p>Same as <a href="#LinearAlgebra.schur"><code>schur</code></a> but uses the input matrices <code>A</code> and <code>B</code> as workspace.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/schur.jl#L184-L188">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.schur" href="#LinearAlgebra.schur"><code>LinearAlgebra.schur</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">schur(A::StridedMatrix) -&gt; F::Schur</code></pre><p>Computes the Schur factorization of the matrix <code>A</code>. The (quasi) triangular Schur factor can be obtained from the <code>Schur</code> object <code>F</code> with either <code>F.Schur</code> or <code>F.T</code> and the orthogonal/unitary Schur vectors can be obtained with <code>F.vectors</code> or <code>F.Z</code> such that <code>A = F.vectors * F.Schur * F.vectors&#39;</code>. The eigenvalues of <code>A</code> can be obtained with <code>F.values</code>.</p><p>Iterating the decomposition produces the components <code>F.T</code>, <code>F.Z</code>, and <code>F.values</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [5. 7.; -2. -4.]
2Ã2 Array{Float64,2}:
  5.0   7.0
 -2.0  -4.0

julia&gt; F = schur(A)
Schur{Float64,Array{Float64,2}}
T factor:
2Ã2 Array{Float64,2}:
 3.0   9.0
 0.0  -2.0
Z factor:
2Ã2 Array{Float64,2}:
  0.961524  0.274721
 -0.274721  0.961524
eigenvalues:
2-element Array{Float64,1}:
  3.0
 -2.0

julia&gt; F.vectors * F.Schur * F.vectors&#39;
2Ã2 Array{Float64,2}:
  5.0   7.0
 -2.0  -4.0

julia&gt; t, z, vals = F; # destructuring via iteration

julia&gt; t == F.T &amp;&amp; z == F.Z &amp;&amp; vals == F.values
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/schur.jl#L53-L95">source</a><div><div><pre><code class="language-none">schur(A::StridedMatrix, B::StridedMatrix) -&gt; F::GeneralizedSchur</code></pre><p>Computes the Generalized Schur (or QZ) factorization of the matrices <code>A</code> and <code>B</code>. The (quasi) triangular Schur factors can be obtained from the <code>Schur</code> object <code>F</code> with <code>F.S</code> and <code>F.T</code>, the left unitary/orthogonal Schur vectors can be obtained with <code>F.left</code> or <code>F.Q</code> and the right unitary/orthogonal Schur vectors can be obtained with <code>F.right</code> or <code>F.Z</code> such that <code>A=F.left*F.S*F.right&#39;</code> and <code>B=F.left*F.T*F.right&#39;</code>. The generalized eigenvalues of <code>A</code> and <code>B</code> can be obtained with <code>F.Î±./F.Î²</code>.</p><p>Iterating the decomposition produces the components <code>F.S</code>, <code>F.T</code>, <code>F.Q</code>, <code>F.Z</code>, <code>F.Î±</code>, and <code>F.Î²</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/schur.jl#L192-L204">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.ordschur" href="#LinearAlgebra.ordschur"><code>LinearAlgebra.ordschur</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ordschur(F::Schur, select::Union{Vector{Bool},BitVector}) -&gt; F::Schur</code></pre><p>Reorders the Schur factorization <code>F</code> of a matrix <code>A = Z*T*Z&#39;</code> according to the logical array <code>select</code> returning the reordered factorization <code>F</code> object. The selected eigenvalues appear in the leading diagonal of <code>F.Schur</code> and the corresponding leading columns of <code>F.vectors</code> form an orthogonal/unitary basis of the corresponding right invariant subspace. In the real case, a complex conjugate pair of eigenvalues must be either both included or both excluded via <code>select</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/schur.jl#L145-L154">source</a><div><div><pre><code class="language-none">ordschur(F::GeneralizedSchur, select::Union{Vector{Bool},BitVector}) -&gt; F::GeneralizedSchur</code></pre><p>Reorders the Generalized Schur factorization <code>F</code> of a matrix pair <code>(A, B) = (Q*S*Z&#39;, Q*T*Z&#39;)</code> according to the logical array <code>select</code> and returns a GeneralizedSchur object <code>F</code>. The selected eigenvalues appear in the leading diagonal of both <code>F.S</code> and <code>F.T</code>, and the left and right orthogonal/unitary Schur vectors are also reordered such that <code>(A, B) = F.Q*(F.S, F.T)*F.Z&#39;</code> still holds and the generalized eigenvalues of <code>A</code> and <code>B</code> can still be obtained with <code>F.Î±./F.Î²</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/schur.jl#L231-L240">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.ordschur!" href="#LinearAlgebra.ordschur!"><code>LinearAlgebra.ordschur!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ordschur!(F::Schur, select::Union{Vector{Bool},BitVector}) -&gt; F::Schur</code></pre><p>Same as <a href="#LinearAlgebra.ordschur"><code>ordschur</code></a> but overwrites the factorization <code>F</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/schur.jl#L128-L132">source</a><div><div><pre><code class="language-none">ordschur!(F::GeneralizedSchur, select::Union{Vector{Bool},BitVector}) -&gt; F::GeneralizedSchur</code></pre><p>Same as <code>ordschur</code> but overwrites the factorization <code>F</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/schur.jl#L211-L215">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.svd" href="#LinearAlgebra.svd"><code>LinearAlgebra.svd</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">svd(A; full::Bool = false) -&gt; SVD</code></pre><p>Compute the singular value decomposition (SVD) of <code>A</code> and return an <code>SVD</code> object.</p><p><code>U</code>, <code>S</code>, <code>V</code> and <code>Vt</code> can be obtained from the factorization <code>F</code> with <code>F.U</code>, <code>F.S</code>, <code>F.V</code> and <code>F.Vt</code>, such that <code>A = U * Diagonal(S) * Vt</code>. The algorithm produces <code>Vt</code> and hence <code>Vt</code> is more efficient to extract than <code>V</code>. The singular values in <code>S</code> are sorted in descending order.</p><p>Iterating the decomposition produces the components <code>U</code>, <code>S</code>, and <code>V</code>.</p><p>If <code>full = false</code> (default), a &quot;thin&quot; SVD is returned. For a <span>$M \times N$</span> matrix <code>A</code>, in the full factorization <code>U</code> is <code>M \times M</code> and <code>V</code> is <code>N \times N</code>, while in the thin factorization <code>U</code> is <code>M \times K</code> and <code>V</code> is <code>N \times K</code>, where <code>K = \min(M,N)</code> is the number of singular values.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1. 0. 0. 0. 2.; 0. 0. 3. 0. 0.; 0. 0. 0. 0. 0.; 0. 2. 0. 0. 0.]
4Ã5 Array{Float64,2}:
 1.0  0.0  0.0  0.0  2.0
 0.0  0.0  3.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0
 0.0  2.0  0.0  0.0  0.0

julia&gt; F = svd(A);

julia&gt; F.U * Diagonal(F.S) * F.Vt
4Ã5 Array{Float64,2}:
 1.0  0.0  0.0  0.0  2.0
 0.0  0.0  3.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0
 0.0  2.0  0.0  0.0  0.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/svd.jl#L68-L104">source</a><div><div><pre><code class="language-none">svd(A, B) -&gt; GeneralizedSVD</code></pre><p>Compute the generalized SVD of <code>A</code> and <code>B</code>, returning a <code>GeneralizedSVD</code> factorization object <code>F</code>, such that <code>A = F.U*F.D1*F.R0*F.Q&#39;</code> and <code>B = F.V*F.D2*F.R0*F.Q&#39;</code>.</p><p>For an M-by-N matrix <code>A</code> and P-by-N matrix <code>B</code>,</p><ul><li><code>U</code> is a M-by-M orthogonal matrix,</li><li><code>V</code> is a P-by-P orthogonal matrix,</li><li><code>Q</code> is a N-by-N orthogonal matrix,</li><li><code>D1</code> is a M-by-(K+L) diagonal matrix with 1s in the first K entries,</li><li><code>D2</code> is a P-by-(K+L) matrix whose top right L-by-L block is diagonal,</li><li><code>R0</code> is a (K+L)-by-N matrix whose rightmost (K+L)-by-(K+L) block is          nonsingular upper block triangular,</li></ul><p><code>K+L</code> is the effective numerical rank of the matrix <code>[A; B]</code>.</p><p>Iterating the decomposition produces the components <code>U</code>, <code>V</code>, <code>Q</code>, <code>D1</code>, <code>D2</code>, and <code>R0</code>.</p><p>The entries of <code>F.D1</code> and <code>F.D2</code> are related, as explained in the LAPACK documentation for the <a href="http://www.netlib.org/lapack/lug/node36.html">generalized SVD</a> and the <a href="http://www.netlib.org/lapack/explore-html/d6/db3/dggsvd3_8f.html">xGGSVD3</a> routine which is called underneath (in LAPACK 3.6.0 and newer).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1. 0.; 0. -1.]
2Ã2 Array{Float64,2}:
 1.0   0.0
 0.0  -1.0

julia&gt; B = [0. 1.; 1. 0.]
2Ã2 Array{Float64,2}:
 0.0  1.0
 1.0  0.0

julia&gt; F = svd(A, B);

julia&gt; F.U*F.D1*F.R0*F.Q&#39;
2Ã2 Array{Float64,2}:
 1.0   0.0
 0.0  -1.0

julia&gt; F.V*F.D2*F.R0*F.Q&#39;
2Ã2 Array{Float64,2}:
 0.0  1.0
 1.0  0.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/svd.jl#L283-L333">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.svd!" href="#LinearAlgebra.svd!"><code>LinearAlgebra.svd!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">svd!(A; full::Bool = false) -&gt; SVD</code></pre><p><code>svd!</code> is the same as <a href="#LinearAlgebra.svd"><code>svd</code></a>, but saves space by overwriting the input <code>A</code>, instead of creating a copy.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1. 0. 0. 0. 2.; 0. 0. 3. 0. 0.; 0. 0. 0. 0. 0.; 0. 2. 0. 0. 0.]
4Ã5 Array{Float64,2}:
 1.0  0.0  0.0  0.0  2.0
 0.0  0.0  3.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0
 0.0  2.0  0.0  0.0  0.0

julia&gt; F = svd!(A);

julia&gt; F.U * Diagonal(F.S) * F.Vt
4Ã5 Array{Float64,2}:
 1.0  0.0  0.0  0.0  2.0
 0.0  0.0  3.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0
 0.0  2.0  0.0  0.0  0.0

julia&gt; A
4Ã5 Array{Float64,2}:
 -2.23607   0.0   0.0  0.0  0.618034
  0.0      -3.0   1.0  0.0  0.0
  0.0       0.0   0.0  0.0  0.0
  0.0       0.0  -2.0  0.0  0.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/svd.jl#L26-L57">source</a><div><div><pre><code class="language-none">svd!(A, B) -&gt; GeneralizedSVD</code></pre><p><code>svd!</code> is the same as <a href="#LinearAlgebra.svd"><code>svd</code></a>, but modifies the arguments <code>A</code> and <code>B</code> in-place, instead of making copies.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1. 0.; 0. -1.]
2Ã2 Array{Float64,2}:
 1.0   0.0
 0.0  -1.0

julia&gt; B = [0. 1.; 1. 0.]
2Ã2 Array{Float64,2}:
 0.0  1.0
 1.0  0.0

julia&gt; F = svd!(A, B);

julia&gt; F.U*F.D1*F.R0*F.Q&#39;
2Ã2 Array{Float64,2}:
 1.0   0.0
 0.0  -1.0

julia&gt; F.V*F.D2*F.R0*F.Q&#39;
2Ã2 Array{Float64,2}:
 0.0  1.0
 1.0  0.0

julia&gt; A
2Ã2 Array{Float64,2}:
 1.41421   0.0
 0.0      -1.41421

julia&gt; B
2Ã2 Array{Float64,2}:
 1.0  -0.0
 0.0  -1.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/svd.jl#L231-L271">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.svdvals" href="#LinearAlgebra.svdvals"><code>LinearAlgebra.svdvals</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">svdvals(A)</code></pre><p>Return the singular values of <code>A</code> in descending order.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1. 0. 0. 0. 2.; 0. 0. 3. 0. 0.; 0. 0. 0. 0. 0.; 0. 2. 0. 0. 0.]
4Ã5 Array{Float64,2}:
 1.0  0.0  0.0  0.0  2.0
 0.0  0.0  3.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0
 0.0  2.0  0.0  0.0  0.0

julia&gt; svdvals(A)
4-element Array{Float64,1}:
 3.0
 2.23606797749979
 2.0
 0.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/svd.jl#L167-L188">source</a><div><div><pre><code class="language-none">svdvals(A, B)</code></pre><p>Return the generalized singular values from the generalized singular value decomposition of <code>A</code> and <code>B</code>. See also <a href="#LinearAlgebra.svd"><code>svd</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1. 0.; 0. -1.]
2Ã2 Array{Float64,2}:
 1.0   0.0
 0.0  -1.0

julia&gt; B = [0. 1.; 1. 0.]
2Ã2 Array{Float64,2}:
 0.0  1.0
 1.0  0.0

julia&gt; svdvals(A, B)
2-element Array{Float64,1}:
 1.0
 1.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/svd.jl#L432-L455">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.svdvals!" href="#LinearAlgebra.svdvals!"><code>LinearAlgebra.svdvals!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">svdvals!(A)</code></pre><p>Return the singular values of <code>A</code>, saving space by overwriting the input. See also <a href="#LinearAlgebra.svdvals"><code>svdvals</code></a> and <a href="#LinearAlgebra.svd"><code>svd</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1. 0. 0. 0. 2.; 0. 0. 3. 0. 0.; 0. 0. 0. 0. 0.; 0. 2. 0. 0. 0.]
4Ã5 Array{Float64,2}:
 1.0  0.0  0.0  0.0  2.0
 0.0  0.0  3.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0
 0.0  2.0  0.0  0.0  0.0

julia&gt; svdvals!(A)
4-element Array{Float64,1}:
 3.0
 2.23606797749979
 2.0
 0.0

julia&gt; A
4Ã5 Array{Float64,2}:
 -2.23607   0.0   0.0  0.0  0.618034
  0.0      -3.0   1.0  0.0  0.0
  0.0       0.0   0.0  0.0  0.0
  0.0       0.0  -2.0  0.0  0.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/svd.jl#L134-L163">source</a><div><div><pre><code class="language-none">svdvals!(A, B)</code></pre><p>Return the generalized singular values from the generalized singular value decomposition of <code>A</code> and <code>B</code>, saving space by overwriting <code>A</code> and <code>B</code>. See also <a href="#LinearAlgebra.svd"><code>svd</code></a> and <a href="#LinearAlgebra.svdvals"><code>svdvals</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1. 0.; 0. -1.]
2Ã2 Array{Float64,2}:
 1.0   0.0
 0.0  -1.0

julia&gt; B = [0. 1.; 1. 0.]
2Ã2 Array{Float64,2}:
 0.0  1.0
 1.0  0.0

julia&gt; svdvals!(A, B)
2-element Array{Float64,1}:
 1.0
 1.0

julia&gt; A
2Ã2 Array{Float64,2}:
 1.41421   0.0
 0.0      -1.41421

julia&gt; B
2Ã2 Array{Float64,2}:
 1.0  -0.0
 0.0  -1.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/svd.jl#L386-L420">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.Givens" href="#LinearAlgebra.Givens"><code>LinearAlgebra.Givens</code></a> â <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">LinearAlgebra.Givens(i1,i2,c,s) -&gt; G</code></pre><p>A Givens rotation linear operator. The fields <code>c</code> and <code>s</code> represent the cosine and sine of the rotation angle, respectively. The <code>Givens</code> type supports left multiplication <code>G*A</code> and conjugated transpose right multiplication <code>A*G&#39;</code>. The type doesn&#39;t have a <code>size</code> and can therefore be multiplied with matrices of arbitrary size as long as <code>i2&lt;=size(A,2)</code> for <code>G*A</code> or <code>i2&lt;=size(A,1)</code> for <code>A*G&#39;</code>.</p><p>See also: <a href="#LinearAlgebra.givens"><code>givens</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/givens.jl#L25-L35">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.givens" href="#LinearAlgebra.givens"><code>LinearAlgebra.givens</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">givens(f::T, g::T, i1::Integer, i2::Integer) where {T} -&gt; (G::Givens, r::T)</code></pre><p>Computes the Givens rotation <code>G</code> and scalar <code>r</code> such that for any vector <code>x</code> where</p><pre><code class="language-none">x[i1] = f
x[i2] = g</code></pre><p>the result of the multiplication</p><pre><code class="language-none">y = G*x</code></pre><p>has the property that</p><pre><code class="language-none">y[i1] = r
y[i2] = 0</code></pre><p>See also: <a href="#LinearAlgebra.Givens"><code>LinearAlgebra.Givens</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/givens.jl#L251-L271">source</a><div><div><pre><code class="language-none">givens(A::AbstractArray, i1::Integer, i2::Integer, j::Integer) -&gt; (G::Givens, r)</code></pre><p>Computes the Givens rotation <code>G</code> and scalar <code>r</code> such that the result of the multiplication</p><pre><code class="language-none">B = G*A</code></pre><p>has the property that</p><pre><code class="language-none">B[i1,j] = r
B[i2,j] = 0</code></pre><p>See also: <a href="#LinearAlgebra.Givens"><code>LinearAlgebra.Givens</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/givens.jl#L283-L297">source</a><div><div><pre><code class="language-none">givens(x::AbstractVector, i1::Integer, i2::Integer) -&gt; (G::Givens, r)</code></pre><p>Computes the Givens rotation <code>G</code> and scalar <code>r</code> such that the result of the multiplication</p><pre><code class="language-none">B = G*x</code></pre><p>has the property that</p><pre><code class="language-none">B[i1] = r
B[i2] = 0</code></pre><p>See also: <a href="#LinearAlgebra.Givens"><code>LinearAlgebra.Givens</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/givens.jl#L302-L316">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.triu" href="#LinearAlgebra.triu"><code>LinearAlgebra.triu</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">triu(M)</code></pre><p>Upper triangle of a matrix.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = fill(1.0, (4,4))
4Ã4 Array{Float64,2}:
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0

julia&gt; triu(a)
4Ã4 Array{Float64,2}:
 1.0  1.0  1.0  1.0
 0.0  1.0  1.0  1.0
 0.0  0.0  1.0  1.0
 0.0  0.0  0.0  1.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/generic.jl#L121-L142">source</a><div><div><pre><code class="language-none">triu(M, k::Integer)</code></pre><p>Returns the upper triangle of <code>M</code> starting from the <code>k</code>th superdiagonal.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = fill(1.0, (4,4))
4Ã4 Array{Float64,2}:
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0

julia&gt; triu(a,3)
4Ã4 Array{Float64,2}:
 0.0  0.0  0.0  1.0
 0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0

julia&gt; triu(a,-3)
4Ã4 Array{Float64,2}:
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/generic.jl#L169-L197">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.triu!" href="#LinearAlgebra.triu!"><code>LinearAlgebra.triu!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">triu!(M)</code></pre><p>Upper triangle of a matrix, overwriting <code>M</code> in the process. See also <a href="#LinearAlgebra.triu"><code>triu</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/generic.jl#L231-L236">source</a><div><div><pre><code class="language-none">triu!(M, k::Integer)</code></pre><p>Return the upper triangle of <code>M</code> starting from the <code>k</code>th superdiagonal, overwriting <code>M</code> in the process.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; M = [1 2 3 4 5; 1 2 3 4 5; 1 2 3 4 5; 1 2 3 4 5; 1 2 3 4 5]
5Ã5 Array{Int64,2}:
 1  2  3  4  5
 1  2  3  4  5
 1  2  3  4  5
 1  2  3  4  5
 1  2  3  4  5

julia&gt; triu!(M, 1)
5Ã5 Array{Int64,2}:
 0  2  3  4  5
 0  0  3  4  5
 0  0  0  4  5
 0  0  0  0  5
 0  0  0  0  0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/dense.jl#L146-L170">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.tril" href="#LinearAlgebra.tril"><code>LinearAlgebra.tril</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">tril(M)</code></pre><p>Lower triangle of a matrix.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = fill(1.0, (4,4))
4Ã4 Array{Float64,2}:
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0

julia&gt; tril(a)
4Ã4 Array{Float64,2}:
 1.0  0.0  0.0  0.0
 1.0  1.0  0.0  0.0
 1.0  1.0  1.0  0.0
 1.0  1.0  1.0  1.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/generic.jl#L145-L166">source</a><div><div><pre><code class="language-none">tril(M, k::Integer)</code></pre><p>Returns the lower triangle of <code>M</code> starting from the <code>k</code>th superdiagonal.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = fill(1.0, (4,4))
4Ã4 Array{Float64,2}:
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0

julia&gt; tril(a,3)
4Ã4 Array{Float64,2}:
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0

julia&gt; tril(a,-3)
4Ã4 Array{Float64,2}:
 0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0
 1.0  0.0  0.0  0.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/generic.jl#L200-L228">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.tril!" href="#LinearAlgebra.tril!"><code>LinearAlgebra.tril!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">tril!(M)</code></pre><p>Lower triangle of a matrix, overwriting <code>M</code> in the process. See also <a href="#LinearAlgebra.tril"><code>tril</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/generic.jl#L239-L244">source</a><div><div><pre><code class="language-none">tril!(M, k::Integer)</code></pre><p>Return the lower triangle of <code>M</code> starting from the <code>k</code>th superdiagonal, overwriting <code>M</code> in the process.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; M = [1 2 3 4 5; 1 2 3 4 5; 1 2 3 4 5; 1 2 3 4 5; 1 2 3 4 5]
5Ã5 Array{Int64,2}:
 1  2  3  4  5
 1  2  3  4  5
 1  2  3  4  5
 1  2  3  4  5
 1  2  3  4  5

julia&gt; tril!(M, 2)
5Ã5 Array{Int64,2}:
 1  2  3  0  0
 1  2  3  4  0
 1  2  3  4  5
 1  2  3  4  5
 1  2  3  4  5</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/dense.jl#L184-L208">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.diagind" href="#LinearAlgebra.diagind"><code>LinearAlgebra.diagind</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">diagind(M, k::Integer=0)</code></pre><p>An <code>AbstractRange</code> giving the indices of the <code>k</code>th diagonal of the matrix <code>M</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1 2 3; 4 5 6; 7 8 9]
3Ã3 Array{Int64,2}:
 1  2  3
 4  5  6
 7  8  9

julia&gt; diagind(A,-1)
2:4:6</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/dense.jl#L241-L257">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.diag" href="#LinearAlgebra.diag"><code>LinearAlgebra.diag</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">diag(M, k::Integer=0)</code></pre><p>The <code>k</code>th diagonal of a matrix, as a vector.</p><p>See also: <a href="#LinearAlgebra.diagm"><code>diagm</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1 2 3; 4 5 6; 7 8 9]
3Ã3 Array{Int64,2}:
 1  2  3
 4  5  6
 7  8  9

julia&gt; diag(A,1)
2-element Array{Int64,1}:
 2
 6</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/dense.jl#L263-L283">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.diagm" href="#LinearAlgebra.diagm"><code>LinearAlgebra.diagm</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">diagm(kv::Pair{&lt;:Integer,&lt;:AbstractVector}...)</code></pre><p>Construct a square matrix from <code>Pair</code>s of diagonals and vectors. Vector <code>kv.second</code> will be placed on the <code>kv.first</code> diagonal. <code>diagm</code> constructs a full matrix; if you want storage-efficient versions with fast arithmetic, see <a href="#LinearAlgebra.Diagonal"><code>Diagonal</code></a>, <a href="#LinearAlgebra.Bidiagonal"><code>Bidiagonal</code></a> <a href="#LinearAlgebra.Tridiagonal"><code>Tridiagonal</code></a> and <a href="#LinearAlgebra.SymTridiagonal"><code>SymTridiagonal</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; diagm(1 =&gt; [1,2,3])
4Ã4 Array{Int64,2}:
 0  1  0  0
 0  0  2  0
 0  0  0  3
 0  0  0  0

julia&gt; diagm(1 =&gt; [1,2,3], -1 =&gt; [4,5])
4Ã4 Array{Int64,2}:
 0  1  0  0
 4  0  2  0
 0  5  0  3
 0  0  0  0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/dense.jl#L286-L311">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.rank" href="#LinearAlgebra.rank"><code>LinearAlgebra.rank</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">rank(A[, tol::Real])</code></pre><p>Compute the rank of a matrix by counting how many singular values of <code>A</code> have magnitude greater than <code>tol*Ïâ</code> where <code>Ïâ</code> is <code>A</code>&#39;s largest singular values. By default, the value of <code>tol</code> is the smallest dimension of <code>A</code> multiplied by the <a href="../Dates/#Base.eps"><code>eps</code></a> of the <a href="../../base/collections/#Base.eltype"><code>eltype</code></a> of <code>A</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; rank(Matrix(I, 3, 3))
3

julia&gt; rank(diagm(0 =&gt; [1, 0, 2]))
2

julia&gt; rank(diagm(0 =&gt; [1, 0.001, 2]), 0.1)
2

julia&gt; rank(diagm(0 =&gt; [1, 0.001, 2]), 0.00001)
3</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/generic.jl#L717-L740">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.norm" href="#LinearAlgebra.norm"><code>LinearAlgebra.norm</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">norm(A, p::Real=2)</code></pre><p>For any iterable container <code>A</code> (including arrays of any dimension) of numbers (or any element type for which <code>norm</code> is defined), compute the <code>p</code>-norm (defaulting to <code>p=2</code>) as if <code>A</code> were a vector of the corresponding length.</p><p>The <code>p</code>-norm is defined as</p><div>\[\|A\|_p = \left( \sum_{i=1}^n | a_i | ^p \right)^{1/p}\]</div><p>with <span>$a_i$</span> the entries of <span>$A$</span>, <span>$| a_i |$</span> the <a href="#LinearAlgebra.norm"><code>norm</code></a> of <span>$a_i$</span>, and <span>$n$</span> the length of <span>$A$</span>. Since the <code>p</code>-norm is computed using the <a href="#LinearAlgebra.norm"><code>norm</code></a>s of the entries of <code>A</code>, the <code>p</code>-norm of a vector of vectors is not compatible with the interpretation of it as a block vector in general if <code>p != 2</code>.</p><p><code>p</code> can assume any numeric value (even though not all values produce a mathematically valid vector norm). In particular, <code>norm(A, Inf)</code> returns the largest value in <code>abs.(A)</code>, whereas <code>norm(A, -Inf)</code> returns the smallest. If <code>A</code> is a matrix and <code>p=2</code>, then this is equivalent to the Frobenius norm.</p><p>The second argument <code>p</code> is not necessarily a part of the interface for <code>norm</code>, i.e. a custom type may only implement <code>norm(A)</code> without second argument.</p><p>Use <a href="#LinearAlgebra.opnorm"><code>opnorm</code></a> to compute the operator norm of a matrix.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; v = [3, -2, 6]
3-element Array{Int64,1}:
  3
 -2
  6

julia&gt; norm(v)
7.0

julia&gt; norm(v, 1)
11.0

julia&gt; norm(v, Inf)
6.0

julia&gt; norm([1 2 3; 4 5 6; 7 8 9])
16.881943016134134

julia&gt; norm([1 2 3 4 5 6 7 8 9])
16.881943016134134

julia&gt; norm(1:9)
16.881943016134134

julia&gt; norm(hcat(v,v), 1) == norm(vcat(v,v), 1) != norm([v,v], 1)
true

julia&gt; norm(hcat(v,v), 2) == norm(vcat(v,v), 2) == norm([v,v], 2)
true

julia&gt; norm(hcat(v,v), Inf) == norm(vcat(v,v), Inf) != norm([v,v], Inf)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/generic.jl#L364-L425">source</a><div><div><pre><code class="language-none">norm(x::Number, p::Real=2)</code></pre><p>For numbers, return <span>$\left( |x|^p \right)^{1/p}$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; norm(2, 1)
2

julia&gt; norm(-2, 1)
2

julia&gt; norm(2, 2)
2

julia&gt; norm(-2, 2)
2

julia&gt; norm(2, Inf)
2

julia&gt; norm(-2, Inf)
2</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/generic.jl#L443-L468">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.opnorm" href="#LinearAlgebra.opnorm"><code>LinearAlgebra.opnorm</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">opnorm(A::AbstractMatrix, p::Real=2)</code></pre><p>Compute the operator norm (or matrix norm) induced by the vector <code>p</code>-norm, where valid values of <code>p</code> are <code>1</code>, <code>2</code>, or <code>Inf</code>. (Note that for sparse matrices, <code>p=2</code> is currently not implemented.) Use <a href="#LinearAlgebra.norm"><code>norm</code></a> to compute the Frobenius norm.</p><p>When <code>p=1</code>, the operator norm is the maximum absolute column sum of <code>A</code>:</p><div>\[\|A\|_1 = \max_{1 â¤ j â¤ n} \sum_{i=1}^m | a_{ij} |\]</div><p>with <span>$a_{ij}$</span> the entries of <span>$A$</span>, and <span>$m$</span> and <span>$n$</span> its dimensions.</p><p>When <code>p=2</code>, the operator norm is the spectral norm, equal to the largest singular value of <code>A</code>.</p><p>When <code>p=Inf</code>, the operator norm is the maximum absolute row sum of <code>A</code>:</p><div>\[\|A\|_\infty = \max_{1 â¤ i â¤ m} \sum _{j=1}^n | a_{ij} |\]</div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1 -2 -3; 2 3 -1]
2Ã3 Array{Int64,2}:
 1  -2  -3
 2   3  -1

julia&gt; opnorm(A, Inf)
6.0

julia&gt; opnorm(A, 1)
5.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/generic.jl#L518-L553">source</a><div><div><pre><code class="language-none">opnorm(x::Number, p::Real=2)</code></pre><p>For numbers, return <span>$\left( |x|^p \right)^{1/p}$</span>. This is equivalent to <a href="#LinearAlgebra.norm"><code>norm</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/generic.jl#L566-L571">source</a><div><div><pre><code class="language-none">opnorm(A::Adjoint{&lt;:Any,&lt;:AbstracVector}, q::Real=2)
opnorm(A::Transpose{&lt;:Any,&lt;:AbstracVector}, q::Real=2)</code></pre><p>For Adjoint/Transpose-wrapped vectors, return the operator <span>$q$</span>-norm of <code>A</code>, which is equivalent to the <code>p</code>-norm with value <code>p = q/(q-1)</code>. They coincide at <code>p = q = 2</code>. Use <a href="#LinearAlgebra.norm"><code>norm</code></a> to compute the <code>p</code> norm of <code>A</code> as a vector.</p><p>The difference in norm between a vector space and its dual arises to preserve the relationship between duality and the dot product, and the result is consistent with the operator <code>p</code>-norm of a <code>1 Ã n</code> matrix.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; v = [1; im];

julia&gt; vc = v&#39;;

julia&gt; opnorm(vc, 1)
1.0

julia&gt; norm(vc, 1)
2.0

julia&gt; norm(v, 1)
2.0

julia&gt; opnorm(vc, 2)
1.4142135623730951

julia&gt; norm(vc, 2)
1.4142135623730951

julia&gt; norm(v, 2)
1.4142135623730951

julia&gt; opnorm(vc, Inf)
2.0

julia&gt; norm(vc, Inf)
1.0

julia&gt; norm(v, Inf)
1.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/generic.jl#L574-L619">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.normalize!" href="#LinearAlgebra.normalize!"><code>LinearAlgebra.normalize!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">normalize!(v::AbstractVector, p::Real=2)</code></pre><p>Normalize the vector <code>v</code> in-place so that its <code>p</code>-norm equals unity, i.e. <code>norm(v, p) == 1</code>. See also <a href="#LinearAlgebra.normalize"><code>normalize</code></a> and <a href="#LinearAlgebra.norm"><code>norm</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/generic.jl#L1348-L1354">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.normalize" href="#LinearAlgebra.normalize"><code>LinearAlgebra.normalize</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">normalize(v::AbstractVector, p::Real=2)</code></pre><p>Normalize the vector <code>v</code> so that its <code>p</code>-norm equals unity, i.e. <code>norm(v, p) == vecnorm(v, p) == 1</code>. See also <a href="#LinearAlgebra.normalize!"><code>normalize!</code></a> and <a href="#LinearAlgebra.norm"><code>norm</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = [1,2,4];

julia&gt; b = normalize(a)
3-element Array{Float64,1}:
 0.2182178902359924
 0.4364357804719848
 0.8728715609439696

julia&gt; norm(b)
1.0

julia&gt; c = normalize(a, 1)
3-element Array{Float64,1}:
 0.14285714285714285
 0.2857142857142857
 0.5714285714285714

julia&gt; norm(c, 1)
1.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/generic.jl#L1377-L1406">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.cond" href="#LinearAlgebra.cond"><code>LinearAlgebra.cond</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">cond(M, p::Real=2)</code></pre><p>Condition number of the matrix <code>M</code>, computed using the operator <code>p</code>-norm. Valid values for <code>p</code> are <code>1</code>, <code>2</code> (default), or <code>Inf</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/dense.jl#L1344-L1349">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.condskeel" href="#LinearAlgebra.condskeel"><code>LinearAlgebra.condskeel</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">condskeel(M, [x, p::Real=Inf])</code></pre><div>\[\kappa_S(M, p) = \left\Vert \left\vert M \right\vert \left\vert M^{-1} \right\vert \right\Vert_p \\
\kappa_S(M, x, p) = \left\Vert \left\vert M \right\vert \left\vert M^{-1} \right\vert \left\vert x \right\vert \right\Vert_p\]</div><p>Skeel condition number <span>$\kappa_S$</span> of the matrix <code>M</code>, optionally with respect to the vector <code>x</code>, as computed using the operator <code>p</code>-norm. <span>$\left\vert M \right\vert$</span> denotes the matrix of (entry wise) absolute values of <span>$M$</span>; <span>$\left\vert M \right\vert_{ij} = \left\vert M_{ij} \right\vert$</span>. Valid values for <code>p</code> are <code>1</code>, <code>2</code> and <code>Inf</code> (default).</p><p>This quantity is also known in the literature as the Bauer condition number, relative condition number, or componentwise relative condition number.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/generic.jl#L887-L903">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.tr" href="#LinearAlgebra.tr"><code>LinearAlgebra.tr</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">tr(M)</code></pre><p>Matrix trace. Sums the diagonal elements of <code>M</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1 2; 3 4]
2Ã2 Array{Int64,2}:
 1  2
 3  4

julia&gt; tr(A)
5</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/generic.jl#L747-L762">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.det" href="#LinearAlgebra.det"><code>LinearAlgebra.det</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">det(M)</code></pre><p>Matrix determinant.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; M = [1 0; 2 2]
2Ã2 Array{Int64,2}:
 1  0
 2  2

julia&gt; det(M)
2.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/generic.jl#L1221-L1236">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.logdet" href="#LinearAlgebra.logdet"><code>LinearAlgebra.logdet</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">logdet(M)</code></pre><p>Log of matrix determinant. Equivalent to <code>log(det(M))</code>, but may provide increased accuracy and/or speed.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; M = [1 0; 2 2]
2Ã2 Array{Int64,2}:
 1  0
 2  2

julia&gt; logdet(M)
0.6931471805599453

julia&gt; logdet(Matrix(I, 3, 3))
0.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/generic.jl#L1279-L1298">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.logabsdet" href="#LinearAlgebra.logabsdet"><code>LinearAlgebra.logabsdet</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">logabsdet(M)</code></pre><p>Log of absolute value of matrix determinant. Equivalent to <code>(log(abs(det(M))), sign(det(M)))</code>, but may provide increased accuracy and/or speed.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [-1. 0.; 0. 1.]
2Ã2 Array{Float64,2}:
 -1.0  0.0
  0.0  1.0

julia&gt; det(A)
-1.0

julia&gt; logabsdet(A)
(0.0, -1.0)

julia&gt; B = [2. 0.; 0. 1.]
2Ã2 Array{Float64,2}:
 2.0  0.0
 0.0  1.0

julia&gt; det(B)
2.0

julia&gt; logabsdet(B)
(0.6931471805599453, 1.0)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/generic.jl#L1246-L1276">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.inv-Tuple{AbstractArray{T,2} where T}" href="#Base.inv-Tuple{AbstractArray{T,2} where T}"><code>Base.inv</code></a> â <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">inv(M)</code></pre><p>Matrix inverse. Computes matrix <code>N</code> such that <code>M * N = I</code>, where <code>I</code> is the identity matrix. Computed by solving the left-division <code>N = M \ I</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; M = [2 5; 1 3]
2Ã2 Array{Int64,2}:
 2  5
 1  3

julia&gt; N = inv(M)
2Ã2 Array{Float64,2}:
  3.0  -5.0
 -1.0   2.0

julia&gt; M*N == N*M == Matrix(I, 2, 2)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/generic.jl#L774-L797">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.pinv" href="#LinearAlgebra.pinv"><code>LinearAlgebra.pinv</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">pinv(M[, tol::Real])</code></pre><p>Computes the Moore-Penrose pseudoinverse.</p><p>For matrices <code>M</code> with floating point elements, it is convenient to compute the pseudoinverse by inverting only singular values above a given threshold, <code>tol</code>.</p><p>The optimal choice of <code>tol</code> varies both with the value of <code>M</code> and the intended application of the pseudoinverse. The default value of <code>tol</code> is <code>eps(real(float(one(eltype(M)))))*minimum(size(M))</code>, which is essentially machine epsilon for the real part of a matrix element multiplied by the larger matrix dimension. For inverting dense ill-conditioned matrices in a least-squares sense, <code>tol = sqrt(eps(real(float(one(eltype(M))))))</code> is recommended.</p><p>For more information, see <a href="#footnote-issue8859">[issue8859]</a>, <a href="#footnote-B96">[B96]</a>, <a href="#footnote-S84">[S84]</a>, <a href="#footnote-KY88">[KY88]</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; M = [1.5 1.3; 1.2 1.9]
2Ã2 Array{Float64,2}:
 1.5  1.3
 1.2  1.9

julia&gt; N = pinv(M)
2Ã2 Array{Float64,2}:
  1.47287   -1.00775
 -0.930233   1.16279

julia&gt; M * N
2Ã2 Array{Float64,2}:
 1.0          -2.22045e-16
 4.44089e-16   1.0</code></pre><div class="footnote" id="footnote-issue8859"><a href="#footnote-issue8859"><strong>[issue8859]</strong></a><p>Issue 8859, &quot;Fix least squares&quot;, https://github.com/JuliaLang/julia/pull/8859</p></div><div class="footnote" id="footnote-B96"><a href="#footnote-B96"><strong>[B96]</strong></a><p>Ãke BjÃ¶rck, &quot;Numerical Methods for Least Squares Problems&quot;,  SIAM Press, Philadelphia, 1996, &quot;Other Titles in Applied Mathematics&quot;, Vol. 51. <a href="http://epubs.siam.org/doi/book/10.1137/1.9781611971484">doi:10.1137/1.9781611971484</a></p></div><div class="footnote" id="footnote-S84"><a href="#footnote-S84"><strong>[S84]</strong></a><p>G. W. Stewart, &quot;Rank Degeneracy&quot;, SIAM Journal on Scientific and Statistical Computing, 5(2), 1984, 403-413. <a href="http://epubs.siam.org/doi/abs/10.1137/0905030">doi:10.1137/0905030</a></p></div><div class="footnote" id="footnote-KY88"><a href="#footnote-KY88"><strong>[KY88]</strong></a><p>Konstantinos Konstantinides and Kung Yao, &quot;Statistical analysis of effective singular values in matrix rank determination&quot;, IEEE Transactions on Acoustics, Speech and Signal Processing, 36(5), 1988, 757-763. <a href="https://doi.org/10.1109/29.1585">doi:10.1109/29.1585</a></p></div></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/dense.jl#L1221-L1264">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.nullspace" href="#LinearAlgebra.nullspace"><code>LinearAlgebra.nullspace</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">nullspace(M[, tol::Real])</code></pre><p>Computes a basis for the nullspace of <code>M</code> by including the singular vectors of A whose singular have magnitude are greater than <code>tol*Ïâ</code>, where <code>Ïâ</code> is <code>A</code>&#39;s largest singular values. By default, the value of <code>tol</code> is the smallest dimension of <code>A</code> multiplied by the <a href="../Dates/#Base.eps"><code>eps</code></a> of the <a href="../../base/collections/#Base.eltype"><code>eltype</code></a> of <code>A</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; M = [1 0 0; 0 1 0; 0 0 0]
3Ã3 Array{Int64,2}:
 1  0  0
 0  1  0
 0  0  0

julia&gt; nullspace(M)
3Ã1 Array{Float64,2}:
 0.0
 0.0
 1.0

julia&gt; nullspace(M, 2)
3Ã3 Array{Float64,2}:
 0.0  1.0  0.0
 1.0  0.0  0.0
 0.0  0.0  1.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/dense.jl#L1305-L1334">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.kron" href="#Base.kron"><code>Base.kron</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">kron(A, B)</code></pre><p>Kronecker tensor product of two vectors or two matrices.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1 2; 3 4]
2Ã2 Array{Int64,2}:
 1  2
 3  4

julia&gt; B = [im 1; 1 -im]
2Ã2 Array{Complex{Int64},2}:
 0+1im  1+0im
 1+0im  0-1im

julia&gt; kron(A, B)
4Ã4 Array{Complex{Int64},2}:
 0+1im  1+0im  0+2im  2+0im
 1+0im  0-1im  2+0im  0-2im
 0+3im  3+0im  0+4im  4+0im
 3+0im  0-3im  4+0im  0-4im</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/dense.jl#L342-L366">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.exp-Tuple{Union{DenseArray{#s37,2}, ReinterpretArray{#s37,2,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, ReshapedArray{#s37,2,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, SubArray{#s37,2,A,I,L} where L where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where #s37&lt;:Union{Complex{Float32}, Complex{Float64}, Float32, Float64}}" href="#Base.exp-Tuple{Union{DenseArray{#s37,2}, ReinterpretArray{#s37,2,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, ReshapedArray{#s37,2,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, SubArray{#s37,2,A,I,L} where L where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where #s37&lt;:Union{Complex{Float32}, Complex{Float64}, Float32, Float64}}"><code>Base.exp</code></a> â <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">exp(A::AbstractMatrix)</code></pre><p>Compute the matrix exponential of <code>A</code>, defined by</p><div>\[e^A = \sum_{n=0}^{\infty} \frac{A^n}{n!}.\]</div><p>For symmetric or Hermitian <code>A</code>, an eigendecomposition (<a href="#LinearAlgebra.eigen"><code>eigen</code></a>) is used, otherwise the scaling and squaring algorithm (see <a href="#footnote-H05">[H05]</a>) is chosen.</p><div class="footnote" id="footnote-H05"><a href="#footnote-H05"><strong>[H05]</strong></a><p>Nicholas J. Higham, &quot;The squaring and scaling method for the matrix exponential revisited&quot;, SIAM Journal on Matrix Analysis and Applications, 26(4), 2005, 1179-1193. <a href="https://doi.org/10.1137/090768539">doi:10.1137/090768539</a></p></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = Matrix(1.0I, 2, 2)
2Ã2 Array{Float64,2}:
 1.0  0.0
 0.0  1.0

julia&gt; exp(A)
2Ã2 Array{Float64,2}:
 2.71828  0.0
 0.0      2.71828</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/dense.jl#L462-L488">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.log-Tuple{Union{DenseArray{T,2}, ReinterpretArray{T,2,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}" href="#Base.log-Tuple{Union{DenseArray{T,2}, ReinterpretArray{T,2,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}"><code>Base.log</code></a> â <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">log(A{T}::StridedMatrix{T})</code></pre><p>If <code>A</code> has no negative real eigenvalue, compute the principal matrix logarithm of <code>A</code>, i.e. the unique matrix <span>$X$</span> such that <span>$e^X = A$</span> and <span>$-\pi &lt; Im(\lambda) &lt; \pi$</span> for all the eigenvalues <span>$\lambda$</span> of <span>$X$</span>. If <code>A</code> has nonpositive eigenvalues, a nonprincipal matrix function is returned whenever possible.</p><p>If <code>A</code> is symmetric or Hermitian, its eigendecomposition (<a href="#LinearAlgebra.eigen"><code>eigen</code></a>) is used, if <code>A</code> is triangular an improved version of the inverse scaling and squaring method is employed (see <a href="#footnote-AH12">[AH12]</a> and <a href="#footnote-AHR13">[AHR13]</a>). For general matrices, the complex Schur form (<a href="#LinearAlgebra.schur"><code>schur</code></a>) is computed and the triangular algorithm is used on the triangular factor.</p><div class="footnote" id="footnote-AH12"><a href="#footnote-AH12"><strong>[AH12]</strong></a><p>Awad H. Al-Mohy and Nicholas J. Higham, &quot;Improved inverse  scaling and squaring algorithms for the matrix logarithm&quot;, SIAM Journal on Scientific Computing, 34(4), 2012, C153-C169. <a href="https://doi.org/10.1137/110852553">doi:10.1137/110852553</a></p></div><div class="footnote" id="footnote-AHR13"><a href="#footnote-AHR13"><strong>[AHR13]</strong></a><p>Awad H. Al-Mohy, Nicholas J. Higham and Samuel D. Relton, &quot;Computing the FrÃ©chet derivative of the matrix logarithm and estimating the condition number&quot;, SIAM Journal on Scientific Computing, 35(4), 2013, C394-C410. <a href="https://doi.org/10.1137/120885991">doi:10.1137/120885991</a></p></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = Matrix(2.7182818*I, 2, 2)
2Ã2 Array{Float64,2}:
 2.71828  0.0
 0.0      2.71828

julia&gt; log(A)
2Ã2 Array{Float64,2}:
 1.0  0.0
 0.0  1.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/dense.jl#L587-L617">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.sqrt-Tuple{Union{DenseArray{#s37,2}, ReinterpretArray{#s37,2,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, ReshapedArray{#s37,2,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, SubArray{#s37,2,A,I,L} where L where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where #s37&lt;:Real}" href="#Base.sqrt-Tuple{Union{DenseArray{#s37,2}, ReinterpretArray{#s37,2,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, ReshapedArray{#s37,2,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, SubArray{#s37,2,A,I,L} where L where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where #s37&lt;:Real}"><code>Base.sqrt</code></a> â <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">sqrt(A::AbstractMatrix)</code></pre><p>If <code>A</code> has no negative real eigenvalues, compute the principal matrix square root of <code>A</code>, that is the unique matrix <span>$X$</span> with eigenvalues having positive real part such that <span>$X^2 = A$</span>. Otherwise, a nonprincipal square root is returned.</p><p>If <code>A</code> is symmetric or Hermitian, its eigendecomposition (<a href="#LinearAlgebra.eigen"><code>eigen</code></a>) is used to compute the square root. Otherwise, the square root is determined by means of the BjÃ¶rck-Hammarling method <a href="#footnote-BH83">[BH83]</a>, which computes the complex Schur form (<a href="#LinearAlgebra.schur"><code>schur</code></a>) and then the complex square root of the triangular factor.</p><div class="footnote" id="footnote-BH83"><a href="#footnote-BH83"><strong>[BH83]</strong></a><p>Ãke BjÃ¶rck and Sven Hammarling, &quot;A Schur method for the square root of a matrix&quot;, Linear Algebra and its Applications, 52-53, 1983, 127-140. <a href="https://doi.org/10.1016/0024-3795(83)80010-X">doi:10.1016/0024-3795(83)80010-X</a></p></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [4 0; 0 4]
2Ã2 Array{Int64,2}:
 4  0
 0  4

julia&gt; sqrt(A)
2Ã2 Array{Float64,2}:
 2.0  0.0
 0.0  2.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/dense.jl#L646-L676">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.cos-Tuple{Union{DenseArray{#s37,2}, ReinterpretArray{#s37,2,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, ReshapedArray{#s37,2,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, SubArray{#s37,2,A,I,L} where L where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where #s37&lt;:Real}" href="#Base.cos-Tuple{Union{DenseArray{#s37,2}, ReinterpretArray{#s37,2,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, ReshapedArray{#s37,2,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, SubArray{#s37,2,A,I,L} where L where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where #s37&lt;:Real}"><code>Base.cos</code></a> â <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">cos(A::AbstractMatrix)</code></pre><p>Compute the matrix cosine of a square matrix <code>A</code>.</p><p>If <code>A</code> is symmetric or Hermitian, its eigendecomposition (<a href="#LinearAlgebra.eigen"><code>eigen</code></a>) is used to compute the cosine. Otherwise, the cosine is determined by calling <a href="../../base/math/#Base.exp-Tuple{Float64}"><code>exp</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; cos(fill(1.0, (2,2)))
2Ã2 Array{Float64,2}:
  0.291927  -0.708073
 -0.708073   0.291927</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/dense.jl#L720-L735">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.sin-Tuple{Union{DenseArray{#s37,2}, ReinterpretArray{#s37,2,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, ReshapedArray{#s37,2,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, SubArray{#s37,2,A,I,L} where L where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where #s37&lt;:Real}" href="#Base.sin-Tuple{Union{DenseArray{#s37,2}, ReinterpretArray{#s37,2,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, ReshapedArray{#s37,2,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, SubArray{#s37,2,A,I,L} where L where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where #s37&lt;:Real}"><code>Base.sin</code></a> â <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">sin(A::AbstractMatrix)</code></pre><p>Compute the matrix sine of a square matrix <code>A</code>.</p><p>If <code>A</code> is symmetric or Hermitian, its eigendecomposition (<a href="#LinearAlgebra.eigen"><code>eigen</code></a>) is used to compute the sine. Otherwise, the sine is determined by calling <a href="../../base/math/#Base.exp-Tuple{Float64}"><code>exp</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; sin(fill(1.0, (2,2)))
2Ã2 Array{Float64,2}:
 0.454649  0.454649
 0.454649  0.454649</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/dense.jl#L753-L768">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Math.sincos-Tuple{Union{DenseArray{#s37,2}, ReinterpretArray{#s37,2,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, ReshapedArray{#s37,2,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, SubArray{#s37,2,A,I,L} where L where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where #s37&lt;:Real}" href="#Base.Math.sincos-Tuple{Union{DenseArray{#s37,2}, ReinterpretArray{#s37,2,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, ReshapedArray{#s37,2,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, SubArray{#s37,2,A,I,L} where L where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where #s37&lt;:Real}"><code>Base.Math.sincos</code></a> â <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">sincos(A::AbstractMatrix)</code></pre><p>Compute the matrix sine and cosine of a square matrix <code>A</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; S, C = sincos(fill(1.0, (2,2)));

julia&gt; S
2Ã2 Array{Float64,2}:
 0.454649  0.454649
 0.454649  0.454649

julia&gt; C
2Ã2 Array{Float64,2}:
  0.291927  -0.708073
 -0.708073   0.291927</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/dense.jl#L790-L809">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.tan-Tuple{Union{DenseArray{#s37,2}, ReinterpretArray{#s37,2,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, ReshapedArray{#s37,2,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, SubArray{#s37,2,A,I,L} where L where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where #s37&lt;:Real}" href="#Base.tan-Tuple{Union{DenseArray{#s37,2}, ReinterpretArray{#s37,2,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, ReshapedArray{#s37,2,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, SubArray{#s37,2,A,I,L} where L where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where #s37&lt;:Real}"><code>Base.tan</code></a> â <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">tan(A::AbstractMatrix)</code></pre><p>Compute the matrix tangent of a square matrix <code>A</code>.</p><p>If <code>A</code> is symmetric or Hermitian, its eigendecomposition (<a href="#LinearAlgebra.eigen"><code>eigen</code></a>) is used to compute the tangent. Otherwise, the tangent is determined by calling <a href="../../base/math/#Base.exp-Tuple{Float64}"><code>exp</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; tan(fill(1.0, (2,2)))
2Ã2 Array{Float64,2}:
 -1.09252  -1.09252
 -1.09252  -1.09252</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/dense.jl#L839-L854">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Math.sec-Tuple{Union{DenseArray{T,2}, ReinterpretArray{T,2,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}" href="#Base.Math.sec-Tuple{Union{DenseArray{T,2}, ReinterpretArray{T,2,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}"><code>Base.Math.sec</code></a> â <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">sec(A::AbstractMatrix)</code></pre><p>Compute the matrix secant of a square matrix <code>A</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/dense.jl#L1065-L1069">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Math.csc-Tuple{Union{DenseArray{T,2}, ReinterpretArray{T,2,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}" href="#Base.Math.csc-Tuple{Union{DenseArray{T,2}, ReinterpretArray{T,2,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}"><code>Base.Math.csc</code></a> â <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">csc(A::AbstractMatrix)</code></pre><p>Compute the matrix cosecant of a square matrix <code>A</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/dense.jl#L1065-L1069">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Math.cot-Tuple{Union{DenseArray{T,2}, ReinterpretArray{T,2,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}" href="#Base.Math.cot-Tuple{Union{DenseArray{T,2}, ReinterpretArray{T,2,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}"><code>Base.Math.cot</code></a> â <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">cot(A::AbstractMatrix)</code></pre><p>Compute the matrix cotangent of a square matrix <code>A</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/dense.jl#L1065-L1069">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.cosh-Tuple{Union{DenseArray{T,2}, ReinterpretArray{T,2,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}" href="#Base.cosh-Tuple{Union{DenseArray{T,2}, ReinterpretArray{T,2,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}"><code>Base.cosh</code></a> â <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">cosh(A::AbstractMatrix)</code></pre><p>Compute the matrix hyperbolic cosine of a square matrix <code>A</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/dense.jl#L864-L868">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.sinh-Tuple{Union{DenseArray{T,2}, ReinterpretArray{T,2,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}" href="#Base.sinh-Tuple{Union{DenseArray{T,2}, ReinterpretArray{T,2,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}"><code>Base.sinh</code></a> â <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">sinh(A::AbstractMatrix)</code></pre><p>Compute the matrix hyperbolic sine of a square matrix <code>A</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/dense.jl#L878-L882">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.tanh-Tuple{Union{DenseArray{T,2}, ReinterpretArray{T,2,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}" href="#Base.tanh-Tuple{Union{DenseArray{T,2}, ReinterpretArray{T,2,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}"><code>Base.tanh</code></a> â <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">tanh(A::AbstractMatrix)</code></pre><p>Compute the matrix hyperbolic tangent of a square matrix <code>A</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/dense.jl#L892-L896">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Math.sech-Tuple{Union{DenseArray{T,2}, ReinterpretArray{T,2,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}" href="#Base.Math.sech-Tuple{Union{DenseArray{T,2}, ReinterpretArray{T,2,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}"><code>Base.Math.sech</code></a> â <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">sech(A::AbstractMatrix)</code></pre><p>Compute the matrix hyperbolic secant of square matrix <code>A</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/dense.jl#L1070-L1074">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Math.csch-Tuple{Union{DenseArray{T,2}, ReinterpretArray{T,2,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}" href="#Base.Math.csch-Tuple{Union{DenseArray{T,2}, ReinterpretArray{T,2,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}"><code>Base.Math.csch</code></a> â <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">csch(A::AbstractMatrix)</code></pre><p>Compute the matrix hyperbolic cosecant of square matrix <code>A</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/dense.jl#L1070-L1074">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Math.coth-Tuple{Union{DenseArray{T,2}, ReinterpretArray{T,2,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}" href="#Base.Math.coth-Tuple{Union{DenseArray{T,2}, ReinterpretArray{T,2,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}"><code>Base.Math.coth</code></a> â <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">coth(A::AbstractMatrix)</code></pre><p>Compute the matrix hyperbolic cotangent of square matrix <code>A</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/dense.jl#L1070-L1074">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.acos-Tuple{Union{DenseArray{T,2}, ReinterpretArray{T,2,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}" href="#Base.acos-Tuple{Union{DenseArray{T,2}, ReinterpretArray{T,2,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}"><code>Base.acos</code></a> â <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">acos(A::AbstractMatrix)</code></pre><p>Compute the inverse matrix cosine of a square matrix <code>A</code>.</p><p>If <code>A</code> is symmetric or Hermitian, its eigendecomposition (<a href="#LinearAlgebra.eigen"><code>eigen</code></a>) is used to compute the inverse cosine. Otherwise, the inverse cosine is determined by using <a href="../../base/math/#Base.log-Tuple{Number}"><code>log</code></a> and <a href="../../base/math/#Base.sqrt-Tuple{Real}"><code>sqrt</code></a>.  For the theory and logarithmic formulas used to compute this function, see <a href="#footnote-AH16_1">[AH16_1]</a>.</p><div class="footnote" id="footnote-AH16_1"><a href="#footnote-AH16_1"><strong>[AH16_1]</strong></a><p>Mary Aprahamian and Nicholas J. Higham, &quot;Matrix Inverse Trigonometric and Inverse Hyperbolic Functions: Theory and Algorithms&quot;, MIMS EPrint: 2016.4. <a href="https://doi.org/10.1137/16M1057577">https://doi.org/10.1137/16M1057577</a></p></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; acos(cos([0.5 0.1; -0.2 0.3]))
2Ã2 Array{Complex{Float64},2}:
  0.5-5.55112e-17im  0.1-2.77556e-17im
 -0.2+2.498e-16im    0.3-3.46945e-16im</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/dense.jl#L912-L931">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.asin-Tuple{Union{DenseArray{T,2}, ReinterpretArray{T,2,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}" href="#Base.asin-Tuple{Union{DenseArray{T,2}, ReinterpretArray{T,2,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}"><code>Base.asin</code></a> â <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">asin(A::AbstractMatrix)</code></pre><p>Compute the inverse matrix sine of a square matrix <code>A</code>.</p><p>If <code>A</code> is symmetric or Hermitian, its eigendecomposition (<a href="#LinearAlgebra.eigen"><code>eigen</code></a>) is used to compute the inverse sine. Otherwise, the inverse sine is determined by using <a href="../../base/math/#Base.log-Tuple{Number}"><code>log</code></a> and <a href="../../base/math/#Base.sqrt-Tuple{Real}"><code>sqrt</code></a>.  For the theory and logarithmic formulas used to compute this function, see <a href="#footnote-AH16_2">[AH16_2]</a>.</p><div class="footnote" id="footnote-AH16_2"><a href="#footnote-AH16_2"><strong>[AH16_2]</strong></a><p>Mary Aprahamian and Nicholas J. Higham, &quot;Matrix Inverse Trigonometric and Inverse Hyperbolic Functions: Theory and Algorithms&quot;, MIMS EPrint: 2016.4. <a href="https://doi.org/10.1137/16M1057577">https://doi.org/10.1137/16M1057577</a></p></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; asin(sin([0.5 0.1; -0.2 0.3]))
2Ã2 Array{Complex{Float64},2}:
  0.5-4.16334e-17im  0.1-5.55112e-17im
 -0.2+9.71445e-17im  0.3-1.249e-16im</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/dense.jl#L943-L962">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.atan-Tuple{Union{DenseArray{T,2}, ReinterpretArray{T,2,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}" href="#Base.atan-Tuple{Union{DenseArray{T,2}, ReinterpretArray{T,2,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}"><code>Base.atan</code></a> â <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">atan(A::AbstractMatrix)</code></pre><p>Compute the inverse matrix tangent of a square matrix <code>A</code>.</p><p>If <code>A</code> is symmetric or Hermitian, its eigendecomposition (<a href="#LinearAlgebra.eigen"><code>eigen</code></a>) is used to compute the inverse tangent. Otherwise, the inverse tangent is determined by using <a href="../../base/math/#Base.log-Tuple{Number}"><code>log</code></a>.  For the theory and logarithmic formulas used to compute this function, see <a href="#footnote-AH16_3">[AH16_3]</a>.</p><div class="footnote" id="footnote-AH16_3"><a href="#footnote-AH16_3"><strong>[AH16_3]</strong></a><p>Mary Aprahamian and Nicholas J. Higham, &quot;Matrix Inverse Trigonometric and Inverse Hyperbolic Functions: Theory and Algorithms&quot;, MIMS EPrint: 2016.4. <a href="https://doi.org/10.1137/16M1057577">https://doi.org/10.1137/16M1057577</a></p></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; atan(tan([0.5 0.1; -0.2 0.3]))
2Ã2 Array{Complex{Float64},2}:
  0.5+1.38778e-17im  0.1-2.77556e-17im
 -0.2+6.93889e-17im  0.3-4.16334e-17im</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/dense.jl#L974-L993">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Math.asec-Tuple{Union{DenseArray{T,2}, ReinterpretArray{T,2,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}" href="#Base.Math.asec-Tuple{Union{DenseArray{T,2}, ReinterpretArray{T,2,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}"><code>Base.Math.asec</code></a> â <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">asec(A::AbstractMatrix)</code></pre><p>Compute the inverse matrix secant of <code>A</code>. </p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/dense.jl#L1084-L1086">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Math.acsc-Tuple{Union{DenseArray{T,2}, ReinterpretArray{T,2,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}" href="#Base.Math.acsc-Tuple{Union{DenseArray{T,2}, ReinterpretArray{T,2,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}"><code>Base.Math.acsc</code></a> â <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">acsc(A::AbstractMatrix)</code></pre><p>Compute the inverse matrix cosecant of <code>A</code>. </p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/dense.jl#L1084-L1086">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Math.acot-Tuple{Union{DenseArray{T,2}, ReinterpretArray{T,2,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}" href="#Base.Math.acot-Tuple{Union{DenseArray{T,2}, ReinterpretArray{T,2,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}"><code>Base.Math.acot</code></a> â <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">acot(A::AbstractMatrix)</code></pre><p>Compute the inverse matrix cotangent of <code>A</code>. </p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/dense.jl#L1084-L1086">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.acosh-Tuple{Union{DenseArray{T,2}, ReinterpretArray{T,2,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}" href="#Base.acosh-Tuple{Union{DenseArray{T,2}, ReinterpretArray{T,2,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}"><code>Base.acosh</code></a> â <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">acosh(A::AbstractMatrix)</code></pre><p>Compute the inverse hyperbolic matrix cosine of a square matrix <code>A</code>.  For the theory and logarithmic formulas used to compute this function, see <a href="#footnote-AH16_4">[AH16_4]</a>.</p><div class="footnote" id="footnote-AH16_4"><a href="#footnote-AH16_4"><strong>[AH16_4]</strong></a><p>Mary Aprahamian and Nicholas J. Higham, &quot;Matrix Inverse Trigonometric and Inverse Hyperbolic Functions: Theory and Algorithms&quot;, MIMS EPrint: 2016.4. <a href="https://doi.org/10.1137/16M1057577">https://doi.org/10.1137/16M1057577</a></p></div></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/dense.jl#L1004-L1011">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.asinh-Tuple{Union{DenseArray{T,2}, ReinterpretArray{T,2,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}" href="#Base.asinh-Tuple{Union{DenseArray{T,2}, ReinterpretArray{T,2,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}"><code>Base.asinh</code></a> â <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">asinh(A::AbstractMatrix)</code></pre><p>Compute the inverse hyperbolic matrix sine of a square matrix <code>A</code>.  For the theory and logarithmic formulas used to compute this function, see <a href="#footnote-AH16_5">[AH16_5]</a>.</p><div class="footnote" id="footnote-AH16_5"><a href="#footnote-AH16_5"><strong>[AH16_5]</strong></a><p>Mary Aprahamian and Nicholas J. Higham, &quot;Matrix Inverse Trigonometric and Inverse Hyperbolic Functions: Theory and Algorithms&quot;, MIMS EPrint: 2016.4. <a href="https://doi.org/10.1137/16M1057577">https://doi.org/10.1137/16M1057577</a></p></div></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/dense.jl#L1023-L1030">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.atanh-Tuple{Union{DenseArray{T,2}, ReinterpretArray{T,2,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}" href="#Base.atanh-Tuple{Union{DenseArray{T,2}, ReinterpretArray{T,2,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}"><code>Base.atanh</code></a> â <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">atanh(A::AbstractMatrix)</code></pre><p>Compute the inverse hyperbolic matrix tangent of a square matrix <code>A</code>.  For the theory and logarithmic formulas used to compute this function, see <a href="#footnote-AH16_6">[AH16_6]</a>.</p><div class="footnote" id="footnote-AH16_6"><a href="#footnote-AH16_6"><strong>[AH16_6]</strong></a><p>Mary Aprahamian and Nicholas J. Higham, &quot;Matrix Inverse Trigonometric and Inverse Hyperbolic Functions: Theory and Algorithms&quot;, MIMS EPrint: 2016.4. <a href="https://doi.org/10.1137/16M1057577">https://doi.org/10.1137/16M1057577</a></p></div></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/dense.jl#L1041-L1048">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Math.asech-Tuple{Union{DenseArray{T,2}, ReinterpretArray{T,2,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}" href="#Base.Math.asech-Tuple{Union{DenseArray{T,2}, ReinterpretArray{T,2,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}"><code>Base.Math.asech</code></a> â <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">asech(A::AbstractMatrix)</code></pre><p>Compute the inverse matrix hyperbolic secant of <code>A</code>. </p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/dense.jl#L1087-L1089">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Math.acsch-Tuple{Union{DenseArray{T,2}, ReinterpretArray{T,2,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}" href="#Base.Math.acsch-Tuple{Union{DenseArray{T,2}, ReinterpretArray{T,2,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}"><code>Base.Math.acsch</code></a> â <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">acsch(A::AbstractMatrix)</code></pre><p>Compute the inverse matrix hyperbolic cosecant of <code>A</code>. </p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/dense.jl#L1087-L1089">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Math.acoth-Tuple{Union{DenseArray{T,2}, ReinterpretArray{T,2,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}" href="#Base.Math.acoth-Tuple{Union{DenseArray{T,2}, ReinterpretArray{T,2,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{ReinterpretArray{T,N,S,A} where S where A&lt;:Union{SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I&lt;:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A&lt;:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}"><code>Base.Math.acoth</code></a> â <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">acoth(A::AbstractMatrix)</code></pre><p>Compute the inverse matrix hyperbolic cotangent of <code>A</code>. </p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/dense.jl#L1087-L1089">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.lyap" href="#LinearAlgebra.lyap"><code>LinearAlgebra.lyap</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">lyap(A, C)</code></pre><p>Computes the solution <code>X</code> to the continuous Lyapunov equation <code>AX + XA&#39; + C = 0</code>, where no eigenvalue of <code>A</code> has a zero real part and no two eigenvalues are negative complex conjugates of each other.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [3. 4.; 5. 6]
2Ã2 Array{Float64,2}:
 3.0  4.0
 5.0  6.0

julia&gt; B = [1. 1.; 1. 2.]
2Ã2 Array{Float64,2}:
 1.0  1.0
 1.0  2.0

julia&gt; X = lyap(A, B)
2Ã2 Array{Float64,2}:
  0.5  -0.5
 -0.5   0.25

julia&gt; A*X + X*A&#39; + B
2Ã2 Array{Float64,2}:
 0.0          6.66134e-16
 6.66134e-16  8.88178e-16</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/dense.jl#L1416-L1445">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.sylvester" href="#LinearAlgebra.sylvester"><code>LinearAlgebra.sylvester</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">sylvester(A, B, C)</code></pre><p>Computes the solution <code>X</code> to the Sylvester equation <code>AX + XB + C = 0</code>, where <code>A</code>, <code>B</code> and <code>C</code> have compatible dimensions and <code>A</code> and <code>-B</code> have no eigenvalues with equal real part.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [3. 4.; 5. 6]
2Ã2 Array{Float64,2}:
 3.0  4.0
 5.0  6.0

julia&gt; B = [1. 1.; 1. 2.]
2Ã2 Array{Float64,2}:
 1.0  1.0
 1.0  2.0

julia&gt; C = [1. 2.; -2. 1]
2Ã2 Array{Float64,2}:
  1.0  2.0
 -2.0  1.0

julia&gt; X = sylvester(A, B, C)
2Ã2 Array{Float64,2}:
 -4.46667   1.93333
  3.73333  -1.8

julia&gt; A*X + X*B + C
2Ã2 Array{Float64,2}:
  2.66454e-15  1.77636e-15
 -3.77476e-15  4.44089e-16</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/dense.jl#L1368-L1401">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.issuccess" href="#LinearAlgebra.issuccess"><code>LinearAlgebra.issuccess</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">issuccess(F::Factorization)</code></pre><p>Test that a factorization of a matrix succeeded.</p><pre><code class="language-julia-repl">julia&gt; F = cholesky([1 0; 0 1]);

julia&gt; LinearAlgebra.issuccess(F)
true

julia&gt; F = lu([1 0; 0 0]; check = false);

julia&gt; LinearAlgebra.issuccess(F)
false</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/factorization.jl#L14-L30">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.issymmetric" href="#LinearAlgebra.issymmetric"><code>LinearAlgebra.issymmetric</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">issymmetric(A) -&gt; Bool</code></pre><p>Test whether a matrix is symmetric.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = [1 2; 2 -1]
2Ã2 Array{Int64,2}:
 1   2
 2  -1

julia&gt; issymmetric(a)
true

julia&gt; b = [1 im; -im 1]
2Ã2 Array{Complex{Int64},2}:
 1+0im  0+1im
 0-1im  1+0im

julia&gt; issymmetric(b)
false</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/generic.jl#L908-L931">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.isposdef" href="#LinearAlgebra.isposdef"><code>LinearAlgebra.isposdef</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">isposdef(A) -&gt; Bool</code></pre><p>Test whether a matrix is positive definite (and Hermitian) by trying to perform a Cholesky factorization of <code>A</code>. See also <a href="#LinearAlgebra.isposdef!"><code>isposdef!</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1 2; 2 50]
2Ã2 Array{Int64,2}:
 1   2
 2  50

julia&gt; isposdef(A)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/dense.jl#L95-L112">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.isposdef!" href="#LinearAlgebra.isposdef!"><code>LinearAlgebra.isposdef!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">isposdef!(A) -&gt; Bool</code></pre><p>Test whether a matrix is positive definite (and Hermitian) by trying to perform a Cholesky factorization of <code>A</code>, overwriting <code>A</code> in the process. See also <a href="#LinearAlgebra.isposdef"><code>isposdef</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1. 2.; 2. 50.];

julia&gt; isposdef!(A)
true

julia&gt; A
2Ã2 Array{Float64,2}:
 1.0  2.0
 2.0  6.78233</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/dense.jl#L72-L91">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.istril" href="#LinearAlgebra.istril"><code>LinearAlgebra.istril</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">istril(A::AbstractMatrix, k::Integer = 0) -&gt; Bool</code></pre><p>Test whether <code>A</code> is lower triangular starting from the <code>k</code>th superdiagonal.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = [1 2; 2 -1]
2Ã2 Array{Int64,2}:
 1   2
 2  -1

julia&gt; istril(a)
false

julia&gt; istril(a, 1)
true

julia&gt; b = [1 0; -im -1]
2Ã2 Array{Complex{Int64},2}:
 1+0im   0+0im
 0-1im  -1+0im

julia&gt; istril(b)
true

julia&gt; istril(b, -1)
false</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/generic.jl#L1028-L1057">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.istriu" href="#LinearAlgebra.istriu"><code>LinearAlgebra.istriu</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">istriu(A::AbstractMatrix, k::Integer = 0) -&gt; Bool</code></pre><p>Test whether <code>A</code> is upper triangular starting from the <code>k</code>th superdiagonal.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = [1 2; 2 -1]
2Ã2 Array{Int64,2}:
 1   2
 2  -1

julia&gt; istriu(a)
false

julia&gt; istriu(a, -1)
true

julia&gt; b = [1 im; 0 -1]
2Ã2 Array{Complex{Int64},2}:
 1+0im   0+1im
 0+0im  -1+0im

julia&gt; istriu(b)
true

julia&gt; istriu(b, 1)
false</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/generic.jl#L986-L1015">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.isdiag" href="#LinearAlgebra.isdiag"><code>LinearAlgebra.isdiag</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">isdiag(A) -&gt; Bool</code></pre><p>Test whether a matrix is diagonal.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = [1 2; 2 -1]
2Ã2 Array{Int64,2}:
 1   2
 2  -1

julia&gt; isdiag(a)
false

julia&gt; b = [im 0; 0 -im]
2Ã2 Array{Complex{Int64},2}:
 0+1im  0+0im
 0+0im  0-1im

julia&gt; isdiag(b)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/generic.jl#L1103-L1126">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.ishermitian" href="#LinearAlgebra.ishermitian"><code>LinearAlgebra.ishermitian</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ishermitian(A) -&gt; Bool</code></pre><p>Test whether a matrix is Hermitian.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = [1 2; 2 -1]
2Ã2 Array{Int64,2}:
 1   2
 2  -1

julia&gt; ishermitian(a)
true

julia&gt; b = [1 im; -im 1]
2Ã2 Array{Complex{Int64},2}:
 1+0im  0+1im
 0-1im  1+0im

julia&gt; ishermitian(b)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/generic.jl#L947-L970">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.transpose" href="#Base.transpose"><code>Base.transpose</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">transpose(A)</code></pre><p>Lazy transpose. Mutating the returned object should appropriately mutate <code>A</code>. Often, but not always, yields <code>Transpose(A)</code>, where <code>Transpose</code> is a lazy transpose wrapper. Note that this operation is recursive.</p><p>This operation is intended for linear algebra usage - for general data manipulation see <a href="../../base/arrays/#Base.permutedims"><code>permutedims</code></a>, which is non-recursive.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [3+2im 9+2im; 8+7im  4+6im]
2Ã2 Array{Complex{Int64},2}:
 3+2im  9+2im
 8+7im  4+6im

julia&gt; transpose(A)
2Ã2 Transpose{Complex{Int64},Array{Complex{Int64},2}}:
 3+2im  8+7im
 9+2im  4+6im</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/adjtrans.jl#L78-L100">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.transpose!" href="#LinearAlgebra.transpose!"><code>LinearAlgebra.transpose!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">transpose!(dest,src)</code></pre><p>Transpose array <code>src</code> and store the result in the preallocated array <code>dest</code>, which should have a size corresponding to <code>(size(src,2),size(src,1))</code>. No in-place transposition is supported and unexpected results will happen if <code>src</code> and <code>dest</code> have overlapping memory regions.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [3+2im 9+2im; 8+7im  4+6im]
2Ã2 Array{Complex{Int64},2}:
 3+2im  9+2im
 8+7im  4+6im

julia&gt; B = zeros(Complex{Int64}, 2, 2)
2Ã2 Array{Complex{Int64},2}:
 0+0im  0+0im
 0+0im  0+0im

julia&gt; transpose!(B, A);

julia&gt; B
2Ã2 Array{Complex{Int64},2}:
 3+2im  8+7im
 9+2im  4+6im

julia&gt; A
2Ã2 Array{Complex{Int64},2}:
 3+2im  9+2im
 8+7im  4+6im</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/transpose.jl#L8-L40">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.adjoint" href="#Base.adjoint"><code>Base.adjoint</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">adjoint(A)</code></pre><p>Lazy adjoint (conjugate transposition) (also postfix <code>&#39;</code>). Note that <code>adjoint</code> is applied recursively to elements.</p><p>This operation is intended for linear algebra usage - for general data manipulation see <a href="../../base/arrays/#Base.permutedims"><code>permutedims</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [3+2im 9+2im; 8+7im  4+6im]
2Ã2 Array{Complex{Int64},2}:
 3+2im  9+2im
 8+7im  4+6im

julia&gt; adjoint(A)
2Ã2 Adjoint{Complex{Int64},Array{Complex{Int64},2}}:
 3-2im  8-7im
 9-2im  4-6im</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/adjtrans.jl#L54-L75">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.adjoint!" href="#LinearAlgebra.adjoint!"><code>LinearAlgebra.adjoint!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">adjoint!(dest,src)</code></pre><p>Conjugate transpose array <code>src</code> and store the result in the preallocated array <code>dest</code>, which should have a size corresponding to <code>(size(src,2),size(src,1))</code>. No in-place transposition is supported and unexpected results will happen if <code>src</code> and <code>dest</code> have overlapping memory regions.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [3+2im 9+2im; 8+7im  4+6im]
2Ã2 Array{Complex{Int64},2}:
 3+2im  9+2im
 8+7im  4+6im

julia&gt; B = zeros(Complex{Int64}, 2, 2)
2Ã2 Array{Complex{Int64},2}:
 0+0im  0+0im
 0+0im  0+0im

julia&gt; adjoint!(B, A);

julia&gt; B
2Ã2 Array{Complex{Int64},2}:
 3-2im  8-7im
 9-2im  4-6im

julia&gt; A
2Ã2 Array{Complex{Int64},2}:
 3+2im  9+2im
 8+7im  4+6im</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/transpose.jl#L43-L75">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.copy-Tuple{Union{Adjoint, Transpose}}" href="#Base.copy-Tuple{Union{Adjoint, Transpose}}"><code>Base.copy</code></a> â <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">copy(A::Transpose)
copy(A::Adjoint)</code></pre><p>Eagerly evaluate the lazy matrix transpose/adjoint. Note that the transposition is applied recursively to elements.</p><p>This operation is intended for linear algebra usage - for general data manipulation see <a href="../../base/arrays/#Base.permutedims"><code>permutedims</code></a>, which is non-recursive.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1 2im; -3im 4]
2Ã2 Array{Complex{Int64},2}:
 1+0im  0+2im
 0-3im  4+0im

julia&gt; T = transpose(A)
2Ã2 Transpose{Complex{Int64},Array{Complex{Int64},2}}:
 1+0im  0-3im
 0+2im  4+0im

julia&gt; copy(T)
2Ã2 Array{Complex{Int64},2}:
 1+0im  0-3im
 0+2im  4+0im</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/transpose.jl#L148-L175">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.stride1" href="#LinearAlgebra.stride1"><code>LinearAlgebra.stride1</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">stride1(A) -&gt; Int</code></pre><p>Return the distance between successive array elements in dimension 1 in units of element size.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1,2,3,4]
4-element Array{Int64,1}:
 1
 2
 3
 4

julia&gt; LinearAlgebra.stride1(A)
1

julia&gt; B = view(A, 2:2:4)
2-element view(::Array{Int64,1}, 2:2:4) with eltype Int64:
 2
 4

julia&gt; LinearAlgebra.stride1(B)
2</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/LinearAlgebra.jl#L163-L189">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.checksquare" href="#LinearAlgebra.checksquare"><code>LinearAlgebra.checksquare</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">LinearAlgebra.checksquare(A)</code></pre><p>Check that a matrix is square, then return its common dimension. For multiple arguments, return a vector.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = fill(1, (4,4)); B = fill(1, (5,5));

julia&gt; LinearAlgebra.checksquare(A, B)
2-element Array{Int64,1}:
 4
 5</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/LinearAlgebra.jl#L198-L213">source</a></section><h2><a class="nav-anchor" id="Low-level-matrix-operations-1" href="#Low-level-matrix-operations-1">Low-level matrix operations</a></h2><p>In many cases there are in-place versions of matrix operations that allow you to supply a pre-allocated output vector or matrix.  This is useful when optimizing critical code in order to avoid the overhead of repeated allocations. These in-place operations are suffixed with <code>!</code> below (e.g. <code>mul!</code>) according to the usual Julia convention.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.mul!" href="#LinearAlgebra.mul!"><code>LinearAlgebra.mul!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">mul!(Y, A, B) -&gt; Y</code></pre><p>Calculates the matrix-matrix or matrix-vector product <span>$AB$</span> and stores the result in <code>Y</code>, overwriting the existing value of <code>Y</code>. Note that <code>Y</code> must not be aliased with either <code>A</code> or <code>B</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A=[1.0 2.0; 3.0 4.0]; B=[1.0 1.0; 1.0 1.0]; Y = similar(B); mul!(Y, A, B);

julia&gt; Y
2Ã2 Array{Float64,2}:
 3.0  3.0
 7.0  7.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/matmul.jl#L155-L171">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.lmul!" href="#LinearAlgebra.lmul!"><code>LinearAlgebra.lmul!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">lmul!(a::Number, B::AbstractArray)</code></pre><p>Scale an array <code>B</code> by a scalar <code>a</code> overwriting <code>B</code> in-place.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; B = [1 2; 3 4]
2Ã2 Array{Int64,2}:
 1  2
 3  4

julia&gt; lmul!(2, B)
2Ã2 Array{Int64,2}:
 2  4
 6  8</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/generic.jl#L65-L82">source</a><div><div><pre><code class="language-none">lmul!(A, B)</code></pre><p>Calculate the matrix-matrix product <span>$AB$</span>, overwriting <code>B</code>, and return the result.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; B = [0 1; 1 0];

julia&gt; A = LinearAlgebra.UpperTriangular([1 2; 0 3]);

julia&gt; LinearAlgebra.lmul!(A, B);

julia&gt; B
2Ã2 Array{Int64,2}:
 2  1
 3  0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/matmul.jl#L195-L213">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.rmul!" href="#LinearAlgebra.rmul!"><code>LinearAlgebra.rmul!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">rmul!(A::AbstractArray, b::Number)</code></pre><p>Scale an array <code>A</code> by a scalar <code>b</code> overwriting <code>A</code> in-place.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1 2; 3 4]
2Ã2 Array{Int64,2}:
 1  2
 3  4

julia&gt; rmul!(A, 2)
2Ã2 Array{Int64,2}:
 2  4
 6  8</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/generic.jl#L45-L62">source</a><div><div><pre><code class="language-none">rmul!(A, B)</code></pre><p>Calculate the matrix-matrix product <span>$AB$</span>, overwriting <code>A</code>, and return the result.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [0 1; 1 0];

julia&gt; B = LinearAlgebra.UpperTriangular([1 2; 0 3]);

julia&gt; LinearAlgebra.rmul!(A, B);

julia&gt; A
2Ã2 Array{Int64,2}:
 0  3
 1  2</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/matmul.jl#L174-L192">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.ldiv!" href="#LinearAlgebra.ldiv!"><code>LinearAlgebra.ldiv!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ldiv!(Y, A, B) -&gt; Y</code></pre><p>Compute <code>A \ B</code> in-place and store the result in <code>Y</code>, returning the result.</p><p>The argument <code>A</code> should <em>not</em> be a matrix.  Rather, instead of matrices it should be a factorization object (e.g. produced by <a href="#LinearAlgebra.factorize"><code>factorize</code></a> or <a href="#LinearAlgebra.cholesky"><code>cholesky</code></a>). The reason for this is that factorization itself is both expensive and typically allocates memory (although it can also be done in-place via, e.g., <a href="#LinearAlgebra.lu!"><code>lu!</code></a>), and performance-critical situations requiring <code>ldiv!</code> usually also require fine-grained control over the factorization of <code>A</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1 2.2 4; 3.1 0.2 3; 4 1 2];

julia&gt; X = [1; 2.5; 3];

julia&gt; Y = zero(X);

julia&gt; ldiv!(Y, qr(A), X);

julia&gt; Y
3-element Array{Float64,1}:
  0.7128099173553719
 -0.051652892561983674
  0.10020661157024757

julia&gt; A\X
3-element Array{Float64,1}:
  0.7128099173553719
 -0.05165289256198333
  0.10020661157024785</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/LinearAlgebra.jl#L239-L273">source</a><div><div><pre><code class="language-none">ldiv!(A, B)</code></pre><p>Compute <code>A \ B</code> in-place and overwriting <code>B</code> to store the result.</p><p>The argument <code>A</code> should <em>not</em> be a matrix.  Rather, instead of matrices it should be a factorization object (e.g. produced by <a href="#LinearAlgebra.factorize"><code>factorize</code></a> or <a href="#LinearAlgebra.cholesky"><code>cholesky</code></a>). The reason for this is that factorization itself is both expensive and typically allocates memory (although it can also be done in-place via, e.g., <a href="#LinearAlgebra.lu!"><code>lu!</code></a>), and performance-critical situations requiring <code>ldiv!</code> usually also require fine-grained control over the factorization of <code>A</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1 2.2 4; 3.1 0.2 3; 4 1 2];

julia&gt; X = [1; 2.5; 3];

julia&gt; Y = copy(X);

julia&gt; ldiv!(qr(A), X);

julia&gt; X
3-element Array{Float64,1}:
  0.7128099173553719
 -0.051652892561983674
  0.10020661157024757

julia&gt; A\Y
3-element Array{Float64,1}:
  0.7128099173553719
 -0.05165289256198333
  0.10020661157024785</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/LinearAlgebra.jl#L276-L310">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.rdiv!" href="#LinearAlgebra.rdiv!"><code>LinearAlgebra.rdiv!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">rdiv!(A, B)</code></pre><p>Compute <code>A / B</code> in-place and overwriting <code>A</code> to store the result.</p><p>The argument <code>B</code> should <em>not</em> be a matrix.  Rather, instead of matrices it should be a factorization object (e.g. produced by <a href="#LinearAlgebra.factorize"><code>factorize</code></a> or <a href="#LinearAlgebra.cholesky"><code>cholesky</code></a>). The reason for this is that factorization itself is both expensive and typically allocates memory (although it can also be done in-place via, e.g., <a href="#LinearAlgebra.lu!"><code>lu!</code></a>), and performance-critical situations requiring <code>rdiv!</code> usually also require fine-grained control over the factorization of <code>B</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/LinearAlgebra.jl#L314-L325">source</a></section><h2><a class="nav-anchor" id="BLAS-Functions-1" href="#BLAS-Functions-1">BLAS Functions</a></h2><p>In Julia (as in much of scientific computation), dense linear-algebra operations are based on the <a href="http://www.netlib.org/lapack/">LAPACK library</a>, which in turn is built on top of basic linear-algebra building-blocks known as the <a href="http://www.netlib.org/blas/">BLAS</a>. There are highly optimized implementations of BLAS available for every computer architecture, and sometimes in high-performance linear algebra routines it is useful to call the BLAS functions directly.</p><p><code>LinearAlgebra.BLAS</code> provides wrappers for some of the BLAS functions. Those BLAS functions that overwrite one of the input arrays have names ending in <code>&#39;!&#39;</code>.  Usually, a BLAS function has four methods defined, for <a href="../../base/numbers/#Core.Float64"><code>Float64</code></a>, <a href="../../base/numbers/#Core.Float32"><code>Float32</code></a>, <code>ComplexF64</code>, and <code>ComplexF32</code> arrays.</p><h3><a class="nav-anchor" id="stdlib-blas-chars-1" href="#stdlib-blas-chars-1">BLAS Character Arguments</a></h3><p>Many BLAS functions accept arguments that determine whether to transpose an argument (<code>trans</code>), which triangle of a matrix to reference (<code>uplo</code> or <code>ul</code>), whether the diagonal of a triangular matrix can be assumed to be all ones (<code>dA</code>) or which side of a matrix multiplication the input argument belongs on (<code>side</code>). The possibilities are:</p><h4><a class="nav-anchor" id="stdlib-blas-side-1" href="#stdlib-blas-side-1">Multplication Order</a></h4><table><tr><th><code>side</code></th><th>Meaning</th></tr><tr><td><code>&#39;L&#39;</code></td><td>The argument goes on the <em>left</em> side of a matrix-matrix operation.</td></tr><tr><td><code>&#39;R&#39;</code></td><td>The argument goes on the <em>right</em> side of a matrix-matrix operation.</td></tr></table><h4><a class="nav-anchor" id="stdlib-blas-uplo-1" href="#stdlib-blas-uplo-1">Triangle Referencing</a></h4><table><tr><th><code>uplo</code>/<code>ul</code></th><th>Meaning</th></tr><tr><td><code>&#39;U&#39;</code></td><td>Only the <em>upper</em> triangle of the matrix will be used.</td></tr><tr><td><code>&#39;L&#39;</code></td><td>Only the <em>lower</em> triangle of the matrix will be used.</td></tr></table><h4><a class="nav-anchor" id="stdlib-blas-trans-1" href="#stdlib-blas-trans-1">Transposition Operation</a></h4><table><tr><th><code>trans</code>/<code>tX</code></th><th>Meaning</th></tr><tr><td><code>&#39;N&#39;</code></td><td>The input matrix <code>X</code> is not transposed or conjugated.</td></tr><tr><td><code>&#39;T&#39;</code></td><td>The input matrix <code>X</code> will be transposed.</td></tr><tr><td><code>&#39;C&#39;</code></td><td>The input matrix <code>X</code> will be conjugated and transposed.</td></tr></table><h4><a class="nav-anchor" id="stdlib-blas-diag-1" href="#stdlib-blas-diag-1">Unit Diagonal</a></h4><table><tr><th><code>diag</code>/<code>dX</code></th><th>Meaning</th></tr><tr><td><code>&#39;N&#39;</code></td><td>The diagonal values of the matrix <code>X</code> will be read.</td></tr><tr><td><code>&#39;U&#39;</code></td><td>The diagonal of the matrix <code>X</code> is assumed to be all ones.</td></tr></table><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.BLAS" href="#LinearAlgebra.BLAS"><code>LinearAlgebra.BLAS</code></a> â <span class="docstring-category">Module</span>.</div><div><div><p>Interface to BLAS subroutines.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/blas.jl#L4-L6">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.BLAS.dotu" href="#LinearAlgebra.BLAS.dotu"><code>LinearAlgebra.BLAS.dotu</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">dotu(n, X, incx, Y, incy)</code></pre><p>Dot function for two complex vectors consisting of <code>n</code> elements of array <code>X</code> with stride <code>incx</code> and <code>n</code> elements of array <code>Y</code> with stride <code>incy</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; BLAS.dotu(10, fill(1.0im, 10), 1, fill(1.0+im, 20), 2)
-10.0 + 10.0im</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/blas.jl#L261-L272">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.BLAS.dotc" href="#LinearAlgebra.BLAS.dotc"><code>LinearAlgebra.BLAS.dotc</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">dotc(n, X, incx, U, incy)</code></pre><p>Dot function for two complex vectors, consisting of <code>n</code> elements of array <code>X</code> with stride <code>incx</code> and <code>n</code> elements of array <code>U</code> with stride <code>incy</code>, conjugating the first vector.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; BLAS.dotc(10, fill(1.0im, 10), 1, fill(1.0+im, 20), 2)
10.0 - 10.0im</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/blas.jl#L246-L258">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.BLAS.blascopy!" href="#LinearAlgebra.BLAS.blascopy!"><code>LinearAlgebra.BLAS.blascopy!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">blascopy!(n, X, incx, Y, incy)</code></pre><p>Copy <code>n</code> elements of array <code>X</code> with stride <code>incx</code> to array <code>Y</code> with stride <code>incy</code>. Returns <code>Y</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/blas.jl#L176-L180">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.BLAS.nrm2" href="#LinearAlgebra.BLAS.nrm2"><code>LinearAlgebra.BLAS.nrm2</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">nrm2(n, X, incx)</code></pre><p>2-norm of a vector consisting of <code>n</code> elements of array <code>X</code> with stride <code>incx</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; BLAS.nrm2(4, fill(1.0, 8), 2)
2.0

julia&gt; BLAS.nrm2(1, fill(1.0, 8), 2)
1.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/blas.jl#L355-L368">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.BLAS.asum" href="#LinearAlgebra.BLAS.asum"><code>LinearAlgebra.BLAS.asum</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">asum(n, X, incx)</code></pre><p>Sum of the absolute values of the first <code>n</code> elements of array <code>X</code> with stride <code>incx</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; BLAS.asum(5, fill(1.0im, 10), 2)
5.0

julia&gt; BLAS.asum(2, fill(1.0im, 10), 5)
2.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/blas.jl#L388-L401">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.axpy!" href="#LinearAlgebra.axpy!"><code>LinearAlgebra.axpy!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">axpy!(a, X, Y)</code></pre><p>Overwrite <code>Y</code> with <code>a*X + Y</code>, where <code>a</code> is a scalar. Return <code>Y</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; x = [1; 2; 3];

julia&gt; y = [4; 5; 6];

julia&gt; BLAS.axpy!(2, x, y)
3-element Array{Int64,1}:
  6
  9
 12</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/blas.jl#L421-L438">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.BLAS.scal!" href="#LinearAlgebra.BLAS.scal!"><code>LinearAlgebra.BLAS.scal!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">scal!(n, a, X, incx)</code></pre><p>Overwrite <code>X</code> with <code>a*X</code> for the first <code>n</code> elements of array <code>X</code> with stride <code>incx</code>. Returns <code>X</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/blas.jl#L200-L204">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.BLAS.scal" href="#LinearAlgebra.BLAS.scal"><code>LinearAlgebra.BLAS.scal</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">scal(n, a, X, incx)</code></pre><p>Return <code>X</code> scaled by <code>a</code> for the first <code>n</code> elements of array <code>X</code> with stride <code>incx</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/blas.jl#L207-L211">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.BLAS.ger!" href="#LinearAlgebra.BLAS.ger!"><code>LinearAlgebra.BLAS.ger!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ger!(alpha, x, y, A)</code></pre><p>Rank-1 update of the matrix <code>A</code> with vectors <code>x</code> and <code>y</code> as <code>alpha*x*y&#39; + A</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/blas.jl#L990-L994">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.BLAS.syr!" href="#LinearAlgebra.BLAS.syr!"><code>LinearAlgebra.BLAS.syr!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">syr!(uplo, alpha, x, A)</code></pre><p>Rank-1 update of the symmetric matrix <code>A</code> with vector <code>x</code> as <code>alpha*x*transpose(x) + A</code>. <a href="#stdlib-blas-uplo-1"><code>uplo</code></a> controls which triangle of <code>A</code> is updated. Returns <code>A</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/blas.jl#L1022-L1027">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.BLAS.syrk!" href="#LinearAlgebra.BLAS.syrk!"><code>LinearAlgebra.BLAS.syrk!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">syrk!(uplo, trans, alpha, A, beta, C)</code></pre><p>Rank-k update of the symmetric matrix <code>C</code> as <code>alpha*A*transpose(A) + beta*C</code> or <code>alpha*transpose(A)*A + beta*C</code> according to <a href="#stdlib-blas-trans-1"><code>trans</code></a>. Only the <a href="#stdlib-blas-uplo-1"><code>uplo</code></a> triangle of <code>C</code> is used. Returns <code>C</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/blas.jl#L1270-L1276">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.BLAS.syrk" href="#LinearAlgebra.BLAS.syrk"><code>LinearAlgebra.BLAS.syrk</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">syrk(uplo, trans, alpha, A)</code></pre><p>Returns either the upper triangle or the lower triangle of <code>A</code>, according to <a href="#stdlib-blas-uplo-1"><code>uplo</code></a>, of <code>alpha*A*transpose(A)</code> or <code>alpha*transpose(A)*A</code>, according to <a href="#stdlib-blas-trans-1"><code>trans</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/blas.jl#L1279-L1286">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.BLAS.her!" href="#LinearAlgebra.BLAS.her!"><code>LinearAlgebra.BLAS.her!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">her!(uplo, alpha, x, A)</code></pre><p>Methods for complex arrays only. Rank-1 update of the Hermitian matrix <code>A</code> with vector <code>x</code> as <code>alpha*x*x&#39; + A</code>. <a href="#stdlib-blas-uplo-1"><code>uplo</code></a> controls which triangle of <code>A</code> is updated. Returns <code>A</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/blas.jl#L1053-L1059">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.BLAS.herk!" href="#LinearAlgebra.BLAS.herk!"><code>LinearAlgebra.BLAS.herk!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">herk!(uplo, trans, alpha, A, beta, C)</code></pre><p>Methods for complex arrays only. Rank-k update of the Hermitian matrix <code>C</code> as <code>alpha*A*A&#39; + beta*C</code> or <code>alpha*A&#39;*A + beta*C</code> according to <a href="#stdlib-blas-trans-1"><code>trans</code></a>. Only the <a href="#stdlib-blas-uplo-1"><code>uplo</code></a> triangle of <code>C</code> is updated. Returns <code>C</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/blas.jl#L1329-L1336">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.BLAS.herk" href="#LinearAlgebra.BLAS.herk"><code>LinearAlgebra.BLAS.herk</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">herk(uplo, trans, alpha, A)</code></pre><p>Methods for complex arrays only. Returns the <a href="#stdlib-blas-uplo-1"><code>uplo</code></a> triangle of <code>alpha*A*A&#39;</code> or <code>alpha*A&#39;*A</code>, according to <a href="#stdlib-blas-trans-1"><code>trans</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/blas.jl#L1339-L1345">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.BLAS.gbmv!" href="#LinearAlgebra.BLAS.gbmv!"><code>LinearAlgebra.BLAS.gbmv!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">gbmv!(trans, m, kl, ku, alpha, A, x, beta, y)</code></pre><p>Update vector <code>y</code> as <code>alpha*A*x + beta*y</code> or <code>alpha*A&#39;*x + beta*y</code> according to <a href="#stdlib-blas-trans-1"><code>trans</code></a>. The matrix <code>A</code> is a general band matrix of dimension <code>m</code> by <code>size(A,2)</code> with <code>kl</code> sub-diagonals and <code>ku</code> super-diagonals. <code>alpha</code> and <code>beta</code> are scalars. Return the updated <code>y</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/blas.jl#L619-L625">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.BLAS.gbmv" href="#LinearAlgebra.BLAS.gbmv"><code>LinearAlgebra.BLAS.gbmv</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">gbmv(trans, m, kl, ku, alpha, A, x)</code></pre><p>Return <code>alpha*A*x</code> or <code>alpha*A&#39;*x</code> according to <a href="#stdlib-blas-trans-1"><code>trans</code></a>. The matrix <code>A</code> is a general band matrix of dimension <code>m</code> by <code>size(A,2)</code> with <code>kl</code> sub-diagonals and <code>ku</code> super-diagonals, and <code>alpha</code> is a scalar.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/blas.jl#L628-L634">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.BLAS.sbmv!" href="#LinearAlgebra.BLAS.sbmv!"><code>LinearAlgebra.BLAS.sbmv!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">sbmv!(uplo, k, alpha, A, x, beta, y)</code></pre><p>Update vector <code>y</code> as <code>alpha*A*x + beta*y</code> where <code>A</code> is a a symmetric band matrix of order <code>size(A,2)</code> with <code>k</code> super-diagonals stored in the argument <code>A</code>. The storage layout for <code>A</code> is described the reference BLAS module, level-2 BLAS at <a href="http://www.netlib.org/lapack/explore-html/">http://www.netlib.org/lapack/explore-html/</a>. Only the <a href="#stdlib-blas-uplo-1"><code>uplo</code></a> triangle of <code>A</code> is used.</p><p>Return the updated <code>y</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/blas.jl#L834-L844">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.BLAS.sbmv-NTuple{5,Any}" href="#LinearAlgebra.BLAS.sbmv-NTuple{5,Any}"><code>LinearAlgebra.BLAS.sbmv</code></a> â <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">sbmv(uplo, k, alpha, A, x)</code></pre><p>Return <code>alpha*A*x</code> where <code>A</code> is a symmetric band matrix of order <code>size(A,2)</code> with <code>k</code> super-diagonals stored in the argument <code>A</code>. Only the <a href="#stdlib-blas-uplo-1"><code>uplo</code></a> triangle of <code>A</code> is used.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/blas.jl#L816-L822">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.BLAS.sbmv-NTuple{4,Any}" href="#LinearAlgebra.BLAS.sbmv-NTuple{4,Any}"><code>LinearAlgebra.BLAS.sbmv</code></a> â <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">sbmv(uplo, k, A, x)</code></pre><p>Return <code>A*x</code> where <code>A</code> is a symmetric band matrix of order <code>size(A,2)</code> with <code>k</code> super-diagonals stored in the argument <code>A</code>. Only the <a href="#stdlib-blas-uplo-1"><code>uplo</code></a> triangle of <code>A</code> is used.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/blas.jl#L825-L831">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.BLAS.gemm!" href="#LinearAlgebra.BLAS.gemm!"><code>LinearAlgebra.BLAS.gemm!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">gemm!(tA, tB, alpha, A, B, beta, C)</code></pre><p>Update <code>C</code> as <code>alpha*A*B + beta*C</code> or the other three variants according to <a href="#stdlib-blas-trans-1"><code>tA</code></a> and <code>tB</code>. Return the updated <code>C</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/blas.jl#L1084-L1089">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.BLAS.gemm-NTuple{5,Any}" href="#LinearAlgebra.BLAS.gemm-NTuple{5,Any}"><code>LinearAlgebra.BLAS.gemm</code></a> â <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">gemm(tA, tB, alpha, A, B)</code></pre><p>Return <code>alpha*A*B</code> or the other three variants according to <a href="#stdlib-blas-trans-1"><code>tA</code></a> and <code>tB</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/blas.jl#L1140-L1144">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.BLAS.gemm-NTuple{4,Any}" href="#LinearAlgebra.BLAS.gemm-NTuple{4,Any}"><code>LinearAlgebra.BLAS.gemm</code></a> â <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">gemm(tA, tB, A, B)</code></pre><p>Return <code>A*B</code> or the other three variants according to <a href="#stdlib-blas-trans-1"><code>tA</code></a> and <code>tB</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/blas.jl#L1147-L1151">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.BLAS.gemv!" href="#LinearAlgebra.BLAS.gemv!"><code>LinearAlgebra.BLAS.gemv!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">gemv!(tA, alpha, A, x, beta, y)</code></pre><p>Update the vector <code>y</code> as <code>alpha*A*x + beta*y</code> or <code>alpha*A&#39;x + beta*y</code> according to <a href="#stdlib-blas-trans-1"><code>tA</code></a>. <code>alpha</code> and <code>beta</code> are scalars. Return the updated <code>y</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/blas.jl#L593-L599">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.BLAS.gemv-NTuple{4,Any}" href="#LinearAlgebra.BLAS.gemv-NTuple{4,Any}"><code>LinearAlgebra.BLAS.gemv</code></a> â <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">gemv(tA, alpha, A, x)</code></pre><p>Return <code>alpha*A*x</code> or <code>alpha*A&#39;x</code> according to <a href="#stdlib-blas-trans-1"><code>tA</code></a>. <code>alpha</code> is a scalar.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/blas.jl#L602-L607">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.BLAS.gemv-Tuple{Any,Any,Any}" href="#LinearAlgebra.BLAS.gemv-Tuple{Any,Any,Any}"><code>LinearAlgebra.BLAS.gemv</code></a> â <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">gemv(tA, A, x)</code></pre><p>Return <code>A*x</code> or <code>A&#39;x</code> according to <a href="#stdlib-blas-trans-1"><code>tA</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/blas.jl#L610-L614">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.BLAS.symm!" href="#LinearAlgebra.BLAS.symm!"><code>LinearAlgebra.BLAS.symm!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">symm!(side, ul, alpha, A, B, beta, C)</code></pre><p>Update <code>C</code> as <code>alpha*A*B + beta*C</code> or <code>alpha*B*A + beta*C</code> according to <a href="#stdlib-blas-side-1"><code>side</code></a>. <code>A</code> is assumed to be symmetric. Only the <a href="#stdlib-blas-uplo-1"><code>ul</code></a> triangle of <code>A</code> is used. Return the updated <code>C</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/blas.jl#L1217-L1223">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.BLAS.symm-NTuple{5,Any}" href="#LinearAlgebra.BLAS.symm-NTuple{5,Any}"><code>LinearAlgebra.BLAS.symm</code></a> â <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">symm(side, ul, alpha, A, B)</code></pre><p>Return <code>alpha*A*B</code> or <code>alpha*B*A</code> according to <a href="#stdlib-blas-side-1"><code>side</code></a>. <code>A</code> is assumed to be symmetric. Only the <a href="#stdlib-blas-uplo-1"><code>ul</code></a> triangle of <code>A</code> is used.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/blas.jl#L1199-L1205">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.BLAS.symm-NTuple{4,Any}" href="#LinearAlgebra.BLAS.symm-NTuple{4,Any}"><code>LinearAlgebra.BLAS.symm</code></a> â <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">symm(side, ul, A, B)</code></pre><p>Return <code>A*B</code> or <code>B*A</code> according to <a href="#stdlib-blas-side-1"><code>side</code></a>. <code>A</code> is assumed to be symmetric. Only the <a href="#stdlib-blas-uplo-1"><code>ul</code></a> triangle of <code>A</code> is used.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/blas.jl#L1208-L1214">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.BLAS.symv!" href="#LinearAlgebra.BLAS.symv!"><code>LinearAlgebra.BLAS.symv!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">symv!(ul, alpha, A, x, beta, y)</code></pre><p>Update the vector <code>y</code> as <code>alpha*A*x + beta*y</code>. <code>A</code> is assumed to be symmetric. Only the <a href="#stdlib-blas-uplo-1"><code>ul</code></a> triangle of <code>A</code> is used. <code>alpha</code> and <code>beta</code> are scalars. Return the updated <code>y</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/blas.jl#L675-L681">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.BLAS.symv-NTuple{4,Any}" href="#LinearAlgebra.BLAS.symv-NTuple{4,Any}"><code>LinearAlgebra.BLAS.symv</code></a> â <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">symv(ul, alpha, A, x)</code></pre><p>Return <code>alpha*A*x</code>. <code>A</code> is assumed to be symmetric. Only the <a href="#stdlib-blas-uplo-1"><code>ul</code></a> triangle of <code>A</code> is used. <code>alpha</code> is a scalar.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/blas.jl#L728-L734">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.BLAS.symv-Tuple{Any,Any,Any}" href="#LinearAlgebra.BLAS.symv-Tuple{Any,Any,Any}"><code>LinearAlgebra.BLAS.symv</code></a> â <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">symv(ul, A, x)</code></pre><p>Return <code>A*x</code>. <code>A</code> is assumed to be symmetric. Only the <a href="#stdlib-blas-uplo-1"><code>ul</code></a> triangle of <code>A</code> is used.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/blas.jl#L737-L742">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.BLAS.trmm!" href="#LinearAlgebra.BLAS.trmm!"><code>LinearAlgebra.BLAS.trmm!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">trmm!(side, ul, tA, dA, alpha, A, B)</code></pre><p>Update <code>B</code> as <code>alpha*A*B</code> or one of the other three variants determined by <a href="#stdlib-blas-side-1"><code>side</code></a> and <a href="#stdlib-blas-trans-1"><code>tA</code></a>. Only the <a href="#stdlib-blas-uplo-1"><code>ul</code></a> triangle of <code>A</code> is used. <a href="#stdlib-blas-diag-1"><code>dA</code></a> determines if the diagonal values are read or are assumed to be all ones. Returns the updated <code>B</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/blas.jl#L1473-L1482">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.BLAS.trmm" href="#LinearAlgebra.BLAS.trmm"><code>LinearAlgebra.BLAS.trmm</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">trmm(side, ul, tA, dA, alpha, A, B)</code></pre><p>Returns <code>alpha*A*B</code> or one of the other three variants determined by <a href="#stdlib-blas-side-1"><code>side</code></a> and <a href="#stdlib-blas-trans-1"><code>tA</code></a>. Only the <a href="#stdlib-blas-uplo-1"><code>ul</code></a> triangle of <code>A</code> is used. <a href="#stdlib-blas-diag-1"><code>dA</code></a> determines if the diagonal values are read or are assumed to be all ones.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/blas.jl#L1485-L1493">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.BLAS.trsm!" href="#LinearAlgebra.BLAS.trsm!"><code>LinearAlgebra.BLAS.trsm!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">trsm!(side, ul, tA, dA, alpha, A, B)</code></pre><p>Overwrite <code>B</code> with the solution to <code>A*X = alpha*B</code> or one of the other three variants determined by <a href="#stdlib-blas-side-1"><code>side</code></a> and <a href="#stdlib-blas-trans-1"><code>tA</code></a>. Only the <a href="#stdlib-blas-uplo-1"><code>ul</code></a> triangle of <code>A</code> is used. <a href="#stdlib-blas-diag-1"><code>dA</code></a> determines if the diagonal values are read or are assumed to be all ones. Returns the updated <code>B</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/blas.jl#L1496-L1505">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.BLAS.trsm" href="#LinearAlgebra.BLAS.trsm"><code>LinearAlgebra.BLAS.trsm</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">trsm(side, ul, tA, dA, alpha, A, B)</code></pre><p>Return the solution to <code>A*X = alpha*B</code> or one of the other three variants determined by determined by <a href="#stdlib-blas-side-1"><code>side</code></a> and <a href="#stdlib-blas-trans-1"><code>tA</code></a>. Only the <a href="#stdlib-blas-uplo-1"><code>ul</code></a> triangle of <code>A</code> is used. <a href="#stdlib-blas-diag-1"><code>dA</code></a> determines if the diagonal values are read or are assumed to be all ones.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/blas.jl#L1508-L1516">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.BLAS.trmv!" href="#LinearAlgebra.BLAS.trmv!"><code>LinearAlgebra.BLAS.trmv!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">trmv!(ul, tA, dA, A, b)</code></pre><p>Return <code>op(A)*b</code>, where <code>op</code> is determined by <a href="#stdlib-blas-trans-1"><code>tA</code></a>. Only the <a href="#stdlib-blas-uplo-1"><code>ul</code></a> triangle of <code>A</code> is used. <a href="#stdlib-blas-diag-1"><code>dA</code></a> determines if the diagonal values are read or are assumed to be all ones. The multiplication occurs in-place on <code>b</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/blas.jl#L892-L900">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.BLAS.trmv" href="#LinearAlgebra.BLAS.trmv"><code>LinearAlgebra.BLAS.trmv</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">trmv(ul, tA, dA, A, b)</code></pre><p>Return <code>op(A)*b</code>, where <code>op</code> is determined by <a href="#stdlib-blas-trans-1"><code>tA</code></a>. Only the <a href="#stdlib-blas-uplo-1"><code>ul</code></a> triangle of <code>A</code> is used. <a href="#stdlib-blas-diag-1"><code>dA</code></a> determines if the diagonal values are read or are assumed to be all ones.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/blas.jl#L882-L889">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.BLAS.trsv!" href="#LinearAlgebra.BLAS.trsv!"><code>LinearAlgebra.BLAS.trsv!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">trsv!(ul, tA, dA, A, b)</code></pre><p>Overwrite <code>b</code> with the solution to <code>A*x = b</code> or one of the other two variants determined by <a href="#stdlib-blas-trans-1"><code>tA</code></a> and <a href="#stdlib-blas-uplo-1"><code>ul</code></a>. <a href="#stdlib-blas-diag-1"><code>dA</code></a> determines if the diagonal values are read or are assumed to be all ones. Return the updated <code>b</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/blas.jl#L936-L944">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.BLAS.trsv" href="#LinearAlgebra.BLAS.trsv"><code>LinearAlgebra.BLAS.trsv</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">trsv(ul, tA, dA, A, b)</code></pre><p>Return the solution to <code>A*x = b</code> or one of the other two variants determined by <a href="#stdlib-blas-trans-1"><code>tA</code></a> and <a href="#stdlib-blas-uplo-1"><code>ul</code></a>. <a href="#stdlib-blas-diag-1"><code>dA</code></a> determines if the diagonal values are read or are assumed to be all ones.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/blas.jl#L947-L954">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.BLAS.set_num_threads" href="#LinearAlgebra.BLAS.set_num_threads"><code>LinearAlgebra.BLAS.set_num_threads</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">set_num_threads(n)</code></pre><p>Set the number of threads the BLAS library should use.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/blas.jl#L105-L109">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.I" href="#LinearAlgebra.I"><code>LinearAlgebra.I</code></a> â <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-none">I</code></pre><p>An object of type <a href="#LinearAlgebra.UniformScaling"><code>UniformScaling</code></a>, representing an identity matrix of any size.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; fill(1, (5,6)) * I == fill(1, (5,6))
true

julia&gt; [1 2im 3; 1im 2 3] * I
2Ã3 Array{Complex{Int64},2}:
 1+0im  0+2im  3+0im
 0+1im  2+0im  3+0im</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/uniformscaling.jl#L33-L48">source</a></section><h2><a class="nav-anchor" id="LAPACK-Functions-1" href="#LAPACK-Functions-1">LAPACK Functions</a></h2><p><code>LinearAlgebra.LAPACK</code> provides wrappers for some of the LAPACK functions for linear algebra.  Those functions that overwrite one of the input arrays have names ending in <code>&#39;!&#39;</code>.</p><p>Usually a function has 4 methods defined, one each for <a href="../../base/numbers/#Core.Float64"><code>Float64</code></a>, <a href="../../base/numbers/#Core.Float32"><code>Float32</code></a>, <code>ComplexF64</code> and <code>ComplexF32</code> arrays.</p><p>Note that the LAPACK API provided by Julia can and will change in the future. Since this API is not user-facing, there is no commitment to support/deprecate this specific set of functions in future releases.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.LAPACK" href="#LinearAlgebra.LAPACK"><code>LinearAlgebra.LAPACK</code></a> â <span class="docstring-category">Module</span>.</div><div><div><p>Interfaces to LAPACK subroutines.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L4-L6">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.LAPACK.gbtrf!" href="#LinearAlgebra.LAPACK.gbtrf!"><code>LinearAlgebra.LAPACK.gbtrf!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">gbtrf!(kl, ku, m, AB) -&gt; (AB, ipiv)</code></pre><p>Compute the LU factorization of a banded matrix <code>AB</code>. <code>kl</code> is the first subdiagonal containing a nonzero band, <code>ku</code> is the last superdiagonal containing one, and <code>m</code> is the first dimension of the matrix <code>AB</code>. Returns the LU factorization in-place and <code>ipiv</code>, the vector of pivots used.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L167-L174">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.LAPACK.gbtrs!" href="#LinearAlgebra.LAPACK.gbtrs!"><code>LinearAlgebra.LAPACK.gbtrs!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">gbtrs!(trans, kl, ku, m, AB, ipiv, B)</code></pre><p>Solve the equation <code>AB * X = B</code>. <code>trans</code> determines the orientation of <code>AB</code>. It may be <code>N</code> (no transpose), <code>T</code> (transpose), or <code>C</code> (conjugate transpose). <code>kl</code> is the first subdiagonal containing a nonzero band, <code>ku</code> is the last superdiagonal containing one, and <code>m</code> is the first dimension of the matrix <code>AB</code>. <code>ipiv</code> is the vector of pivots returned from <code>gbtrf!</code>. Returns the vector or matrix <code>X</code>, overwriting <code>B</code> in-place.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L177-L185">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.LAPACK.gebal!" href="#LinearAlgebra.LAPACK.gebal!"><code>LinearAlgebra.LAPACK.gebal!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">gebal!(job, A) -&gt; (ilo, ihi, scale)</code></pre><p>Balance the matrix <code>A</code> before computing its eigensystem or Schur factorization. <code>job</code> can be one of <code>N</code> (<code>A</code> will not be permuted or scaled), <code>P</code> (<code>A</code> will only be permuted), <code>S</code> (<code>A</code> will only be scaled), or <code>B</code> (<code>A</code> will be both permuted and scaled). Modifies <code>A</code> in-place and returns <code>ilo</code>, <code>ihi</code>, and <code>scale</code>. If permuting was turned on, <code>A[i,j] = 0</code> if <code>j &gt; i</code> and <code>1 &lt; j &lt; ilo</code> or <code>j &gt; ihi</code>. <code>scale</code> contains information about the scaling/permutations performed.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L242-L251">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.LAPACK.gebak!" href="#LinearAlgebra.LAPACK.gebak!"><code>LinearAlgebra.LAPACK.gebak!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">gebak!(job, side, ilo, ihi, scale, V)</code></pre><p>Transform the eigenvectors <code>V</code> of a matrix balanced using <code>gebal!</code> to the unscaled/unpermuted eigenvectors of the original matrix. Modifies <code>V</code> in-place. <code>side</code> can be <code>L</code> (left eigenvectors are transformed) or <code>R</code> (right eigenvectors are transformed).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L254-L261">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.LAPACK.gebrd!" href="#LinearAlgebra.LAPACK.gebrd!"><code>LinearAlgebra.LAPACK.gebrd!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">gebrd!(A) -&gt; (A, d, e, tauq, taup)</code></pre><p>Reduce <code>A</code> in-place to bidiagonal form <code>A = QBP&#39;</code>. Returns <code>A</code>, containing the bidiagonal matrix <code>B</code>; <code>d</code>, containing the diagonal elements of <code>B</code>; <code>e</code>, containing the off-diagonal elements of <code>B</code>; <code>tauq</code>, containing the elementary reflectors representing <code>Q</code>; and <code>taup</code>, containing the elementary reflectors representing <code>P</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L560-L568">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.LAPACK.gelqf!" href="#LinearAlgebra.LAPACK.gelqf!"><code>LinearAlgebra.LAPACK.gelqf!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">gelqf!(A, tau)</code></pre><p>Compute the <code>LQ</code> factorization of <code>A</code>, <code>A = LQ</code>. <code>tau</code> contains scalars which parameterize the elementary reflectors of the factorization. <code>tau</code> must have length greater than or equal to the smallest dimension of <code>A</code>.</p><p>Returns <code>A</code> and <code>tau</code> modified in-place.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L571-L580">source</a><div><div><pre><code class="language-none">gelqf!(A) -&gt; (A, tau)</code></pre><p>Compute the <code>LQ</code> factorization of <code>A</code>, <code>A = LQ</code>.</p><p>Returns <code>A</code>, modified in-place, and <code>tau</code>, which contains scalars which parameterize the elementary reflectors of the factorization.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L666-L673">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.LAPACK.geqlf!" href="#LinearAlgebra.LAPACK.geqlf!"><code>LinearAlgebra.LAPACK.geqlf!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">geqlf!(A, tau)</code></pre><p>Compute the <code>QL</code> factorization of <code>A</code>, <code>A = QL</code>. <code>tau</code> contains scalars which parameterize the elementary reflectors of the factorization. <code>tau</code> must have length greater than or equal to the smallest dimension of <code>A</code>.</p><p>Returns <code>A</code> and <code>tau</code> modified in-place.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L583-L591">source</a><div><div><pre><code class="language-none">geqlf!(A) -&gt; (A, tau)</code></pre><p>Compute the <code>QL</code> factorization of <code>A</code>, <code>A = QL</code>.</p><p>Returns <code>A</code>, modified in-place, and <code>tau</code>, which contains scalars which parameterize the elementary reflectors of the factorization.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L676-L683">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.LAPACK.geqrf!" href="#LinearAlgebra.LAPACK.geqrf!"><code>LinearAlgebra.LAPACK.geqrf!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">geqrf!(A, tau)</code></pre><p>Compute the <code>QR</code> factorization of <code>A</code>, <code>A = QR</code>. <code>tau</code> contains scalars which parameterize the elementary reflectors of the factorization. <code>tau</code> must have length greater than or equal to the smallest dimension of <code>A</code>.</p><p>Returns <code>A</code> and <code>tau</code> modified in-place.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L633-L641">source</a><div><div><pre><code class="language-none">geqrf!(A) -&gt; (A, tau)</code></pre><p>Compute the <code>QR</code> factorization of <code>A</code>, <code>A = QR</code>.</p><p>Returns <code>A</code>, modified in-place, and <code>tau</code>, which contains scalars which parameterize the elementary reflectors of the factorization.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L708-L715">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.LAPACK.geqp3!" href="#LinearAlgebra.LAPACK.geqp3!"><code>LinearAlgebra.LAPACK.geqp3!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">geqp3!(A, jpvt, tau)</code></pre><p>Compute the pivoted <code>QR</code> factorization of <code>A</code>, <code>AP = QR</code> using BLAS level 3. <code>P</code> is a pivoting matrix, represented by <code>jpvt</code>. <code>tau</code> stores the elementary reflectors. <code>jpvt</code> must have length length greater than or equal to <code>n</code> if <code>A</code> is an <code>(m x n)</code> matrix. <code>tau</code> must have length greater than or equal to the smallest dimension of <code>A</code>.</p><p><code>A</code>, <code>jpvt</code>, and <code>tau</code> are modified in-place.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L594-L604">source</a><div><div><pre><code class="language-none">geqp3!(A, jpvt) -&gt; (A, jpvt, tau)</code></pre><p>Compute the pivoted <code>QR</code> factorization of <code>A</code>, <code>AP = QR</code> using BLAS level 3. <code>P</code> is a pivoting matrix, represented by <code>jpvt</code>. <code>jpvt</code> must have length greater than or equal to <code>n</code> if <code>A</code> is an <code>(m x n)</code> matrix.</p><p>Returns <code>A</code> and <code>jpvt</code>, modified in-place, and <code>tau</code>, which stores the elementary reflectors.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L728-L737">source</a><div><div><pre><code class="language-none">geqp3!(A) -&gt; (A, jpvt, tau)</code></pre><p>Compute the pivoted <code>QR</code> factorization of <code>A</code>, <code>AP = QR</code> using BLAS level 3.</p><p>Returns <code>A</code>, modified in-place, <code>jpvt</code>, which represents the pivoting matrix <code>P</code>, and <code>tau</code>, which stores the elementary reflectors.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L743-L750">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.LAPACK.gerqf!" href="#LinearAlgebra.LAPACK.gerqf!"><code>LinearAlgebra.LAPACK.gerqf!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">gerqf!(A, tau)</code></pre><p>Compute the <code>RQ</code> factorization of <code>A</code>, <code>A = RQ</code>. <code>tau</code> contains scalars which parameterize the elementary reflectors of the factorization. <code>tau</code> must have length greater than or equal to the smallest dimension of <code>A</code>.</p><p>Returns <code>A</code> and <code>tau</code> modified in-place.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L644-L652">source</a><div><div><pre><code class="language-none">gerqf!(A) -&gt; (A, tau)</code></pre><p>Compute the <code>RQ</code> factorization of <code>A</code>, <code>A = RQ</code>.</p><p>Returns <code>A</code>, modified in-place, and <code>tau</code>, which contains scalars which parameterize the elementary reflectors of the factorization.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L718-L725">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.LAPACK.geqrt!" href="#LinearAlgebra.LAPACK.geqrt!"><code>LinearAlgebra.LAPACK.geqrt!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">geqrt!(A, T)</code></pre><p>Compute the blocked <code>QR</code> factorization of <code>A</code>, <code>A = QR</code>. <code>T</code> contains upper triangular block reflectors which parameterize the elementary reflectors of the factorization. The first dimension of <code>T</code> sets the block size and it must be between 1 and <code>n</code>. The second dimension of <code>T</code> must equal the smallest dimension of <code>A</code>.</p><p>Returns <code>A</code> and <code>T</code> modified in-place.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L607-L617">source</a><div><div><pre><code class="language-none">geqrt!(A, nb) -&gt; (A, T)</code></pre><p>Compute the blocked <code>QR</code> factorization of <code>A</code>, <code>A = QR</code>. <code>nb</code> sets the block size and it must be between 1 and <code>n</code>, the second dimension of <code>A</code>.</p><p>Returns <code>A</code>, modified in-place, and <code>T</code>, which contains upper triangular block reflectors which parameterize the elementary reflectors of the factorization.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L686-L695">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.LAPACK.geqrt3!" href="#LinearAlgebra.LAPACK.geqrt3!"><code>LinearAlgebra.LAPACK.geqrt3!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">geqrt3!(A, T)</code></pre><p>Recursively computes the blocked <code>QR</code> factorization of <code>A</code>, <code>A = QR</code>. <code>T</code> contains upper triangular block reflectors which parameterize the elementary reflectors of the factorization.  The first dimension of <code>T</code> sets the block size and it must be between 1 and <code>n</code>. The second dimension of <code>T</code> must equal the smallest dimension of <code>A</code>.</p><p>Returns <code>A</code> and <code>T</code> modified in-place.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L620-L630">source</a><div><div><pre><code class="language-none">geqrt3!(A) -&gt; (A, T)</code></pre><p>Recursively computes the blocked <code>QR</code> factorization of <code>A</code>, <code>A = QR</code>.</p><p>Returns <code>A</code>, modified in-place, and <code>T</code>, which contains upper triangular block reflectors which parameterize the elementary reflectors of the factorization.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L698-L705">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.LAPACK.getrf!" href="#LinearAlgebra.LAPACK.getrf!"><code>LinearAlgebra.LAPACK.getrf!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">getrf!(A) -&gt; (A, ipiv, info)</code></pre><p>Compute the pivoted <code>LU</code> factorization of <code>A</code>, <code>A = LU</code>.</p><p>Returns <code>A</code>, modified in-place, <code>ipiv</code>, the pivoting information, and an <code>info</code> code which indicates success (<code>info = 0</code>), a singular value in <code>U</code> (<code>info = i</code>, in which case <code>U[i,i]</code> is singular), or an error code (<code>info &lt; 0</code>).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L655-L663">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.LAPACK.tzrzf!" href="#LinearAlgebra.LAPACK.tzrzf!"><code>LinearAlgebra.LAPACK.tzrzf!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">tzrzf!(A) -&gt; (A, tau)</code></pre><p>Transforms the upper trapezoidal matrix <code>A</code> to upper triangular form in-place. Returns <code>A</code> and <code>tau</code>, the scalar parameters for the elementary reflectors of the transformation.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L853-L859">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.LAPACK.ormrz!" href="#LinearAlgebra.LAPACK.ormrz!"><code>LinearAlgebra.LAPACK.ormrz!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ormrz!(side, trans, A, tau, C)</code></pre><p>Multiplies the matrix <code>C</code> by <code>Q</code> from the transformation supplied by <code>tzrzf!</code>. Depending on <code>side</code> or <code>trans</code> the multiplication can be left-sided (<code>side = L, Q*C</code>) or right-sided (<code>side = R, C*Q</code>) and <code>Q</code> can be unmodified (<code>trans = N</code>), transposed (<code>trans = T</code>), or conjugate transposed (<code>trans = C</code>). Returns matrix <code>C</code> which is modified in-place with the result of the multiplication.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L841-L850">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.LAPACK.gels!" href="#LinearAlgebra.LAPACK.gels!"><code>LinearAlgebra.LAPACK.gels!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">gels!(trans, A, B) -&gt; (F, B, ssr)</code></pre><p>Solves the linear equation <code>A * X = B</code>, <code>transpose(A) * X = B</code>, or <code>adjoint(A) * X = B</code> using a QR or LQ factorization. Modifies the matrix/vector <code>B</code> in place with the solution. <code>A</code> is overwritten with its <code>QR</code> or <code>LQ</code> factorization. <code>trans</code> may be one of <code>N</code> (no modification), <code>T</code> (transpose), or <code>C</code> (conjugate transpose). <code>gels!</code> searches for the minimum norm/least squares solution. <code>A</code> may be under or over determined. The solution is returned in <code>B</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L993-L1002">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.LAPACK.gesv!" href="#LinearAlgebra.LAPACK.gesv!"><code>LinearAlgebra.LAPACK.gesv!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">gesv!(A, B) -&gt; (B, A, ipiv)</code></pre><p>Solves the linear equation <code>A * X = B</code> where <code>A</code> is a square matrix using the <code>LU</code> factorization of <code>A</code>. <code>A</code> is overwritten with its <code>LU</code> factorization and <code>B</code> is overwritten with the solution <code>X</code>. <code>ipiv</code> contains the pivoting information for the <code>LU</code> factorization of <code>A</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L1005-L1012">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.LAPACK.getrs!" href="#LinearAlgebra.LAPACK.getrs!"><code>LinearAlgebra.LAPACK.getrs!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">getrs!(trans, A, ipiv, B)</code></pre><p>Solves the linear equation <code>A * X = B</code>, <code>transpose(A) * X = B</code>, or <code>adjoint(A) * X = B</code> for square <code>A</code>. Modifies the matrix/vector <code>B</code> in place with the solution. <code>A</code> is the <code>LU</code> factorization from <code>getrf!</code>, with <code>ipiv</code> the pivoting information. <code>trans</code> may be one of <code>N</code> (no modification), <code>T</code> (transpose), or <code>C</code> (conjugate transpose).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L1015-L1023">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.LAPACK.getri!" href="#LinearAlgebra.LAPACK.getri!"><code>LinearAlgebra.LAPACK.getri!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">getri!(A, ipiv)</code></pre><p>Computes the inverse of <code>A</code>, using its <code>LU</code> factorization found by <code>getrf!</code>. <code>ipiv</code> is the pivot information output and <code>A</code> contains the <code>LU</code> factorization of <code>getrf!</code>. <code>A</code> is overwritten with its inverse.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L1026-L1033">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.LAPACK.gesvx!" href="#LinearAlgebra.LAPACK.gesvx!"><code>LinearAlgebra.LAPACK.gesvx!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">gesvx!(fact, trans, A, AF, ipiv, equed, R, C, B) -&gt; (X, equed, R, C, B, rcond, ferr, berr, work)</code></pre><p>Solves the linear equation <code>A * X = B</code> (<code>trans = N</code>), <code>transpose(A) * X = B</code> (<code>trans = T</code>), or <code>adjoint(A) * X = B</code> (<code>trans = C</code>) using the <code>LU</code> factorization of <code>A</code>. <code>fact</code> may be <code>E</code>, in which case <code>A</code> will be equilibrated and copied to <code>AF</code>; <code>F</code>, in which case <code>AF</code> and <code>ipiv</code> from a previous <code>LU</code> factorization are inputs; or <code>N</code>, in which case <code>A</code> will be copied to <code>AF</code> and then factored. If <code>fact = F</code>, <code>equed</code> may be <code>N</code>, meaning <code>A</code> has not been equilibrated; <code>R</code>, meaning <code>A</code> was multiplied by <code>Diagonal(R)</code> from the left; <code>C</code>, meaning <code>A</code> was multiplied by <code>Diagonal(C)</code> from the right; or <code>B</code>, meaning <code>A</code> was multiplied by <code>Diagonal(R)</code> from the left and <code>Diagonal(C)</code> from the right. If <code>fact = F</code> and <code>equed = R</code> or <code>B</code> the elements of <code>R</code> must all be positive. If <code>fact = F</code> and <code>equed = C</code> or <code>B</code> the elements of <code>C</code> must all be positive.</p><p>Returns the solution <code>X</code>; <code>equed</code>, which is an output if <code>fact</code> is not <code>N</code>, and describes the equilibration that was performed; <code>R</code>, the row equilibration diagonal; <code>C</code>, the column equilibration diagonal; <code>B</code>, which may be overwritten with its equilibrated form <code>Diagonal(R)*B</code> (if <code>trans = N</code> and <code>equed = R,B</code>) or <code>Diagonal(C)*B</code> (if <code>trans = T,C</code> and <code>equed = C,B</code>); <code>rcond</code>, the reciprocal condition number of <code>A</code> after equilbrating; <code>ferr</code>, the forward error bound for each solution vector in <code>X</code>; <code>berr</code>, the forward error bound for each solution vector in <code>X</code>; and <code>work</code>, the reciprocal pivot growth factor.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L1178-L1201">source</a><div><div><pre><code class="language-none">gesvx!(A, B)</code></pre><p>The no-equilibration, no-transpose simplification of <code>gesvx!</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L1205-L1209">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.LAPACK.gelsd!" href="#LinearAlgebra.LAPACK.gelsd!"><code>LinearAlgebra.LAPACK.gelsd!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">gelsd!(A, B, rcond) -&gt; (B, rnk)</code></pre><p>Computes the least norm solution of <code>A * X = B</code> by finding the <code>SVD</code> factorization of <code>A</code>, then dividing-and-conquering the problem. <code>B</code> is overwritten with the solution <code>X</code>. Singular values below <code>rcond</code> will be treated as zero. Returns the solution in <code>B</code> and the effective rank of <code>A</code> in <code>rnk</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L1404-L1412">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.LAPACK.gelsy!" href="#LinearAlgebra.LAPACK.gelsy!"><code>LinearAlgebra.LAPACK.gelsy!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">gelsy!(A, B, rcond) -&gt; (B, rnk)</code></pre><p>Computes the least norm solution of <code>A * X = B</code> by finding the full <code>QR</code> factorization of <code>A</code>, then dividing-and-conquering the problem. <code>B</code> is overwritten with the solution <code>X</code>. Singular values below <code>rcond</code> will be treated as zero. Returns the solution in <code>B</code> and the effective rank of <code>A</code> in <code>rnk</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L1415-L1423">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.LAPACK.gglse!" href="#LinearAlgebra.LAPACK.gglse!"><code>LinearAlgebra.LAPACK.gglse!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">gglse!(A, c, B, d) -&gt; (X,res)</code></pre><p>Solves the equation <code>A * x = c</code> where <code>x</code> is subject to the equality constraint <code>B * x = d</code>. Uses the formula <code>||c - A*x||^2 = 0</code> to solve. Returns <code>X</code> and the residual sum-of-squares.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L1477-L1483">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.LAPACK.geev!" href="#LinearAlgebra.LAPACK.geev!"><code>LinearAlgebra.LAPACK.geev!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">geev!(jobvl, jobvr, A) -&gt; (W, VL, VR)</code></pre><p>Finds the eigensystem of <code>A</code>. If <code>jobvl = N</code>, the left eigenvectors of <code>A</code> aren&#39;t computed. If <code>jobvr = N</code>, the right eigenvectors of <code>A</code> aren&#39;t computed. If <code>jobvl = V</code> or <code>jobvr = V</code>, the corresponding eigenvectors are computed. Returns the eigenvalues in <code>W</code>, the right eigenvectors in <code>VR</code>, and the left eigenvectors in <code>VL</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L1774-L1782">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.LAPACK.gesdd!" href="#LinearAlgebra.LAPACK.gesdd!"><code>LinearAlgebra.LAPACK.gesdd!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">gesdd!(job, A) -&gt; (U, S, VT)</code></pre><p>Finds the singular value decomposition of <code>A</code>, <code>A = U * S * V&#39;</code>, using a divide and conquer approach. If <code>job = A</code>, all the columns of <code>U</code> and the rows of <code>V&#39;</code> are computed. If <code>job = N</code>, no columns of <code>U</code> or rows of <code>V&#39;</code> are computed. If <code>job = O</code>, <code>A</code> is overwritten with the columns of (thin) <code>U</code> and the rows of (thin) <code>V&#39;</code>. If <code>job = S</code>, the columns of (thin) <code>U</code> and the rows of (thin) <code>V&#39;</code> are computed and returned separately.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L1785-L1794">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.LAPACK.gesvd!" href="#LinearAlgebra.LAPACK.gesvd!"><code>LinearAlgebra.LAPACK.gesvd!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">gesvd!(jobu, jobvt, A) -&gt; (U, S, VT)</code></pre><p>Finds the singular value decomposition of <code>A</code>, <code>A = U * S * V&#39;</code>. If <code>jobu = A</code>, all the columns of <code>U</code> are computed. If <code>jobvt = A</code> all the rows of <code>V&#39;</code> are computed. If <code>jobu = N</code>, no columns of <code>U</code> are computed. If <code>jobvt = N</code> no rows of <code>V&#39;</code> are computed. If <code>jobu = O</code>, <code>A</code> is overwritten with the columns of (thin) <code>U</code>. If <code>jobvt = O</code>, <code>A</code> is overwritten with the rows of (thin) <code>V&#39;</code>. If <code>jobu = S</code>, the columns of (thin) <code>U</code> are computed and returned separately. If <code>jobvt = S</code> the rows of (thin) <code>V&#39;</code> are computed and returned separately. <code>jobu</code> and <code>jobvt</code> can&#39;t both be <code>O</code>.</p><p>Returns <code>U</code>, <code>S</code>, and <code>Vt</code>, where <code>S</code> are the singular values of <code>A</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L1797-L1810">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.LAPACK.ggsvd!" href="#LinearAlgebra.LAPACK.ggsvd!"><code>LinearAlgebra.LAPACK.ggsvd!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ggsvd!(jobu, jobv, jobq, A, B) -&gt; (U, V, Q, alpha, beta, k, l, R)</code></pre><p>Finds the generalized singular value decomposition of <code>A</code> and <code>B</code>, <code>U&#39;*A*Q = D1*R</code> and <code>V&#39;*B*Q = D2*R</code>. <code>D1</code> has <code>alpha</code> on its diagonal and <code>D2</code> has <code>beta</code> on its diagonal. If <code>jobu = U</code>, the orthogonal/unitary matrix <code>U</code> is computed. If <code>jobv = V</code> the orthogonal/unitary matrix <code>V</code> is computed. If <code>jobq = Q</code>, the orthogonal/unitary matrix <code>Q</code> is computed. If <code>jobu</code>, <code>jobv</code> or <code>jobq</code> is <code>N</code>, that matrix is not computed. This function is only available in LAPACK versions prior to 3.6.0.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L1813-L1823">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.LAPACK.ggsvd3!" href="#LinearAlgebra.LAPACK.ggsvd3!"><code>LinearAlgebra.LAPACK.ggsvd3!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ggsvd3!(jobu, jobv, jobq, A, B) -&gt; (U, V, Q, alpha, beta, k, l, R)</code></pre><p>Finds the generalized singular value decomposition of <code>A</code> and <code>B</code>, <code>U&#39;*A*Q = D1*R</code> and <code>V&#39;*B*Q = D2*R</code>. <code>D1</code> has <code>alpha</code> on its diagonal and <code>D2</code> has <code>beta</code> on its diagonal. If <code>jobu = U</code>, the orthogonal/unitary matrix <code>U</code> is computed. If <code>jobv = V</code> the orthogonal/unitary matrix <code>V</code> is computed. If <code>jobq = Q</code>, the orthogonal/unitary matrix <code>Q</code> is computed. If <code>jobu</code>, <code>jobv</code>, or <code>jobq</code> is <code>N</code>, that matrix is not computed. This function requires LAPACK 3.6.0.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L1944-L1953">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.LAPACK.geevx!" href="#LinearAlgebra.LAPACK.geevx!"><code>LinearAlgebra.LAPACK.geevx!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">geevx!(balanc, jobvl, jobvr, sense, A) -&gt; (A, w, VL, VR, ilo, ihi, scale, abnrm, rconde, rcondv)</code></pre><p>Finds the eigensystem of <code>A</code> with matrix balancing. If <code>jobvl = N</code>, the left eigenvectors of <code>A</code> aren&#39;t computed. If <code>jobvr = N</code>, the right eigenvectors of <code>A</code> aren&#39;t computed. If <code>jobvl = V</code> or <code>jobvr = V</code>, the corresponding eigenvectors are computed. If <code>balanc = N</code>, no balancing is performed. If <code>balanc = P</code>, <code>A</code> is permuted but not scaled. If <code>balanc = S</code>, <code>A</code> is scaled but not permuted. If <code>balanc = B</code>, <code>A</code> is permuted and scaled. If <code>sense = N</code>, no reciprocal condition numbers are computed. If <code>sense = E</code>, reciprocal condition numbers are computed for the eigenvalues only. If <code>sense = V</code>, reciprocal condition numbers are computed for the right eigenvectors only. If <code>sense = B</code>, reciprocal condition numbers are computed for the right eigenvectors and the eigenvectors. If <code>sense = E,B</code>, the right and left eigenvectors must be computed.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L2256-L2272">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.LAPACK.ggev!" href="#LinearAlgebra.LAPACK.ggev!"><code>LinearAlgebra.LAPACK.ggev!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ggev!(jobvl, jobvr, A, B) -&gt; (alpha, beta, vl, vr)</code></pre><p>Finds the generalized eigendecomposition of <code>A</code> and <code>B</code>. If <code>jobvl = N</code>, the left eigenvectors aren&#39;t computed. If <code>jobvr = N</code>, the right eigenvectors aren&#39;t computed. If <code>jobvl = V</code> or <code>jobvr = V</code>, the corresponding eigenvectors are computed.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L2275-L2282">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.LAPACK.gtsv!" href="#LinearAlgebra.LAPACK.gtsv!"><code>LinearAlgebra.LAPACK.gtsv!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">gtsv!(dl, d, du, B)</code></pre><p>Solves the equation <code>A * X = B</code> where <code>A</code> is a tridiagonal matrix with <code>dl</code> on the subdiagonal, <code>d</code> on the diagonal, and <code>du</code> on the superdiagonal.</p><p>Overwrites <code>B</code> with the solution <code>X</code> and returns it.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L2454-L2462">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.LAPACK.gttrf!" href="#LinearAlgebra.LAPACK.gttrf!"><code>LinearAlgebra.LAPACK.gttrf!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">gttrf!(dl, d, du) -&gt; (dl, d, du, du2, ipiv)</code></pre><p>Finds the <code>LU</code> factorization of a tridiagonal matrix with <code>dl</code> on the subdiagonal, <code>d</code> on the diagonal, and <code>du</code> on the superdiagonal.</p><p>Modifies <code>dl</code>, <code>d</code>, and <code>du</code> in-place and returns them and the second superdiagonal <code>du2</code> and the pivoting vector <code>ipiv</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L2465-L2473">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.LAPACK.gttrs!" href="#LinearAlgebra.LAPACK.gttrs!"><code>LinearAlgebra.LAPACK.gttrs!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">gttrs!(trans, dl, d, du, du2, ipiv, B)</code></pre><p>Solves the equation <code>A * X = B</code> (<code>trans = N</code>), <code>transpose(A) * X = B</code> (<code>trans = T</code>), or <code>adjoint(A) * X = B</code> (<code>trans = C</code>) using the <code>LU</code> factorization computed by <code>gttrf!</code>. <code>B</code> is overwritten with the solution <code>X</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L2476-L2482">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.LAPACK.orglq!" href="#LinearAlgebra.LAPACK.orglq!"><code>LinearAlgebra.LAPACK.orglq!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">orglq!(A, tau, k = length(tau))</code></pre><p>Explicitly finds the matrix <code>Q</code> of a <code>LQ</code> factorization after calling <code>gelqf!</code> on <code>A</code>. Uses the output of <code>gelqf!</code>. <code>A</code> is overwritten by <code>Q</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L2883-L2888">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.LAPACK.orgqr!" href="#LinearAlgebra.LAPACK.orgqr!"><code>LinearAlgebra.LAPACK.orgqr!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">orgqr!(A, tau, k = length(tau))</code></pre><p>Explicitly finds the matrix <code>Q</code> of a <code>QR</code> factorization after calling <code>geqrf!</code> on <code>A</code>. Uses the output of <code>geqrf!</code>. <code>A</code> is overwritten by <code>Q</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L2891-L2896">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.LAPACK.orgql!" href="#LinearAlgebra.LAPACK.orgql!"><code>LinearAlgebra.LAPACK.orgql!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">orgql!(A, tau, k = length(tau))</code></pre><p>Explicitly finds the matrix <code>Q</code> of a <code>QL</code> factorization after calling <code>geqlf!</code> on <code>A</code>. Uses the output of <code>geqlf!</code>. <code>A</code> is overwritten by <code>Q</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L2899-L2904">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.LAPACK.orgrq!" href="#LinearAlgebra.LAPACK.orgrq!"><code>LinearAlgebra.LAPACK.orgrq!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">orgrq!(A, tau, k = length(tau))</code></pre><p>Explicitly finds the matrix <code>Q</code> of a <code>RQ</code> factorization after calling <code>gerqf!</code> on <code>A</code>. Uses the output of <code>gerqf!</code>. <code>A</code> is overwritten by <code>Q</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L2907-L2912">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.LAPACK.ormlq!" href="#LinearAlgebra.LAPACK.ormlq!"><code>LinearAlgebra.LAPACK.ormlq!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ormlq!(side, trans, A, tau, C)</code></pre><p>Computes <code>Q * C</code> (<code>trans = N</code>), <code>transpose(Q) * C</code> (<code>trans = T</code>), <code>adjoint(Q) * C</code> (<code>trans = C</code>) for <code>side = L</code> or the equivalent right-sided multiplication for <code>side = R</code> using <code>Q</code> from a <code>LQ</code> factorization of <code>A</code> computed using <code>gelqf!</code>. <code>C</code> is overwritten.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L2915-L2922">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.LAPACK.ormqr!" href="#LinearAlgebra.LAPACK.ormqr!"><code>LinearAlgebra.LAPACK.ormqr!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ormqr!(side, trans, A, tau, C)</code></pre><p>Computes <code>Q * C</code> (<code>trans = N</code>), <code>transpose(Q) * C</code> (<code>trans = T</code>), <code>adjoint(Q) * C</code> (<code>trans = C</code>) for <code>side = L</code> or the equivalent right-sided multiplication for <code>side = R</code> using <code>Q</code> from a <code>QR</code> factorization of <code>A</code> computed using <code>geqrf!</code>. <code>C</code> is overwritten.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L2925-L2932">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.LAPACK.ormql!" href="#LinearAlgebra.LAPACK.ormql!"><code>LinearAlgebra.LAPACK.ormql!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ormql!(side, trans, A, tau, C)</code></pre><p>Computes <code>Q * C</code> (<code>trans = N</code>), <code>transpose(Q) * C</code> (<code>trans = T</code>), <code>adjoint(Q) * C</code> (<code>trans = C</code>) for <code>side = L</code> or the equivalent right-sided multiplication for <code>side = R</code> using <code>Q</code> from a <code>QL</code> factorization of <code>A</code> computed using <code>geqlf!</code>. <code>C</code> is overwritten.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L2935-L2942">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.LAPACK.ormrq!" href="#LinearAlgebra.LAPACK.ormrq!"><code>LinearAlgebra.LAPACK.ormrq!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ormrq!(side, trans, A, tau, C)</code></pre><p>Computes <code>Q * C</code> (<code>trans = N</code>), <code>transpose(Q) * C</code> (<code>trans = T</code>), <code>adjoint(Q) * C</code> (<code>trans = C</code>) for <code>side = L</code> or the equivalent right-sided multiplication for <code>side = R</code> using <code>Q</code> from a <code>RQ</code> factorization of <code>A</code> computed using <code>gerqf!</code>. <code>C</code> is overwritten.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L2945-L2952">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.LAPACK.gemqrt!" href="#LinearAlgebra.LAPACK.gemqrt!"><code>LinearAlgebra.LAPACK.gemqrt!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">gemqrt!(side, trans, V, T, C)</code></pre><p>Computes <code>Q * C</code> (<code>trans = N</code>), <code>transpose(Q) * C</code> (<code>trans = T</code>), <code>adjoint(Q) * C</code> (<code>trans = C</code>) for <code>side = L</code> or the equivalent right-sided multiplication for <code>side = R</code> using <code>Q</code> from a <code>QR</code> factorization of <code>A</code> computed using <code>geqrt!</code>. <code>C</code> is overwritten.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L2955-L2962">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.LAPACK.posv!" href="#LinearAlgebra.LAPACK.posv!"><code>LinearAlgebra.LAPACK.posv!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">posv!(uplo, A, B) -&gt; (A, B)</code></pre><p>Finds the solution to <code>A * X = B</code> where <code>A</code> is a symmetric or Hermitian positive definite matrix. If <code>uplo = U</code> the upper Cholesky decomposition of <code>A</code> is computed. If <code>uplo = L</code> the lower Cholesky decomposition of <code>A</code> is computed. <code>A</code> is overwritten by its Cholesky decomposition. <code>B</code> is overwritten with the solution <code>X</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L3097-L3105">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.LAPACK.potrf!" href="#LinearAlgebra.LAPACK.potrf!"><code>LinearAlgebra.LAPACK.potrf!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">potrf!(uplo, A)</code></pre><p>Computes the Cholesky (upper if <code>uplo = U</code>, lower if <code>uplo = L</code>) decomposition of positive-definite matrix <code>A</code>. <code>A</code> is overwritten and returned with an info code.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L3108-L3114">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.LAPACK.potri!" href="#LinearAlgebra.LAPACK.potri!"><code>LinearAlgebra.LAPACK.potri!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">potri!(uplo, A)</code></pre><p>Computes the inverse of positive-definite matrix <code>A</code> after calling <code>potrf!</code> to find its (upper if <code>uplo = U</code>, lower if <code>uplo = L</code>) Cholesky decomposition.</p><p><code>A</code> is overwritten by its inverse and returned.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L3117-L3125">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.LAPACK.potrs!" href="#LinearAlgebra.LAPACK.potrs!"><code>LinearAlgebra.LAPACK.potrs!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">potrs!(uplo, A, B)</code></pre><p>Finds the solution to <code>A * X = B</code> where <code>A</code> is a symmetric or Hermitian positive definite matrix whose Cholesky decomposition was computed by <code>potrf!</code>. If <code>uplo = U</code> the upper Cholesky decomposition of <code>A</code> was computed. If <code>uplo = L</code> the lower Cholesky decomposition of <code>A</code> was computed. <code>B</code> is overwritten with the solution <code>X</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L3128-L3136">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.LAPACK.pstrf!" href="#LinearAlgebra.LAPACK.pstrf!"><code>LinearAlgebra.LAPACK.pstrf!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">pstrf!(uplo, A, tol) -&gt; (A, piv, rank, info)</code></pre><p>Computes the (upper if <code>uplo = U</code>, lower if <code>uplo = L</code>) pivoted Cholesky decomposition of positive-definite matrix <code>A</code> with a user-set tolerance <code>tol</code>. <code>A</code> is overwritten by its Cholesky decomposition.</p><p>Returns <code>A</code>, the pivots <code>piv</code>, the rank of <code>A</code>, and an <code>info</code> code. If <code>info = 0</code>, the factorization succeeded. If <code>info = i &gt; 0</code>, then <code>A</code> is indefinite or rank-deficient.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L3139-L3149">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.LAPACK.ptsv!" href="#LinearAlgebra.LAPACK.ptsv!"><code>LinearAlgebra.LAPACK.ptsv!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ptsv!(D, E, B)</code></pre><p>Solves <code>A * X = B</code> for positive-definite tridiagonal <code>A</code>. <code>D</code> is the diagonal of <code>A</code> and <code>E</code> is the off-diagonal. <code>B</code> is overwritten with the solution <code>X</code> and returned.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L3206-L3212">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.LAPACK.pttrf!" href="#LinearAlgebra.LAPACK.pttrf!"><code>LinearAlgebra.LAPACK.pttrf!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">pttrf!(D, E)</code></pre><p>Computes the LDLt factorization of a positive-definite tridiagonal matrix with <code>D</code> as diagonal and <code>E</code> as off-diagonal. <code>D</code> and <code>E</code> are overwritten and returned.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L3215-L3221">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.LAPACK.pttrs!" href="#LinearAlgebra.LAPACK.pttrs!"><code>LinearAlgebra.LAPACK.pttrs!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">pttrs!(D, E, B)</code></pre><p>Solves <code>A * X = B</code> for positive-definite tridiagonal <code>A</code> with diagonal <code>D</code> and off-diagonal <code>E</code> after computing <code>A</code>&#39;s LDLt factorization using <code>pttrf!</code>. <code>B</code> is overwritten with the solution <code>X</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L3288-L3294">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.LAPACK.trtri!" href="#LinearAlgebra.LAPACK.trtri!"><code>LinearAlgebra.LAPACK.trtri!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">trtri!(uplo, diag, A)</code></pre><p>Finds the inverse of (upper if <code>uplo = U</code>, lower if <code>uplo = L</code>) triangular matrix <code>A</code>. If <code>diag = N</code>, <code>A</code> has non-unit diagonal elements. If <code>diag = U</code>, all diagonal elements of <code>A</code> are one. <code>A</code> is overwritten with its inverse.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L3354-L3361">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.LAPACK.trtrs!" href="#LinearAlgebra.LAPACK.trtrs!"><code>LinearAlgebra.LAPACK.trtrs!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">trtrs!(uplo, trans, diag, A, B)</code></pre><p>Solves <code>A * X = B</code> (<code>trans = N</code>), <code>transpose(A) * X = B</code> (<code>trans = T</code>), or <code>adjoint(A) * X = B</code> (<code>trans = C</code>) for (upper if <code>uplo = U</code>, lower if <code>uplo = L</code>) triangular matrix <code>A</code>. If <code>diag = N</code>, <code>A</code> has non-unit diagonal elements. If <code>diag = U</code>, all diagonal elements of <code>A</code> are one. <code>B</code> is overwritten with the solution <code>X</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L3364-L3372">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.LAPACK.trcon!" href="#LinearAlgebra.LAPACK.trcon!"><code>LinearAlgebra.LAPACK.trcon!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">trcon!(norm, uplo, diag, A)</code></pre><p>Finds the reciprocal condition number of (upper if <code>uplo = U</code>, lower if <code>uplo = L</code>) triangular matrix <code>A</code>. If <code>diag = N</code>, <code>A</code> has non-unit diagonal elements. If <code>diag = U</code>, all diagonal elements of <code>A</code> are one. If <code>norm = I</code>, the condition number is found in the infinity norm. If <code>norm = O</code> or <code>1</code>, the condition number is found in the one norm.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L3639-L3647">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.LAPACK.trevc!" href="#LinearAlgebra.LAPACK.trevc!"><code>LinearAlgebra.LAPACK.trevc!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">trevc!(side, howmny, select, T, VL = similar(T), VR = similar(T))</code></pre><p>Finds the eigensystem of an upper triangular matrix <code>T</code>. If <code>side = R</code>, the right eigenvectors are computed. If <code>side = L</code>, the left eigenvectors are computed. If <code>side = B</code>, both sets are computed. If <code>howmny = A</code>, all eigenvectors are found. If <code>howmny = B</code>, all eigenvectors are found and backtransformed using <code>VL</code> and <code>VR</code>. If <code>howmny = S</code>, only the eigenvectors corresponding to the values in <code>select</code> are computed.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L3650-L3660">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.LAPACK.trrfs!" href="#LinearAlgebra.LAPACK.trrfs!"><code>LinearAlgebra.LAPACK.trrfs!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">trrfs!(uplo, trans, diag, A, B, X, Ferr, Berr) -&gt; (Ferr, Berr)</code></pre><p>Estimates the error in the solution to <code>A * X = B</code> (<code>trans = N</code>), <code>transpose(A) * X = B</code> (<code>trans = T</code>), <code>adjoint(A) * X = B</code> (<code>trans = C</code>) for <code>side = L</code>, or the equivalent equations a right-handed <code>side = R</code> <code>X * A</code> after computing <code>X</code> using <code>trtrs!</code>. If <code>uplo = U</code>, <code>A</code> is upper triangular. If <code>uplo = L</code>, <code>A</code> is lower triangular. If <code>diag = N</code>, <code>A</code> has non-unit diagonal elements. If <code>diag = U</code>, all diagonal elements of <code>A</code> are one. <code>Ferr</code> and <code>Berr</code> are optional inputs. <code>Ferr</code> is the forward error and <code>Berr</code> is the backward error, each component-wise.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L3664-L3675">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.LAPACK.stev!" href="#LinearAlgebra.LAPACK.stev!"><code>LinearAlgebra.LAPACK.stev!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">stev!(job, dv, ev) -&gt; (dv, Zmat)</code></pre><p>Computes the eigensystem for a symmetric tridiagonal matrix with <code>dv</code> as diagonal and <code>ev</code> as off-diagonal. If <code>job = N</code> only the eigenvalues are found and returned in <code>dv</code>. If <code>job = V</code> then the eigenvectors are also found and returned in <code>Zmat</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L3840-L3847">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.LAPACK.stebz!" href="#LinearAlgebra.LAPACK.stebz!"><code>LinearAlgebra.LAPACK.stebz!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">stebz!(range, order, vl, vu, il, iu, abstol, dv, ev) -&gt; (dv, iblock, isplit)</code></pre><p>Computes the eigenvalues for a symmetric tridiagonal matrix with <code>dv</code> as diagonal and <code>ev</code> as off-diagonal. If <code>range = A</code>, all the eigenvalues are found. If <code>range = V</code>, the eigenvalues in the half-open interval <code>(vl, vu]</code> are found. If <code>range = I</code>, the eigenvalues with indices between <code>il</code> and <code>iu</code> are found. If <code>order = B</code>, eigvalues are ordered within a block. If <code>order = E</code>, they are ordered across all the blocks. <code>abstol</code> can be set as a tolerance for convergence.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L3850-L3860">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.LAPACK.stegr!" href="#LinearAlgebra.LAPACK.stegr!"><code>LinearAlgebra.LAPACK.stegr!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">stegr!(jobz, range, dv, ev, vl, vu, il, iu) -&gt; (w, Z)</code></pre><p>Computes the eigenvalues (<code>jobz = N</code>) or eigenvalues and eigenvectors (<code>jobz = V</code>) for a symmetric tridiagonal matrix with <code>dv</code> as diagonal and <code>ev</code> as off-diagonal. If <code>range = A</code>, all the eigenvalues are found. If <code>range = V</code>, the eigenvalues in the half-open interval <code>(vl, vu]</code> are found. If <code>range = I</code>, the eigenvalues with indices between <code>il</code> and <code>iu</code> are found. The eigenvalues are returned in <code>w</code> and the eigenvectors in <code>Z</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L3863-L3873">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.LAPACK.stein!" href="#LinearAlgebra.LAPACK.stein!"><code>LinearAlgebra.LAPACK.stein!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">stein!(dv, ev_in, w_in, iblock_in, isplit_in)</code></pre><p>Computes the eigenvectors for a symmetric tridiagonal matrix with <code>dv</code> as diagonal and <code>ev_in</code> as off-diagonal. <code>w_in</code> specifies the input eigenvalues for which to find corresponding eigenvectors. <code>iblock_in</code> specifies the submatrices corresponding to the eigenvalues in <code>w_in</code>. <code>isplit_in</code> specifies the splitting points between the submatrix blocks.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L3876-L3884">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.LAPACK.syconv!" href="#LinearAlgebra.LAPACK.syconv!"><code>LinearAlgebra.LAPACK.syconv!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">syconv!(uplo, A, ipiv) -&gt; (A, work)</code></pre><p>Converts a symmetric matrix <code>A</code> (which has been factorized into a triangular matrix) into two matrices <code>L</code> and <code>D</code>. If <code>uplo = U</code>, <code>A</code> is upper triangular. If <code>uplo = L</code>, it is lower triangular. <code>ipiv</code> is the pivot vector from the triangular factorization. <code>A</code> is overwritten by <code>L</code> and <code>D</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L4838-L4846">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.LAPACK.sysv!" href="#LinearAlgebra.LAPACK.sysv!"><code>LinearAlgebra.LAPACK.sysv!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">sysv!(uplo, A, B) -&gt; (B, A, ipiv)</code></pre><p>Finds the solution to <code>A * X = B</code> for symmetric matrix <code>A</code>. If <code>uplo = U</code>, the upper half of <code>A</code> is stored. If <code>uplo = L</code>, the lower half is stored. <code>B</code> is overwritten by the solution <code>X</code>. <code>A</code> is overwritten by its Bunch-Kaufman factorization. <code>ipiv</code> contains pivoting information about the factorization.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L4849-L4857">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.LAPACK.sytrf!" href="#LinearAlgebra.LAPACK.sytrf!"><code>LinearAlgebra.LAPACK.sytrf!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">sytrf!(uplo, A) -&gt; (A, ipiv, info)</code></pre><p>Computes the Bunch-Kaufman factorization of a symmetric matrix <code>A</code>. If <code>uplo = U</code>, the upper half of <code>A</code> is stored. If <code>uplo = L</code>, the lower half is stored.</p><p>Returns <code>A</code>, overwritten by the factorization, a pivot vector <code>ipiv</code>, and the error code <code>info</code> which is a non-negative integer. If <code>info</code> is positive the matrix is singular and the diagonal part of the factorization is exactly zero at position <code>info</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L4860-L4871">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.LAPACK.sytri!" href="#LinearAlgebra.LAPACK.sytri!"><code>LinearAlgebra.LAPACK.sytri!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">sytri!(uplo, A, ipiv)</code></pre><p>Computes the inverse of a symmetric matrix <code>A</code> using the results of <code>sytrf!</code>. If <code>uplo = U</code>, the upper half of <code>A</code> is stored. If <code>uplo = L</code>, the lower half is stored. <code>A</code> is overwritten by its inverse.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L4874-L4880">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.LAPACK.sytrs!" href="#LinearAlgebra.LAPACK.sytrs!"><code>LinearAlgebra.LAPACK.sytrs!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">sytrs!(uplo, A, ipiv, B)</code></pre><p>Solves the equation <code>A * X = B</code> for a symmetric matrix <code>A</code> using the results of <code>sytrf!</code>. If <code>uplo = U</code>, the upper half of <code>A</code> is stored. If <code>uplo = L</code>, the lower half is stored. <code>B</code> is overwritten by the solution <code>X</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L4883-L4890">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.LAPACK.hesv!" href="#LinearAlgebra.LAPACK.hesv!"><code>LinearAlgebra.LAPACK.hesv!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">hesv!(uplo, A, B) -&gt; (B, A, ipiv)</code></pre><p>Finds the solution to <code>A * X = B</code> for Hermitian matrix <code>A</code>. If <code>uplo = U</code>, the upper half of <code>A</code> is stored. If <code>uplo = L</code>, the lower half is stored. <code>B</code> is overwritten by the solution <code>X</code>. <code>A</code> is overwritten by its Bunch-Kaufman factorization. <code>ipiv</code> contains pivoting information about the factorization.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L4894-L4902">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.LAPACK.hetrf!" href="#LinearAlgebra.LAPACK.hetrf!"><code>LinearAlgebra.LAPACK.hetrf!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">hetrf!(uplo, A) -&gt; (A, ipiv, info)</code></pre><p>Computes the Bunch-Kaufman factorization of a Hermitian matrix <code>A</code>. If <code>uplo = U</code>, the upper half of <code>A</code> is stored. If <code>uplo = L</code>, the lower half is stored.</p><p>Returns <code>A</code>, overwritten by the factorization, a pivot vector <code>ipiv</code>, and the error code <code>info</code> which is a non-negative integer. If <code>info</code> is positive the matrix is singular and the diagonal part of the factorization is exactly zero at position <code>info</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L4905-L4916">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.LAPACK.hetri!" href="#LinearAlgebra.LAPACK.hetri!"><code>LinearAlgebra.LAPACK.hetri!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">hetri!(uplo, A, ipiv)</code></pre><p>Computes the inverse of a Hermitian matrix <code>A</code> using the results of <code>sytrf!</code>. If <code>uplo = U</code>, the upper half of <code>A</code> is stored. If <code>uplo = L</code>, the lower half is stored. <code>A</code> is overwritten by its inverse.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L4919-L4925">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.LAPACK.hetrs!" href="#LinearAlgebra.LAPACK.hetrs!"><code>LinearAlgebra.LAPACK.hetrs!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">hetrs!(uplo, A, ipiv, B)</code></pre><p>Solves the equation <code>A * X = B</code> for a Hermitian matrix <code>A</code> using the results of <code>sytrf!</code>. If <code>uplo = U</code>, the upper half of <code>A</code> is stored. If <code>uplo = L</code>, the lower half is stored. <code>B</code> is overwritten by the solution <code>X</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L4928-L4935">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.LAPACK.syev!" href="#LinearAlgebra.LAPACK.syev!"><code>LinearAlgebra.LAPACK.syev!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">syev!(jobz, uplo, A)</code></pre><p>Finds the eigenvalues (<code>jobz = N</code>) or eigenvalues and eigenvectors (<code>jobz = V</code>) of a symmetric matrix <code>A</code>. If <code>uplo = U</code>, the upper triangle of <code>A</code> is used. If <code>uplo = L</code>, the lower triangle of <code>A</code> is used.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L5237-L5243">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.LAPACK.syevr!" href="#LinearAlgebra.LAPACK.syevr!"><code>LinearAlgebra.LAPACK.syevr!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">syevr!(jobz, range, uplo, A, vl, vu, il, iu, abstol) -&gt; (W, Z)</code></pre><p>Finds the eigenvalues (<code>jobz = N</code>) or eigenvalues and eigenvectors (<code>jobz = V</code>) of a symmetric matrix <code>A</code>. If <code>uplo = U</code>, the upper triangle of <code>A</code> is used. If <code>uplo = L</code>, the lower triangle of <code>A</code> is used. If <code>range = A</code>, all the eigenvalues are found. If <code>range = V</code>, the eigenvalues in the half-open interval <code>(vl, vu]</code> are found. If <code>range = I</code>, the eigenvalues with indices between <code>il</code> and <code>iu</code> are found. <code>abstol</code> can be set as a tolerance for convergence.</p><p>The eigenvalues are returned in <code>W</code> and the eigenvectors in <code>Z</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L5246-L5258">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.LAPACK.sygvd!" href="#LinearAlgebra.LAPACK.sygvd!"><code>LinearAlgebra.LAPACK.sygvd!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">sygvd!(itype, jobz, uplo, A, B) -&gt; (w, A, B)</code></pre><p>Finds the generalized eigenvalues (<code>jobz = N</code>) or eigenvalues and eigenvectors (<code>jobz = V</code>) of a symmetric matrix <code>A</code> and symmetric positive-definite matrix <code>B</code>. If <code>uplo = U</code>, the upper triangles of <code>A</code> and <code>B</code> are used. If <code>uplo = L</code>, the lower triangles of <code>A</code> and <code>B</code> are used. If <code>itype = 1</code>, the problem to solve is <code>A * x = lambda * B * x</code>. If <code>itype = 2</code>, the problem to solve is <code>A * B * x = lambda * x</code>. If <code>itype = 3</code>, the problem to solve is <code>B * A * x = lambda * x</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L5262-L5273">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.LAPACK.bdsqr!" href="#LinearAlgebra.LAPACK.bdsqr!"><code>LinearAlgebra.LAPACK.bdsqr!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">bdsqr!(uplo, d, e_, Vt, U, C) -&gt; (d, Vt, U, C)</code></pre><p>Computes the singular value decomposition of a bidiagonal matrix with <code>d</code> on the diagonal and <code>e_</code> on the off-diagonal. If <code>uplo = U</code>, <code>e_</code> is the superdiagonal. If <code>uplo = L</code>, <code>e_</code> is the subdiagonal. Can optionally also compute the product <code>Q&#39; * C</code>.</p><p>Returns the singular values in <code>d</code>, and the matrix <code>C</code> overwritten with <code>Q&#39; * C</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L5326-L5335">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.LAPACK.bdsdc!" href="#LinearAlgebra.LAPACK.bdsdc!"><code>LinearAlgebra.LAPACK.bdsdc!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">bdsdc!(uplo, compq, d, e_) -&gt; (d, e, u, vt, q, iq)</code></pre><p>Computes the singular value decomposition of a bidiagonal matrix with <code>d</code> on the diagonal and <code>e_</code> on the off-diagonal using a divide and conqueq method. If <code>uplo = U</code>, <code>e_</code> is the superdiagonal. If <code>uplo = L</code>, <code>e_</code> is the subdiagonal. If <code>compq = N</code>, only the singular values are found. If <code>compq = I</code>, the singular values and vectors are found. If <code>compq = P</code>, the singular values and vectors are found in compact form. Only works for real types.</p><p>Returns the singular values in <code>d</code>, and if <code>compq = P</code>, the compact singular vectors in <code>iq</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L5395-L5407">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.LAPACK.gecon!" href="#LinearAlgebra.LAPACK.gecon!"><code>LinearAlgebra.LAPACK.gecon!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">gecon!(normtype, A, anorm)</code></pre><p>Finds the reciprocal condition number of matrix <code>A</code>. If <code>normtype = I</code>, the condition number is found in the infinity norm. If <code>normtype = O</code> or <code>1</code>, the condition number is found in the one norm. <code>A</code> must be the result of <code>getrf!</code> and <code>anorm</code> is the norm of <code>A</code> in the relevant norm.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L5478-L5485">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.LAPACK.gehrd!" href="#LinearAlgebra.LAPACK.gehrd!"><code>LinearAlgebra.LAPACK.gehrd!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">gehrd!(ilo, ihi, A) -&gt; (A, tau)</code></pre><p>Converts a matrix <code>A</code> to Hessenberg form. If <code>A</code> is balanced with <code>gebal!</code> then <code>ilo</code> and <code>ihi</code> are the outputs of <code>gebal!</code>. Otherwise they should be <code>ilo = 1</code> and <code>ihi = size(A,2)</code>. <code>tau</code> contains the elementary reflectors of the factorization.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L5528-L5535">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.LAPACK.orghr!" href="#LinearAlgebra.LAPACK.orghr!"><code>LinearAlgebra.LAPACK.orghr!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">orghr!(ilo, ihi, A, tau)</code></pre><p>Explicitly finds <code>Q</code>, the orthogonal/unitary matrix from <code>gehrd!</code>. <code>ilo</code>, <code>ihi</code>, <code>A</code>, and <code>tau</code> must correspond to the input/output to <code>gehrd!</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L5578-L5583">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.LAPACK.gees!" href="#LinearAlgebra.LAPACK.gees!"><code>LinearAlgebra.LAPACK.gees!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">gees!(jobvs, A) -&gt; (A, vs, w)</code></pre><p>Computes the eigenvalues (<code>jobvs = N</code>) or the eigenvalues and Schur vectors (<code>jobvs = V</code>) of matrix <code>A</code>. <code>A</code> is overwritten by its Schur form.</p><p>Returns <code>A</code>, <code>vs</code> containing the Schur vectors, and <code>w</code>, containing the eigenvalues.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L5827-L5835">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.LAPACK.gges!" href="#LinearAlgebra.LAPACK.gges!"><code>LinearAlgebra.LAPACK.gges!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">gges!(jobvsl, jobvsr, A, B) -&gt; (A, B, alpha, beta, vsl, vsr)</code></pre><p>Computes the generalized eigenvalues, generalized Schur form, left Schur vectors (<code>jobsvl = V</code>), or right Schur vectors (<code>jobvsr = V</code>) of <code>A</code> and <code>B</code>.</p><p>The generalized eigenvalues are returned in <code>alpha</code> and <code>beta</code>. The left Schur vectors are returned in <code>vsl</code> and the right Schur vectors are returned in <code>vsr</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L5839-L5848">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.LAPACK.trexc!" href="#LinearAlgebra.LAPACK.trexc!"><code>LinearAlgebra.LAPACK.trexc!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">trexc!(compq, ifst, ilst, T, Q) -&gt; (T, Q)</code></pre><p>Reorder the Schur factorization of a matrix. If <code>compq = V</code>, the Schur vectors <code>Q</code> are reordered. If <code>compq = N</code> they are not modified. <code>ifst</code> and <code>ilst</code> specify the reordering of the vectors.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L6147-L6153">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.LAPACK.trsen!" href="#LinearAlgebra.LAPACK.trsen!"><code>LinearAlgebra.LAPACK.trsen!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">trsen!(compq, job, select, T, Q) -&gt; (T, Q, w, s, sep)</code></pre><p>Reorder the Schur factorization of a matrix and optionally finds reciprocal condition numbers. If <code>job = N</code>, no condition numbers are found. If <code>job = E</code>, only the condition number for this cluster of eigenvalues is found. If <code>job = V</code>, only the condition number for the invariant subspace is found. If <code>job = B</code> then the condition numbers for the cluster and subspace are found. If <code>compq = V</code> the Schur vectors <code>Q</code> are updated. If <code>compq = N</code> the Schur vectors are not modified. <code>select</code> determines which eigenvalues are in the cluster.</p><p>Returns <code>T</code>, <code>Q</code>, reordered eigenvalues in <code>w</code>, the condition number of the cluster of eigenvalues <code>s</code>, and the condition number of the invariant subspace <code>sep</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L6156-L6171">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.LAPACK.tgsen!" href="#LinearAlgebra.LAPACK.tgsen!"><code>LinearAlgebra.LAPACK.tgsen!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">tgsen!(select, S, T, Q, Z) -&gt; (S, T, alpha, beta, Q, Z)</code></pre><p>Reorders the vectors of a generalized Schur decomposition. <code>select</code> specifies the eigenvalues in each cluster.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L6174-L6179">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.LAPACK.trsyl!" href="#LinearAlgebra.LAPACK.trsyl!"><code>LinearAlgebra.LAPACK.trsyl!</code></a> â <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">trsyl!(transa, transb, A, B, C, isgn=1) -&gt; (C, scale)</code></pre><p>Solves the Sylvester matrix equation <code>A * X +/- X * B = scale*C</code> where <code>A</code> and <code>B</code> are both quasi-upper triangular. If <code>transa = N</code>, <code>A</code> is not modified. If <code>transa = T</code>, <code>A</code> is transposed. If <code>transa = C</code>, <code>A</code> is conjugate transposed. Similarly for <code>transb</code> and <code>B</code>. If <code>isgn = 1</code>, the equation <code>A * X + X * B = scale * C</code> is solved. If <code>isgn = -1</code>, the equation <code>A * X - X * B = scale * C</code> is solved.</p><p>Returns <code>X</code> (overwriting <code>C</code>) and <code>scale</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/e7d15d4a013a43442b75ba4e477382804fa4ac49/stdlib/LinearAlgebra/src/lapack.jl#L6214-L6225">source</a></section><footer><hr/><a class="previous" href="../Libdl/"><span class="direction">Previous</span><span class="title">Dynamic Linker</span></a><a class="next" href="../Logging/"><span class="direction">Next</span><span class="title">Logging</span></a></footer></article></body></html>
