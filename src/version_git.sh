# This file is a part of Julia. License is MIT: http://julialang.org/license

# This file collects git info and creates a header and implementation file
# for libjulia, pass it the file prefix you want it to write out.  E.g. if
# you run ``./src/version_git.sh src/julia_version` it will create two files,
# src/julia_version.h and src/julia_version.c

MAJOR_MINOR_PATCH_DEFINES=$(echo $JULIA_VERSION | awk 'BEGIN {FS="[.,-]"} \
{print "#define JULIA_VERSION_MAJOR " $1 "\n" \
       "#define JULIA_VERSION_MINOR " $2 "\n" \
       "#define JULIA_VERSION_PATCH " $3 ; \
if (NF<4) print "#define JULIA_VERSION_IS_RELEASE 1" ; else print  "#define JULIA_VERSION_IS_RELEASE 0"}')

# Write out header file
cat > "$1.h" <<EOF
// This header file autogenerated in src/version_git.sh
#ifndef JULIA_VERSION_H
#define JULIA_VERSION_H
#define JULIA_VERSION_STRING "$JULIA_VERSION"
$MAJOR_MINOR_PATCH_DEFINES
typedef struct {
    const char * commit;
    const char * commit_short;
    const char * branch;
    int build_number;
    const char * date_string;
    int tagged_commit;
    int fork_master_distance;
    double fork_master_timestamp;
} jl_git_version_t;

extern const jl_git_version_t JL_GIT_VERSION;
#endif //JULIA_VERSION_H
EOF

# Write out default version info
cat > "$1.c" <<EOF
// This file autogenerated in src/version_git.sh
// Default output if git is not available.
#include <julia_version.h>
const jl_git_version_t JL_GIT_VERSION = {"", "", "", 0, "", true, 0, 0};
EOF

# If the script asked not to use git info
if [  "$#" = "2"  -a "$2" = "NO_GIT" ]; then
    echo "WARNING: Using boilerplate git version info" >&2
    exit 0
fi
# Collect temporary variables
origin=$(git config -l 2>/dev/null | grep 'remote\.\w*\.url.*JuliaLang/julia.git' | sed -n 's/remote\.\([a-zA-Z]*\)\..*/\1\//p')
if [ -z "$origin" ]; then
    origin="origin/"
fi
last_tag=$(git describe --tags --abbrev=0)
git_time=$(git log -1 --pretty=format:%ct)

#collect the contents
commit=$(git rev-parse HEAD)
commit_short=$(git rev-parse --short HEAD)
if [ -n "$(git status --porcelain)" ]; then
    # append dirty mark '*' if the repository has uncommited changes
    commit_short="$commit_short"*
fi
branch=$(git branch | sed -n '/\* /s///p')
# Some versions of wc (eg on OS X) add extra whitespace to their output.
# The sed(1) call stops this from breaking the generated Julia's indentation by
# stripping all non-digits.
build_number=$(git rev-list HEAD ^$last_tag | wc -l | sed -e 's/[^[:digit:]]//g')

date_string=$git_time
case $(uname) in
  Darwin | FreeBSD)
    date_string="$(/bin/date -jr $git_time -u '+%Y-%m-%d %H:%M %Z')"
    ;;
  MINGW*)
    git_time=$(git log -1 --pretty=format:%ci)
    date_string="$(/bin/date --date="$git_time" -u '+%Y-%m-%d %H:%M %Z')"
    ;;
  *)
    date_string="$(/bin/date --date="@$git_time" -u '+%Y-%m-%d %H:%M %Z')"
    ;;
esac
if [ $(git describe --tags --exact-match 2> /dev/null) ]; then
    tagged_commit="1"
else
    tagged_commit="0"
fi
fork_master_distance=$(git rev-list HEAD ^"$(echo $origin)master" | wc -l | sed -e 's/[^[:digit:]]//g')
fork_master_timestamp=$(git show -s $(git merge-base HEAD $(echo $origin)master) --format=format:"%ct")

# Check for errrors and emit default value for missing numbers.
if [ -z "$build_number" ]; then
    build_number="0"
fi
if [ -z "$fork_master_distance" ]; then
    fork_master_distance="-1"
fi
if [ -z "$fork_master_timestamp" ]; then
    fork_master_timestamp="0"
fi

# Write out complete version info now that we've interrogated git
cat > "$1.c" <<EOF
// This file autogenerated in src/version_git.sh
#include <julia_version.h>
const jl_git_version_t JL_GIT_VERSION = {
    "$commit",
    "$commit_short",
    "$branch",
    $build_number,
    "$date_string",
    $tagged_commit,
    $fork_master_distance,
    $fork_master_timestamp
};
EOF
