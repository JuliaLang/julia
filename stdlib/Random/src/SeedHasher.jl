## SeedHasher

#=
`SeedHasher` implements the seed-mixing algorithm designed by M. E. O'Neill
as an alternative to `std::seed_seq`, intended to produce, from a
user-provided seed, high-quality initialization data for RNGs.
Cf. https://www.pcg-random.org/posts/developing-a-seed_seq-alternative.html

This implementation is derived from the `seed_seq_fe` C++ reference version:
https://gist.github.com/imneme/540829265469e673d045 (MIT license).

The original algorithm uses a fixed-size entropy buffer (128 or 256 bits).
`SeedHasher` adjusts the buffer size dynamically, roughly to the size of the
input seed, up to a maximum of 256 bits.
=#

const _SH_MAX_ENTROPY = 8 # number of stored UInt32 words of entropy
const _SH_BUFSIZE = 32
@assert _SH_BUFSIZE > _SH_MAX_ENTROPY # the diff should be at least 8 for decent performance
const _SH_XSHIFT::UInt32 = UInt32(sizeof(UInt32) * 4)

"""
    Random.SeedHasher(seed=nothing)

Create a `Random.SeedHasher` RNG, which produces random bytes derived from the
entropy extracted from `seed` via calls to [`Random.hashseed!`](@ref).

Given two seeds `s1` and `s2`, the random streams generated by
`SeedHasher(s1)` and `SeedHasher(s2)` should be distinct if and only if
`s1` and `s2` are distinct.

`SeedHasher` is used by default in `Random.seed!(::AbstractRNG, seed::Any)`,
so RNGs typically need only implement `seed!(rng, ::AbstractRNG)`.

!!! warning
    `SeedHasher` is intended only for producing initialization data for other RNGs.
    It is *not* suitable for use as a general-purpose RNG.

This is an internal type, subject to change.
"""
mutable struct SeedHasher <: AbstractRNG
    const mixer::Memory{UInt32}
    len::Int # size of the entropy store
    idx::Int
    hash_const::UInt32

    SeedHasher(::UndefInitializer) =
        new(Memory{UInt32}(undef, _SH_BUFSIZE), 0, 0, UInt32(0))
end

SeedHasher(seed=nothing) = seed!(SeedHasher(undef), seed)

seed!(rng::SeedHasher, ::Nothing) = seed!(rng, RandomDevice())

function seed!(rng::SeedHasher, seeder::AbstractRNG)
    # no seed mixing necessary, directly randomize `mixer`
    rand!(seeder, view(rng.mixer, 1:_SH_MAX_ENTROPY))
    rng.len = _SH_MAX_ENTROPY
    rng.idx = 0
    rng.hash_const = 0x8b51f9dd # INIT_B
    rng
end

function seed!(rng::SeedHasher, seed)
    rng.len = 0
    rng.idx = 0
    rng.hash_const = 0x43b0d7e5 # INIT_A
    hashseed!(rng, seed)
    finalize!(rng)
    if rng.len <= 2
        # additional mixing (`stir()` in the C++ code)
        rng.idx = rng.len << 2
        rng.len = 0
        rng.hash_const = 0x43b0d7e5 # this follows the C++ code, but might not be necessary?
        mix_entropy!(rng)
    end
    rng.idx = 0
    rng.hash_const = 0x8b51f9dd # INIT_B
    rng
end

# During seed ingestion (entropy extraction), the seed is encoded as bytes
# (via `hashseed!`) and written verbatim into `rng.mixer`, starting at the
# byte index `rng.idx + 1`. Once the buffer is filled for the first time,
# this initial block is mixed to produce the initial state of the entropy
# store, which occupies the first `_EM_MAX_ENTROPY` UInt32 words of
# `rng.mixer`. The remaining portion of the buffer stays available to ingest
# further bytes from the seed.
function ingest!(rng::SeedHasher,
                 xs::Union{AbstractArray{UInt8}, NTuple{N, UInt8}}) where N
    mixer8 = reinterpret(UInt8, rng.mixer)
    xsi = 0 # number of consumed bytes from xs
    while xsi != length(xs)
        if rng.idx == length(mixer8)
            mix_entropy!(rng)
            # now, the upper side of mixer8 is free
        end
        (; idx) = rng
        tocopy = min(length(xs) - xsi, length(mixer8) - idx)
        for ii = 1:tocopy
            @inbounds mixer8[idx + ii] = xs[xsi + ii]
        end
        xsi += tocopy
        rng.idx += tocopy
    end
    rng
end

function finalize!(rng)
    mixer8 = reinterpret(UInt8, rng.mixer)
    while 0 != (rng.idx & 0x3)
        mixer8[rng.idx += 1] = 0
    end
    mix_entropy!(rng)
end

function mix_entropy!(rng::SeedHasher)
    function hash(value::UInt32)
        value ⊻= rng.hash_const
        rng.hash_const *= 0x931e8875
        value *= rng.hash_const
        value ⊻= value >> _SH_XSHIFT
        value
    end

    function mix(x::UInt32, y::UInt32)
        result::UInt32 = 0xca01f9dd * x - 0x4973f715 * y
        result ⊻= result >> _SH_XSHIFT
        result
    end

    (; mixer, len, idx) = rng
    @assert 0 == (idx & 0x3)
    idx >>= 2 # number of `UInt32` values written into mixer

    if len == 0 # nothing has been mixed in so far
        len = rng.len = min(_SH_MAX_ENTROPY, idx)
        for ii = 1:len
            @inbounds mixer[ii] = hash(mixer[ii])
        end
        for isrc = 1:len, idst = 1:len
            if isrc != idst
                @inbounds mixer[idst] = mix(mixer[idst], hash(mixer[isrc]))
            end
        end
    end

    for ii = len+1:idx
        for idst = 1:len
            @inbounds mixer[idst] = mix(mixer[idst], hash(mixer[ii]))
        end
    end

    rng.idx = len << 2
    rng
end

### generation

function rand(rng::SeedHasher, ::SamplerType{UInt32})
    (; mixer, len, idx, hash_const) = rng
    dataval = @inbounds mixer[idx += 1]
    dataval ⊻= hash_const
    hash_const *= 0x58f38ded # MULT_B
    dataval *= hash_const
    dataval ⊻= dataval >> _SH_XSHIFT
    rng.idx = idx == len ? 0 : idx
    rng.hash_const = hash_const
    dataval
end

rand(rng::SeedHasher, T::SamplerUnion(Bool, Int8, UInt8, Int16, UInt16, Int32)) =
    rand(rng, UInt32) % T[]
rand(rng::SeedHasher, T::SamplerUnion(Int64, UInt64)) =
    (rand(rng, UInt32) % T[]) << 32 ⊻ rand(rng, UInt32) % T[]
rand(rng::SeedHasher, T::SamplerUnion(Int128, UInt128)) = rand_generic(rng, T[])

rng_native_52(::SeedHasher) = UInt64
