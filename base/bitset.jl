# This file is a part of Julia. License is MIT: https://julialang.org/license

const Bits = Vector{UInt64}
const Chk0 = zero(UInt64)

struct BitSet <: AbstractSet{Int}
    bits::Vector{UInt64}
    BitSet() = new(sizehint!(zeros(UInt64, 0), 4))
end

"""
    BitSet([itr])

Construct a sorted set of positive `Int`s generated by the given iterable object, or an
empty set. Implemented as a bit string, and therefore designed for dense integer sets. Only
`Int`s greater than 0 can be stored. If the set will be sparse (for example holding a few
very large integers), use [`Set`](@ref) instead.
"""
BitSet(itr) = union!(BitSet(), itr)

eltype(::Type{BitSet}) = Int
similar(s::BitSet) = BitSet()
copy(s1::BitSet) = copy!(BitSet(), s1)

"""
    copy!(dst, src)

In-place [`copy`](@ref) of `src` into `dst`. After the call to `copy!`,
`dst` must be left equal to `src`, otherwise an error is thrown; this
function appropriately resizes `dst` if necessary.
See also [`copyto!`](@ref).
"""
function copy!(dest::BitSet, src::BitSet)
    resize!(dest.bits, length(src.bits))
    copyto!(dest.bits, src.bits)
    dest
end
eltype(s::BitSet) = Int
sizehint!(s::BitSet, n::Integer) = (n > length(s.bits) && _resize0!(s.bits, n); s)

# given an integer i, return the chunk which stores it
chk_index(i::Integer) = _div64(Int(i)+63)
# return the bit offset of i within chk_index(i)
chk_offset(i::Int) = _mod64(i-1)

unsafe_bitsetindex!(a, b::Bool, n::Integer) = unsafe_bitsetindex!(a, b, Int(n))

function _bits_getindex(b::Bits, i::Int)
    ci = chk_index(i)
    ci > length(b) && return false
    @inbounds r = (b[ci] & (one(UInt64) << chk_offset(i))) != 0
    r
end

function _bits_findnext(b::Bits, start::Int)
    start = max(1, start)
    chk_index(start) > length(b) && return 0
    unsafe_bitfindnext(b, start)
end

function _bits_findprev(b::Bits, start::Int)
    start = min(length(b)*64, start)
    start > 0 || return 0
    unsafe_bitfindprev(b, start)
end

# An internal function for setting the inclusion bit for a given integer n >= 0
@inline function _setint!(s::BitSet, idx::Integer, b::Bool)
    cidx = chk_index(idx)
    if cidx > length(s.bits)
        b || return s # setting a bit to zero outside the set's bits is a no-op
        _resize0!(s.bits, cidx)
    end
    unsafe_bitsetindex!(s.bits, b, idx)
    s
end

# An internal function to resize a Bits object and ensure the newly allocated
# elements are zeroed (will become unnecessary if this behavior changes)
@inline function _resize0!(b::Bits, newlen::Int)
    len = length(b)
    resize!(b, newlen)
    len < newlen && @inbounds b[len+1:newlen] = Chk0 # resize! gives dirty memory
    nothing
end

# An internal function that takes a pure function `f` and maps across two BitArrays
# allowing the lengths to be different and altering b1 with the result
# WARNING: the assumptions written in the else clauses must hold
function _matched_map!(f, b1::Bits, b2::Bits)
    l1, l2 = length(b1), length(b2)

    # map! over the common indices
    map!(f, b1, b1, b2)

    if l1 < l2
        if f(false, false) == f(false, true) == false
            # We don't need to worry about the trailing bits — they're all false
        else # @assert f(false, x) == x
            resize!(b1, l2)
            unsafe_copyto!(b1, l1+1, b2, l1+1, l2-l1)
        end
    elseif l1 > l2
        if f(false, false) == f(true, false) == false
            # We don't need to worry about the trailing bits — they're all false
            resize!(b1, l2)
        else # @assert f(x, false) == x
            # We don't need to worry about the trailing bits — they already have the
            # correct value
        end
    end
    b1
end

@noinline _throw_bitset_bounds_err() = throw(ArgumentError("elements of BitSet must be between 1 and typemax(Int)"))
@noinline _throw_keyerror(n) = throw(KeyError(n))

@inline function push!(s::BitSet, n::Integer)
    0 < n <= typemax(Int) || _throw_bitset_bounds_err()
    _setint!(s, n, true)
end
push!(s::BitSet, ns::Integer...) = (for n in ns; push!(s, n); end; s)

@inline function pop!(s::BitSet)
    pop!(s, last(s))
end
@inline function pop!(s::BitSet, n::Integer)
    n in s ? (_delete!(s, n); n) : _throw_keyerror(n)
end
@inline function pop!(s::BitSet, n::Integer, default)
    n in s ? (_delete!(s, n); n) : default
end
@inline _delete!(s::BitSet, n::Integer) = _setint!(s, n, false)
@inline delete!(s::BitSet, n::Integer) = n > 0 ? _delete!(s, n) : s
shift!(s::BitSet) = pop!(s, first(s))

empty!(s::BitSet) = (fill!(s.bits, Chk0); s)
isempty(s::BitSet) = all(equalto(Chk0), s.bits)

# Mathematical set functions: union!, intersect!, setdiff!, symdiff!

union(s::BitSet) = copy(s)
union(s1::BitSet, s2::BitSet) = union!(copy(s1), s2)
union(s1::BitSet, ss::BitSet...) = union(s1, union(ss...))
union(s::BitSet, ns) = union!(copy(s), ns)
union!(s::BitSet, ns) = (for n in ns; push!(s, n); end; s)
function union!(s1::BitSet, s2::BitSet)
    _matched_map!(|, s1.bits, s2.bits)
    s1
end

intersect(s1::BitSet) = copy(s1)
intersect(s1::BitSet, ss::BitSet...) = intersect(s1, intersect(ss...))
function intersect(s1::BitSet, ns)
    s = BitSet()
    for n in ns
        n in s1 && push!(s, n)
    end
    s
end
intersect(s1::BitSet, s2::BitSet) =
    length(s1.bits) < length(s2.bits) ? intersect!(copy(s1), s2) : intersect!(copy(s2), s1)
"""
    intersect!(s1::BitSet, s2::BitSet)

Intersects sets `s1` and `s2` and overwrites the set `s1` with the result. If needed, `s1`
will be expanded to the size of `s2`.
"""
function intersect!(s1::BitSet, s2::BitSet)
    _matched_map!(&, s1.bits, s2.bits)
    s1
end

setdiff(s::BitSet, ns) = setdiff!(copy(s), ns)
setdiff!(s::BitSet, ns) = (for n in ns; delete!(s, n); end; s)
function setdiff!(s1::BitSet, s2::BitSet)
    _matched_map!((p, q) -> p & ~q, s1.bits, s2.bits)
    s1
end

symdiff(s::BitSet, ns) = symdiff!(copy(s), ns)
"""
    symdiff!(s, itr)

For each element in `itr`, destructively toggle its inclusion in set `s`.
"""
symdiff!(s::BitSet, ns) = (for n in ns; int_symdiff!(s, n); end; s)
"""
    symdiff!(s, n)

The set `s` is destructively modified to toggle the inclusion of integer `n`.
"""
symdiff!(s::BitSet, n::Integer) = int_symdiff!(s, n)

function int_symdiff!(s::BitSet, n::Integer)
    0 < n < typemax(Int) || _throw_bitset_bounds_err()
    val = !(n in s)
    _setint!(s, n, val)
    s
end
function symdiff!(s1::BitSet, s2::BitSet)
    _matched_map!(xor, s1.bits, s2.bits)
    s1
end

@inline in(n::Integer, s::BitSet) = _bits_getindex(s.bits, Int(n))

# Use the next-set index as the state to prevent looking it up again in done
start(s::BitSet) = next(s, 0)[2]
function next(s::BitSet, i::Int)
    nextidx = i == typemax(Int) ? 0 : _bits_findnext(s.bits, i+1)
    (i, nextidx)
end
done(s::BitSet, i) = i == 0


@noinline _throw_bitset_notempty_error() = throw(ArgumentError("collection must be non-empty"))

function first(s::BitSet)
    idx = _bits_findnext(s.bits, 1)
    idx == 0 ? _throw_bitset_notempty_error() : idx
end

function last(s::BitSet)
    idx = _bits_findprev(s.bits, typemax(Int))
    idx == 0 ? _throw_bitset_notempty_error() : idx
end

length(s::BitSet) = bitcount(s.bits) # = mapreduce(count_ones, +, 0, s.bits)

function show(io::IO, s::BitSet)
    print(io, "BitSet([")
    first = true
    for n in s
        !first && print(io, ", ")
        print(io, n)
        first = false
    end
    print(io, "])")
end

function ==(s1::BitSet, s2::BitSet)
    c1 = s1.bits
    c2 = s2.bits
    # Swap so c1 is always longer
    if length(c1) < length(c2)
        c1, c2 = c2, c1
    end
    _memcmp(c1, c2, length(c2)) == 0 || return false
    # Ensure remaining chunks are zero
    @inbounds for i in length(c2)+1:length(c1)
        c1[i] == Chk0 || return false
    end
    return true
end

issubset(a::BitSet, b::BitSet) = isequal(a, intersect(a,b))
<(a::BitSet, b::BitSet) = (a<=b) && !isequal(a,b)
<=(a::BitSet, b::BitSet) = issubset(a, b)

const hashis_seed = UInt === UInt64 ? 0x88989f1fc7dea67d : 0xc7dea67d
function hash(s::BitSet, h::UInt)
    h ⊻= hashis_seed
    bc = s.bits
    i = length(bc)
    while i > 0 && bc[i] == UInt64(0)
        # Skip trailing empty bytes to prevent extra space from changing the hash
        i -= 1
    end
    while i > 0
        h = hash(bc[i], h)
        i -= 1
    end
    h
end

minimum(s::BitSet) = first(s)
maximum(s::BitSet) = last(s)
extrema(s::BitSet) = (first(s), last(s))
issorted(s::BitSet) = true
