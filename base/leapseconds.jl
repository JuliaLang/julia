include("time/leapsinfo.jl") ### File generated by base/time/tzcompile.jl

# Convenience macro/functions for handling leap seconds
macro leapstree(a,r,var)
    A = eval(a)
    R = eval(r)
    ret = Expr(:block)
    push!(ret.args,:($var < $(A[1]) && return 0))
    push!(ret.args,:($var >= $(A[end]) && return $(endof(A)*1000)))
    push!(ret.args,searchsortedfirsttree(A[2:(endof(A)-1)],R,var))
    return ret
end
# Recursively build binary search tree w/ known lookup values
# A is sorted array of lookup values
# R is return values for each index of A
# i.e. R[1] is returned for values < A[1], R[2] for < A[2], etc.
function searchsortedfirsttree(A,R,var)
    l = length(A)
    mid = iseven(l) ? l>>>1 : (l>>>1)+1
    if mid == 1
        if l == 1
            return :($var < $(A[1]) ? $(R[1]) : $(R[2]))
        else # l == 2
            return :($var < $(A[1]) ? $(R[1]) : 
                     $var < $(A[2]) ? $(R[2]) : $(R[3]))
        end
    end
    iftree = Expr(:if)
    iftree.args = Array(Any,3)
    iftree.args[1] = :($var < $(A[mid])) # condition
    iftree.args[2] = searchsortedfirsttree(A[1:mid-1],R[1:mid],var)
    iftree.args[3] = searchsortedfirsttree(A[mid+1:end],R[mid+1:end],var)
    return iftree
end
function setleaps(ms)
    @leapstree(SETLEAPS,[1000:1000:((endof(SETLEAPS)-1)*1000)],ms)
end
function setleapsecond(ms)
    @leapstree([SETLEAPS[i]+1000 for i = 1:length(SETLEAPS)],
                 [1000:1000:((endof(SETLEAPS)-1)*1000)],ms)
end
function getleaps(ms)
    @leapstree(GETLEAPS,[1000:1000:((endof(SETLEAPS)-1)*1000)],ms)
end
function getleapsecond(ms)
    @leapstree([GETLEAPS[i]+1000 for i = 1:length(GETLEAPS)],
                 [1000:1000:((endof(SETLEAPS)-1)*1000)],ms)
end