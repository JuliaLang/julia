include("time/leapsinfo.jl") ### File generated by base/time/tzcompile.jl

# Convenience macro/functions for handling leap seconds
macro leapstree(a,r,var)
    A = eval(a)
    R = eval(r)
    ret = Expr(:block)
    push!(ret.args,:($var < $(A[1]) && return 0))
    push!(ret.args,:($var >= $(A[end]) && return $(endof(A)*1000)))
    push!(ret.args,searchsortedfirsttree(A[2:(endof(A)-1)],R,var))
    return ret
end
# Recursively build binary search tree w/ known lookup values
# A is sorted array of lookup values
# R is return values for each index of A
# i.e. R[1] is returned for values < A[1], R[2] for < A[2], etc.
function searchsortedfirsttree(A,R,var)
    l = length(A)
    mid = iseven(l) ? l>>>1 : (l>>>1)+1
    if mid == 1
        if l == 1
            return :($var < $(A[1]) ? $(R[1]) : $(R[2]))
        else # l == 2
            return :($var < $(A[1]) ? $(R[1]) : 
                     $var < $(A[2]) ? $(R[2]) : $(R[3]))
        end
    end
    iftree = Expr(:if)
    iftree.args = Array(Any,3)
    iftree.args[1] = :($var < $(A[mid])) # condition
    iftree.args[2] = searchsortedfirsttree(A[1:mid-1],R[1:mid],var)
    iftree.args[3] = searchsortedfirsttree(A[mid+1:end],R[mid+1:end],var)
    return iftree
end
function setleaps(ms)
    @leapstree(SETLEAPS,[1000:1000:((endof(SETLEAPS)-1)*1000)],ms)
end
function setleapsecond(ms)
    @leapstree([SETLEAPS[i]+1000 for i = 1:length(SETLEAPS)],
                 [1000:1000:((endof(SETLEAPS)-1)*1000)],ms)
end
function getleaps(ms)
    @leapstree(GETLEAPS,[1000:1000:((endof(SETLEAPS)-1)*1000)],ms)
end
function getleapsecond(ms)
    @leapstree([GETLEAPS[i]+1000 for i = 1:length(GETLEAPS)],
                 [1000:1000:((endof(SETLEAPS)-1)*1000)],ms)
end

# PoliticalTimezones carry daylight savings rules with them
# which may change from year to year.
# Each timezone is mapped to an entity in the Olsen Timezone Database
# Reference: http://www.iana.org/time-zones
abstract PoliticalTimezone <: Timezone

include("time/tzinfo.jl") ### File generated by base/time/tzcompile.jl

macro timezonetree(a,r,defaultreturn,var)
    A = eval(a)
    R = eval(r)
    ret = Expr(:block)
    push!(ret.args,:($var < $(A[1]) && return $defaultreturn))
    push!(ret.args,:($var >= $(A[end]) && return $defaultreturn)) # return rule?
    push!(ret.args,searchsortedfirsttree(A[2:(endof(A)-1)],R,var))
    return ret
end

# Fallback constructor that takes any non-defined PoliticalTimezone
# loads its data, and creates a type-specific constructor
function Datetime{T<:PoliticalTimezone}(y,m,d,h,mi,s,ms,::Type{T})
    # Timezone files = serialized 4-Tuple in the form
    # (timezone name, default_offset, default_abbreviation, [DST_ms_instant offset abbr])
    #nm, off, abbr, tzdata = open(Base.find_source_file("time/tzdata/" * string(T.name))) do x
    nm, off, abbr, tzdata = open("C:/Users/karbarcca/time/time/tzdata/" * string(T.name)) do x
        deserialize(x)
    end
    # Here f is capturing the result of the last expr, our new
    # Datetime constructor build specifically for Timezone T
    # We then call that new constructor with apply(f,...)
    f = @eval begin
        function settzoffset(::Type{$T},ms)
            @timezonetree($(tzdata[:,1] .+ tzdata[:,2]),$(tzdata[:,2]),$off,ms)
        end
        function gettzoffset(::Type{$T},ms)
            @timezonetree($(tzdata[:,1]),$(tzdata[:,2]),$off,ms)
        end
        function getabbr(::Type{$T},ms)
            @timezonetree($(tzdata[:,1]),$(tzdata[:,3]),$abbr,ms)
        end
        function Datetime(y,m,d,h,mi,s,ms,::Type{$T})
            0 < m < 13 || error("Month out of range")
            rata = ms + 1000*(s + 60mi + 3600h + 86400*totaldays(y,m,d))
            return ISODatetime{$T}(Millisecond(
                rata + (s == 60 ? setoffsetsecond($T,rata) : setoffset($T,rata))))
        end
    end
    return apply(f,(y,m,d,h,mi,s,ms,T))
end
# now(T) is the other entry point, so we make sure the timezone's
# data is loaded first with this fallback
function unix2date{T<:PoliticalTimezone}(x,::Type{T})
    load = Datetime(2000,1,1,0,0,0,0,T)
    return ISODatetime{T}(Millisecond(UNIXEPOCH+x))
end

typealias PT PoliticalTimezone
setoffset{T<:PT}(      ::Type{T},ms) = (t = settzoffset(T,ms); return -t + setleaps(ms-t))
setoffsetsecond{T<:PT}(::Type{T},ms) = (t = settzoffset(T,ms); return -t + setleapsecond(ms-t))
getoffset{T<:PT}(      ::Type{T},ms) = (s = getleaps(ms);      return -gettzoffset(T,ms-s) + s)
getoffsetsecond{T<:PT}(::Type{T},ms) = (s = getleapsecond(ms); return -gettzoffset(T,ms-s) + s)

Datetime(y,m,d,h,mi,s,ms,tz::String) = Datetime(y,m,d,h,mi,s,0,timezone(tz))
Datetime(y,m,d,h,mi,s,tz::String) = Datetime(y,m,d,h,mi,s,0,timezone(tz))
timezone(tz::String) = TIMEZONES1[tz]
timezone{T<:PoliticalTimezone}(::Type{T}) = TIMEZONES[T]
Datetime(dt::Date,tz::Timezone) = Datetime(year(dt),month(dt),day(dt),0,0,0,0,tz)
