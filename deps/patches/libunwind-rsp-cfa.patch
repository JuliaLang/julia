commit 66f68ab50d35bb17a7ae3ac47f17e1ba5913760c
Author: Keno Fischer <keno@juliacomputing.com>
Date:   Sat Feb 6 18:13:16 2021 -0500

    x86_64: Stop aliasing RSP and CFA
    
    RSP and CFA are different concepts. RSP refers to the physical
    register, CFA is a virtual register that serves as the base
    address for various other saved registers. It is true that
    in many frames these are set to alias, however this is not
    a requirement. For example, a function that performs a stack
    switch would likely change the rsp in the middle of the function,
    but would keep the CFA at the original RSP such that saved registers
    may be appropriately recovered.
    
    We are seeing incorrect unwinds in the Julia runtime when running
    julia under rr. This is because injects code (with correct CFI)
    that performs just such a stack switch [1]. GDB manages to unwind
    this correctly, but libunwind incorrectly sets the rsp to the CFA
    address, causing a misunwind.
    
    Tested on x86_64, patches for other architectures are ported, but
    not tested.
    
    [1] https://github.com/rr-debugger/rr/blob/469c22059a4a1798d33a8a224457faf22b2c178c/src/preload/syscall_hook.S#L454

diff --git a/include/dwarf.h b/include/dwarf.h
index fab93c61..b845e2eb 100644
--- a/include/dwarf.h
+++ b/include/dwarf.h
@@ -227,6 +227,7 @@ typedef enum
     DWARF_WHERE_REG,            /* register saved in another register */
     DWARF_WHERE_EXPR,           /* register saved */
     DWARF_WHERE_VAL_EXPR,       /* register has computed value */
+    DWARF_WHERE_CFA,            /* register is set to the computed cfa value */
   }
 dwarf_where_t;
 
@@ -309,7 +310,7 @@ typedef struct dwarf_cursor
     void *as_arg;               /* argument to address-space callbacks */
     unw_addr_space_t as;        /* reference to per-address-space info */
 
-    unw_word_t cfa;     /* canonical frame address; aka frame-/stack-pointer */
+    unw_word_t cfa;     /* canonical frame address; aka frame-pointer */
     unw_word_t ip;              /* instruction pointer */
     unw_word_t args_size;       /* size of arguments */
     unw_word_t eh_args[UNW_TDEP_NUM_EH_REGS];
diff --git a/src/dwarf/Gparser.c b/src/dwarf/Gparser.c
index 7d255aee..986c4a89 100644
--- a/src/dwarf/Gparser.c
+++ b/src/dwarf/Gparser.c
@@ -500,6 +500,8 @@ setup_fde (struct dwarf_cursor *c, dwarf_state_record_t *sr)
   memset (sr, 0, sizeof (*sr));
   for (i = 0; i < DWARF_NUM_PRESERVED_REGS + 2; ++i)
     set_reg (sr, i, DWARF_WHERE_SAME, 0);
+  // SP defaults to CFA (but is overridable)
+  set_reg (sr, UNW_TDEP_SP, DWARF_WHERE_CFA, 0);
 
   struct dwarf_cie_info *dci = c->pi.unwind_info;
   sr->rs_current.ret_addr_column  = dci->ret_addr_column;
@@ -826,6 +828,10 @@ apply_reg_state (struct dwarf_cursor *c, struct dwarf_reg_state *rs)
         case DWARF_WHERE_SAME:
           break;
 
+        case DWARF_WHERE_CFA:
+          new_loc[i] = DWARF_VAL_LOC (c, cfa);
+          break;
+
         case DWARF_WHERE_CFAREL:
           new_loc[i] = DWARF_MEM_LOC (c, cfa + rs->reg.val[i]);
           break;
diff --git a/src/x86/Gos-freebsd.c b/src/x86/Gos-freebsd.c
index 7dd01404..1b251d02 100644
--- a/src/x86/Gos-freebsd.c
+++ b/src/x86/Gos-freebsd.c
@@ -138,6 +138,7 @@ x86_handle_signal_frame (unw_cursor_t *cursor)
     c->dwarf.loc[ST0] = DWARF_NULL_LOC;
   } else if (c->sigcontext_format == X86_SCF_FREEBSD_SYSCALL) {
     c->dwarf.loc[EIP] = DWARF_LOC (c->dwarf.cfa, 0);
+    c->dwarf.loc[ESP] = DWARF_VAL_LOC (c, c->dwarf.cfa + 4);
     c->dwarf.loc[EAX] = DWARF_NULL_LOC;
     c->dwarf.cfa += 4;
     c->dwarf.use_prev_instr = 1;
diff --git a/src/x86/Gregs.c b/src/x86/Gregs.c
index 4a959261..9446d6c6 100644
--- a/src/x86/Gregs.c
+++ b/src/x86/Gregs.c
@@ -53,7 +53,6 @@ tdep_access_reg (struct cursor *c, unw_regnum_t reg, unw_word_t *valp,
       break;
 
     case UNW_X86_CFA:
-    case UNW_X86_ESP:
       if (write)
         return -UNW_EREADONLYREG;
       *valp = c->dwarf.cfa;
@@ -81,6 +80,7 @@ tdep_access_reg (struct cursor *c, unw_regnum_t reg, unw_word_t *valp,
     case UNW_X86_ECX: loc = c->dwarf.loc[ECX]; break;
     case UNW_X86_EBX: loc = c->dwarf.loc[EBX]; break;
 
+    case UNW_X86_ESP: loc = c->dwarf.loc[ESP]; break;
     case UNW_X86_EBP: loc = c->dwarf.loc[EBP]; break;
     case UNW_X86_ESI: loc = c->dwarf.loc[ESI]; break;
     case UNW_X86_EDI: loc = c->dwarf.loc[EDI]; break;
diff --git a/src/x86/Gstep.c b/src/x86/Gstep.c
index 129b739a..061dcbaa 100644
--- a/src/x86/Gstep.c
+++ b/src/x86/Gstep.c
@@ -47,7 +47,7 @@ unw_step (unw_cursor_t *cursor)
     {
       /* DWARF failed, let's see if we can follow the frame-chain
          or skip over the signal trampoline.  */
-      struct dwarf_loc ebp_loc, eip_loc;
+      struct dwarf_loc ebp_loc, eip_loc, esp_loc;
 
       /* We could get here because of missing/bad unwind information.
          Validate all addresses before dereferencing. */
@@ -77,6 +77,7 @@ unw_step (unw_cursor_t *cursor)
                  c->dwarf.cfa);
 
           ebp_loc = DWARF_LOC (c->dwarf.cfa, 0);
+          esp_loc = DWARF_VAL_LOC (c, c->dwarf.cfa + 8);
           eip_loc = DWARF_LOC (c->dwarf.cfa + 4, 0);
           c->dwarf.cfa += 8;
 
@@ -87,6 +88,7 @@ unw_step (unw_cursor_t *cursor)
             c->dwarf.loc[i] = DWARF_NULL_LOC;
 
           c->dwarf.loc[EBP] = ebp_loc;
+          c->dwarf.loc[ESP] = esp_loc;
           c->dwarf.loc[EIP] = eip_loc;
           c->dwarf.use_prev_instr = 1;
         }
diff --git a/src/x86_64/Gos-freebsd.c b/src/x86_64/Gos-freebsd.c
index 883025c8..8bb101ea 100644
--- a/src/x86_64/Gos-freebsd.c
+++ b/src/x86_64/Gos-freebsd.c
@@ -133,6 +133,7 @@ x86_64_handle_signal_frame (unw_cursor_t *cursor)
     c->dwarf.loc[RCX] = c->dwarf.loc[R10];
     /*  rsp_loc = DWARF_LOC(c->dwarf.cfa - 8, 0);       */
     /*  rbp_loc = c->dwarf.loc[RBP];                    */
+    c->dwarf.loc[RSP] = DWARF_VAL_LOC (c, c->dwarf.cfa + 8);
     c->dwarf.loc[RIP] = DWARF_LOC (c->dwarf.cfa, 0);
     ret = dwarf_get (&c->dwarf, c->dwarf.loc[RIP], &c->dwarf.ip);
     Debug (1, "Frame Chain [RIP=0x%Lx] = 0x%Lx\n",
diff --git a/src/x86_64/Gregs.c b/src/x86_64/Gregs.c
index baf8a24f..dff5bcbe 100644
--- a/src/x86_64/Gregs.c
+++ b/src/x86_64/Gregs.c
@@ -79,7 +79,6 @@ tdep_access_reg (struct cursor *c, unw_regnum_t reg, unw_word_t *valp,
       break;
 
     case UNW_X86_64_CFA:
-    case UNW_X86_64_RSP:
       if (write)
         return -UNW_EREADONLYREG;
       *valp = c->dwarf.cfa;
@@ -107,6 +106,7 @@ tdep_access_reg (struct cursor *c, unw_regnum_t reg, unw_word_t *valp,
     case UNW_X86_64_RCX: loc = c->dwarf.loc[RCX]; break;
     case UNW_X86_64_RBX: loc = c->dwarf.loc[RBX]; break;
 
+    case UNW_X86_64_RSP: loc = c->dwarf.loc[RSP]; break;
     case UNW_X86_64_RBP: loc = c->dwarf.loc[RBP]; break;
     case UNW_X86_64_RSI: loc = c->dwarf.loc[RSI]; break;
     case UNW_X86_64_RDI: loc = c->dwarf.loc[RDI]; break;
diff --git a/src/x86_64/Gstep.c b/src/x86_64/Gstep.c
index 10498170..5425e3db 100644
--- a/src/x86_64/Gstep.c
+++ b/src/x86_64/Gstep.c
@@ -160,7 +160,7 @@ unw_step (unw_cursor_t *cursor)
             {
               unw_word_t rbp1 = 0;
               rbp_loc = DWARF_LOC(rbp, 0);
-              rsp_loc = DWARF_NULL_LOC;
+              rsp_loc = DWARF_VAL_LOC(c, rbp + 16);
               rip_loc = DWARF_LOC (rbp + 8, 0);
               ret = dwarf_get (&c->dwarf, rbp_loc, &rbp1);
               Debug (1, "[RBP=0x%lx] = 0x%lx (cfa = 0x%lx) -> 0x%lx\n",
