From b5a0e6ca2b0c6367b082dd9a77b02c26607c8d7d Mon Sep 17 00:00:00 2001
From: Kai Luo <lkail@cn.ibm.com>
Date: Tue, 29 Dec 2020 12:11:55 +0000
Subject: [PATCH 2/4] [PowerPC] Remaining KnownBits should be constant when
 performing non-sign comparison

In `PPCTargetLowering::DAGCombineTruncBoolExt`, when checking if it's correct to perform the transformation for non-sign comparison, as the comment says
```
      // This is neither a signed nor an unsigned comparison, just make sure
      // that the high bits are equal.
```
Origin check
```
      if (Op1Known.Zero != Op2Known.Zero || Op1Known.One != Op2Known.One)
        return SDValue();
```
is not strong enough. For example,
```
Op1Known = 111x000x;
Op2Known = 111x000x;
```
Bit 4, besides bit 0, is still unknown and affects the final result.

This patch fixes https://bugs.llvm.org/show_bug.cgi?id=48388.

Reviewed By: nemanjai, #powerpc

Differential Revision: https://reviews.llvm.org/D93092
---
 llvm/lib/Target/PowerPC/PPCISelLowering.cpp | 10 +++--
 llvm/test/CodeGen/PowerPC/pr48388.ll        | 41 +++++++++++++++++++++
 2 files changed, 47 insertions(+), 4 deletions(-)
 create mode 100644 llvm/test/CodeGen/PowerPC/pr48388.ll

diff --git llvm/lib/Target/PowerPC/PPCISelLowering.cpp llvm/lib/Target/PowerPC/PPCISelLowering.cpp
index f54f1673526d..38dbff4197b9 100644
--- llvm/lib/Target/PowerPC/PPCISelLowering.cpp
+++ llvm/lib/Target/PowerPC/PPCISelLowering.cpp
@@ -13287,11 +13287,13 @@ SDValue PPCTargetLowering::DAGCombineTruncBoolExt(SDNode *N,
       KnownBits Op2Known = DAG.computeKnownBits(N->getOperand(1));
 
       // We don't really care about what is known about the first bit (if
-      // anything), so clear it in all masks prior to comparing them.
-      Op1Known.Zero.clearBit(0); Op1Known.One.clearBit(0);
-      Op2Known.Zero.clearBit(0); Op2Known.One.clearBit(0);
+      // anything), so pretend that it is known zero for both to ensure they can
+      // be compared as constants.
+      Op1Known.Zero.setBit(0); Op1Known.One.clearBit(0);
+      Op2Known.Zero.setBit(0); Op2Known.One.clearBit(0);
 
-      if (Op1Known.Zero != Op2Known.Zero || Op1Known.One != Op2Known.One)
+      if (!Op1Known.isConstant() || !Op2Known.isConstant() ||
+          Op1Known.getConstant() != Op2Known.getConstant())
         return SDValue();
     }
   }
diff --git llvm/test/CodeGen/PowerPC/pr48388.ll llvm/test/CodeGen/PowerPC/pr48388.ll
new file mode 100644
index 000000000000..822e5d852317
--- /dev/null
+++ llvm/test/CodeGen/PowerPC/pr48388.ll
@@ -0,0 +1,41 @@
+; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
+; RUN: llc -verify-machineinstrs -mtriple=powerpc64le -ppc-asm-full-reg-names \
+; RUN:   < %s | FileCheck %s
+
+define i64 @julia_div_i64(i64 %0, i64 %1) local_unnamed_addr #0 {
+; CHECK-LABEL: julia_div_i64:
+; CHECK:       # %bb.0: # %entry
+; CHECK-NEXT:    divd r6, r3, r4
+; CHECK-NEXT:    lis r5, -1592
+; CHECK-NEXT:    ori r7, r5, 21321
+; CHECK-NEXT:    ori r5, r5, 65519
+; CHECK-NEXT:    cmpdi r3, 0
+; CHECK-NEXT:    rldic r7, r7, 4, 17
+; CHECK-NEXT:    rldic r5, r5, 4, 17
+; CHECK-NEXT:    iselgt r9, r5, r7
+; CHECK-NEXT:    cmpdi r4, 0
+; CHECK-NEXT:    mulld r8, r6, r4
+; CHECK-NEXT:    iselgt r4, r5, r7
+; CHECK-NEXT:    xor r4, r9, r4
+; CHECK-NEXT:    cntlzd r4, r4
+; CHECK-NEXT:    rldicl r4, r4, 58, 63
+; CHECK-NEXT:    xor r3, r8, r3
+; CHECK-NEXT:    addic r5, r3, -1
+; CHECK-NEXT:    subfe r3, r5, r3
+; CHECK-NEXT:    and r3, r4, r3
+; CHECK-NEXT:    add r3, r6, r3
+; CHECK-NEXT:    blr
+entry:
+  %2 = sdiv i64 %0, %1
+  %3 = icmp sgt i64 %0, 0
+  %4 = icmp sgt i64 %1, 0
+  %5 = select i1 %3, i64 140735820070640, i64 140735819363472
+  %6 = select i1 %4, i64 140735820070640, i64 140735819363472
+  %7 = icmp eq i64 %5, %6
+  %8 = mul i64 %2, %1
+  %9 = icmp ne i64 %8, %0
+  %10 = and i1 %7, %9
+  %11 = zext i1 %10 to i64
+  %12 = add i64 %2, %11
+  ret i64 %12
+}
-- 
2.30.0

