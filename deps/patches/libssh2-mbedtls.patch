diff --git a/.travis.yml b/.travis.yml
index 9d6c0be..8bc1292 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -49,6 +49,10 @@ env:
    - ADDRESS_SIZE=64 CRYPTO_BACKEND=Libgcrypt BUILD_SHARED_LIBS=ON ENABLE_ZLIB_COMPRESSION=OFF
    - ADDRESS_SIZE=64 CRYPTO_BACKEND=Libgcrypt BUILD_SHARED_LIBS=OFF ENABLE_ZLIB_COMPRESSION=ON
    - ADDRESS_SIZE=64 CRYPTO_BACKEND=Libgcrypt BUILD_SHARED_LIBS=ON ENABLE_ZLIB_COMPRESSION=ON
+   - ADDRESS_SIZE=64 CRYPTO_BACKEND=mbedTLS BUILD_SHARED_LIBS=OFF ENABLE_ZLIB_COMPRESSION=OFF
+   - ADDRESS_SIZE=64 CRYPTO_BACKEND=mbedTLS BUILD_SHARED_LIBS=ON ENABLE_ZLIB_COMPRESSION=OFF
+   - ADDRESS_SIZE=64 CRYPTO_BACKEND=mbedTLS BUILD_SHARED_LIBS=OFF ENABLE_ZLIB_COMPRESSION=ON
+   - ADDRESS_SIZE=64 CRYPTO_BACKEND=mbedTLS BUILD_SHARED_LIBS=ON ENABLE_ZLIB_COMPRESSION=ON
    - ADDRESS_SIZE=32 CRYPTO_BACKEND=OpenSSL BUILD_SHARED_LIBS=OFF ENABLE_ZLIB_COMPRESSION=OFF
    - ADDRESS_SIZE=32 CRYPTO_BACKEND=OpenSSL BUILD_SHARED_LIBS=ON ENABLE_ZLIB_COMPRESSION=OFF
    - ADDRESS_SIZE=32 CRYPTO_BACKEND=OpenSSL BUILD_SHARED_LIBS=OFF ENABLE_ZLIB_COMPRESSION=ON
@@ -57,6 +61,11 @@ env:
    - ADDRESS_SIZE=32 CRYPTO_BACKEND=Libgcrypt BUILD_SHARED_LIBS=ON ENABLE_ZLIB_COMPRESSION=OFF
    - ADDRESS_SIZE=32 CRYPTO_BACKEND=Libgcrypt BUILD_SHARED_LIBS=OFF ENABLE_ZLIB_COMPRESSION=ON
    - ADDRESS_SIZE=32 CRYPTO_BACKEND=Libgcrypt BUILD_SHARED_LIBS=ON ENABLE_ZLIB_COMPRESSION=ON
+   - ADDRESS_SIZE=32 CRYPTO_BACKEND=mbedTLS BUILD_SHARED_LIBS=OFF ENABLE_ZLIB_COMPRESSION=OFF
+   - ADDRESS_SIZE=32 CRYPTO_BACKEND=mbedTLS BUILD_SHARED_LIBS=ON ENABLE_ZLIB_COMPRESSION=OFF
+   - ADDRESS_SIZE=32 CRYPTO_BACKEND=mbedTLS BUILD_SHARED_LIBS=OFF ENABLE_ZLIB_COMPRESSION=ON
+   - ADDRESS_SIZE=32 CRYPTO_BACKEND=mbedTLS BUILD_SHARED_LIBS=ON ENABLE_ZLIB_COMPRESSION=ON
+
 
 before_install:
   - sudo add-apt-repository --yes ppa:kalakris/cmake
@@ -66,6 +75,9 @@ before_install:
   - if [ $ADDRESS_SIZE = '32' ]; then sudo apt-get install -y linux-libc-dev linux-libc-dev:i386; fi
   - if [ $ADDRESS_SIZE = '32' ]; then sudo apt-get install -y gcc-multilib libgcrypt11-dev:i386 libssl-dev:i386 zlib1g-dev:i386; fi
   - if [ $ADDRESS_SIZE = '32' ]; then export TOOLCHAIN_OPTION="-DCMAKE_TOOLCHAIN_FILE=../cmake/Toolchain-Linux-32.cmake"; fi
+  - if [ $CRYPTO_BACKEND = 'mbedTLS' ]; then mbedtls/buildmbedtls; fi
+  - if [ $CRYPTO_BACKEND = 'mbedTLS' ]; then export TOOLCHAIN_OPTION="-DCMAKE_PREFIX_PATH=../mbedtls/install"; fi
+  - if [ $CRYPTO_BACKEND = 'mbedTLS' ]; then export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$PWD/mbedtls/install/lib; fi
 
 install:
   - mkdir bin
diff --git a/README b/README
index 39abc20..8a14856 100644
--- a/README
+++ b/README
@@ -4,9 +4,9 @@ libssh2 - SSH2 library
 libssh2 is a library implementing the SSH2 protocol, available under
 the revised BSD license.
 
-Web site: http://www.libssh2.org/
+Web site: https://www.libssh2.org/
 
-Mailing list: http://cool.haxx.se/mailman/listinfo/libssh2-devel
+Mailing list: https://cool.haxx.se/mailman/listinfo/libssh2-devel
 
 License: see COPYING
 
diff --git a/RELEASE-NOTES b/RELEASE-NOTES
index 2b22288..94525cb 100644
--- a/RELEASE-NOTES
+++ b/RELEASE-NOTES
@@ -11,7 +11,7 @@ This release includes the following changes:
 This release includes the following security advisory:
 
  o diffie_hellman_sha256: convert bytes to bits
-   CVE-2016-0787: http://www.libssh2.org/adv_20160223.html
+   CVE-2016-0787: https://www.libssh2.org/adv_20160223.html
 
 This release includes the following bugfixes:
 
@@ -49,8 +49,8 @@ advice from friends like these:
 
   Alexander Lamaison, Andreas Schneider, brian m. carlson, Daniel Stenberg,
   David Byron, Jakob Egger, Kamil Dudka, Marc Hoersken, Mizunashi Mana,
-  Patrick Monnerat, Paul Howarth, Salvador Fandino, Salvador Fandiño,
-  Salvador Fandiño, Viktor Szakats, Will Cosgrove,
-  (16 contributors)
+  Patrick Monnerat, Paul Howarth, Salvador Fandiño, Viktor Szakats,
+  Will Cosgrove
+  (14 contributors)
 
         Thanks! (and sorry if I forgot to mention someone)
diff --git a/cmake/FindmbedTLS.cmake b/cmake/FindmbedTLS.cmake
new file mode 100644
index 0000000..2f4adbc
--- /dev/null
+++ b/cmake/FindmbedTLS.cmake
@@ -0,0 +1,64 @@
+# - Try to find mbedTLS
+# Once done this will define
+#
+# Read-Only variables
+#  MBEDTLS_FOUND - system has mbedTLS
+#  MBEDTLS_INCLUDE_DIR - the mbedTLS include directory
+#  MBEDTLS_LIBRARY_DIR - the mbedTLS library directory
+#  MBEDTLS_LIBRARIES - Link these to use mbedTLS
+#  MBEDTLS_LIBRARY - path to mbedTLS library
+#  MBEDX509_LIBRARY - path to mbedTLS X.509 library
+#  MBEDCRYPTO_LIBRARY - path to mbedTLS Crypto library
+
+FIND_PATH(MBEDTLS_INCLUDE_DIR mbedtls/version.h)
+
+IF(MBEDTLS_INCLUDE_DIR AND MBEDTLS_LIBRARIES)
+    # Already in cache, be silent
+    SET(MBEDTLS_FIND_QUIETLY TRUE)
+ENDIF()
+
+FIND_LIBRARY(MBEDTLS_LIBRARY NAMES mbedtls libmbedtls libmbedx509)
+FIND_LIBRARY(MBEDX509_LIBRARY NAMES mbedx509 libmbedx509)
+FIND_LIBRARY(MBEDCRYPTO_LIBRARY NAMES mbedcrypto libmbedcrypto)
+
+IF(MBEDTLS_INCLUDE_DIR AND MBEDTLS_LIBRARY AND MBEDX509_LIBRARY AND MBEDCRYPTO_LIBRARY)
+     SET(MBEDTLS_FOUND TRUE)
+ENDIF()
+
+IF(MBEDTLS_FOUND)
+    # split mbedTLS into -L and -l linker options, so we can set them for pkg-config
+    GET_FILENAME_COMPONENT(MBEDTLS_LIBRARY_DIR ${MBEDTLS_LIBRARY} PATH)
+    GET_FILENAME_COMPONENT(MBEDTLS_LIBRARY_FILE ${MBEDTLS_LIBRARY} NAME_WE)
+    GET_FILENAME_COMPONENT(MBEDX509_LIBRARY_FILE ${MBEDX509_LIBRARY} NAME_WE)
+    GET_FILENAME_COMPONENT(MBEDCRYPTO_LIBRARY_FILE ${MBEDCRYPTO_LIBRARY} NAME_WE)
+    STRING(REGEX REPLACE "^lib" "" MBEDTLS_LIBRARY_FILE ${MBEDTLS_LIBRARY_FILE})
+    STRING(REGEX REPLACE "^lib" "" MBEDX509_LIBRARY_FILE ${MBEDX509_LIBRARY_FILE})
+    STRING(REGEX REPLACE "^lib" "" MBEDCRYPTO_LIBRARY_FILE ${MBEDCRYPTO_LIBRARY_FILE})
+    SET(MBEDTLS_LIBRARIES "-L${MBEDTLS_LIBRARY_DIR} -l${MBEDTLS_LIBRARY_FILE} -l${MBEDX509_LIBRARY_FILE} -l${MBEDCRYPTO_LIBRARY_FILE}")
+
+    IF(NOT MBEDTLS_FIND_QUIETLY)
+        MESSAGE(STATUS "Found mbedTLS:")
+        FILE(READ ${MBEDTLS_INCLUDE_DIR}/mbedtls/version.h MBEDTLSCONTENT)
+        STRING(REGEX MATCH "MBEDTLS_VERSION_STRING +\"[0-9|.]+\"" MBEDTLSMATCH ${MBEDTLSCONTENT})
+        IF (MBEDTLSMATCH)
+            STRING(REGEX REPLACE "MBEDTLS_VERSION_STRING +\"([0-9|.]+)\"" "\\1" MBEDTLS_VERSION ${MBEDTLSMATCH})
+            MESSAGE(STATUS "  version ${MBEDTLS_VERSION}")
+        ENDIF(MBEDTLSMATCH)
+        MESSAGE(STATUS "  TLS: ${MBEDTLS_LIBRARY}")
+        MESSAGE(STATUS "  X509: ${MBEDX509_LIBRARY}")
+        MESSAGE(STATUS "  Crypto: ${MBEDCRYPTO_LIBRARY}")
+    ENDIF(NOT MBEDTLS_FIND_QUIETLY)
+ELSE(MBEDTLS_FOUND)
+    IF(MBEDTLS_FIND_REQUIRED)
+        MESSAGE(FATAL_ERROR "Could not find mbedTLS")
+    ENDIF(MBEDTLS_FIND_REQUIRED)
+ENDIF(MBEDTLS_FOUND)
+
+MARK_AS_ADVANCED(
+    MBEDTLS_INCLUDE_DIR
+    MBEDTLS_LIBRARY_DIR
+    MBEDTLS_LIBRARIES
+    MBEDTLS_LIBRARY
+    MBEDX509_LIBRARY
+    MBEDCRYPTO_LIBRARY
+)
diff --git a/docs/BINDINGS b/docs/BINDINGS
index b97758f..471f9be 100644
--- a/docs/BINDINGS
+++ b/docs/BINDINGS
@@ -10,16 +10,16 @@ Cocoa/Objective-C
   https://github.com/karelia/libssh2_sftp-Cocoa-wrapper
 
 Haskell
-  FFI bindings - http://hackage.haskell.org/package/libssh2
+  FFI bindings - https://hackage.haskell.org/package/libssh2
 
 Perl
-  Net::SSH2 - http://search.cpan.org/~rkitover/Net-SSH2-0.45/lib/Net/SSH2.pm
+  Net::SSH2 - https://metacpan.org/pod/Net::SSH2
 
 PHP
-  ssh2 - http://pecl.php.net/package/ssh2 
+  ssh2 - https://pecl.php.net/package/ssh2
 
 Python
-  pylibssh2 - http://www.wallix.org/pylibssh2-project/
+  pylibssh2 - https://pypi.python.org/pypi/pylibssh2
 
 Python-ctypes
 
diff --git a/docs/INSTALL_AUTOTOOLS b/docs/INSTALL_AUTOTOOLS
index bc5a0eb..b469533 100644
--- a/docs/INSTALL_AUTOTOOLS
+++ b/docs/INSTALL_AUTOTOOLS
@@ -284,7 +284,7 @@ Some ./configure options deserve additional comments:
  * --with-libgcrypt-prefix=DIR
 
 	libssh2 can use the Libgcrypt library
-	(http://www.gnupg.org/) for cryptographic operations.
+	(https://www.gnupg.org/) for cryptographic operations.
 	Either Libgcrypt or OpenSSL is required.
 
 	Configure will attempt to locate Libgcrypt
@@ -298,7 +298,7 @@ Some ./configure options deserve additional comments:
  * --with-libssl-prefix=[DIR]
 
 	libssh2 can use the OpenSSL library
-	(http://www.openssl.org) for cryptographic operations.
+	(https://www.openssl.org) for cryptographic operations.
 	Either Libgcrypt or OpenSSL is required.
 
 	Configure will attempt to locate OpenSSL in the
diff --git a/docs/INSTALL_CMAKE b/docs/INSTALL_CMAKE
index 7040370..d2d7169 100644
--- a/docs/INSTALL_CMAKE
+++ b/docs/INSTALL_CMAKE
@@ -47,8 +47,8 @@ The following options are available:
  * `CRYPTO_BACKEND=`
 
     Chooses a specific cryptography library to use for cryptographic
-    operations.  Can be `OpenSSL` (http://www.openssl.org),
-    `Libgcrypt` (http://www.gnupg.org/), `WinCNG` (Windows Vista+) or
+    operations.  Can be `OpenSSL` (https://www.openssl.org),
+    `Libgcrypt` (https://www.gnupg.org/), `WinCNG` (Windows Vista+) or
     blank to use any library available.
 
     CMake will attempt to locate the libraries automatically.  See [2]
@@ -161,14 +161,14 @@ builds your project:
         Libssh2
         URL <libssh2 download location>
         URL_HASH SHA1=<libssh2 archive SHA1>
-	INSTALL_COMMAND "")
+        INSTALL_COMMAND "")
 
     ExternalProject_Add(
         MyProject DEPENDS Libssh2
         SOURCE_DIR ${CMAKE_CURRENT_SOURCE_DIR}/src
         INSTALL_COMMAND "")
 
-[1] http://www.cmake.org/cmake/resources/software.html
-[2] http://www.cmake.org/cmake/help/v3.0/manual/cmake-packages.7.html
-[3] http://www.cmake.org/cmake/help/v3.0/manual/cmake-packages.7.html#package-registry
-[4] http://www.kitware.com/media/html/BuildingExternalProjectsWithCMake2.8.html
\ No newline at end of file
+[1] https://www.cmake.org/cmake/resources/software.html
+[2] https://www.cmake.org/cmake/help/v3.0/manual/cmake-packages.7.html
+[3] https://www.cmake.org/cmake/help/v3.0/manual/cmake-packages.7.html#package-registry
+[4] http://www.kitware.com/media/html/BuildingExternalProjectsWithCMake2.8.html
diff --git a/docs/libssh2_sftp_get_channel.3 b/docs/libssh2_sftp_get_channel.3
index f3d364a..d1d82bc 100644
--- a/docs/libssh2_sftp_get_channel.3
+++ b/docs/libssh2_sftp_get_channel.3
@@ -1,21 +1,21 @@
-.TH libssh2_sftp_get_channel 3 "9 Sep 2011" "libssh2 1.4.0" "libssh2 manual"
-.SH NAME
-libssh2_sftp_get_channel - return the channel of sftp
-.SH SYNOPSIS
-.nf
-#include <libssh2.h>
-#include <libssh2_sftp.h>
-
-.fi
-LIBSSH2_CHANNEL *libssh2_sftp_get_channel(LIBSSH2_SFTP *sftp);
-.SH DESCRIPTION
-\fIsftp\fP - SFTP instance as returned by 
-.BR libssh2_sftp_init(3)
-
-Return the channel of the given sftp handle.
-.SH RETURN VALUE
-The channel of the SFTP instance or NULL if something was wrong.
-.SH AVAILABILITY
-Added in 1.4.0
-.SH SEE ALSO
-.BR libssh2_sftp_init(3)
+.TH libssh2_sftp_get_channel 3 "9 Sep 2011" "libssh2 1.4.0" "libssh2 manual"
+.SH NAME
+libssh2_sftp_get_channel - return the channel of sftp
+.SH SYNOPSIS
+.nf
+#include <libssh2.h>
+#include <libssh2_sftp.h>
+
+.fi
+LIBSSH2_CHANNEL *libssh2_sftp_get_channel(LIBSSH2_SFTP *sftp);
+.SH DESCRIPTION
+\fIsftp\fP - SFTP instance as returned by
+.BR libssh2_sftp_init(3)
+
+Return the channel of the given sftp handle.
+.SH RETURN VALUE
+The channel of the SFTP instance or NULL if something was wrong.
+.SH AVAILABILITY
+Added in 1.4.0
+.SH SEE ALSO
+.BR libssh2_sftp_init(3)
diff --git a/example/subsystem_netconf.c b/example/subsystem_netconf.c
index 96ef54a..82c4941 100644
--- a/example/subsystem_netconf.c
+++ b/example/subsystem_netconf.c
@@ -250,7 +250,7 @@ int main(int argc, char *argv[])
         goto shutdown;
     }
 
-    /* NETCONF: http://tools.ietf.org/html/draft-ietf-netconf-ssh-06 */
+    /* NETCONF: https://tools.ietf.org/html/draft-ietf-netconf-ssh-06 */
 
     fprintf(stderr, "Sending NETCONF client <hello>\n");
     snprintf(buf, sizeof(buf),
diff --git a/include/libssh2.h b/include/libssh2.h
index c157757..9ef9ff1 100644
--- a/include/libssh2.h
+++ b/include/libssh2.h
@@ -202,7 +202,16 @@ typedef off_t libssh2_struct_stat_size;
 #endif
 
 #ifndef LIBSSH2_STRUCT_STAT_SIZE_FORMAT
-#  define LIBSSH2_STRUCT_STAT_SIZE_FORMAT      "%zd"
+#  ifdef __VMS
+/* We have to roll our own format here because %z is a C99-ism we don't have. */
+#    if __USE_OFF64_T || __USING_STD_STAT
+#      define LIBSSH2_STRUCT_STAT_SIZE_FORMAT      "%Ld"
+#    else
+#      define LIBSSH2_STRUCT_STAT_SIZE_FORMAT      "%d"
+#    endif
+#  else
+#    define LIBSSH2_STRUCT_STAT_SIZE_FORMAT      "%zd"
+#  endif
 typedef struct stat libssh2_struct_stat;
 typedef off_t libssh2_struct_stat_size;
 #endif
diff --git a/libssh2.pc.in b/libssh2.pc.in
index 084918a..9663816 100644
--- a/libssh2.pc.in
+++ b/libssh2.pc.in
@@ -8,7 +8,7 @@ libdir=@libdir@
 includedir=@includedir@
 
 Name: libssh2
-URL: http://www.libssh2.org/
+URL: https://www.libssh2.org/
 Description: Library for SSH-based communication
 Version: @LIBSSH2VER@
 Requires.private: @LIBSREQUIRED@
diff --git a/mbedtls/buildmbedtls b/mbedtls/buildmbedtls
new file mode 100755
index 0000000..2385a8b
--- /dev/null
+++ b/mbedtls/buildmbedtls
@@ -0,0 +1,18 @@
+#!/bin/sh
+set -ex
+
+MBEDTLS_SRC_ARCH=mbedtls-2.2.1
+
+# download mbedtls sources
+cd mbedtls
+wget https://github.com/ARMmbed/mbedtls/archive/$MBEDTLS_SRC_ARCH.tar.gz
+tar -xzf $MBEDTLS_SRC_ARCH.tar.gz
+
+# patch mbedtls configuration
+cd mbedtls-$MBEDTLS_SRC_ARCH
+patch -p0 < ../mbedtls.patch
+
+# build library
+cmake -DCMAKE_BUILD_TYPE=RelWithDebInfo -DUSE_SHARED_MBEDTLS_LIBRARY=ON \
+      -DCMAKE_INSTALL_PREFIX:PATH=../install
+make install
diff --git a/mbedtls/mbedtls.patch b/mbedtls/mbedtls.patch
new file mode 100644
index 0000000..1f774ec
--- /dev/null
+++ b/mbedtls/mbedtls.patch
@@ -0,0 +1,27 @@
+diff --git include/mbedtls/config.h include/mbedtls/config.h
+index 0efee04..787cd8c 100644
+--- include/mbedtls/config.h
++++ include/mbedtls/config.h
+@@ -2434,19 +2434,19 @@
+ 
+ /* MPI / BIGNUM options */
+ //#define MBEDTLS_MPI_WINDOW_SIZE            6 /**< Maximum windows size used. */
+-//#define MBEDTLS_MPI_MAX_SIZE            1024 /**< Maximum number of bytes for usable MPIs. */
++#define MBEDTLS_MPI_MAX_SIZE            2048 /**< Maximum number of bytes for usable MPIs. */
+ 
+ /* CTR_DRBG options */
+ //#define MBEDTLS_CTR_DRBG_ENTROPY_LEN               48 /**< Amount of entropy used per seed by default (48 with SHA-512, 32 with SHA-256) */
+ //#define MBEDTLS_CTR_DRBG_RESEED_INTERVAL        10000 /**< Interval before reseed is performed by default */
+ //#define MBEDTLS_CTR_DRBG_MAX_INPUT                256 /**< Maximum number of additional input bytes */
+-//#define MBEDTLS_CTR_DRBG_MAX_REQUEST             1024 /**< Maximum number of requested bytes per call */
++#define MBEDTLS_CTR_DRBG_MAX_REQUEST             2048 /**< Maximum number of requested bytes per call */
+ //#define MBEDTLS_CTR_DRBG_MAX_SEED_INPUT           384 /**< Maximum size of (re)seed buffer */
+ 
+ /* HMAC_DRBG options */
+ //#define MBEDTLS_HMAC_DRBG_RESEED_INTERVAL   10000 /**< Interval before reseed is performed by default */
+ //#define MBEDTLS_HMAC_DRBG_MAX_INPUT           256 /**< Maximum number of additional input bytes */
+-//#define MBEDTLS_HMAC_DRBG_MAX_REQUEST        1024 /**< Maximum number of requested bytes per call */
++#define MBEDTLS_HMAC_DRBG_MAX_REQUEST        2048 /**< Maximum number of requested bytes per call */
+ //#define MBEDTLS_HMAC_DRBG_MAX_SEED_INPUT      384 /**< Maximum size of (re)seed buffer */
+ 
+ /* ECP options */
diff --git a/nw/GNUmakefile b/nw/GNUmakefile
index 0a1d0b3..8899fdd 100644
--- a/nw/GNUmakefile
+++ b/nw/GNUmakefile
@@ -38,7 +38,7 @@ DEVLARC	= $(DEVLDIR).zip
 TARGET	= libssh2
 VERSION	= $(LIBSSH2_VERSION)
 CPRIGHT	= Copyright (c) $(LIBSSH2_COPYRIGHT_STR)
-WWWURL	= http://www.libssh2.org/
+WWWURL	= https://www.libssh2.org/
 DESCR	= libssh2 $(LIBSSH2_VERSION_STR) ($(LIBARCH)) - $(WWWURL)
 MTSAFE	= YES
 STACK	= 64000
@@ -223,7 +223,7 @@ include ../Makefile.inc
 OBJECTS := $(patsubst %.c,%.o,$(CSOURCES))
 ifeq ($(LIBARCH),CLIB)
 # CLIB lacks of snprint() function - here's a replacement:
-# http://www.ijs.si/software/snprintf/
+# https://www.ijs.si/software/snprintf/
 OBJECTS += snprintf.o
 vpath %.c $(SNPRINTF)
 endif
@@ -388,7 +388,7 @@ libssh2_config.h: GNUmakefile
 	@echo $(DL)** All your changes will be lost!!$(DL) >> $@
 	@echo $(DL)*/$(DL) >> $@
 	@echo $(DL)#define VERSION "$(LIBSSH2_VERSION_STR)"$(DL) >> $@
-	@echo $(DL)#define PACKAGE_BUGREPORT "http://sourceforge.net/projects/libssh2"$(DL) >> $@
+	@echo $(DL)#define PACKAGE_BUGREPORT "https://github.com/libssh2/libssh2/issues"$(DL) >> $@
 ifeq ($(LIBARCH),CLIB)
 	@echo $(DL)#define OS "i586-pc-clib-NetWare"$(DL) >> $@
 	@echo $(DL)#define NETDB_USE_INTERNET 1$(DL) >> $@
diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index 1a76399..987dfe0 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -48,7 +48,7 @@ set(CRYPTO_BACKEND
   ""
   CACHE
   STRING
-  "The backend to use for cryptography: OpenSSL, Libgcrypt or WinCNG,
+  "The backend to use for cryptography: OpenSSL, Libgcrypt or WinCNG, mbedTLS
 or empty to try any available")
 
 # If the crypto backend was given, rather than searching for the first
@@ -71,6 +71,11 @@ if(CRYPTO_BACKEND STREQUAL "OpenSSL" OR NOT CRYPTO_BACKEND)
     list(APPEND PC_REQUIRES_PRIVATE libssl libcrypto)
 
     if (WIN32)
+      # Statically linking to OpenSSL requires crypt32 for some Windows APIs.
+      # This should really be handled by FindOpenSSL.cmake.
+      list(APPEND LIBRARIES crypt32)
+      list(APPEND PC_LIBS -lcrypt32)
+
       find_file(DLL_LIBEAY32
 	NAMES libeay32.dll crypto.dll
         HINTS ${_OPENSSL_ROOT_HINTS} PATHS ${_OPENSSL_ROOT_PATHS}
@@ -146,6 +151,21 @@ if(CRYPTO_BACKEND STREQUAL "WinCNG" OR NOT CRYPTO_BACKEND)
   endif()
 endif()
 
+if(CRYPTO_BACKEND STREQUAL "mbedTLS" OR NOT CRYPTO_BACKEND)
+
+  find_package(mbedTLS ${SPECIFIC_CRYPTO_REQUIREMENT})
+
+  if(MBEDTLS_FOUND)
+    set(CRYPTO_BACKEND "mbedTLS")
+    set(CRYPTO_SOURCES mbedtls.c mbedtls.h)
+    list(APPEND PRIVATE_COMPILE_DEFINITIONS LIBSSH2_MBEDTLS)
+    list(APPEND PRIVATE_INCLUDE_DIRECTORIES ${MBEDTLS_INCLUDE_DIR})
+    list(APPEND LIBRARIES ${MBEDTLS_LIBRARIES})
+    list(APPEND PC_LIBS -lmbedcrypto)
+    link_directories(${MBEDTLS_LIBRARY_DIR})
+  endif()
+endif()
+
 if(NOT CRYPTO_BACKEND)
   message(FATAL_ERROR "No suitable cryptography backend found.")
 endif()
@@ -204,6 +224,11 @@ target_include_directories(libssh2
 
 ## Options
 
+option(CLEAR_MEMORY "Enable clearing of memory before being freed" OFF)
+if(CLEAR_MEMORY)
+    add_definitions(-DLIBSSH2_CLEAR_MEMORY)
+endif(CLEAR_MEMORY)
+
 add_feature_info("Shared library" BUILD_SHARED_LIBS
   "creating libssh2 as a shared library (.so/.dll)")
 
diff --git a/src/channel.c b/src/channel.c
index 32d914d..538a0ab 100644
--- a/src/channel.c
+++ b/src/channel.c
@@ -270,7 +270,7 @@ _libssh2_channel_open(LIBSSH2_SESSION * session, const char *channel_type,
             switch (reason_code) {
             case SSH_OPEN_ADMINISTRATIVELY_PROHIBITED:
                 _libssh2_error(session, LIBSSH2_ERROR_CHANNEL_FAILURE,
-                               "Channel open failure (admininstratively prohibited)");
+                               "Channel open failure (administratively prohibited)");
                 break;
             case SSH_OPEN_CONNECT_FAILED:
                 _libssh2_error(session, LIBSSH2_ERROR_CHANNEL_FAILURE,
diff --git a/src/crypto.h b/src/crypto.h
index caad19f..aa997a3 100644
--- a/src/crypto.h
+++ b/src/crypto.h
@@ -54,6 +54,10 @@
 #include "os400qc3.h"
 #endif
 
+#ifdef LIBSSH2_MBEDTLS
+#include "mbedtls.h"
+#endif
+
 int _libssh2_rsa_new(libssh2_rsa_ctx ** rsa,
                      const unsigned char *edata,
                      unsigned long elen,
diff --git a/src/kex.c b/src/kex.c
index e89b36c..65b722f 100644
--- a/src/kex.c
+++ b/src/kex.c
@@ -133,7 +133,7 @@ static int diffie_hellman_sha1(LIBSSH2_SESSION *session,
         memset(&exchange_state->req_state, 0, sizeof(packet_require_state_t));
 
         /* Generate x and e */
-        _libssh2_bn_rand(exchange_state->x, group_order, 0, -1);
+        _libssh2_bn_rand(exchange_state->x, group_order * 8 - 1, 0, -1);
         _libssh2_bn_mod_exp(exchange_state->e, g, exchange_state->x, p,
                             exchange_state->ctx);
 
diff --git a/src/libgcrypt.c b/src/libgcrypt.c
index e85aecd..366d007 100644
--- a/src/libgcrypt.c
+++ b/src/libgcrypt.c
@@ -409,6 +409,9 @@ _libssh2_rsa_sha1_sign(LIBSSH2_SESSION * session,
     }
 
     *signature = LIBSSH2_ALLOC(session, size);
+    if (!*signature) {
+        return -1;
+    }
     memcpy(*signature, tmp, size);
     *signature_len = size;
 
diff --git a/src/libssh2_priv.h b/src/libssh2_priv.h
index ae691ad..b4296a2 100644
--- a/src/libssh2_priv.h
+++ b/src/libssh2_priv.h
@@ -65,8 +65,8 @@
    consistent names of these fields.  While arguable the best would to
    change libssh2.h to use other names, that would break backwards
    compatibility.  For more information, see:
-   http://www.mail-archive.com/libssh2-devel%40lists.sourceforge.net/msg00003.html
-   http://www.mail-archive.com/libssh2-devel%40lists.sourceforge.net/msg00224.html
+   https://www.mail-archive.com/libssh2-devel%40lists.sourceforge.net/msg00003.html
+   https://www.mail-archive.com/libssh2-devel%40lists.sourceforge.net/msg00224.html
 */
 #ifdef HAVE_POLL
 # include <sys/poll.h>
diff --git a/src/mbedtls.c b/src/mbedtls.c
new file mode 100644
index 0000000..98bc549
--- /dev/null
+++ b/src/mbedtls.c
@@ -0,0 +1,570 @@
+#include "libssh2_priv.h"
+
+#ifdef LIBSSH2_MBEDTLS /* compile only if we build with mbedtls */
+
+/*******************************************************************/
+/*
+ * mbedTLS backend: Generic functions
+ */
+
+void
+_libssh2_mbedtls_init(void)
+{
+    int ret;
+
+    mbedtls_entropy_init(&_libssh2_mbedtls_entropy);
+    mbedtls_ctr_drbg_init(&_libssh2_mbedtls_ctr_drbg);
+
+    ret = mbedtls_ctr_drbg_seed(&_libssh2_mbedtls_ctr_drbg,
+                                mbedtls_entropy_func,
+                                &_libssh2_mbedtls_entropy, NULL, 0);
+    if (ret != 0)
+        mbedtls_ctr_drbg_free(&_libssh2_mbedtls_ctr_drbg);
+}
+
+void
+_libssh2_mbedtls_free(void)
+{
+    mbedtls_ctr_drbg_free(&_libssh2_mbedtls_ctr_drbg);
+    mbedtls_entropy_free(&_libssh2_mbedtls_entropy);
+}
+
+int
+_libssh2_mbedtls_random(unsigned char *buf, int len)
+{
+    int ret;
+    ret = mbedtls_ctr_drbg_random(&_libssh2_mbedtls_ctr_drbg, buf, len);
+    return ret == 0 ? 0 : -1;
+}
+
+static void
+_libssh2_mbedtls_safe_free(void *buf, int len)
+{
+#ifndef LIBSSH2_CLEAR_MEMORY
+    (void)len;
+#endif
+
+    if (!buf)
+        return;
+
+#ifdef LIBSSH2_CLEAR_MEMORY
+    if (len > 0)
+        memset(buf, 0, len);
+#endif
+
+    mbedtls_free(buf);
+}
+
+int
+_libssh2_mbedtls_cipher_init(_libssh2_cipher_ctx *ctx,
+                             _libssh2_cipher_type(algo),
+                             unsigned char *iv,
+                             unsigned char *secret,
+                             int encrypt)
+{
+    const mbedtls_cipher_info_t *cipher_info;
+    int ret, op;
+
+    if (!ctx)
+        return -1;
+
+    op = encrypt == 0 ? MBEDTLS_ENCRYPT : MBEDTLS_DECRYPT;
+
+    cipher_info = mbedtls_cipher_info_from_type(algo);
+    if(!cipher_info)
+        return -1;
+
+    mbedtls_cipher_init(ctx);
+    ret = mbedtls_cipher_setup(ctx, cipher_info);
+    if(!ret)
+        ret = mbedtls_cipher_setkey(ctx, secret, cipher_info->key_bitlen, op);
+
+    if(!ret)
+        ret = mbedtls_cipher_set_iv(ctx, iv, cipher_info->iv_size);
+
+    return ret == 0 ? 0 : -1;
+}
+
+int
+_libssh2_mbedtls_cipher_crypt(_libssh2_cipher_ctx *ctx,
+                              _libssh2_cipher_type(algo),
+                              int encrypt,
+                              unsigned char *block,
+                              size_t blocklen)
+{
+    int ret;
+    unsigned char *output;
+    size_t osize, olen, finish_olen;
+
+    (void) encrypt;
+    (void) algo;
+
+    osize = blocklen+mbedtls_cipher_get_block_size(ctx);
+
+    output = (unsigned char *)mbedtls_calloc(osize, sizeof(char));
+    if(output)
+    {
+        ret = mbedtls_cipher_reset(ctx);
+
+        if(!ret)
+            ret = mbedtls_cipher_update(ctx, block, blocklen, output, &olen);
+
+        if(!ret)
+            ret = mbedtls_cipher_finish(ctx, output + olen, &finish_olen);
+
+        olen += finish_olen;
+
+        if (!ret)
+            memcpy(block, output, olen);
+
+        _libssh2_mbedtls_safe_free(output, osize);
+    }
+    else
+        ret = -1;
+
+    return ret == 0 ? 0 : -1;
+}
+
+void
+_libssh2_mbedtls_cipher_dtor(_libssh2_cipher_ctx *ctx)
+{
+    mbedtls_cipher_free(ctx);
+}
+
+
+int
+_libssh2_mbedtls_hash_init(mbedtls_md_context_t *ctx,
+                          mbedtls_md_type_t mdtype,
+                          const unsigned char *key, unsigned long keylen)
+{
+    const mbedtls_md_info_t *md_info;
+    int ret, hmac;
+
+    md_info = mbedtls_md_info_from_type(mdtype);
+    hmac = key == NULL ? 0 : 1;
+
+    mbedtls_md_init(ctx);
+    ret = mbedtls_md_setup(ctx, md_info, hmac);
+    if (!ret){
+        if (hmac)
+            ret = mbedtls_md_hmac_starts(ctx, key, keylen);
+        else
+            ret = mbedtls_md_starts(ctx);
+    }
+
+    return ret == 0 ? 1 : 0;
+}
+
+int
+_libssh2_mbedtls_hash_final(mbedtls_md_context_t *ctx, unsigned char *hash)
+{
+    int ret;
+
+    ret = mbedtls_md_finish(ctx, hash);
+    mbedtls_md_free(ctx);
+
+    return ret == 0 ? 0 : -1;
+}
+
+int
+_libssh2_mbedtls_hash(const unsigned char *data, unsigned long datalen,
+                      mbedtls_md_type_t mdtype, unsigned char *hash)
+{
+    const mbedtls_md_info_t *md_info;
+    int ret;
+
+    md_info = mbedtls_md_info_from_type(mdtype);
+    ret = mbedtls_md(md_info, data, datalen, hash);
+
+    return ret == 0 ? 0 : -1;
+}
+
+/*******************************************************************/
+/*
+ * mbedTLS backend: BigNumber functions
+ */
+
+_libssh2_bn *
+_libssh2_mbedtls_bignum_init(void)
+{
+    _libssh2_bn *bignum;
+
+    bignum = (_libssh2_bn *)mbedtls_calloc(1, sizeof(_libssh2_bn));
+    if (bignum) {
+        mbedtls_mpi_init(bignum);
+    }
+
+    return bignum;
+}
+
+void
+_libssh2_mbedtls_bignum_free(_libssh2_bn *bn)
+{
+    if (bn)
+    {
+        mbedtls_mpi_free(bn);
+#ifdef LIBSSH2_CLEAR_MEMORY
+        memset(bn, 0, sizeof(_libssh2_bn));
+#endif
+    }
+    mbedtls_free(bn);
+}
+
+
+/*******************************************************************/
+/*
+ * mbedTLS backend: RSA functions
+ */
+
+int
+_libssh2_mbedtls_rsa_new(libssh2_rsa_ctx **rsa,
+                        const unsigned char *edata,
+                        unsigned long elen,
+                        const unsigned char *ndata,
+                        unsigned long nlen,
+                        const unsigned char *ddata,
+                        unsigned long dlen,
+                        const unsigned char *pdata,
+                        unsigned long plen,
+                        const unsigned char *qdata,
+                        unsigned long qlen,
+                        const unsigned char *e1data,
+                        unsigned long e1len,
+                        const unsigned char *e2data,
+                        unsigned long e2len,
+                        const unsigned char *coeffdata,
+                        unsigned long coefflen)
+{
+    int ret;
+    libssh2_rsa_ctx *ctx;
+
+    ctx = (libssh2_rsa_ctx *) mbedtls_calloc(1, sizeof(libssh2_rsa_ctx));
+    if (ctx != NULL) {
+        mbedtls_rsa_init(ctx, MBEDTLS_RSA_PKCS_V15, 0);
+    }
+    else
+        return -1;
+
+    if( (ret = mbedtls_mpi_read_binary(&(ctx->E), edata, elen) ) != 0 ||
+        (ret = mbedtls_mpi_read_binary(&(ctx->N), ndata, nlen) ) != 0 )
+    {
+        ret = -1;
+    }
+
+    if (!ret)
+    {
+        ctx->len = mbedtls_mpi_size(&(ctx->N));
+    }
+
+    if (!ret && ddata)
+    {
+        if( (ret = mbedtls_mpi_read_binary(&(ctx->D) , ddata, dlen) ) != 0 ||
+            (ret = mbedtls_mpi_read_binary(&(ctx->P) , pdata, plen) ) != 0 ||
+            (ret = mbedtls_mpi_read_binary(&(ctx->Q) , qdata, qlen) ) != 0 ||
+            (ret = mbedtls_mpi_read_binary(&(ctx->DP), e1data, e1len) ) != 0 ||
+            (ret = mbedtls_mpi_read_binary(&(ctx->DQ), e2data, e2len) ) != 0 ||
+            (ret = mbedtls_mpi_read_binary(&(ctx->QP), coeffdata, coefflen) ) != 0 )
+        {
+            ret = -1;
+        }
+        ret = mbedtls_rsa_check_privkey(ctx);
+    }
+    else if (!ret)
+    {
+        ret = mbedtls_rsa_check_pubkey(ctx);
+    }
+
+    if (ret && ctx) {
+        _libssh2_mbedtls_rsa_free(ctx);
+        ctx = NULL;
+    }
+    *rsa = ctx;
+    return ret;
+}
+
+int
+_libssh2_mbedtls_rsa_new_private(libssh2_rsa_ctx **rsa,
+                                LIBSSH2_SESSION *session,
+                                const char *filename,
+                                const unsigned char *passphrase)
+{
+    int ret;
+    mbedtls_pk_context pkey;
+
+    *rsa = (libssh2_rsa_ctx *) LIBSSH2_ALLOC(session, sizeof(libssh2_rsa_ctx));
+    if (*rsa == NULL)
+        return -1;
+
+    mbedtls_rsa_init(*rsa, MBEDTLS_RSA_PKCS_V15, 0);
+    mbedtls_pk_init(&pkey);
+
+    ret = mbedtls_pk_parse_keyfile(&pkey, filename, (char *)passphrase);
+    if( ret != 0 )
+    {
+        mbedtls_pk_free(&pkey);
+        mbedtls_rsa_free(*rsa);
+        LIBSSH2_FREE(session, *rsa);
+        *rsa = NULL;
+        return -1;
+    }
+
+    mbedtls_rsa_context *pk_rsa = mbedtls_pk_rsa(pkey);
+    mbedtls_rsa_copy(*rsa, pk_rsa);
+    mbedtls_pk_free(&pkey);
+
+    return 0;
+}
+
+int
+_libssh2_mbedtls_rsa_new_private_frommemory(libssh2_rsa_ctx **rsa,
+                                           LIBSSH2_SESSION *session,
+                                           const char *filedata,
+                                           size_t filedata_len,
+                                           unsigned const char *passphrase)
+{
+    int ret;
+    mbedtls_pk_context pkey;
+
+    *rsa = (libssh2_rsa_ctx *) mbedtls_calloc( 1, sizeof( libssh2_rsa_ctx ) );
+    if (*rsa == NULL)
+        return -1;
+
+    mbedtls_pk_init(&pkey);
+
+    ret = mbedtls_pk_parse_key(&pkey, (unsigned char *)filedata,
+                              filedata_len, NULL, 0);
+    if( ret != 0 )
+    {
+        mbedtls_pk_free(&pkey);
+        mbedtls_rsa_free(*rsa);
+        LIBSSH2_FREE(session, *rsa);
+        *rsa = NULL;
+        return -1;
+    }
+
+    mbedtls_rsa_context *pk_rsa = mbedtls_pk_rsa(pkey);
+    mbedtls_rsa_copy(*rsa, pk_rsa);
+    mbedtls_pk_free(&pkey);
+
+    return 0;
+}
+
+int
+_libssh2_mbedtls_rsa_sha1_verify(libssh2_rsa_ctx *rsa,
+                                const unsigned char *sig,
+                                unsigned long sig_len,
+                                const unsigned char *m,
+                                unsigned long m_len)
+{
+    unsigned char hash[SHA_DIGEST_LENGTH];
+    int ret;
+
+    ret = _libssh2_mbedtls_hash(m, m_len, MBEDTLS_MD_SHA1, hash);
+    if(ret)
+        return -1; /* failure */
+
+    ret = mbedtls_rsa_pkcs1_verify(rsa, NULL, NULL, MBEDTLS_RSA_PUBLIC,
+                                   MBEDTLS_MD_SHA1, sig_len, hash, sig);
+
+    return (ret == 0) ? 0 : -1;
+}
+
+int
+_libssh2_mbedtls_rsa_sha1_sign(LIBSSH2_SESSION *session,
+                              libssh2_rsa_ctx *rsa,
+                              const unsigned char *hash,
+                              size_t hash_len,
+                              unsigned char **signature,
+                              size_t *signature_len)
+{
+    int ret;
+    unsigned char *sig;
+    unsigned int sig_len;
+
+    (void)hash_len;
+
+    sig_len = rsa->len;
+    sig = LIBSSH2_ALLOC(session, sig_len);
+    if (!sig) {
+        return -1;
+    }
+
+    ret = mbedtls_rsa_pkcs1_sign(rsa, NULL, NULL, MBEDTLS_RSA_PRIVATE,
+                                 MBEDTLS_MD_SHA1, SHA_DIGEST_LENGTH,
+                                 hash, sig);
+    if (ret) {
+        LIBSSH2_FREE(session, sig);
+        return -1;
+    }
+
+    *signature = sig;
+    *signature_len = sig_len;
+
+    return (ret == 0) ? 0 : -1;
+}
+
+void
+_libssh2_mbedtls_rsa_free(libssh2_rsa_ctx *ctx)
+{
+    mbedtls_rsa_free(ctx);
+    mbedtls_free(ctx);
+}
+
+static unsigned char *
+gen_publickey_from_rsa(LIBSSH2_SESSION *session,
+                      mbedtls_rsa_context *rsa,
+                      size_t *keylen)
+{
+    int            e_bytes, n_bytes;
+    unsigned long  len;
+    unsigned char* key;
+    unsigned char* p;
+
+    e_bytes = mbedtls_mpi_size(&rsa->E);
+    n_bytes = mbedtls_mpi_size(&rsa->N);
+
+    /* Key form is "ssh-rsa" + e + n. */
+    len = 4 + 7 + 4 + e_bytes + 4 + n_bytes;
+
+    key = LIBSSH2_ALLOC(session, len);
+    if (!key) {
+        return NULL;
+    }
+
+    /* Process key encoding. */
+    p = key;
+
+    _libssh2_htonu32(p, 7);  /* Key type. */
+    p += 4;
+    memcpy(p, "ssh-rsa", 7);
+    p += 7;
+
+    _libssh2_htonu32(p, e_bytes);
+    p += 4;
+    mbedtls_mpi_write_binary(&rsa->E, p, e_bytes);
+
+    _libssh2_htonu32(p, n_bytes);
+    p += 4;
+    mbedtls_mpi_write_binary(&rsa->N, p, n_bytes);
+
+    *keylen = (size_t)(p - key);
+    return key;
+}
+
+static int
+_libssh2_mbedtls_pub_priv_key(LIBSSH2_SESSION *session,
+                               unsigned char **method,
+                               size_t *method_len,
+                               unsigned char **pubkeydata,
+                               size_t *pubkeydata_len,
+                               mbedtls_pk_context *pkey)
+{
+    unsigned char *key = NULL, *mth = NULL;
+    size_t keylen = 0, mthlen = 0;
+    int ret;
+
+    if( mbedtls_pk_get_type(pkey) != MBEDTLS_PK_RSA )
+    {
+        mbedtls_pk_free(pkey);
+        return _libssh2_error(session, LIBSSH2_ERROR_FILE,
+                              "Key type not supported");
+    }
+
+    // write method
+    mthlen = 7;
+    mth = LIBSSH2_ALLOC(session, mthlen);
+    if (mth) {
+        memcpy(mth, "ssh-rsa", mthlen);
+    } else {
+        ret = -1;
+    }
+
+    mbedtls_rsa_context *rsa = mbedtls_pk_rsa(*pkey);
+    key = gen_publickey_from_rsa(session, rsa, &keylen);
+    if (key == NULL) {
+        ret = -1;
+    }
+
+    // write output
+    if (ret) {
+        if (mth)
+            LIBSSH2_FREE(session, mth);
+        if (key)
+            LIBSSH2_FREE(session, key);
+    } else {
+        *method = mth;
+        *method_len = mthlen;
+        *pubkeydata = key;
+        *pubkeydata_len = keylen;
+    }
+
+    return ret;
+}
+
+int
+_libssh2_mbedtls_pub_priv_keyfile(LIBSSH2_SESSION *session,
+                                 unsigned char **method,
+                                 size_t *method_len,
+                                 unsigned char **pubkeydata,
+                                 size_t *pubkeydata_len,
+                                 const char *privatekey,
+                                 const char *passphrase)
+{
+    mbedtls_pk_context pkey;
+    char buf[1024];
+    int ret;
+
+    mbedtls_pk_init(&pkey);
+    ret = mbedtls_pk_parse_keyfile(&pkey, privatekey, passphrase);
+    if( ret != 0 )
+    {
+        mbedtls_strerror(ret, (char *)buf, sizeof(buf));
+        mbedtls_pk_free(&pkey);
+        return _libssh2_error(session, LIBSSH2_ERROR_FILE, buf);
+    }
+
+    ret = _libssh2_mbedtls_pub_priv_key(session, method, method_len,
+                                       pubkeydata, pubkeydata_len, &pkey);
+
+    mbedtls_pk_free(&pkey);
+
+    return ret;
+}
+
+int
+_libssh2_mbedtls_pub_priv_keyfilememory(LIBSSH2_SESSION *session,
+                                       unsigned char **method,
+                                       size_t *method_len,
+                                       unsigned char **pubkeydata,
+                                       size_t *pubkeydata_len,
+                                       const char *privatekeydata,
+                                       size_t privatekeydata_len,
+                                       const char *passphrase)
+{
+    mbedtls_pk_context pkey;
+    char buf[1024];
+    int ret;
+
+    mbedtls_pk_init(&pkey);
+    ret = mbedtls_pk_parse_key(&pkey, (unsigned char *)privatekeydata,
+                              privatekeydata_len, NULL, 0);
+    if( ret != 0 )
+    {
+        mbedtls_strerror(ret, (char *)buf, sizeof(buf));
+        mbedtls_pk_free(&pkey);
+        return _libssh2_error(session, LIBSSH2_ERROR_FILE, buf);
+    }
+
+    ret = _libssh2_mbedtls_pub_priv_key(session, method, method_len,
+                                       pubkeydata, pubkeydata_len, &pkey);
+
+    mbedtls_pk_free(&pkey);
+
+    return ret;
+}
+
+void _libssh2_init_aes_ctr(void)
+{
+    /* no implementation */
+}
+#endif /* LIBSSH2_MBEDTLS */
diff --git a/src/mbedtls.h b/src/mbedtls.h
new file mode 100644
index 0000000..f594575
--- /dev/null
+++ b/src/mbedtls.h
@@ -0,0 +1,368 @@
+#include <stdlib.h>
+#include <string.h>
+
+#include <mbedtls/platform.h>
+#include <mbedtls/md.h>
+#include <mbedtls/rsa.h>
+#include <mbedtls/bignum.h>
+#include <mbedtls/cipher.h>
+#include <mbedtls/entropy.h>
+#include <mbedtls/ctr_drbg.h>
+#include <mbedtls/pk.h>
+#include <mbedtls/error.h>
+
+/* Define which features are supported. */
+#define LIBSSH2_MD5             1
+
+#define LIBSSH2_HMAC_RIPEMD     1
+#define LIBSSH2_HMAC_SHA256     1
+#define LIBSSH2_HMAC_SHA512     1
+
+#define LIBSSH2_AES             1
+#define LIBSSH2_AES_CTR         1
+#define LIBSSH2_BLOWFISH        1
+#define LIBSSH2_RC4             1
+#define LIBSSH2_CAST            0
+#define LIBSSH2_3DES            1
+
+#define LIBSSH2_RSA             1
+#define LIBSSH2_DSA             0
+
+#define MD5_DIGEST_LENGTH      16
+#define SHA_DIGEST_LENGTH      20
+#define SHA256_DIGEST_LENGTH   32
+#define SHA512_DIGEST_LENGTH   64
+
+/*******************************************************************/
+/*
+ * mbedTLS backend: Global context handles
+ */
+
+mbedtls_entropy_context  _libssh2_mbedtls_entropy;
+mbedtls_ctr_drbg_context _libssh2_mbedtls_ctr_drbg;
+
+/*******************************************************************/
+/*
+ * mbedTLS backend: Generic functions
+ */
+
+#define libssh2_crypto_init() \
+  _libssh2_mbedtls_init()
+#define libssh2_crypto_exit() \
+  _libssh2_mbedtls_free()
+
+#define _libssh2_random(buf, len) \
+  _libssh2_mbedtls_random(buf, len)
+
+#define libssh2_prepare_iovec(vec, len)  /* Empty. */
+
+
+/*******************************************************************/
+/*
+ * mbedTLS backend: HMAC functions
+ */
+
+#define libssh2_hmac_ctx    mbedtls_md_context_t
+
+#define libssh2_hmac_ctx_init(ctx)
+#define libssh2_hmac_cleanup(pctx) \
+  mbedtls_md_free(pctx)
+#define libssh2_hmac_update(ctx, data, datalen) \
+  mbedtls_md_hmac_update(&ctx, (unsigned char *) data, datalen)
+#define libssh2_hmac_final(ctx, hash) \
+  mbedtls_md_hmac_finish(&ctx, hash)
+
+#define libssh2_hmac_sha1_init(pctx, key, keylen) \
+  _libssh2_mbedtls_hash_init(pctx, MBEDTLS_MD_SHA1, key, keylen)
+#define libssh2_hmac_md5_init(pctx, key, keylen) \
+  _libssh2_mbedtls_hash_init(pctx, MBEDTLS_MD_MD5, key, keylen)
+#define libssh2_hmac_ripemd160_init(pctx, key, keylen) \
+  _libssh2_mbedtls_hash_init(pctx, MBEDTLS_MD_RIPEMD160, key, keylen)
+#define libssh2_hmac_sha256_init(pctx, key, keylen) \
+  _libssh2_mbedtls_hash_init(pctx, MBEDTLS_MD_SHA256, key, keylen)
+#define libssh2_hmac_sha512_init(pctx, key, keylen) \
+  _libssh2_mbedtls_hash_init(pctx, MBEDTLS_MD_SHA512, key, keylen)
+
+
+/*******************************************************************/
+/*
+ * mbedTLS backend: SHA1 functions
+ */
+
+#define libssh2_sha1_ctx      mbedtls_md_context_t
+
+#define libssh2_sha1_init(pctx) \
+  _libssh2_mbedtls_hash_init(pctx, MBEDTLS_MD_SHA1, NULL, 0)
+#define libssh2_sha1_update(ctx, data, datalen) \
+  mbedtls_md_update(&ctx, (unsigned char *) data, datalen)
+#define libssh2_sha1_final(ctx, hash) \
+  _libssh2_mbedtls_hash_final(&ctx, hash)
+#define libssh2_sha1(data, datalen, hash) \
+  _libssh2_mbedtls_hash(data, datalen, MBEDTLS_MD_SHA1, hash)
+
+/*******************************************************************/
+/*
+ * mbedTLS backend: SHA256 functions
+ */
+
+#define libssh2_sha256_ctx      mbedtls_md_context_t
+
+#define libssh2_sha256_init(pctx) \
+  _libssh2_mbedtls_hash_init(pctx, MBEDTLS_MD_SHA256, NULL, 0)
+#define libssh2_sha256_update(ctx, data, datalen) \
+  mbedtls_md_update(&ctx, (unsigned char *) data, datalen)
+#define libssh2_sha256_final(ctx, hash) \
+  _libssh2_mbedtls_hash_final(&ctx, hash)
+#define libssh2_sha256(data, datalen, hash) \
+  _libssh2_mbedtls_hash(data, datalen, MBEDTLS_MD_SHA256, hash)
+
+
+/*******************************************************************/
+/*
+ * mbedTLS backend: SHA512 functions
+ */
+
+#define libssh2_sha512_ctx      mbedtls_md_context_t
+
+#define libssh2_sha512_init(pctx) \
+  _libssh2_mbedtls_hash_init(pctx, MBEDTLS_MD_SHA512, NULL, 0)
+#define libssh2_sha512_update(ctx, data, datalen) \
+  mbedtls_md_update(&ctx, (unsigned char *) data, datalen)
+#define libssh2_sha512_final(ctx, hash) \
+  _libssh2_mbedtls_hash_final(&ctx, hash)
+#define libssh2_sha512(data, datalen, hash) \
+  _libssh2_mbedtls_hash(data, datalen, MBEDTLS_MD_SHA512, hash)
+
+
+/*******************************************************************/
+/*
+ * mbedTLS backend: MD5 functions
+ */
+
+#define libssh2_md5_ctx      mbedtls_md_context_t
+
+#define libssh2_md5_init(pctx) \
+  _libssh2_mbedtls_hash_init(pctx, MBEDTLS_MD_MD5, NULL, 0)
+#define libssh2_md5_update(ctx, data, datalen) \
+  mbedtls_md_update(&ctx, (unsigned char *) data, datalen)
+#define libssh2_md5_final(ctx, hash) \
+  _libssh2_mbedtls_hash_final(&ctx, hash)
+#define libssh2_md5(data, datalen, hash) \
+  _libssh2_mbedtls_hash(data, datalen, MBEDTLS_MD_MD5, hash)
+
+/*******************************************************************/
+/*
+ * mbedTLS backend: RSA structure
+ */
+
+#define libssh2_rsa_ctx  mbedtls_rsa_context
+
+#define _libssh2_rsa_new(rsactx, e, e_len, n, n_len, \
+                         d, d_len, p, p_len, q, q_len, \
+                         e1, e1_len, e2, e2_len, c, c_len) \
+  _libssh2_mbedtls_rsa_new(rsactx, e, e_len, n, n_len, \
+                          d, d_len, p, p_len, q, q_len, \
+                          e1, e1_len, e2, e2_len, c, c_len)
+
+#define _libssh2_rsa_new_private(rsactx, s, filename, passphrase) \
+  _libssh2_mbedtls_rsa_new_private(rsactx, s, filename, passphrase)
+
+#define _libssh2_rsa_new_private_frommemory(rsactx, s, filedata, \
+                                            filedata_len, passphrase) \
+  _libssh2_mbedtls_rsa_new_private_frommemory(rsactx, s, filedata, \
+                                             filedata_len, passphrase)
+
+#define _libssh2_rsa_sha1_sign(s, rsactx, hash, hash_len, sig, sig_len) \
+  _libssh2_mbedtls_rsa_sha1_sign(s, rsactx, hash, hash_len, sig, sig_len)
+
+#define _libssh2_rsa_sha1_verify(rsactx, sig, sig_len, m, m_len) \
+  _libssh2_mbedtls_rsa_sha1_verify(rsactx, sig, sig_len, m, m_len)
+
+#define _libssh2_rsa_free(rsactx) \
+  _libssh2_mbedtls_rsa_free(rsactx)
+
+/*
+ * mbedTLS backend: Key functions
+ */
+
+#define _libssh2_pub_priv_keyfile(s, m, m_len, p, p_len, pk, pw) \
+  _libssh2_mbedtls_pub_priv_keyfile(s, m, m_len, p, p_len, pk, pw)
+#define _libssh2_pub_priv_keyfilememory(s, m, m_len, p, p_len, \
+                                                     pk, pk_len, pw) \
+  _libssh2_mbedtls_pub_priv_keyfilememory(s, m, m_len, p, p_len, \
+                                                      pk, pk_len, pw)
+
+
+ /*******************************************************************/
+/*
+ * mbedTLS backend: Cipher Context structure
+ */
+#define _libssh2_cipher_ctx         mbedtls_cipher_context_t
+
+#define _libssh2_cipher_type(algo)  mbedtls_cipher_type_t algo
+
+#define _libssh2_cipher_aes256ctr MBEDTLS_CIPHER_AES_256_CTR
+#define _libssh2_cipher_aes192ctr MBEDTLS_CIPHER_AES_192_CTR
+#define _libssh2_cipher_aes128ctr MBEDTLS_CIPHER_AES_128_CTR
+#define _libssh2_cipher_aes256    MBEDTLS_CIPHER_AES_256_CBC
+#define _libssh2_cipher_aes192    MBEDTLS_CIPHER_AES_192_CBC
+#define _libssh2_cipher_aes128    MBEDTLS_CIPHER_AES_128_CBC
+#define _libssh2_cipher_blowfish  MBEDTLS_CIPHER_BLOWFISH_CBC
+#define _libssh2_cipher_arcfour   MBEDTLS_CIPHER_ARC4_128
+#define _libssh2_cipher_cast5     MBEDTLS_CIPHER_NULL
+#define _libssh2_cipher_3des      MBEDTLS_CIPHER_DES_EDE3_CBC
+
+/*
+ * mbedTLS backend: Cipher functions
+ */
+
+#define _libssh2_cipher_init(ctx, type, iv, secret, encrypt) \
+  _libssh2_mbedtls_cipher_init(ctx, type, iv, secret, encrypt)
+#define _libssh2_cipher_crypt(ctx, type, encrypt, block, blocklen) \
+  _libssh2_mbedtls_cipher_crypt(ctx, type, encrypt, block, blocklen)
+#define _libssh2_cipher_dtor(ctx) \
+  _libssh2_mbedtls_cipher_dtor(ctx)
+
+
+/*******************************************************************/
+/*
+ * mbedTLS backend: BigNumber Support
+ */
+
+#define _libssh2_bn_ctx int /* not used */
+#define _libssh2_bn_ctx_new() 0 /* not used */
+#define _libssh2_bn_ctx_free(bnctx) ((void)0) /* not used */
+
+#define _libssh2_bn mbedtls_mpi
+
+#define _libssh2_bn_init() \
+  _libssh2_mbedtls_bignum_init()
+#define _libssh2_bn_init_from_bin() \
+  _libssh2_mbedtls_bignum_init()
+#define _libssh2_bn_rand(bn, bytes, top, bottom) \
+  mbedtls_mpi_fill_random(bn, bytes, mbedtls_ctr_drbg_random, &_libssh2_mbedtls_ctr_drbg)
+#define _libssh2_bn_mod_exp(r, a, p, m, ctx) \
+  mbedtls_mpi_exp_mod(r, a, p, m, NULL)
+#define _libssh2_bn_set_word(bn, word) \
+  mbedtls_mpi_lset(bn, word)
+#define _libssh2_bn_from_bin(bn, len, bin) \
+  mbedtls_mpi_read_binary(bn, bin, len)
+#define _libssh2_bn_to_bin(bn, bin) \
+  mbedtls_mpi_write_binary(bn, bin, mbedtls_mpi_size(bn))
+#define _libssh2_bn_bytes(bn) \
+  mbedtls_mpi_size(bn)
+#define _libssh2_bn_bits(bn) \
+  mbedtls_mpi_bitlen(bn)
+#define _libssh2_bn_free(bn) \
+  _libssh2_mbedtls_bignum_free(bn)
+
+
+/*******************************************************************/
+/*
+ * mbedTLS backend: forward declarations
+ */
+void
+_libssh2_mbedtls_init(void);
+
+void
+_libssh2_mbedtls_free(void);
+
+int
+_libssh2_mbedtls_random(unsigned char *buf, int len);
+
+int
+_libssh2_mbedtls_cipher_init(_libssh2_cipher_ctx *ctx,
+                            _libssh2_cipher_type(type),
+                            unsigned char *iv,
+                            unsigned char *secret,
+                            int encrypt);
+int
+_libssh2_mbedtls_cipher_crypt(_libssh2_cipher_ctx *ctx,
+                             _libssh2_cipher_type(type),
+                             int encrypt,
+                             unsigned char *block,
+                             size_t blocklen);
+void
+_libssh2_mbedtls_cipher_dtor(_libssh2_cipher_ctx *ctx);
+
+int
+_libssh2_mbedtls_hash_init(mbedtls_md_context_t *ctx,
+                          mbedtls_md_type_t mdtype,
+                          const unsigned char *key, unsigned long keylen);
+
+int
+_libssh2_mbedtls_hash_final(mbedtls_md_context_t *ctx, unsigned char *hash);
+int
+_libssh2_mbedtls_hash(const unsigned char *data, unsigned long datalen,
+                      mbedtls_md_type_t mdtype, unsigned char *hash);
+
+_libssh2_bn *
+_libssh2_mbedtls_bignum_init(void);
+
+void
+_libssh2_mbedtls_bignum_free(_libssh2_bn *bn);
+
+int
+_libssh2_mbedtls_rsa_new(libssh2_rsa_ctx **rsa,
+                        const unsigned char *edata,
+                        unsigned long elen,
+                        const unsigned char *ndata,
+                        unsigned long nlen,
+                        const unsigned char *ddata,
+                        unsigned long dlen,
+                        const unsigned char *pdata,
+                        unsigned long plen,
+                        const unsigned char *qdata,
+                        unsigned long qlen,
+                        const unsigned char *e1data,
+                        unsigned long e1len,
+                        const unsigned char *e2data,
+                        unsigned long e2len,
+                        const unsigned char *coeffdata,
+                        unsigned long coefflen);
+
+int
+_libssh2_mbedtls_rsa_new_private(libssh2_rsa_ctx **rsa,
+                                LIBSSH2_SESSION *session,
+                                const char *filename,
+                                const unsigned char *passphrase);
+
+int
+_libssh2_mbedtls_rsa_new_private_frommemory(libssh2_rsa_ctx **rsa,
+                                           LIBSSH2_SESSION *session,
+                                           const char *filedata,
+                                           size_t filedata_len,
+                                           unsigned const char *passphrase);
+int
+_libssh2_mbedtls_rsa_sha1_verify(libssh2_rsa_ctx *rsa,
+                                const unsigned char *sig,
+                                unsigned long sig_len,
+                                const unsigned char *m,
+                                unsigned long m_len);
+int
+_libssh2_mbedtls_rsa_sha1_sign(LIBSSH2_SESSION *session,
+                              libssh2_rsa_ctx *rsa,
+                              const unsigned char *hash,
+                              size_t hash_len,
+                              unsigned char **signature,
+                              size_t *signature_len);
+void
+_libssh2_mbedtls_rsa_free(libssh2_rsa_ctx *rsa);
+
+int
+_libssh2_mbedtls_pub_priv_keyfile(LIBSSH2_SESSION *session,
+                                 unsigned char **method,
+                                 size_t *method_len,
+                                 unsigned char **pubkeydata,
+                                 size_t *pubkeydata_len,
+                                 const char *privatekey,
+                                 const char *passphrase);
+int
+_libssh2_mbedtls_pub_priv_keyfilememory(LIBSSH2_SESSION *session,
+                                       unsigned char **method,
+                                       size_t *method_len,
+                                       unsigned char **pubkeydata,
+                                       size_t *pubkeydata_len,
+                                       const char *privatekeydata,
+                                       size_t privatekeydata_len,
+                                       const char *passphrase);
diff --git a/src/sftp.c b/src/sftp.c
index c142713..7c44116 100644
--- a/src/sftp.c
+++ b/src/sftp.c
@@ -1527,7 +1527,7 @@ static ssize_t sftp_read(LIBSSH2_SFTP_HANDLE * handle, char *buffer,
                 if (chunk->offset != filep->offset) {
                     /* This could happen if the server returns less bytes than
                        requested, which shouldn't happen for normal files. See:
-                       http://tools.ietf.org/html/draft-ietf-secsh-filexfer-02
+                       https://tools.ietf.org/html/draft-ietf-secsh-filexfer-02
                        #section-6.4
                     */
                     return _libssh2_error(session, LIBSSH2_ERROR_SFTP_PROTOCOL,
diff --git a/src/wincng.c b/src/wincng.c
index 635b3e3..d3271b3 100755
--- a/src/wincng.c
+++ b/src/wincng.c
@@ -861,7 +861,7 @@ _libssh2_wincng_rsa_new(libssh2_rsa_ctx **rsa,
     memset(key, 0, keylen);
 
 
-    /* http://msdn.microsoft.com/library/windows/desktop/aa375531.aspx */
+    /* https://msdn.microsoft.com/library/windows/desktop/aa375531.aspx */
     rsakey = (BCRYPT_RSAKEY_BLOB *)key;
     rsakey->BitLength = mlen * 8;
     rsakey->cbPublicExp = elen;
@@ -1179,7 +1179,7 @@ _libssh2_wincng_dsa_new(libssh2_dsa_ctx **dsa,
     memset(key, 0, keylen);
 
 
-    /* http://msdn.microsoft.com/library/windows/desktop/aa833126.aspx */
+    /* https://msdn.microsoft.com/library/windows/desktop/aa833126.aspx */
     dsakey = (BCRYPT_DSA_KEY_BLOB *)key;
     dsakey->cbKey = length;
 
@@ -1903,7 +1903,7 @@ _libssh2_wincng_bignum_mod_exp(_libssh2_bn *r,
         return -1;
 
 
-    /* http://msdn.microsoft.com/library/windows/desktop/aa375531.aspx */
+    /* https://msdn.microsoft.com/library/windows/desktop/aa375531.aspx */
     rsakey = (BCRYPT_RSAKEY_BLOB *)key;
     rsakey->Magic = BCRYPT_RSAPUBLIC_MAGIC;
     rsakey->BitLength = m->length * 8;
diff --git a/vms/libssh2_config.h b/vms/libssh2_config.h
index 2eb09a8..b8f73e2 100644
--- a/vms/libssh2_config.h
+++ b/vms/libssh2_config.h
@@ -14,6 +14,7 @@ typedef unsigned int socklen_t; /* missing in headers on VMS */
 /* Have's */
 
 #define HAVE_UNISTD_H
+#define HAVE_STDLIB_H
 #define HAVE_INTTYPES_H
 #define HAVE_SYS_TIME_H
 #define HAVE_SELECT
@@ -23,6 +24,8 @@ typedef unsigned int socklen_t; /* missing in headers on VMS */
 #define HAVE_NETINET_IN_H
 #define HAVE_ARPA_INET_H
 
+#define HAVE_GETTIMEOFDAY 1
+
 #define POSIX_C_SOURCE
 
 /* Enable the possibility of using tracing */
@@ -68,8 +71,11 @@ typedef unsigned int socklen_t; /* missing in headers on VMS */
 
 #endif
 
+/* Use OpenSSL */
+#define LIBSSH2_OPENSSL 1
+
 /* Compile in zlib support. We link against gnv$libzshr, as available
- * on encompasserve.com.
+ * from https://sourceforge.net/projects/vms-ports/files/.
  */
 
 #define LIBSSH2_HAVE_ZLIB
diff --git a/vms/libssh2_make_example.dcl b/vms/libssh2_make_example.dcl
index d8191f3..af4116d 100644
--- a/vms/libssh2_make_example.dcl
+++ b/vms/libssh2_make_example.dcl
@@ -29,6 +29,7 @@ $ this = f$search("exadir:*.c;0")
 $ if this .eqs. "" then goto EndLoop
 $!
 $ what = f$parse( this,,,"name")
+$ if what .eqs. "x11" then goto loop ! not portable yet
 $ call Make
 $!
 $ goto Loop
@@ -84,7 +85,7 @@ $ define objdir 'objdir'
 $ define exadir 'exadir'
 $!
 $ cc_include = "/include=([],[-.include])"
-$ cc_flags   = "/name=shortened/show=all"
+$ cc_flags   = "/name=shortened/show=all/define=(_USE_STD_STAT=1)"
 $ link_opts  = "objdir:libssh2_''thisid'.opt"
 $!
 $!
diff --git a/vms/libssh2_make_help.dcl b/vms/libssh2_make_help.dcl
index b28265d..b36512e 100644
--- a/vms/libssh2_make_help.dcl
+++ b/vms/libssh2_make_help.dcl
@@ -11,23 +11,27 @@ $ man2help sys$input: libssh2.hlp -b 1
 
 LIBSSH2
 
-OpenVMS port of the public domain libssh2 library, which 
-provides an API to implement client SSH communciation.
+OpenVMS port of the libssh2 library, which provides an
+API to implement client SSH communication.
 
-License information is available at the copying subtopic.
+License information is available at the Copying subtopic.
 
 $!
 $ open/append mh libssh2.hlp
 $ write mh helpversion
 $ close mh
 $!
-$ man2help -a [-]readme.; libssh2.hlp        -b 2
-$ man2help -a [-]authors.; libssh2.hlp       -b 2
-$ man2help -a [-]copying.; libssh2.hlp       -b 2
-$ man2help -a [-]news.; libssh2.hlp          -b 2
-$ man2help -a [-]release-notes.; libssh2.hlp -b 2
-$ man2help -a [-]hacking.; libssh2.hlp       -b 2
-$ man2help -a [-]todo.; libssh2.hlp          -b 2
+$ man2help -a [-]README.; libssh2.hlp        -b 2
+$ man2help -a [-]COPYING.; libssh2.hlp       -b 2
+$ man2help -a [-]NEWS.; libssh2.hlp          -b 2
+$ man2help -a [-]RELEASE-NOTES.; libssh2.hlp -b 2
+$ man2help -a [-.docs]AUTHORS.; libssh2.hlp  -b 2
+$ man2help -a [-.docs]BINDINGS.; libssh2.hlp -b 2
+$ man2help -a [-.docs]HACKING.; libssh2.hlp  -b 2
+$ if f$search("[]HACKING_CRYPTO.") .nes. "" then delete []HACKING_CRYPTO.;*
+$ copy [-.docs]HACKING.CRYPTO; []HACKING_CRYPTO.
+$ man2help -a []HACKING_CRYPTO.; libssh2.hlp -b 2
+$ man2help -a [-.docs]TODO.; libssh2.hlp     -b 2
 $!
 $ man2help -a sys$input: libssh2.hlp         -b 2
 
diff --git a/vms/libssh2_make_kit.dcl b/vms/libssh2_make_kit.dcl
index dceca4f..6a14958 100644
--- a/vms/libssh2_make_kit.dcl
+++ b/vms/libssh2_make_kit.dcl
@@ -194,7 +194,7 @@ $ write pt "=prompt JCB LIBSSH2 for OpenVMS"
 $ write pt ""
 $ write pt "libssh2 is an open source client side library that aims to implement"
 $ write pt "the SSH protocol. This is the OpenVMS port of that library."
-$ write pt "Further information at http://www.libssh2.org."
+$ write pt "Further information at https://www.libssh2.org."
 $ write pt ""
 $ write pt "1 NEED_VMS83"
 $ write pt "=prompt OpenVMS 8.3 or later is not installed on your system."
diff --git a/vms/libssh2_make_lib.dcl b/vms/libssh2_make_lib.dcl
index 6d8b13b..56d168f 100644
--- a/vms/libssh2_make_lib.dcl
+++ b/vms/libssh2_make_lib.dcl
@@ -46,7 +46,8 @@ $!
 $ define objdir 'objdir'
 $ define srcdir 'srcdir'
 $!
-$ cc_include = "/include=([],[-.include])"
+$ cc_include = "/include=([],[-.include],""/gnv$zlib_include"")"
+$ cc_define = "/DEFINE=(_USE_STD_STAT=1)"
 $ link_opts  = "objdir:libssh2_''thisid'.opt"
 $!
 $ pipe search [-.include]libssh2.h libssh2_version_major/nohead | (read sys$input l ; l = f$element(2," ",f$edit(l,"trim,compress")) ; - 
@@ -137,7 +138,7 @@ $CaseLoop:
 $!
 $ if case .eq. 0 
 $ then!camel case names 
-$   cc_flags = "/names=(shortened,as_is)"
+$   cc_flags = "/names=(shortened,as_is)''cc_define'"
 $   objlib = "libssh2_asis.olb"
 $ endif
 $!
@@ -149,7 +150,7 @@ $      rename [.cxx_repository]cxx$demangler_db.; *.lowercase
 $      purge  [.cxx_repository]cxx$demangler_db.lowercase
 $   endif
 $!
-$   cc_flags = "/names=(shortened)"
+$   cc_flags = "/names=(shortened)''cc_define'"
 $   objlib = "libssh2_up.olb"
 $ endif
 $!
diff --git a/win32/libssh2_config.h b/win32/libssh2_config.h
index 3e3caf4..6ac2ef4 100644
--- a/win32/libssh2_config.h
+++ b/win32/libssh2_config.h
@@ -24,6 +24,7 @@
 #define HAVE_SELECT
 
 #ifdef _MSC_VER
+#if _MSC_VER < 1900
 #define snprintf _snprintf
 #if _MSC_VER < 1500
 #define vsnprintf _vsnprintf
@@ -31,6 +32,7 @@
 #define strdup _strdup
 #define strncasecmp _strnicmp
 #define strcasecmp _stricmp
+#endif
 #else
 #ifndef __MINGW32__
 #define strncasecmp strnicmp
