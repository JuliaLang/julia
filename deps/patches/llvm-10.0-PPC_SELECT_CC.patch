From 4765db99fa35257a4209e2976903d81087a3f0d7 Mon Sep 17 00:00:00 2001
From: Nemanja Ivanovic <nemanja.i.ibm@gmail.com>
Date: Thu, 9 Apr 2020 13:53:02 -0500
Subject: [PATCH] [PowerPC] Don't assert on SELECT_CC with i1 type

When we try to select a SELECT_CC on Power9, we check if it can be matched to a
SETB instruction. In that function, we assert that the output type is i32/i64.
This is unnecessary as it is perfectly reasonable to have an i1 SELECT_CC.
Change that from an assert to an early exit condition.
Fixes: https://bugs.llvm.org/show_bug.cgi?id=45448
---
 llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp |  7 +-
 llvm/test/CodeGen/PowerPC/pr45448.ll        | 90 +++++++++++++++++++++
 2 files changed, 92 insertions(+), 5 deletions(-)
 create mode 100644 llvm/test/CodeGen/PowerPC/pr45448.ll

diff --git llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
index 776ec52e260..9230ce4118b 100644
--- llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
+++ llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp
@@ -4241,13 +4241,10 @@ static bool mayUseP9Setb(SDNode *N, const ISD::CondCode &CC, SelectionDAG *DAG,
   SDValue TrueRes = N->getOperand(2);
   SDValue FalseRes = N->getOperand(3);
   ConstantSDNode *TrueConst = dyn_cast<ConstantSDNode>(TrueRes);
-  if (!TrueConst)
+  if (!TrueConst || (N->getSimpleValueType(0) != MVT::i64 &&
+                     N->getSimpleValueType(0) != MVT::i32))
     return false;
 
-  assert((N->getSimpleValueType(0) == MVT::i64 ||
-          N->getSimpleValueType(0) == MVT::i32) &&
-         "Expecting either i64 or i32 here.");
-
   // We are looking for any of:
   // (select_cc lhs, rhs,  1, (sext (setcc [lr]hs, [lr]hs, cc2)), cc1)
   // (select_cc lhs, rhs, -1, (zext (setcc [lr]hs, [lr]hs, cc2)), cc1)
diff --git llvm/test/CodeGen/PowerPC/pr45448.ll llvm/test/CodeGen/PowerPC/pr45448.ll
new file mode 100644
index 00000000000..eb0a61cb075
--- /dev/null
+++ llvm/test/CodeGen/PowerPC/pr45448.ll
@@ -0,0 +1,90 @@
+; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
+; RUN: llc -verify-machineinstrs -mtriple=powerpc64le-unknown-linux-gnu \
+; RUN:     -mcpu=pwr9 -ppc-asm-full-reg-names -ppc-vsr-nums-as-vr < %s | \
+; RUN: FileCheck %s
+define hidden void @julia_tryparse_internal_45896() #0 {
+; CHECK-LABEL: julia_tryparse_internal_45896:
+; CHECK:       # %bb.0: # %top
+; CHECK-NEXT:    ld r3, 0(r3)
+; CHECK-NEXT:    cmpldi r3, 0
+; CHECK-NEXT:    beq cr0, .LBB0_3
+; CHECK-NEXT:  # %bb.1: # %top
+; CHECK-NEXT:    cmpldi r3, 10
+; CHECK-NEXT:    beq cr0, .LBB0_4
+; CHECK-NEXT:  # %bb.2: # %top
+; CHECK-NEXT:  .LBB0_3: # %fail194
+; CHECK-NEXT:  .LBB0_4: # %L294
+; CHECK-NEXT:    bc 12, 4*cr5+lt, .LBB0_6
+; CHECK-NEXT:  # %bb.5: # %L294
+; CHECK-NEXT:    bc 4, 4*cr5+lt, .LBB0_7
+; CHECK-NEXT:  .LBB0_6: # %L1057.preheader
+; CHECK-NEXT:  .LBB0_7: # %L670
+; CHECK-NEXT:    lis r5, 4095
+; CHECK-NEXT:    ori r5, r5, 65533
+; CHECK-NEXT:    sldi r5, r5, 4
+; CHECK-NEXT:    cmpdi r3, 0
+; CHECK-NEXT:    sradi r4, r3, 63
+; CHECK-NEXT:    mulhdu r3, r3, r5
+; CHECK-NEXT:    maddld r6, r4, r5, r3
+; CHECK-NEXT:    crnor 4*cr5+gt, eq, eq
+; CHECK-NEXT:    cmpld r6, r3
+; CHECK-NEXT:    mulld r3, r4, r5
+; CHECK-NEXT:    cmpldi cr1, r3, 0
+; CHECK-NEXT:    crandc 4*cr5+lt, lt, 4*cr1+eq
+; CHECK-NEXT:    mulhdu. r3, r4, r5
+; CHECK-NEXT:    bc 4, 4*cr5+gt, .LBB0_10
+; CHECK-NEXT:  # %bb.8: # %L670
+; CHECK-NEXT:    crorc 4*cr5+lt, 4*cr5+lt, eq
+; CHECK-NEXT:    bc 4, 4*cr5+lt, .LBB0_10
+; CHECK-NEXT:  # %bb.9: # %L917
+; CHECK-NEXT:  .LBB0_10: # %L994
+top:
+  %0 = load i64, i64* undef, align 8
+  %1 = icmp ne i64 %0, 0
+  %2 = sext i64 %0 to i128
+  switch i64 %0, label %pass195 [
+    i64 10, label %L294
+    i64 16, label %L294.fold.split
+    i64 0, label %fail194
+  ]
+
+L294.fold.split:                                  ; preds = %top
+  unreachable
+
+L294:                                             ; preds = %top
+  %3 = add nsw i32 0, -48
+  %4 = zext i32 %3 to i128
+  %5 = add i128 %4, 0
+  switch i32 undef, label %L670 [
+    i32 -1031471104, label %L1057.preheader
+    i32 536870912, label %L1057.preheader
+  ]
+
+L670:                                             ; preds = %L294
+  br label %L898
+
+L1057.preheader:                                  ; preds = %L294, %L294
+  unreachable
+
+L898:                                             ; preds = %L670
+  %umul = call { i128, i1 } @llvm.umul.with.overflow.i128(i128 %2, i128 %5)
+  %umul.ov = extractvalue { i128, i1 } %umul, 1
+  %value_phi102 = and i1 %1, %umul.ov
+  %6 = or i1 %value_phi102, false
+  br i1 %6, label %L917, label %L994
+
+L917:                                             ; preds = %L898
+  unreachable
+
+L994:                                             ; preds = %L898
+  unreachable
+
+fail194:                                          ; preds = %top
+  unreachable
+
+pass195:                                          ; preds = %top
+  unreachable
+}
+
+; Function Attrs: nounwind readnone speculatable willreturn
+declare { i128, i1 } @llvm.umul.with.overflow.i128(i128, i128) #1
-- 
2.26.0

