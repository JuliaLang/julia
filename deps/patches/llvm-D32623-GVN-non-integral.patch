From ad3b6cad4fcd66aab2ef2e93566d5868505c03bb Mon Sep 17 00:00:00 2001
From: Keno Fischer <keno@alumni.harvard.edu>
Date: Tue, 9 May 2017 21:07:20 +0000
Subject: [PATCH 4/5] [GVN] Fix a crash on encountering non-integral pointers

Summary:
This fixes the immediate crash caused by introducing an incorrect inttoptr
before attempting the conversion. There may still be a legality
check missing somewhere earlier for non-integral pointers, but this change
seems necessary in any case.

Reviewers: sanjoy, dberlin

Reviewed By: dberlin

Subscribers: llvm-commits

Differential Revision: https://reviews.llvm.org/D32623

git-svn-id: https://llvm.org/svn/llvm-project/llvm/trunk@302587 91177308-0d34-0410-b5e6-96231b3b80d8
---
 lib/Transforms/Utils/VNCoercion.cpp    |  9 ++++++++
 test/Transforms/GVN/PRE/nonintegral.ll | 39 ++++++++++++++++++++++++++++++++++
 2 files changed, 48 insertions(+)
 create mode 100644 test/Transforms/GVN/PRE/nonintegral.ll

diff --git a/lib/Transforms/Utils/VNCoercion.cpp b/lib/Transforms/Utils/VNCoercion.cpp
index 80762ccc0d4..9d2eab19ded 100644
--- a/lib/Transforms/Utils/VNCoercion.cpp
+++ b/lib/Transforms/Utils/VNCoercion.cpp
@@ -301,6 +301,15 @@ Value *getStoreValueForLoad(Value *SrcVal, unsigned Offset, Type *LoadTy,
                             Instruction *InsertPt, const DataLayout &DL) {
   LLVMContext &Ctx = SrcVal->getType()->getContext();
 
+  // If two pointers are in the same address space, they have the same size,
+  // so we don't need to do any truncation, etc. This avoids introducing
+  // ptrtoint instructions for pointers that may be non-integral.
+  if (SrcVal->getType()->isPointerTy() && LoadTy->isPointerTy() &&
+      cast<PointerType>(SrcVal->getType())->getAddressSpace() ==
+          cast<PointerType>(LoadTy)->getAddressSpace()) {
+    return SrcVal;
+  }
+
   uint64_t StoreSize = (DL.getTypeSizeInBits(SrcVal->getType()) + 7) / 8;
   uint64_t LoadSize = (DL.getTypeSizeInBits(LoadTy) + 7) / 8;
 
diff --git a/test/Transforms/GVN/PRE/nonintegral.ll b/test/Transforms/GVN/PRE/nonintegral.ll
new file mode 100644
index 00000000000..75a756e8af8
--- /dev/null
+++ b/test/Transforms/GVN/PRE/nonintegral.ll
@@ -0,0 +1,39 @@
+; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
+; RUN: opt -gvn -S < %s | FileCheck %s
+
+target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128-ni:4"
+target triple = "x86_64-unknown-linux-gnu"
+
+define void @nipre(double addrspace(4)** noalias %p, i64 addrspace(4)** noalias %p2, i8 %jmp) {
+
+; CHECK-LABEL: @nipre(
+; CHECK:    [[PCAST:%.*]] = bitcast double addrspace(4)** [[P:%.*]] to i64 addrspace(4)**
+; CHECK:       a:
+; CHECK:    [[L1:%.*]] = load i64 addrspace(4)*, i64 addrspace(4)** [[PCAST]]
+; CHECK:    [[TMP0:%.*]] = bitcast i64 addrspace(4)* [[L1]] to double addrspace(4)*
+; CHECK:       b:
+; CHECK:    [[L2:%.*]] = load i64 addrspace(4)*, i64 addrspace(4)** [[PCAST]]
+; CHECK:    [[TMP1:%.*]] = bitcast i64 addrspace(4)* [[L2]] to double addrspace(4)*
+; CHECK:       c:
+; CHECK-NEXT:    [[L3_PRE:%.*]] = load double addrspace(4)*, double addrspace(4)** %p
+
+entry:
+  %pcast = bitcast double addrspace(4)** %p to i64 addrspace(4)**
+  switch i8 %jmp, label %c [ i8 0, label %a
+  i8 1, label %b]
+a:
+  %l1 = load i64 addrspace(4)*, i64 addrspace(4)** %pcast
+  store i64 addrspace(4)* %l1, i64 addrspace(4)** %p2
+  br label %tail
+b:
+  %l2 = load i64 addrspace(4)*, i64 addrspace(4)** %pcast
+  store i64 addrspace(4)* %l2, i64 addrspace(4)** %p2
+  br label %tail
+c:
+  br label %tail
+tail:
+  %l3 = load double addrspace(4)*, double addrspace(4)** %p
+  %l3cast = bitcast double addrspace(4)* %l3 to i64 addrspace(4)*
+  store i64 addrspace(4)* %l3cast, i64 addrspace(4)** %p2
+  ret void
+}
-- 
2.13.1

