commit e159b36b285d8bc4ebb03172f4bbfec6be26cae3
Author: Keno Fischer <keno@juliacomputing.com>
Date:   Sat May 12 19:31:34 2018 -0400

    [X86DomainReassignment] Don't delete IMPLICIT_DEF nodes
    
    Summary:
    We cannot simply delete IMPLICIT_DEF nodes. They may be used
    later (e.g. by a PHI) and deleting them will cause later passes (e.g.
    LiveVariables) to crash. However, it seems fine to ignore them for
    purposes of the domain reassignment (as we do with PHI).
    
    Fixes PR37430
    Fixes JuliaLang/julia#27080
    
    Reviewers: craig.topper, guyblank
    
    Subscribers: llvm-commits
    
    Differential Revision: https://reviews.llvm.org/D46797

diff --git a/lib/Target/X86/X86DomainReassignment.cpp b/lib/Target/X86/X86DomainReassignment.cpp
index b41640f7bd7..f48d3ce2227 100644
--- a/lib/Target/X86/X86DomainReassignment.cpp
+++ b/lib/Target/X86/X86DomainReassignment.cpp
@@ -262,25 +262,6 @@ public:
   }
 };
 
-/// An Instruction Converter which completely deletes an instruction.
-/// For example, IMPLICIT_DEF instructions can be deleted when converting from
-/// GPR to mask.
-class InstrDeleter : public InstrConverterBase {
-public:
-  InstrDeleter(unsigned SrcOpcode) : InstrConverterBase(SrcOpcode) {}
-
-  bool convertInstr(MachineInstr *MI, const TargetInstrInfo *TII,
-                    MachineRegisterInfo *MRI) const override {
-    assert(isLegal(MI, TII) && "Cannot convert instruction");
-    return true;
-  }
-
-  double getExtraCost(const MachineInstr *MI,
-                      MachineRegisterInfo *MRI) const override {
-    return 0;
-  }
-};
-
 // Key type to be used by the Instruction Converters map.
 // A converter is identified by <destination domain, source opcode>
 typedef std::pair<int, unsigned> InstrConverterBaseKeyTy;
@@ -587,7 +568,7 @@ void X86DomainReassignment::initConverters() {
       new InstrIgnore(TargetOpcode::PHI);
 
   Converters[{MaskDomain, TargetOpcode::IMPLICIT_DEF}] =
-      new InstrDeleter(TargetOpcode::IMPLICIT_DEF);
+      new InstrIgnore(TargetOpcode::IMPLICIT_DEF);
 
   Converters[{MaskDomain, TargetOpcode::INSERT_SUBREG}] =
       new InstrReplaceWithCopy(TargetOpcode::INSERT_SUBREG, 2);
diff --git a/test/CodeGen/X86/domain-reassignment-implicit-def.ll b/test/CodeGen/X86/domain-reassignment-implicit-def.ll
new file mode 100644
index 00000000000..aa43a2ac766
--- /dev/null
+++ b/test/CodeGen/X86/domain-reassignment-implicit-def.ll
@@ -0,0 +1,25 @@
+; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
+; RUN: llc -mcpu=skylake-avx512 -mtriple=x86_64-unknown-linux-gnu %s -o - | FileCheck %s
+
+; Check that the X86 Domain Reassignment pass doesn't drop IMPLICIT_DEF nodes,
+; which would later cause crashes (e.g. in LiveVariables) - see PR37430
+define void @domain_reassignment_implicit_def(i1 %cond, i8 *%mem, float %arg) {
+; CHECK:    vxorps %xmm1, %xmm1, %xmm1
+; CHECK:    vcmpneqss %xmm1, %xmm0, %k0
+; CHECK:    kmovb %k0, (%rsi)
+top:
+  br i1 %cond, label %L19, label %L15
+
+L15:                                              ; preds = %top
+  %tmp47 = fcmp une float 0.000000e+00, %arg
+  %tmp48 = zext i1 %tmp47 to i8
+  br label %L21
+
+L19:                                              ; preds = %top
+  br label %L21
+
+L21:                                              ; preds = %L19, %L15
+  %.sroa.0.0 = phi i8 [ undef, %L19 ], [ %tmp48, %L15 ]
+  store i8 %.sroa.0.0, i8* %mem, align 1
+  ret void
+}
