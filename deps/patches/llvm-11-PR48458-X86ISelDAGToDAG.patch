From 2c8b03616a3e033b0067ac506e6287970cfd424e Mon Sep 17 00:00:00 2001
From: Craig Topper <craig.topper@sifive.com>
Date: Wed, 9 Dec 2020 10:21:40 -0800
Subject: [PATCH] [X86] Use APInt::isSignedIntN instead of isIntN for 64-bit
 ANDs in X86DAGToDAGISel::IsProfitableToFold

Pretty sure we meant to be checking signed 32 immediates here
rather than unsigned 32 bit. I suspect I messed this up because
in MathExtras.h we have isIntN and isUIntN so isIntN differs in
signedness depending on whether you're using APInt or plain integers.

This fixes a case where we didn't fold a constant created
by shrinkAndImmediate. Since shrinkAndImmediate doesn't topologically
sort constants it creates, we can fail to convert the Constant
to a TargetConstant. This leads to very strange behavior later.

Fixes PR48458.
---
 llvm/lib/Target/X86/X86ISelDAGToDAG.cpp |  2 +-
 llvm/test/CodeGen/X86/pr48458.ll        | 17 +++++++++++++++++
 2 files changed, 18 insertions(+), 1 deletion(-)
 create mode 100644 llvm/test/CodeGen/X86/pr48458.ll

diff --git llvm/lib/Target/X86/X86ISelDAGToDAG.cpp llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
index 3cd80cb04ab8..f6aaef215432 100644
--- llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
+++ llvm/lib/Target/X86/X86ISelDAGToDAG.cpp
@@ -611,7 +611,7 @@ X86DAGToDAGISel::IsProfitableToFold(SDValue N, SDNode *U, SDNode *Root) const {
         // best of both worlds.
         if (U->getOpcode() == ISD::AND &&
             Imm->getAPIntValue().getBitWidth() == 64 &&
-            Imm->getAPIntValue().isIntN(32))
+            Imm->getAPIntValue().isSignedIntN(32))
           return false;

         // If this really a zext_inreg that can be represented with a movzx
diff --git llvm/test/CodeGen/X86/pr48458.ll llvm/test/CodeGen/X86/pr48458.ll
new file mode 100644
index 000000000000..bca355961611
--- /dev/null
+++ llvm/test/CodeGen/X86/pr48458.ll
@@ -0,0 +1,17 @@
+; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
+; RUN: llc < %s -mtriple=x86_64-unknown-linux-gnu | FileCheck %s
+
+define i1 @foo(i64* %0) {
+; CHECK-LABEL: foo:
+; CHECK:       # %bb.0: # %top
+; CHECK-NEXT:    movq (%rdi), %rax
+; CHECK-NEXT:    andq $-2147483648, %rax # imm = 0x80000000
+; CHECK-NEXT:    sete %al
+; CHECK-NEXT:    retq
+top:
+  %1 = load i64, i64* %0, !range !0
+  %2 = icmp ult i64 %1, 2147483648
+  ret i1 %2
+}
+
+!0 = !{i64 0, i64 10000000000}
--
2.29.2
