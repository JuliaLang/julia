# Standalone AOT compilation mode

This mode of compilation aims to statically compile Julia code to libraries or executables
that do not need a system image. This will allow Julia to support more use cases: 

* Smaller standalone executables with faster startup.
* Compilation to standalone libraries. For example, R or Python packages could link to
  Julia binary libraries.
* Cross compilation to more limited systems. This could be an embedded system or WebAssembly
  for web apps. 

To support these modes, the following compilation targets should be supported:

* A shared library that links to the `libjulia` shared library.
* An executable that links to the `libjulia` shared library.
* An object file meant to dynamically link to the `libjulia` shared library.

In addition to these, we'd also like to support these same targets, but statically link 
to `libjulia.a` for smaller standalone executables or libraries.

## Approach

This approach works by introducing a `standalone-aot-mode` into Julia's code generation
process. This is similar to the `imaging-mode`. The main differences are:

* `ccall` -- `foreigncall`'s normally are converted to calls to function pointers. In
  `standalone-aot-mode`, these are compiled to normal external function calls to be 
  resolved at link time.
* `cglobal` -- As with `ccall`'s, these are compiled to normal external references.
* *Global variables* -- This is a tricky part. Global variables (symbols, strings,
  and Julia global variables) are serialized to a "mini image" (a binary array). An
  initialization function is provided to restore the global variables upon startup.
  The serialization code reuses the machinery in "src/dump.c". Some non-core structs 
  and types are converted to tuples or other types that have the same memory layout. 
* *Initialization* -- This is another tricky part. Initialization includes a 
  simplified version of `jl_init` that does not load the standard library. It 
  initializes many types, including some defined in `base/boot.jl`.

## Current status

The code can handle `ccall` and `cglobal`. There's working code for serialization and 
restoration of global variables. Some programs work when compiled to a shared 
library then called from Julia (using `ccall`). It also renames functions, so that 
`julia_myfun_203` is `myfun` in the resulting object file.

The `test/standalone-aot` directory contains tests/examples. `runtests.jl` runs tests.
`IRGen.jl` has code to generate standalone libraries. The main routines are:

* `native = irgen(f, argtypes)` -- Return a native-code representation of function `f`
  with Tuple types `argtypes`.
* `dump_native(native, filename)` -- Dump `native` to the `.o` object file.
* `@jlrun f(args...)` -- Compile `f` to a dynamic library and call it with `ccall`. 
  Uses `clang` to compile the `.o` file to a `.so` shared library (hardcoded for
  Linux for now). The implementation of this macros is clunky. It mainly works for
  constant arguments.

To look at the LLVM code generated by `irgen`, use the following:

```julia
using LLVM
llvmmod(native_code) =
    LLVM.Module(ccall(:jl_get_llvm_module, LLVM.API.LLVMModuleRef,
                      (Ptr{Cvoid},), native_code.p))

f(x) = 2x
llvmmod(irgen(f, Tuple{Int}))
```

This code also can be used to compile for standalone libraries and executables.
See the `test/standalone-aot/standalone-exe` for two examples.
See `test/standalone-aot/runtests.lua` for Lua code that runs examples without the system image.

A major problem area is dynamic code that ends up as a call to  `jl_apply_generic`. 
That doesn't work at all. 

Right now, the testing code just targets Linux.

Basic IO code that uses `Core.stdout` seems to work. 
More general code does not, including writing to `Main.stdout`. 
`print(Core.stdout, "hello", "\n")` works, but `print(Core.stdout, "hello", '\n')` does not.

The API to adjust the new variable `standalone-aot-mode` in code generation is clunky. 
Right now, there's a `jl_set_standalone_aot_mode()` function and a 
`jl_clear_standalone_aot_mode()` function to control this variable. 
Control of this mode should probably be done through codegen parameters.

There's a garbage-collection bug lurking somewhere. For at least the `rand()` test, it
crashes unless GC is disabled.

## Next steps

- Work out `Main.stdin`, `Main.stdout`, etc.
- Work out exceptions. Right now, they bomb.
- Don't export intrinsics as globals.
- Come up with a strategy for dynamic code that ends up as a call to `jl_invoke` or `jl_apply_generic`.
  For now, it is flagged to the user.
- Debug the GC issue.
- Debug `print(Core.stdout, "hello", '\n')`.
- Handle `@cfunction`.
- Look at lowering of `ptls_states`. Some standalone functions run fine when called from Julia 
  but fail with an allocation error when run externally.

Help would be appreciated in any of the above plus code reviews and testing out what types 
of code compiles and what doesn't. 

## Other ideas

- Maybe return an object that has information on what functions are exported. 
  This could be used to generate C headers or interfaces to other languages like R or Python.

## Relevant issues / repos

* https://github.com/JuliaLang/julia/pull/25984 -- Jameson's codegen restructuring 
  branch that can compile recursive functions using the CUDAnative approach
  (jn/codegen-norecursion branch).
* https://github.com/Keno/julia-wasm -- Scripts to compile the wasm version of Julia.
* https://github.com/Keno/julia-wasm/issues/5 -- Discussion of static compilation for wasm.

See also the **codegen** channel on Slack.
